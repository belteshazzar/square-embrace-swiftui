var sqrm = (function () {
	'use strict';

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	function _copy(data) {
		const type = typeof(data);
		if(data && type==="object") {
			return Object.keys(data).reduce((accum,key) => { accum[key] = _copy(data[key]); return accum; },{});
		}
		return data;
	}

	// remove puntuation except possible : and return space separated tokens
	function _tokenize (value,isObject) {
		return value.replace(new RegExp(`[^A-Za-z0-9\\s${isObject ? "\:" : ""}]`,"g"),"").replace(/  +/g," ").toLowerCase().split(" ")
	}

	// return an array of possible misspelling for a word based on common patterns of error
	// will often return uncommon misspellings, but that's ok, it keeps the code simple without a dictionary
	function _misspellings(value,compress) {
		const results = [];
		if(compress) {
		// remove double letter occurrance, e.g. occurance vs ocurance
			const dedoubled = Object.values(value).reduce((accum,char) => accum[accum.length-1]===char ? accum : accum += char,"");
			if(dedoubled!==value) {
				value = dedoubled;
				results.push(dedoubled);
			}
		}
		// common misspelling signatures
		if(value.includes("ie")) results.push(value.replace(/ie/g,"ei"));
		if(value.includes("ei")) results.push(value.replace(/ei/g,"ie"));
		if(value.includes("ea") && !value[0]==="e" && !value[value.length-1]==="a") results.push(value.replace(/ea/g,"e"));
		if(value.includes("sc") && !value[0]==="s" && !value[value.length-1]==="c") results.push(value.replace(/sc/g,"c"));
		if(value.includes("os") && !value[0]==="o" && !value[value.length-1]==="s") results.push(value.replace(/os/g,"ous"));
		if(value.endsWith("ery")) results.push(value.substring(0,value.length-3)+"ary");
		if(value.includes("ite")) results.push(value.replace(/ite/g,"ate"));
		if(value.endsWith("ent")) results.push(value.substring(0,value.length-3)+"ant");
		if(value.endsWith("eur")) results.push(value.substring(0,value.length-3)+"er");
		if(value.endsWith("for")) results.push(value+"e");
		if(value.startsWith("gua")) results.push("gau"+value.substring(4));
		if(value.endsWith("oah")) results.push(value.substring(0,value.length-3)+"aoh");
		if(value.endsWith("ally")) results.push(value.substring(0,value.length-4)+"ly");
		if(value.endsWith("ence")) results.push(value.substring(0,value.length-4)+"ance");
		if(value.endsWith("fore")) results.push(value.substring(0,value.length-1));
		if(value.endsWith("ious")) results.push(value.substring(0,value.length-4)+"ous");
		if(value.endsWith("guese")) results.push(value.substring(0,value.length-4)+"gese");
		if(value.endsWith("ible")) results.push(value.substring(0,value.length-4)+"able");
		if(value.startsWith("busi")) results.push("buis"+value.substring(5));
		if(value.startsWith("fore")) results.push("for"+value.substring(5));
		if(value.startsWith("fluor")) results.push("flor"+value.substring(5));
		if(value.startsWith("propa")) results.push("propo"+value.substring(5));
		return results;
	}

	// remove vowels from a word
	function _disemvowel(value) {
		return value.replace(/[AEIOUaeiou]+/g,"")
	}
	// disemvowel and remove spaces
	function _compress(value) {
		return Object.values(_disemvowel(value)).reduce((accum,char) => accum[accum.length-1]===char ? accum : accum += char,"")
	}

	// join all the tokens together and return an array of three letter sequences, stepping through string one char at a time
	// except treat numbers as numbers
	function _trigrams(tokens) {
		const {string,grams} = tokens.reduce((accum,token) => {
				if(isNaN(parseFloat(token))) {
					accum.string += token;
				} else {
					accum.grams.push(token);
				}
				return accum;
			},{string:"",grams:[]});
			//str = Array.isArray(tokens) ? tokens.join("") : tokens+"";
		for(let i=0;i<string.length-2;i++) {
				grams.push(string.substring(i,i+3));
		}
		return grams;
	}

	//stemmer adapted from from https://github.com/words/stemmer MIT License, Titus Wormer
	/* Character code for `y`. */
	var CC_Y = 'y'.charCodeAt(0);

	/* Standard suffix manipulations. */
	var step2list = {
		ational: 'ate',
		tional: 'tion',
		enci: 'ence',
		anci: 'ance',
		izer: 'ize',
		bli: 'ble',
		alli: 'al',
		entli: 'ent',
		eli: 'e',
		ousli: 'ous',
		ization: 'ize',
		ation: 'ate',
		ator: 'ate',
		alism: 'al',
		iveness: 'ive',
		fulness: 'ful',
		ousness: 'ous',
		aliti: 'al',
		iviti: 'ive',
		biliti: 'ble',
		logi: 'log'
	};

	var step3list = {
		icate: 'ic',
		ative: '',
		alize: 'al',
		iciti: 'ic',
		ical: 'ic',
		ful: '',
		ness: ''
	};

	/* Consonant-vowel sequences. */
	var consonant = '[^aeiou]';
	var vowel = '[aeiouy]';
	var consonantSequence = '(' + consonant + '[^aeiouy]*)';
	var vowelSequence = '(' + vowel + '[aeiou]*)';

	var MEASURE_GT_0 = new RegExp(
		'^' + consonantSequence + '?' + vowelSequence + consonantSequence
	);

	var MEASURE_EQ_1 = new RegExp(
		'^' + consonantSequence + '?' + vowelSequence + consonantSequence +
		vowelSequence + '?$'
	);

	var MEASURE_GT_1 = new RegExp(
		'^' + consonantSequence + '?' +
		'(' + vowelSequence + consonantSequence + '){2,}'
	);

	var VOWEL_IN_STEM = new RegExp(
		'^' + consonantSequence + '?' + vowel
	);

	var CONSONANT_LIKE = new RegExp(
		'^' + consonantSequence + vowel + '[^aeiouwxy]$'
	);

	/* Exception expressions. */
	var SUFFIX_LL = /ll$/;
	var SUFFIX_E = /^(.+?)e$/;
	var SUFFIX_Y = /^(.+?)y$/;
	var SUFFIX_ION = /^(.+?(s|t))(ion)$/;
	var SUFFIX_ED_OR_ING = /^(.+?)(ed|ing)$/;
	var SUFFIX_AT_OR_BL_OR_IZ = /(at|bl|iz)$/;
	var SUFFIX_EED = /^(.+?)eed$/;
	var SUFFIX_S = /^.+?[^s]s$/;
	var SUFFIX_SSES_OR_IES = /^.+?(ss|i)es$/;
	var SUFFIX_MULTI_CONSONANT_LIKE = /([^aeiouylsz])\1$/;
	var STEP_2 = new RegExp(
		'^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|' +
		'ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|' +
		'biliti|logi)$'
	);
	var STEP_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
	var STEP_4 = new RegExp(
		'^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|' +
		'iti|ous|ive|ize)$'
	);

	/* Stem `value`. */
	function _stemmer(value) {
		var firstCharacterWasLowerCaseY;
		var match;

		value = String(value).toLowerCase();

		/* Exit early. */
		if (value.length < 3) {
		return value;
		}

		/* Detect initial `y`, make sure it never matches. */
		if (value.charCodeAt(0) === CC_Y) {
		firstCharacterWasLowerCaseY = true;
		value = 'Y' + value.substr(1);
		}

		/* Step 1a. */
		if (SUFFIX_SSES_OR_IES.test(value)) {
		/* Remove last two characters. */
		value = value.substr(0, value.length - 2);
		} else if (SUFFIX_S.test(value)) {
		/* Remove last character. */
		value = value.substr(0, value.length - 1);
		}

		/* Step 1b. */
		if (match = SUFFIX_EED.exec(value)) {
		if (MEASURE_GT_0.test(match[1])) {
			/* Remove last character. */
			value = value.substr(0, value.length - 1);
		}
		} else if ((match = SUFFIX_ED_OR_ING.exec(value)) && VOWEL_IN_STEM.test(match[1])) {
		value = match[1];

		if (SUFFIX_AT_OR_BL_OR_IZ.test(value)) {
			/* Append `e`. */
			value += 'e';
		} else if (SUFFIX_MULTI_CONSONANT_LIKE.test(value)) {
			/* Remove last character. */
			value = value.substr(0, value.length - 1);
		} else if (CONSONANT_LIKE.test(value)) {
			/* Append `e`. */
			value += 'e';
		}
		}

		/* Step 1c. */
		if ((match = SUFFIX_Y.exec(value)) && VOWEL_IN_STEM.test(match[1])) {
		/* Remove suffixing `y` and append `i`. */
		value = match[1] + 'i';
		}

		/* Step 2. */
		if ((match = STEP_2.exec(value)) && MEASURE_GT_0.test(match[1])) {
		value = match[1] + step2list[match[2]];
		}

		/* Step 3. */
		if ((match = STEP_3.exec(value)) && MEASURE_GT_0.test(match[1])) {
		value = match[1] + step3list[match[2]];
		}

		/* Step 4. */
		if (match = STEP_4.exec(value)) {
		if (MEASURE_GT_1.test(match[1])) {
			value = match[1];
		}
		} else if ((match = SUFFIX_ION.exec(value)) && MEASURE_GT_1.test(match[1])) {
		value = match[1];
		}

		/* Step 5. */
		if (
		(match = SUFFIX_E.exec(value)) &&
		(MEASURE_GT_1.test(match[1]) || (MEASURE_EQ_1.test(match[1]) && !CONSONANT_LIKE.test(match[1])))
		) {
		value = match[1];
		}

		if (SUFFIX_LL.test(value) && MEASURE_GT_1.test(value)) {
		value = value.substr(0, value.length - 1);
		}

		/* Turn initial `Y` back to `y`. */
		if (firstCharacterWasLowerCaseY) {
		value = 'y' + value.substr(1);
		}

		return value;
	}


	var STOPWORDS = [
		'a', 'about', 'after', 'ala', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', 
		'around','as', 'at', 'be',
		'because', 'been', 'before', 'being', 'between', 'both', 'but', 'by', 'came', 'can',
		'come', 'could', 'did', 'do', 'each', 'for', 'from', 'get', 'got', 'has', 'had',
		'he', 'have', 'her', 'here', 'him', 'himself', 'his', 'how', 'i', 'if', 'iff', 'in', 
		'include', 'into',
		'is', 'it', 'like', 'make', 'many', 'me', 'might', 'more', 'most', 'much', 'must',
		'my', 'never', 'now', 'of', 'on', 'only', 'or', 'other', 'our', 'out', 'over',
		'said', 'same', 'see', 'should', 'since', 'some', 'still', 'such', 'take', 'than',
		'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'those',
		'through', 'to', 'too', 'under', 'up', 'very', 'was', 'way', 'we', 'well', 'were',
		'what', 'where', 'which', 'while', 'who', 'with', 'would', 'you', 'your'];

	// return all the values in an object's properties concatenated into a space separated string
	// include the property names followed by :
	function _toText(objectOrPrimitive,seen=new Set()) {
		if(objectOrPrimitive && typeof(objectOrPrimitive)==="object" && !seen.has(objectOrPrimitive)) {
			seen.add(objectOrPrimitive);
			return Object.keys(objectOrPrimitive)
				.reduce((accum,key,i,array) => accum +=  key + ": " + _toText(objectOrPrimitive[key],seen) + (i<array.length-1 ? " " : ""),"");
		}
		return objectOrPrimitive;
	}

	// convert ids into numbers if possible
	function _coerceId(id) {
		try {
			return JSON.parse(id);
		} catch(e) {
			return id;
		}
	}

	function Txi({stops,stems=true,trigrams=true,compressions=true,misspellings=true,onchange,storage={}}={}) {
		const defaults = {stops,stems,trigrams,compressions,misspellings,onchange,storage};
		// ensure Txi is called with the new operator
		if(!this || !(this instanceof Txi)) {
			return new Txi(defaults);
		}
		let {get,set,keys,count} = storage;
		
		// create stop map from array, stop words are not indexed
		stops = (defaults.stops||STOPWORDS).reduce((accum,word) => { accum[word] = true; return accum;},{});
		
		// the map to store the index, which is of the form
		// {[<characterSequence>:{<id>:{stems:<count>,trigrams:<count>,compressions:<count>,numbers:<count>,booleans:<count>}}[,...]}
		let keycount = 0,
			index = {};
		
		if(!keys) {
			keys = async function* () {
				let i = 0,
					key = keys[i];
				while(key) {
					yield key;
					key = keys[++i];
				}
			};
		}
		
		if(!get) {
			get = key => index[key];
		}
		
		if(!set) {
			set = (key,value) => index[key] = value;
		}

		// add words to the stop map created during instantiation
		this.addStops = (...words) => { words.forEach((word) => stops[word] = true); return this; };

		this.compress = () => {
			const onchange = this.onchange || (() => {});
			Object.keys(index)
				.forEach(word => {
					const entry = index[word],
						ids = Object.keys(entry);
					let changed;
					ids.forEach(id => {
						if(entry[id].stems===0 && entry[id].trigrams===0 && entry[id].compressions===0) {
							delete entry[id];
							changed = true;
						}
					});
					if(Object.keys(entry).length===0) {
						delete index[word];
						delete keys[word];
						onchange({[word]:null});
						keycount--;
					} else if(changed) {
						onchange([word],entry);
					}
				});
			return this;
		};

		// remove words from the stop map
		this.removeStops = (...words) => { 
			words.forEach((word) => delete stops[word]); 
			return this; 
		};

		// remove the provided ids from the index
		this.remove = async (...ids) => {
			const onchange = this.onchange || (() => {});
			for(const id of ids) {
				for await(const word of keys()) {
					const node = await get(word);
					if(node && node[id]) { 
						delete node[id];
						await set(word,node);
						onchange({[word]:{[id]:{stems:0,trigrams:0,compressions:0}}});
					}
				}
			}
			return this;
		};

		// return the index so that the calling program can perhaps store it somewhere
		this.getIndex = () => _copy(index);

		this.getKeys = async () => {
			const results = {};
			for await(const key of keys()) {
				results[key] = true;
			}
			return results;
		};

		this.getKeyCount = () => count ? count() : keycount;

		// set the index, in case the calling program is loading it from somewhere
		this.setIndex = newIndex => { 
			index = _copy(newIndex);
			keycount = 0;
			Object.assign(keys,Object.keys(index).reduce((accum,key) => { accum[key] = true; keycount++; return accum; }, {}));
			return this; 
		};

		// function to call every time an index entry is updated
		// called which can be used to update an external data structure using Object.assign(external,updates);
		// alternatively,it can be decomposed so that more precise updating of say a Redis store can be done incrementally
		this.onchange = defaults.onchange;

		// create an index entry with id by indexing objectOrText
		// use the id, perhaps a URL< to lookup the full object when it is returned in search results
		this.index = function(id,objectOrText,{stems=defaults.stems,trigrams=defaults.trigrams,compressions=defaults.compressions,misspellings=defaults.misspellings}=defaults) {
			const  type = typeof(objectOrText);
			if(!objectOrText || !(type==="string" || type==="object")) {
				return;
			}
			if(type==="object") {
				stems = true;
			}
			const text = _toText(objectOrText);
			const tokens = objectOrText ? _tokenize(text,type==="object") : [];
			const stemmed = (stems || type==="object" ? tokens.reduce((accum,token) => 
					{ 
						const type = typeof(token);
						if(type!=="number" && type!=="boolean") {
							const stem = _stemmer(token);
							if(!stops[stem]) {
								accum.push(stem);
							}
						}
						return accum;
					},[]) : []),
				other = tokens.filter(token => token==="true" || token==="false" || !isNaN(parseFloat(token))),
				noproperties = (stems ? stemmed : tokens).filter(token => token[token.length-1]!==":" && isNaN(parseFloat(token)) && token!=="true" && token!=="false"),
				grams = trigrams ? _trigrams(noproperties) : [],
				misspelled = (misspellings ? noproperties.reduce((accum,stem) => accum.concat(_misspellings(stem,true)),[]) : []).filter(word => !grams.includes(word)),
				compressed = compressions ? noproperties.reduce((accum,stem) => accum.concat(_compress(stem)),[]).concat(misspelled.reduce((accum,stem) => accum.concat(_compress(stem)),[])) : [],
				onchange = this.onchange || (() => {});
			let changes,
				count = 0;
			for(const word of stemmed.concat(misspelled).concat(compressed).concat(other)) {
					if(!stops[word]) { // check stops again in case a compression is a stop
						const isboolean = word==="false" || word==="true",
							isnumber = !isNaN(parseFloat(word));
						let node = get(word),
							change;
						keys[word] = true;
						if(isboolean) {
							if(!node) {
								node = {};
								count++;
							}
							if(!node[id]) {
								node[id] =  {stems:0,trigrams:0,compressions:0,numbers:0,booleans:0};
							}
							node[id].boolean++;
							change = node[id];
						}
						if(isnumber) {
							if(!node) {
								node = {};
								count++;
							}
							if(!node[id]) {
								node[id] =  {stems:0,trigrams:0,compressions:0,numbers:0,booleans:0};
							}
							node[id].numbers++;
							change = node[id];
						}
						if(!isboolean && !isnumber) {
							if(stems && (stemmed.includes(word) || misspelled.includes(word))) {
								if(!node) {
									node = {};
									count++;
								}
								if(!node[id]) {
									node[id] =  {stems:0,trigrams:0,compressions:0,numbers:0,booleans:0};
								}
								node[id].stems++;
								change = node[id];
							}
							if(compressions && compressed.includes(word)) {
								if(!node) {
									node = {};
									count++;
								}
								if(!node[id]) {
									node[id] =  {stems:0,trigrams:0,compressions:0};
								}
								node[id].compressions++;
								change = node[id];
							}
						}
						if(change) {
							if(!changes) {
								changes = {};
							}
							if(!changes[word]) {
								changes[word] = {};
							}
							changes[word][id] = change;
							set(word,node);
						}
					}
			}
			for(const word of grams) {
				if(!stops[word]) {
					let node = get(word);
					keys[word] = true;
					if(!node) {
						node = {};
						count++;
					}
					if(!node[id]) {
						node[id] = {stems:0,trigrams:0,compressions:0,booleans:0,numbers:0};
					}
					node[id].trigrams++;
					if(!changes) {
						changes = {};
					}
					if(!changes[word]) {
						changes[word] = {};
					}
					changes[word][id] = node[id];
					set(word,node);
				}
			}
			if(changes) onchange(changes);
			keycount += count;
			return this;
		};

		// return a sorted array of search results matching the provided objectOrText
		this.search = function(objectOrText,{all,stems=defaults.stems,trigrams=defaults.trigrams,compressions=defaults.compressions,misspellings=defaults.misspellings}=defaults) {
			const  type = typeof(objectOrText);
			if(!objectOrText || !(type==="string" || type==="object")) {
				return [];
			}
			if(type==="object") {
				stems = true;
			}
			const	text = _toText(objectOrText),
				tokens = objectOrText ? _tokenize(text,type==="object") : [],
				stemmed = (stems || type==="object" ? tokens.reduce((accum,token) => 
				{ 
					const type = typeof(token);
					if(type!=="number" && type!=="boolean") {
						const stem = _stemmer(token);
						if(!stops[stem]) {
							accum.push(stem);
						}
					}
					return accum;
				},[]) : []),
				other = tokens.filter(token => token==="true" || token==="false" || !isNaN(parseFloat(token))),
				noproperties = (stems ? stemmed : tokens).filter(token => token[token.length-1]!==":" && isNaN(parseFloat(token)) && token!=="true" && token!=="false"),
				grams = trigrams ? _trigrams(noproperties) : [],
				compressed = compressions ? noproperties.map(stem => _compress(stem)) : [],
				results = [];
				for(const word of stemmed.concat(grams).concat(compressed).concat(other)) {
					if(!stops[word]) {
						const node = get(word),
							isboolean = word==="false" || word==="true",
							isnumber = !isNaN(parseFloat(word));
						if(node) {
							Object.keys(node).forEach(id => {
								if(!results[id]) {
									results[id] = {score:0,count:0,stems:{},trigrams:{},compressions:{},booleans:{},numbers:{}};
								}
								let count = 0;
								if(isboolean) {
									if(!results[id].booleans[word]) {
										results[id].booleans[word] = 0;
									}
									results[id].booleans[word] += node[id].booleans;
									results[id].score += node[id].booleans;
									count = 1;
								}
								if(isnumber) {
									if(!results[id].numbers[word]) {
										results[id].numbers[word] = 0;
									}
									results[id].numbers[word] += node[id].numbers;
									results[id].score += node[id].numbers;
									count = 1;
								}
								if(stems && stemmed.includes(word)) {
									if(!results[id].stems[word]) {
										results[id].stems[word] = 0;
									}
									results[id].stems[word] += node[id].stems;
									results[id].score += node[id].stems;
									count = 1;
								}
								if(trigrams && grams.includes(word)) {
									if(!results[id].trigrams[word]) {
										results[id].trigrams[word] = 0;
									}
									const score = node[id].trigrams * .5;
									results[id].trigrams[word] += score;
									results[id].score += score;
								}
								if(compressions && compressed.includes(word)) {
									if(!results[id].compressions[word]) {
										results[id].compressions[word] = 0;
									}
									const score = node[id].compressions * .75;
									results[id].compressions[word] += score;
									results[id].score += score;
									count || (count = 1);
								}
								results[id].count += count;
							});
						}
					}
				}
				const properties = type==="object" ? Object.keys(objectOrText) : [];
				return Object.keys(results)
					.reduce((accum,id) => {
						const result = results[id];
						if(result.score>0) {
							// if matching an object, 
							// find at least one top level matching property name
							// and a matched value
							const method = all ? "every" : "some";
							if(type==="object") {
								if(properties[method](property => {
									if(result.stems[property+":"]) {
										const value = objectOrText[property];
										if(value==="_*_") return true;
										if(value=="true" || value=="false") {
											if(result.booleans[value]) return true;
										} else if(typeof(value)==="number") {
											if(result.numbers[value]) return true;
										} else {
											const stemmed = _tokenize(value).map(token => _stemmer(token));
											return stemmed.some(stem => result.stems[stem]);
										}
									}
								})) {
									accum.push(Object.assign({id:_coerceId(id)},result));
								}
							} else if(all) {
								if(stems && Object.keys(result.stems).length===0 && Object.keys(result.numbers).length===0 && Object.keys(result.booleans).length===0) return accum;
								if(trigrams && Object.keys(result.trigrams).length===0) return accum;
								if(compressions && Object.keys(result.compressions).length===0) return accum;
								accum.push(Object.assign({id:_coerceId(id)},result));
							} else {
								accum.push(Object.assign({id:_coerceId(id)},result));
							}
						}
						return accum;
					},[])
					.sort((a,b) => b.score - a.score);
				};
			}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var earcut$2 = {exports: {}};

	earcut$2.exports = earcut$1;
	earcut$2.exports.default = earcut$1;

	function earcut$1(data, holeIndices, dim) {

	    dim = dim || 2;

	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList$1(data, 0, outerLen, dim, true),
	        triangles = [];

	    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

	    var minX, minY, maxX, maxY, x, y, invSize;

	    if (hasHoles) outerNode = eliminateHoles$1(data, holeIndices, outerNode, dim);

	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];

	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }

	        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
	        invSize = Math.max(maxX - minX, maxY - minY);
	        invSize = invSize !== 0 ? 1 / invSize : 0;
	    }

	    earcutLinked$1(outerNode, triangles, dim, minX, minY, invSize);

	    return triangles;
	}

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList$1(data, start, end, dim, clockwise) {
	    var i, last;

	    if (clockwise === (signedArea$1(data, start, end, dim) > 0)) {
	        for (i = start; i < end; i += dim) last = insertNode$2(i, data[i], data[i + 1], last);
	    } else {
	        for (i = end - dim; i >= start; i -= dim) last = insertNode$2(i, data[i], data[i + 1], last);
	    }

	    if (last && equals$2(last, last.next)) {
	        removeNode$1(last);
	        last = last.next;
	    }

	    return last;
	}

	// eliminate colinear or duplicate points
	function filterPoints$1(start, end) {
	    if (!start) return start;
	    if (!end) end = start;

	    var p = start,
	        again;
	    do {
	        again = false;

	        if (!p.steiner && (equals$2(p, p.next) || area$2(p.prev, p, p.next) === 0)) {
	            removeNode$1(p);
	            p = end = p.prev;
	            if (p === p.next) break;
	            again = true;

	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);

	    return end;
	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked$1(ear, triangles, dim, minX, minY, invSize, pass) {
	    if (!ear) return;

	    // interlink polygon nodes in z-order
	    if (!pass && invSize) indexCurve$1(ear, minX, minY, invSize);

	    var stop = ear,
	        prev, next;

	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;

	        if (invSize ? isEarHashed$1(ear, minX, minY, invSize) : isEar$1(ear)) {
	            // cut off the triangle
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);

	            removeNode$1(ear);

	            // skipping the next vertex leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;

	            continue;
	        }

	        ear = next;

	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked$1(filterPoints$1(ear), triangles, dim, minX, minY, invSize, 1);

	            // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections$1(ear, triangles, dim);
	                earcutLinked$1(ear, triangles, dim, minX, minY, invSize, 2);

	            // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut$1(ear, triangles, dim, minX, minY, invSize);
	            }

	            break;
	        }
	    }
	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar$1(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area$2(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // now make sure we don't have other points inside the potential ear
	    var p = ear.next.next;

	    while (p !== ear.prev) {
	        if (pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area$2(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }

	    return true;
	}

	function isEarHashed$1(ear, minX, minY, invSize) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area$2(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // triangle bbox; min & max are calculated like this for speed
	    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
	        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
	        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
	        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

	    // z-order range for the current triangle bbox;
	    var minZ = zOrder$1(minTX, minTY, minX, minY, invSize),
	        maxZ = zOrder$1(maxTX, maxTY, minX, minY, invSize);

	    var p = ear.prevZ,
	        n = ear.nextZ;

	    // look for points inside the triangle in both directions
	    while (p && p.z >= minZ && n && n.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area$2(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;

	        if (n !== ear.prev && n !== ear.next &&
	            pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
	            area$2(n.prev, n, n.next) >= 0) return false;
	        n = n.nextZ;
	    }

	    // look for remaining points in decreasing z-order
	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area$2(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }

	    // look for remaining points in increasing z-order
	    while (n && n.z <= maxZ) {
	        if (n !== ear.prev && n !== ear.next &&
	            pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
	            area$2(n.prev, n, n.next) >= 0) return false;
	        n = n.nextZ;
	    }

	    return true;
	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections$1(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;

	        if (!equals$2(a, b) && intersects$5(a, p, p.next, b) && locallyInside$1(a, b) && locallyInside$1(b, a)) {

	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);

	            // remove two nodes involved
	            removeNode$1(p);
	            removeNode$1(p.next);

	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);

	    return p;
	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut$1(start, triangles, dim, minX, minY, invSize) {
	    // look for a valid diagonal that divides the polygon into two
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal$1(a, b)) {
	                // split the polygon in two by the diagonal
	                var c = splitPolygon$1(a, b);

	                // filter colinear points around the cuts
	                a = filterPoints$1(a, a.next);
	                c = filterPoints$1(c, c.next);

	                // run earcut on each half
	                earcutLinked$1(a, triangles, dim, minX, minY, invSize);
	                earcutLinked$1(c, triangles, dim, minX, minY, invSize);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles$1(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i, len, start, end, list;

	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList$1(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost$1(list));
	    }

	    queue.sort(compareX$1);

	    // process holes from left to right
	    for (i = 0; i < queue.length; i++) {
	        eliminateHole$1(queue[i], outerNode);
	        outerNode = filterPoints$1(outerNode, outerNode.next);
	    }

	    return outerNode;
	}

	function compareX$1(a, b) {
	    return a.x - b.x;
	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole$1(hole, outerNode) {
	    outerNode = findHoleBridge$1(hole, outerNode);
	    if (outerNode) {
	        var b = splitPolygon$1(outerNode, hole);
	        filterPoints$1(b, b.next);
	    }
	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge$1(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;

	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) return p;
	                    if (hy === p.next.y) return p.next;
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);

	    if (!m) return null;

	    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point

	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;

	    p = m.next;

	    while (p !== stop) {
	        if (hx >= p.x && p.x >= mx && hx !== p.x &&
	                pointInTriangle$1(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

	            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

	            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside$1(p, hole)) {
	                m = p;
	                tanMin = tan;
	            }
	        }

	        p = p.next;
	    }

	    return m;
	}

	// interlink polygon nodes in z-order
	function indexCurve$1(start, minX, minY, invSize) {
	    var p = start;
	    do {
	        if (p.z === null) p.z = zOrder$1(p.x, p.y, minX, minY, invSize);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);

	    p.prevZ.nextZ = null;
	    p.prevZ = null;

	    sortLinked$1(p);
	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked$1(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize,
	        inSize = 1;

	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;

	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }
	            qSize = inSize;

	            while (pSize > 0 || (qSize > 0 && q)) {

	                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }

	                if (tail) tail.nextZ = e;
	                else list = e;

	                e.prevZ = tail;
	                tail = e;
	            }

	            p = q;
	        }

	        tail.nextZ = null;
	        inSize *= 2;

	    } while (numMerges > 1);

	    return list;
	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder$1(x, y, minX, minY, invSize) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = 32767 * (x - minX) * invSize;
	    y = 32767 * (y - minY) * invSize;

	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;

	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;

	    return x | (y << 1);
	}

	// find the leftmost node of a polygon ring
	function getLeftmost$1(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
	        p = p.next;
	    } while (p !== start);

	    return leftmost;
	}

	// check if a point lies within a convex triangle
	function pointInTriangle$1(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
	           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
	           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal$1(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon$4(a, b) &&
	           locallyInside$1(a, b) && locallyInside$1(b, a) && middleInside$1(a, b);
	}

	// signed area of a triangle
	function area$2(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	// check if two points are equal
	function equals$2(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}

	// check if two segments intersect
	function intersects$5(p1, q1, p2, q2) {
	    if ((equals$2(p1, q1) && equals$2(p2, q2)) ||
	        (equals$2(p1, q2) && equals$2(p2, q1))) return true;
	    return area$2(p1, q1, p2) > 0 !== area$2(p1, q1, q2) > 0 &&
	           area$2(p2, q2, p1) > 0 !== area$2(p2, q2, q1) > 0;
	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon$4(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects$5(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);

	    return false;
	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside$1(a, b) {
	    return area$2(a.prev, a, a.next) < 0 ?
	        area$2(a, b, a.next) >= 0 && area$2(a, a.prev, b) >= 0 :
	        area$2(a, b, a.prev) < 0 || area$2(a, a.next, b) < 0;
	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside$1(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
	                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);

	    return inside;
	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon$1(a, b) {
	    var a2 = new Node$3(a.i, a.x, a.y),
	        b2 = new Node$3(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;

	    a.next = b;
	    b.prev = a;

	    a2.next = an;
	    an.prev = a2;

	    b2.next = a2;
	    a2.prev = b2;

	    bp.next = b2;
	    b2.prev = bp;

	    return b2;
	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode$2(i, x, y, last) {
	    var p = new Node$3(i, x, y);

	    if (!last) {
	        p.prev = p;
	        p.next = p;

	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}

	function removeNode$1(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;

	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node$3(i, x, y) {
	    // vertex index in coordinates array
	    this.i = i;

	    // vertex coordinates
	    this.x = x;
	    this.y = y;

	    // previous and next vertex nodes in a polygon ring
	    this.prev = null;
	    this.next = null;

	    // z-order curve value
	    this.z = null;

	    // previous and next nodes in z-order
	    this.prevZ = null;
	    this.nextZ = null;

	    // indicates whether this is a steiner point
	    this.steiner = false;
	}

	// return a percentage difference between the polygon area and its triangulation area;
	// used to verify correctness of triangulation
	earcut$1.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

	    var polygonArea = Math.abs(signedArea$1(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea$1(data, start, end, dim));
	        }
	    }

	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs(
	            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
	            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }

	    return polygonArea === 0 && trianglesArea === 0 ? 0 :
	        Math.abs((trianglesArea - polygonArea) / polygonArea);
	};

	function signedArea$1(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}

	// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
	earcut$1.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = {vertices: [], holes: [], dimensions: dim},
	        holeIndex = 0;

	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};

	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 */
	var earthRadius = 6371008.8;

	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 */
	var factors = {
	    meters: earthRadius,
	    metres: earthRadius,
	    millimeters: earthRadius * 1000,
	    millimetres: earthRadius * 1000,
	    centimeters: earthRadius * 100,
	    centimetres: earthRadius * 100,
	    kilometers: earthRadius / 1000,
	    kilometres: earthRadius / 1000,
	    miles: earthRadius / 1609.344,
	    nauticalmiles: earthRadius / 1852,
	    inches: earthRadius * 39.370,
	    yards: earthRadius / 1.0936,
	    feet: earthRadius * 3.28084,
	    radians: 1,
	    degrees: earthRadius / 111325,
	};

	/**
	 * Units of measurement factors based on 1 meter.
	 */
	var unitsFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000,
	    millimetres: 1000,
	    centimeters: 100,
	    centimetres: 100,
	    kilometers: 1 / 1000,
	    kilometres: 1 / 1000,
	    miles: 1 / 1609.344,
	    nauticalmiles: 1 / 1852,
	    inches: 39.370,
	    yards: 1 / 1.0936,
	    feet: 3.28084,
	    radians: 1 / earthRadius,
	    degrees: 1 / 111325,
	};

	/**
	 * Area of measurement factors based on 1 square meter.
	 */
	var areaFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000000,
	    millimetres: 1000000,
	    centimeters: 10000,
	    centimetres: 10000,
	    kilometers: 0.000001,
	    kilometres: 0.000001,
	    acres: 0.000247105,
	    miles: 3.86e-7,
	    yards: 1.195990046,
	    feet: 10.763910417,
	    inches: 1550.003100006
	};

	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geometry, properties, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (geometry === undefined) throw new Error('geometry is required');
	    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var feat = {type: 'Feature'};
	    if (id) feat.id = id;
	    if (bbox) feat.bbox = bbox;
	    feat.properties = properties || {};
	    feat.geometry = geometry;
	    return feat;
	}

	/**
	 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
	 * For GeometryCollection type use `helpers.geometryCollection`
	 *
	 * @name geometry
	 * @param {string} type Geometry Type
	 * @param {Array<number>} coordinates Coordinates
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry
	 * @returns {Geometry} a GeoJSON Geometry
	 * @example
	 * var type = 'Point';
	 * var coordinates = [110, 50];
	 *
	 * var geometry = turf.geometry(type, coordinates);
	 *
	 * //=geometry
	 */
	function geometry(type, coordinates, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;

	    // Validation
	    if (!type) throw new Error('type is required');
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (bbox) validateBBox(bbox);

	    // Main
	    var geom;
	    switch (type) {
	    case 'Point': geom = point$7(coordinates).geometry; break;
	    case 'LineString': geom = lineString(coordinates).geometry; break;
	    case 'Polygon': geom = polygon$8(coordinates).geometry; break;
	    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
	    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
	    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
	    default: throw new Error(type + ' is invalid');
	    }
	    if (bbox) geom.bbox = bbox;
	    return geom;
	}

	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point$7(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
	    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'Point',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
	 *
	 * @name points
	 * @param {Array<Array<number>>} coordinates an array of Points
	 * @param {Object} [properties={}] Translate these properties to each Feature
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Point>} Point Feature
	 * @example
	 * var points = turf.points([
	 *   [-75, 39],
	 *   [-80, 45],
	 *   [-78, 50]
	 * ]);
	 *
	 * //=points
	 */
	function points(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return point$7(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon$8(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    for (var i = 0; i < coordinates.length; i++) {
	        var ring = coordinates[i];
	        if (ring.length < 4) {
	            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error('First and last Position are not equivalent.');
	            }
	        }
	    }

	    return feature({
	        type: 'Polygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
	 *
	 * @name polygons
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
	 * @example
	 * var polygons = turf.polygons([
	 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
	 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
	 * ]);
	 *
	 * //=polygons
	 */
	function polygons(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return polygon$8(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');
	    // Check if first point of LineString contains two numbers
	    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'LineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
	 *
	 * @name lineStrings
	 * @param {Array<Array<number>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
	 * @example
	 * var linestrings = turf.lineStrings([
	 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
	 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
	 * ]);
	 *
	 * //=linestrings
	 */
	function lineStrings(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return lineString(coords, properties);
	    }), options);
	}

	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (!features) throw new Error('No features passed');
	    if (!Array.isArray(features)) throw new Error('features must be an Array');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var fc = {type: 'FeatureCollection'};
	    if (id) fc.id = id;
	    if (bbox) fc.bbox = bbox;
	    fc.features = features;
	    return fc;
	}

	/**
	 * Creates a {@link Feature<MultiLineString>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiLineString
	 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiLineString>} a MultiLineString feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
	 *
	 * //=multiLine
	 */
	function multiLineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiLineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPoint>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPoint
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPoint>} a MultiPoint feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
	 *
	 * //=multiPt
	 */
	function multiPoint(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPoint',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPolygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<GeometryCollection>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name geometryCollection
	 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
	 * @example
	 * var pt = {
	 *     "type": "Point",
	 *       "coordinates": [100, 0]
	 *     };
	 * var line = {
	 *     "type": "LineString",
	 *     "coordinates": [ [101, 0], [102, 1] ]
	 *   };
	 * var collection = turf.geometryCollection([pt, line]);
	 *
	 * //=collection
	 */
	function geometryCollection(geometries, properties, options) {
	    if (!geometries) throw new Error('geometries is required');
	    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

	    return feature({
	        type: 'GeometryCollection',
	        geometries: geometries
	    }, properties, options);
	}

	/**
	 * Round number to precision
	 *
	 * @param {number} num Number
	 * @param {number} [precision=0] Precision
	 * @returns {number} rounded number
	 * @example
	 * turf.round(120.4321)
	 * //=120
	 *
	 * turf.round(120.4321, 2)
	 * //=120.43
	 */
	function round(num, precision) {
	    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
	    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
	    var multiplier = Math.pow(10, precision || 0);
	    return Math.round(num * multiplier) / multiplier;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
	    if (radians === undefined || radians === null) throw new Error('radians is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return radians * factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	    if (distance === undefined || distance === null) throw new Error('distance is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return distance / factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
	 *
	 * @name lengthToDegrees
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} degrees
	 */
	function lengthToDegrees(distance, units) {
	    return radiansToDegrees(lengthToRadians(distance, units));
	}

	/**
	 * Converts any bearing angle from the north line direction (positive clockwise)
	 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
	 *
	 * @name bearingToAzimuth
	 * @param {number} bearing angle, between -180 and +180 degrees
	 * @returns {number} angle between 0 and 360 degrees
	 */
	function bearingToAzimuth(bearing) {
	    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

	    var angle = bearing % 360;
	    if (angle < 0) angle += 360;
	    return angle;
	}

	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
	    if (radians === null || radians === undefined) throw new Error('radians is required');

	    var degrees = radians % (2 * Math.PI);
	    return degrees * 180 / Math.PI;
	}

	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
	    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

	    var radians = degrees % 360;
	    return radians * Math.PI / 180;
	}

	/**
	 * Converts a length to the requested unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @param {number} length to be converted
	 * @param {string} originalUnit of the length
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted length
	 */
	function convertLength(length, originalUnit, finalUnit) {
	    if (length === null || length === undefined) throw new Error('length is required');
	    if (!(length >= 0)) throw new Error('length must be a positive number');

	    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');
	}

	/**
	 * Converts a area to the requested unit.
	 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
	 * @param {number} area to be converted
	 * @param {string} [originalUnit='meters'] of the distance
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted distance
	 */
	function convertArea(area, originalUnit, finalUnit) {
	    if (area === null || area === undefined) throw new Error('area is required');
	    if (!(area >= 0)) throw new Error('area must be a positive number');

	    var startFactor = areaFactors[originalUnit || 'meters'];
	    if (!startFactor) throw new Error('invalid original units');

	    var finalFactor = areaFactors[finalUnit || 'kilometers'];
	    if (!finalFactor) throw new Error('invalid final units');

	    return (area / startFactor) * finalFactor;
	}

	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
	    return !isNaN(num) && num !== null && !Array.isArray(num);
	}

	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
	    return (!!input) && (input.constructor === Object);
	}

	/**
	 * Validate BBox
	 *
	 * @private
	 * @param {Array<number>} bbox BBox to validate
	 * @returns {void}
	 * @throws Error if BBox is not valid
	 * @example
	 * validateBBox([-180, -40, 110, 50])
	 * //=OK
	 * validateBBox([-180, -40])
	 * //=Error
	 * validateBBox('Foo')
	 * //=Error
	 * validateBBox(5)
	 * //=Error
	 * validateBBox(null)
	 * //=Error
	 * validateBBox(undefined)
	 * //=Error
	 */
	function validateBBox(bbox) {
	    if (!bbox) throw new Error('bbox is required');
	    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
	    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
	    bbox.forEach(function (num) {
	        if (!isNumber(num)) throw new Error('bbox must only contain numbers');
	    });
	}

	/**
	 * Validate Id
	 *
	 * @private
	 * @param {string|number} id Id to validate
	 * @returns {void}
	 * @throws Error if Id is not valid
	 * @example
	 * validateId([-180, -40, 110, 50])
	 * //=Error
	 * validateId([-180, -40])
	 * //=Error
	 * validateId('Foo')
	 * //=OK
	 * validateId(5)
	 * //=OK
	 * validateId(null)
	 * //=Error
	 * validateId(undefined)
	 * //=Error
	 */
	function validateId(id) {
	    if (!id) throw new Error('id is required');
	    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
	}

	// Deprecated methods
	function radians2degrees() {
	    throw new Error('method has been renamed to `radiansToDegrees`');
	}

	function degrees2radians() {
	    throw new Error('method has been renamed to `degreesToRadians`');
	}

	function distanceToDegrees() {
	    throw new Error('method has been renamed to `lengthToDegrees`');
	}

	function distanceToRadians() {
	    throw new Error('method has been renamed to `lengthToRadians`');
	}

	function radiansToDistance() {
	    throw new Error('method has been renamed to `radiansToLength`');
	}

	function bearingToAngle() {
	    throw new Error('method has been renamed to `bearingToAzimuth`');
	}

	function convertDistance() {
	    throw new Error('method has been renamed to `convertLength`');
	}




	Object.freeze({
		earthRadius: earthRadius,
		factors: factors,
		unitsFactors: unitsFactors,
		areaFactors: areaFactors,
		feature: feature,
		geometry: geometry,
		point: point$7,
		points: points,
		polygon: polygon$8,
		polygons: polygons,
		lineString: lineString,
		lineStrings: lineStrings,
		featureCollection: featureCollection,
		multiLineString: multiLineString,
		multiPoint: multiPoint,
		multiPolygon: multiPolygon,
		geometryCollection: geometryCollection,
		round: round,
		radiansToLength: radiansToLength,
		lengthToRadians: lengthToRadians,
		lengthToDegrees: lengthToDegrees,
		bearingToAzimuth: bearingToAzimuth,
		radiansToDegrees: radiansToDegrees,
		degreesToRadians: degreesToRadians,
		convertLength: convertLength,
		convertArea: convertArea,
		isNumber: isNumber,
		isObject: isObject,
		validateBBox: validateBBox,
		validateId: validateId,
		radians2degrees: radians2degrees,
		degrees2radians: degrees2radians,
		distanceToDegrees: distanceToDegrees,
		distanceToRadians: distanceToRadians,
		radiansToDistance: radiansToDistance,
		bearingToAngle: bearingToAngle,
		convertDistance: convertDistance
	});

	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach$1(geojson, callback, excludeWrapCoord) {
	    // Handles null Geometry -- Skips this GeoJSON
	    if (geojson === null) return;
	    var j, k, l, geometry$$1, stopG, coords,
	        geometryMaybeCollection,
	        wrapShrink = 0,
	        coordIndex = 0,
	        isGeometryCollection,
	        type = geojson.type,
	        isFeatureCollection = type === 'FeatureCollection',
	        isFeature = type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
	            var multiFeatureIndex = 0;
	            var geometryIndex = 0;
	            geometry$$1 = isGeometryCollection ?
	                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

	            // Handles null Geometry -- Skips this geometry
	            if (geometry$$1 === null) continue;
	            coords = geometry$$1.coordinates;
	            var geomType = geometry$$1.type;

	            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

	            switch (geomType) {
	            case null:
	                break;
	            case 'Point':
	                callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                coordIndex++;
	                multiFeatureIndex++;
	                break;
	            case 'LineString':
	            case 'MultiPoint':
	                for (j = 0; j < coords.length; j++) {
	                    callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                    coordIndex++;
	                    if (geomType === 'MultiPoint') multiFeatureIndex++;
	                }
	                if (geomType === 'LineString') multiFeatureIndex++;
	                break;
	            case 'Polygon':
	            case 'MultiLineString':
	                for (j = 0; j < coords.length; j++) {
	                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
	                        callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                        coordIndex++;
	                    }
	                    if (geomType === 'MultiLineString') multiFeatureIndex++;
	                    if (geomType === 'Polygon') geometryIndex++;
	                }
	                if (geomType === 'Polygon') multiFeatureIndex++;
	                break;
	            case 'MultiPolygon':
	                for (j = 0; j < coords.length; j++) {
	                    if (geomType === 'MultiPolygon') geometryIndex = 0;
	                    for (k = 0; k < coords[j].length; k++) {
	                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
	                            callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                            coordIndex++;
	                        }
	                        geometryIndex++;
	                    }
	                    multiFeatureIndex++;
	                }
	                break;
	            case 'GeometryCollection':
	                for (j = 0; j < geometry$$1.geometries.length; j++)
	                    coordEach$1(geometry$$1.geometries[j], callback, excludeWrapCoord);
	                break;
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	    }
	}

	/**
	 * Callback for coordReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback coordReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
	 *
	 * @name coordReduce
	 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentCoord;
	 * });
	 */
	function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
	    var previousValue = initialValue;
	    coordEach$1(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
	        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	    }, excludeWrapCoord);
	    return previousValue;
	}

	/**
	 * Callback for propEach
	 *
	 * @callback propEachCallback
	 * @param {Object} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name propEach
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentProperties, featureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propEach(features, function (currentProperties, featureIndex) {
	 *   //=currentProperties
	 *   //=featureIndex
	 * });
	 */
	function propEach(geojson, callback) {
	    var i;
	    switch (geojson.type) {
	    case 'FeatureCollection':
	        for (i = 0; i < geojson.features.length; i++) {
	            callback(geojson.features[i].properties, i);
	        }
	        break;
	    case 'Feature':
	        callback(geojson.properties, 0);
	        break;
	    }
	}


	/**
	 * Callback for propReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback propReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {*} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce properties in any GeoJSON object into a single value,
	 * similar to how Array.reduce works. However, in this case we lazily run
	 * the reduction, so an array of all properties is unnecessary.
	 *
	 * @name propReduce
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
	 *   //=previousValue
	 *   //=currentProperties
	 *   //=featureIndex
	 *   return currentProperties
	 * });
	 */
	function propReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    propEach(geojson, function (currentProperties, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
	        else previousValue = callback(previousValue, currentProperties, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach$1(geojson, callback) {
	    if (geojson.type === 'Feature') {
	        callback(geojson, 0);
	    } else if (geojson.type === 'FeatureCollection') {
	        for (var i = 0; i < geojson.features.length; i++) {
	            callback(geojson.features[i], i);
	        }
	    }
	}

	/**
	 * Callback for featureReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback featureReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name featureReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   return currentFeature
	 * });
	 */
	function featureReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    featureEach$1(geojson, function (currentFeature, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Get all coordinates from any GeoJSON object.
	 *
	 * @name coordAll
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @returns {Array<Array<number>>} coordinate position array
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * var coords = turf.coordAll(features);
	 * //= [[26, 37], [36, 53]]
	 */
	function coordAll(geojson) {
	    var coords = [];
	    coordEach$1(geojson, function (coord) {
	        coords.push(coord);
	    });
	    return coords;
	}

	/**
	 * Callback for geomEach
	 *
	 * @callback geomEachCallback
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name geomEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 * });
	 */
	function geomEach(geojson, callback) {
	    var i, j, g, geometry$$1, stopG,
	        geometryMaybeCollection,
	        isGeometryCollection,
	        featureProperties,
	        featureBBox,
	        featureId,
	        featureIndex = 0,
	        isFeatureCollection = geojson.type === 'FeatureCollection',
	        isFeature = geojson.type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (i = 0; i < stop; i++) {

	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
	            (isFeature ? geojson.properties : {}));
	        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
	            (isFeature ? geojson.bbox : undefined));
	        featureId = (isFeatureCollection ? geojson.features[i].id :
	            (isFeature ? geojson.id : undefined));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (g = 0; g < stopG; g++) {
	            geometry$$1 = isGeometryCollection ?
	                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

	            // Handle null Geometry
	            if (geometry$$1 === null) {
	                callback(null, featureIndex, featureProperties, featureBBox, featureId);
	                continue;
	            }
	            switch (geometry$$1.type) {
	            case 'Point':
	            case 'LineString':
	            case 'MultiPoint':
	            case 'Polygon':
	            case 'MultiLineString':
	            case 'MultiPolygon': {
	                callback(geometry$$1, featureIndex, featureProperties, featureBBox, featureId);
	                break;
	            }
	            case 'GeometryCollection': {
	                for (j = 0; j < geometry$$1.geometries.length; j++) {
	                    callback(geometry$$1.geometries[j], featureIndex, featureProperties, featureBBox, featureId);
	                }
	                break;
	            }
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	        // Only increase `featureIndex` per each feature
	        featureIndex++;
	    }
	}

	/**
	 * Callback for geomReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback geomReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name geomReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=previousValue
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 *   return currentGeometry
	 * });
	 */
	function geomReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
	        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
	    });
	    return previousValue;
	}

	/**
	 * Callback for flattenEach
	 *
	 * @callback flattenEachCallback
	 * @param {Feature} currentFeature The current flattened feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Iterate over flattened features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name flattenEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 * });
	 */
	function flattenEach(geojson, callback) {
	    geomEach(geojson, function (geometry$$1, featureIndex, properties, bbox, id) {
	        // Callback for single geometry
	        var type = (geometry$$1 === null) ? null : geometry$$1.type;
	        switch (type) {
	        case null:
	        case 'Point':
	        case 'LineString':
	        case 'Polygon':
	            callback(feature(geometry$$1, properties, {bbox: bbox, id: id}), featureIndex, 0);
	            return;
	        }

	        var geomType;

	        // Callback for multi-geometry
	        switch (type) {
	        case 'MultiPoint':
	            geomType = 'Point';
	            break;
	        case 'MultiLineString':
	            geomType = 'LineString';
	            break;
	        case 'MultiPolygon':
	            geomType = 'Polygon';
	            break;
	        }

	        geometry$$1.coordinates.forEach(function (coordinate, multiFeatureIndex) {
	            var geom = {
	                type: geomType,
	                coordinates: coordinate
	            };
	            callback(feature(geom, properties), featureIndex, multiFeatureIndex);
	        });

	    });
	}

	/**
	 * Callback for flattenReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback flattenReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name flattenReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   return currentFeature
	 * });
	 */
	function flattenReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
	        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for segmentEach
	 *
	 * @callback segmentEachCallback
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 * @returns {void}
	 */

	/**
	 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //=currentSegment
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   //=segmentIndex
	 * });
	 *
	 * // Calculate the total number of segments
	 * var total = 0;
	 * turf.segmentEach(polygon, function () {
	 *     total++;
	 * });
	 */
	function segmentEach(geojson, callback) {
	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        var segmentIndex = 0;

	        // Exclude null Geometries
	        if (!feature$$1.geometry) return;
	        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	        var type = feature$$1.geometry.type;
	        if (type === 'Point' || type === 'MultiPoint') return;

	        // Generate 2-vertex line segments
	        coordReduce(feature$$1, function (previousCoords, currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {
	            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);
	            callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
	            segmentIndex++;
	            return currentCoord;
	        });
	    });
	}

	/**
	 * Callback for segmentReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback segmentReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 */

	/**
	 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //= previousSegment
	 *   //= currentSegment
	 *   //= featureIndex
	 *   //= multiFeatureIndex
	 *   //= geometryIndex
	 *   //= segmentInex
	 *   return currentSegment
	 * });
	 *
	 * // Calculate the total number of segments
	 * var initialValue = 0
	 * var total = turf.segmentReduce(polygon, function (previousValue) {
	 *     previousValue++;
	 *     return previousValue;
	 * }, initialValue);
	 */
	function segmentReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    var started = false;
	    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	        if (started === false && initialValue === undefined) previousValue = currentSegment;
	        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
	        started = true;
	    });
	    return previousValue;
	}

	/**
	 * Callback for lineEach
	 *
	 * @callback lineEachCallback
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
	 * similar to Array.forEach.
	 *
	 * @name lineEach
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @example
	 * var multiLine = turf.multiLineString([
	 *   [[26, 37], [35, 45]],
	 *   [[36, 53], [38, 50], [41, 55]]
	 * ]);
	 *
	 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function lineEach(geojson, callback) {
	    // validation
	    if (!geojson) throw new Error('geojson is required');

	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        if (feature$$1.geometry === null) return;
	        var type = feature$$1.geometry.type;
	        var coords = feature$$1.geometry.coordinates;
	        switch (type) {
	        case 'LineString':
	            callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0);
	            break;
	        case 'Polygon':
	            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
	                callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex);
	            }
	            break;
	        }
	    });
	}

	/**
	 * Callback for lineReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback lineReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name lineReduce
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var multiPoly = turf.multiPolygon([
	 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
	 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
	 * ]);
	 *
	 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentLine
	 * });
	 */
	function lineReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
	        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
	    });
	    return previousValue;
	}




	Object.freeze({
		coordEach: coordEach$1,
		coordReduce: coordReduce,
		propEach: propEach,
		propReduce: propReduce,
		featureEach: featureEach$1,
		featureReduce: featureReduce,
		coordAll: coordAll,
		geomEach: geomEach,
		geomReduce: geomReduce,
		flattenEach: flattenEach,
		flattenReduce: flattenReduce,
		segmentEach: segmentEach,
		segmentReduce: segmentReduce,
		lineEach: lineEach,
		lineReduce: lineReduce
	});

	/**
	 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
	 *
	 * @name bbox
	 * @param {GeoJSON} geojson any GeoJSON object
	 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
	 * @example
	 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
	 * var bbox = turf.bbox(line);
	 * var bboxPolygon = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [line, bboxPolygon]
	 */
	function bbox(geojson) {
	    var BBox = [Infinity, Infinity, -Infinity, -Infinity];
	    coordEach$1(geojson, function (coord) {
	        if (BBox[0] > coord[0]) BBox[0] = coord[0];
	        if (BBox[1] > coord[1]) BBox[1] = coord[1];
	        if (BBox[2] < coord[0]) BBox[2] = coord[0];
	        if (BBox[3] < coord[1]) BBox[3] = coord[1];
	    });
	    return BBox;
	}

	/**
	 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
	 *
	 * @name getCoord
	 * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object
	 * @returns {Array<number>} coordinates
	 * @example
	 * var pt = turf.point([10, 10]);
	 *
	 * var coord = turf.getCoord(pt);
	 * //= [10, 10]
	 */
	function getCoord(obj) {
	    if (!obj) throw new Error('obj is required');

	    var coordinates = getCoords(obj);

	    // getCoord() must contain at least two numbers (Point)
	    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {
	        return coordinates;
	    } else {
	        throw new Error('Coordinate is not a valid Point');
	    }
	}

	/**
	 * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers
	 *
	 * @name getCoords
	 * @param {Array<number>|Geometry|Feature} obj Object
	 * @returns {Array<number>} coordinates
	 * @example
	 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
	 *
	 * var coord = turf.getCoords(poly);
	 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
	 */
	function getCoords(obj) {
	    if (!obj) throw new Error('obj is required');
	    var coordinates;

	    // Array of numbers
	    if (obj.length) {
	        coordinates = obj;

	    // Geometry Object
	    } else if (obj.coordinates) {
	        coordinates = obj.coordinates;

	    // Feature
	    } else if (obj.geometry && obj.geometry.coordinates) {
	        coordinates = obj.geometry.coordinates;
	    }
	    // Checks if coordinates contains a number
	    if (coordinates) {
	        containsNumber(coordinates);
	        return coordinates;
	    }
	    throw new Error('No valid coordinates');
	}

	/**
	 * Checks if coordinates contains a number
	 *
	 * @name containsNumber
	 * @param {Array<any>} coordinates GeoJSON Coordinates
	 * @returns {boolean} true if Array contains a number
	 */
	function containsNumber(coordinates) {
	    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {
	        return true;
	    }

	    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
	        return containsNumber(coordinates[0]);
	    }
	    throw new Error('coordinates must only contain numbers');
	}

	/**
	 * Enforce expectations about types of GeoJSON objects for Turf.
	 *
	 * @name geojsonType
	 * @param {GeoJSON} value any GeoJSON object
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} if value is not the expected type.
	 */
	function geojsonType(value, type, name) {
	    if (!type || !name) throw new Error('type and name required');

	    if (!value || value.type !== type) {
	        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
	    }
	}

	/**
	 * Enforce expectations about types of {@link Feature} inputs for Turf.
	 * Internally this uses {@link geojsonType} to judge geometry types.
	 *
	 * @name featureOf
	 * @param {Feature} feature a feature with an expected geometry type
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} error if value is not the expected type.
	 */
	function featureOf(feature$$1, type, name) {
	    if (!feature$$1) throw new Error('No feature passed');
	    if (!name) throw new Error('.featureOf() requires a name');
	    if (!feature$$1 || feature$$1.type !== 'Feature' || !feature$$1.geometry) {
	        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
	    }
	    if (!feature$$1.geometry || feature$$1.geometry.type !== type) {
	        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature$$1.geometry.type);
	    }
	}

	/**
	 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
	 * Internally this uses {@link geojsonType} to judge geometry types.
	 *
	 * @name collectionOf
	 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} if value is not the expected type.
	 */
	function collectionOf(featureCollection$$1, type, name) {
	    if (!featureCollection$$1) throw new Error('No featureCollection passed');
	    if (!name) throw new Error('.collectionOf() requires a name');
	    if (!featureCollection$$1 || featureCollection$$1.type !== 'FeatureCollection') {
	        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
	    }
	    for (var i = 0; i < featureCollection$$1.features.length; i++) {
	        var feature$$1 = featureCollection$$1.features[i];
	        if (!feature$$1 || feature$$1.type !== 'Feature' || !feature$$1.geometry) {
	            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
	        }
	        if (!feature$$1.geometry || feature$$1.geometry.type !== type) {
	            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature$$1.geometry.type);
	        }
	    }
	}

	/**
	 * Get Geometry from Feature or Geometry Object
	 *
	 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
	 * @returns {Geometry|null} GeoJSON Geometry Object
	 * @throws {Error} if geojson is not a Feature or Geometry Object
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getGeom(point)
	 * //={"type": "Point", "coordinates": [110, 40]}
	 */
	function getGeom(geojson) {
	    if (!geojson) throw new Error('geojson is required');
	    if (geojson.geometry !== undefined) return geojson.geometry;
	    if (geojson.coordinates || geojson.geometries) return geojson;
	    throw new Error('geojson must be a valid Feature or Geometry Object');
	}

	/**
	 * Get Geometry Type from Feature or Geometry Object
	 *
	 * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType
	 */
	function getGeomType() {
	    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');
	}

	/**
	 * Get GeoJSON object's type, Geometry type is prioritize.
	 *
	 * @param {GeoJSON} geojson GeoJSON object
	 * @param {string} [name] name of the variable to display in error message
	 * @returns {string} GeoJSON type
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getType(point)
	 * //="Point"
	 */
	function getType(geojson, name) {
	    if (!geojson) throw new Error((name || 'geojson') + ' is required');
	    // GeoJSON Feature & GeometryCollection
	    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;
	    // GeoJSON Geometry & FeatureCollection
	    if (geojson.type) return geojson.type;
	    throw new Error((name || 'geojson') + ' is invalid');
	}




	Object.freeze({
		getCoord: getCoord,
		getCoords: getCoords,
		containsNumber: containsNumber,
		geojsonType: geojsonType,
		featureOf: featureOf,
		collectionOf: collectionOf,
		getGeom: getGeom,
		getGeomType: getGeomType,
		getType: getType
	});

	var quickselect$1 = partialSort;

	// Floyd-Rivest selection algorithm:
	// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
	// The k-th element will have the (k - left + 1)th smallest value in [left, right]

	function partialSort(arr, k, left, right, compare) {
	    left = left || 0;
	    right = right || (arr.length - 1);
	    compare = compare || defaultCompare$1;

	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            partialSort(arr, k, newLeft, newRight, compare);
	        }

	        var t = arr[k];
	        var i = left;
	        var j = right;

	        swap$1(arr, left, k);
	        if (compare(arr[right], t) > 0) swap$1(arr, left, right);

	        while (i < j) {
	            swap$1(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) i++;
	            while (compare(arr[j], t) > 0) j--;
	        }

	        if (compare(arr[left], t) === 0) swap$1(arr, left, j);
	        else {
	            j++;
	            swap$1(arr, j, right);
	        }

	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}

	function swap$1(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultCompare$1(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	var rbush_1 = rbush$1;



	function rbush$1(maxEntries, format) {
	    if (!(this instanceof rbush$1)) return new rbush$1(maxEntries, format);

	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

	    if (format) {
	        this._initFormat(format);
	    }

	    this.clear();
	}

	rbush$1.prototype = {

	    all: function () {
	        return this._all(this.data, []);
	    },

	    search: function (bbox) {

	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;

	        if (!intersects$1$1(bbox, node)) return result;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects$1$1(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);
	                    else if (contains$3(bbox, childBBox)) this._all(child, result);
	                    else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return result;
	    },

	    collides: function (bbox) {

	        var node = this.data,
	            toBBox = this.toBBox;

	        if (!intersects$1$1(bbox, node)) return false;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects$1$1(bbox, childBBox)) {
	                    if (node.leaf || contains$3(bbox, childBBox)) return true;
	                    nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return false;
	    },

	    load: function (data) {
	        if (!(data && data.length)) return this;

	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }

	        // recursively build the tree with the given data from stratch using OMT algorithm
	        var node = this._build(data.slice(), 0, data.length - 1, 0);

	        if (!this.data.children.length) {
	            // save as is if tree is empty
	            this.data = node;

	        } else if (this.data.height === node.height) {
	            // split root if trees have the same height
	            this._splitRoot(this.data, node);

	        } else {
	            if (this.data.height < node.height) {
	                // swap trees if inserted one is bigger
	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }

	            // insert the small tree into the large tree at appropriate level
	            this._insert(node, this.data.height - node.height - 1, true);
	        }

	        return this;
	    },

	    insert: function (item) {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },

	    clear: function () {
	        this.data = createNode$1([]);
	        return this;
	    },

	    remove: function (item, equalsFn) {
	        if (!item) return this;

	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i, parent, index, goingUp;

	        // depth-first iterative tree traversal
	        while (node || path.length) {

	            if (!node) { // go up
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }

	            if (node.leaf) { // check current node
	                index = findItem$1(item, node.children, equalsFn);

	                if (index !== -1) {
	                    // item found, remove the item and condense tree upwards
	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }

	            if (!goingUp && !node.leaf && contains$3(node, bbox)) { // go down
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];

	            } else if (parent) { // go right
	                i++;
	                node = parent.children[i];
	                goingUp = false;

	            } else node = null; // nothing found
	        }

	        return this;
	    },

	    toBBox: function (item) { return item; },

	    compareMinX: compareNodeMinX$1,
	    compareMinY: compareNodeMinY$1,

	    toJSON: function () { return this.data; },

	    fromJSON: function (data) {
	        this.data = data;
	        return this;
	    },

	    _all: function (node, result) {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);
	            else nodesToSearch.push.apply(nodesToSearch, node.children);

	            node = nodesToSearch.pop();
	        }
	        return result;
	    },

	    _build: function (items, left, right, height) {

	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;

	        if (N <= M) {
	            // reached leaf level; return leaf
	            node = createNode$1(items.slice(left, right + 1));
	            calcBBox$1(node, this.toBBox);
	            return node;
	        }

	        if (!height) {
	            // target height of the bulk-loaded tree
	            height = Math.ceil(Math.log(N) / Math.log(M));

	            // target number of root entries to maximize storage utilization
	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }

	        node = createNode$1([]);
	        node.leaf = false;
	        node.height = height;

	        // split the items into M mostly square tiles

	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i, j, right2, right3;

	        multiSelect$1(items, left, right, N1, this.compareMinX);

	        for (i = left; i <= right; i += N1) {

	            right2 = Math.min(i + N1 - 1, right);

	            multiSelect$1(items, i, right2, N2, this.compareMinY);

	            for (j = i; j <= right2; j += N2) {

	                right3 = Math.min(j + N2 - 1, right2);

	                // pack each entry recursively
	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }

	        calcBBox$1(node, this.toBBox);

	        return node;
	    },

	    _chooseSubtree: function (bbox, node, level, path) {

	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

	        while (true) {
	            path.push(node);

	            if (node.leaf || path.length - 1 === level) break;

	            minArea = minEnlargement = Infinity;

	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea$1(child);
	                enlargement = enlargedArea$1(bbox, child) - area;

	                // choose entry with the least area enlargement
	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;

	                } else if (enlargement === minEnlargement) {
	                    // otherwise choose one with the smallest area
	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }

	            node = targetNode || node.children[0];
	        }

	        return node;
	    },

	    _insert: function (item, level, isNode) {

	        var toBBox = this.toBBox,
	            bbox = isNode ? item : toBBox(item),
	            insertPath = [];

	        // find the best node for accommodating the item, saving all nodes along the path too
	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

	        // put the item into the node
	        node.children.push(item);
	        extend$1(node, bbox);

	        // split on node overflow; propagate upwards if necessary
	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }

	        // adjust bboxes along the insertion path
	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },

	    // split overflowed node into two
	    _split: function (insertPath, level) {

	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;

	        this._chooseSplitAxis(node, m, M);

	        var splitIndex = this._chooseSplitIndex(node, m, M);

	        var newNode = createNode$1(node.children.splice(splitIndex, node.children.length - splitIndex));
	        newNode.height = node.height;
	        newNode.leaf = node.leaf;

	        calcBBox$1(node, this.toBBox);
	        calcBBox$1(newNode, this.toBBox);

	        if (level) insertPath[level - 1].children.push(newNode);
	        else this._splitRoot(node, newNode);
	    },

	    _splitRoot: function (node, newNode) {
	        // split root node
	        this.data = createNode$1([node, newNode]);
	        this.data.height = node.height + 1;
	        this.data.leaf = false;
	        calcBBox$1(this.data, this.toBBox);
	    },

	    _chooseSplitIndex: function (node, m, M) {

	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

	        minOverlap = minArea = Infinity;

	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox$1(node, 0, i, this.toBBox);
	            bbox2 = distBBox$1(node, i, M, this.toBBox);

	            overlap = intersectionArea$1(bbox1, bbox2);
	            area = bboxArea$1(bbox1) + bboxArea$1(bbox2);

	            // choose distribution with minimum overlap
	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;

	                minArea = area < minArea ? area : minArea;

	            } else if (overlap === minOverlap) {
	                // otherwise choose distribution with minimum area
	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }

	        return index;
	    },

	    // sorts node children by the best axis for split
	    _chooseSplitAxis: function (node, m, M) {

	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX$1,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY$1,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);

	        // if total distributions margin value is minimal for x, sort by minX,
	        // otherwise it's already sorted by minY
	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },

	    // total margin of all possible split distributions where each node is at least m full
	    _allDistMargin: function (node, m, M, compare) {

	        node.children.sort(compare);

	        var toBBox = this.toBBox,
	            leftBBox = distBBox$1(node, 0, m, toBBox),
	            rightBBox = distBBox$1(node, M - m, M, toBBox),
	            margin = bboxMargin$1(leftBBox) + bboxMargin$1(rightBBox),
	            i, child;

	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend$1(leftBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin$1(leftBBox);
	        }

	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend$1(rightBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin$1(rightBBox);
	        }

	        return margin;
	    },

	    _adjustParentBBoxes: function (bbox, path, level) {
	        // adjust bboxes along the given tree path
	        for (var i = level; i >= 0; i--) {
	            extend$1(path[i], bbox);
	        }
	    },

	    _condense: function (path) {
	        // go through the path, removing empty nodes and updating bboxes
	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);

	                } else this.clear();

	            } else calcBBox$1(path[i], this.toBBox);
	        }
	    },

	    _initFormat: function (format) {
	        // data format (minX, minY, maxX, maxY accessors)

	        // uses eval-type function compilation instead of just accepting a toBBox function
	        // because the algorithms are very sensitive to sorting functions performance,
	        // so they should be dead simple and without inner calls

	        var compareArr = ['return a', ' - b', ';'];

	        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
	        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

	        this.toBBox = new Function('a',
	            'return {minX: a' + format[0] +
	            ', minY: a' + format[1] +
	            ', maxX: a' + format[2] +
	            ', maxY: a' + format[3] + '};');
	    }
	};

	function findItem$1(item, items, equalsFn) {
	    if (!equalsFn) return items.indexOf(item);

	    for (var i = 0; i < items.length; i++) {
	        if (equalsFn(item, items[i])) return i;
	    }
	    return -1;
	}

	// calculate node's bbox from bboxes of its children
	function calcBBox$1(node, toBBox) {
	    distBBox$1(node, 0, node.children.length, toBBox, node);
	}

	// min bounding rectangle of node children from k to p-1
	function distBBox$1(node, k, p, toBBox, destNode) {
	    if (!destNode) destNode = createNode$1(null);
	    destNode.minX = Infinity;
	    destNode.minY = Infinity;
	    destNode.maxX = -Infinity;
	    destNode.maxY = -Infinity;

	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend$1(destNode, node.leaf ? toBBox(child) : child);
	    }

	    return destNode;
	}

	function extend$1(a, b) {
	    a.minX = Math.min(a.minX, b.minX);
	    a.minY = Math.min(a.minY, b.minY);
	    a.maxX = Math.max(a.maxX, b.maxX);
	    a.maxY = Math.max(a.maxY, b.maxY);
	    return a;
	}

	function compareNodeMinX$1(a, b) { return a.minX - b.minX; }
	function compareNodeMinY$1(a, b) { return a.minY - b.minY; }

	function bboxArea$1(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
	function bboxMargin$1(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

	function enlargedArea$1(a, b) {
	    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
	           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
	}

	function intersectionArea$1(a, b) {
	    var minX = Math.max(a.minX, b.minX),
	        minY = Math.max(a.minY, b.minY),
	        maxX = Math.min(a.maxX, b.maxX),
	        maxY = Math.min(a.maxY, b.maxY);

	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}

	function contains$3(a, b) {
	    return a.minX <= b.minX &&
	           a.minY <= b.minY &&
	           b.maxX <= a.maxX &&
	           b.maxY <= a.maxY;
	}

	function intersects$1$1(a, b) {
	    return b.minX <= a.maxX &&
	           b.minY <= a.maxY &&
	           b.maxX >= a.minX &&
	           b.maxY >= a.minY;
	}

	function createNode$1(children) {
	    return {
	        children: children,
	        height: 1,
	        leaf: true,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	}

	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach

	function multiSelect$1(arr, left, right, n, compare) {
	    var stack = [left, right],
	        mid;

	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();

	        if (right - left <= n) continue;

	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        quickselect$1(arr, mid, left, right, compare);

	        stack.push(left, mid, mid, right);
	    }
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var twoProduct_1 = twoProduct;

	var SPLITTER = +(Math.pow(2, 27) + 1.0);

	function twoProduct(a, b, result) {
	  var x = a * b;

	  var c = SPLITTER * a;
	  var abig = c - a;
	  var ahi = c - abig;
	  var alo = a - ahi;

	  var d = SPLITTER * b;
	  var bbig = d - b;
	  var bhi = d - bbig;
	  var blo = b - bhi;

	  var err1 = x - (ahi * bhi);
	  var err2 = err1 - (alo * bhi);
	  var err3 = err2 - (ahi * blo);

	  var y = alo * blo - err3;

	  if(result) {
	    result[0] = y;
	    result[1] = x;
	    return result
	  }

	  return [ y, x ]
	}

	var robustSum = linearExpansionSum;

	//Easy case: Add two scalars
	function scalarScalar(a, b) {
	  var x = a + b;
	  var bv = x - a;
	  var av = x - bv;
	  var br = b - bv;
	  var ar = a - av;
	  var y = ar + br;
	  if(y) {
	    return [y, x]
	  }
	  return [x]
	}

	function linearExpansionSum(e, f) {
	  var ne = e.length|0;
	  var nf = f.length|0;
	  if(ne === 1 && nf === 1) {
	    return scalarScalar(e[0], f[0])
	  }
	  var n = ne + nf;
	  var g = new Array(n);
	  var count = 0;
	  var eptr = 0;
	  var fptr = 0;
	  var abs = Math.abs;
	  var ei = e[eptr];
	  var ea = abs(ei);
	  var fi = f[fptr];
	  var fa = abs(fi);
	  var a, b;
	  if(ea < fa) {
	    b = ei;
	    eptr += 1;
	    if(eptr < ne) {
	      ei = e[eptr];
	      ea = abs(ei);
	    }
	  } else {
	    b = fi;
	    fptr += 1;
	    if(fptr < nf) {
	      fi = f[fptr];
	      fa = abs(fi);
	    }
	  }
	  if((eptr < ne && ea < fa) || (fptr >= nf)) {
	    a = ei;
	    eptr += 1;
	    if(eptr < ne) {
	      ei = e[eptr];
	      ea = abs(ei);
	    }
	  } else {
	    a = fi;
	    fptr += 1;
	    if(fptr < nf) {
	      fi = f[fptr];
	      fa = abs(fi);
	    }
	  }
	  var x = a + b;
	  var bv = x - a;
	  var y = b - bv;
	  var q0 = y;
	  var q1 = x;
	  var _x, _bv, _av, _br, _ar;
	  while(eptr < ne && fptr < nf) {
	    if(ea < fa) {
	      a = ei;
	      eptr += 1;
	      if(eptr < ne) {
	        ei = e[eptr];
	        ea = abs(ei);
	      }
	    } else {
	      a = fi;
	      fptr += 1;
	      if(fptr < nf) {
	        fi = f[fptr];
	        fa = abs(fi);
	      }
	    }
	    b = q0;
	    x = a + b;
	    bv = x - a;
	    y = b - bv;
	    if(y) {
	      g[count++] = y;
	    }
	    _x = q1 + x;
	    _bv = _x - q1;
	    _av = _x - _bv;
	    _br = x - _bv;
	    _ar = q1 - _av;
	    q0 = _ar + _br;
	    q1 = _x;
	  }
	  while(eptr < ne) {
	    a = ei;
	    b = q0;
	    x = a + b;
	    bv = x - a;
	    y = b - bv;
	    if(y) {
	      g[count++] = y;
	    }
	    _x = q1 + x;
	    _bv = _x - q1;
	    _av = _x - _bv;
	    _br = x - _bv;
	    _ar = q1 - _av;
	    q0 = _ar + _br;
	    q1 = _x;
	    eptr += 1;
	    if(eptr < ne) {
	      ei = e[eptr];
	    }
	  }
	  while(fptr < nf) {
	    a = fi;
	    b = q0;
	    x = a + b;
	    bv = x - a;
	    y = b - bv;
	    if(y) {
	      g[count++] = y;
	    } 
	    _x = q1 + x;
	    _bv = _x - q1;
	    _av = _x - _bv;
	    _br = x - _bv;
	    _ar = q1 - _av;
	    q0 = _ar + _br;
	    q1 = _x;
	    fptr += 1;
	    if(fptr < nf) {
	      fi = f[fptr];
	    }
	  }
	  if(q0) {
	    g[count++] = q0;
	  }
	  if(q1) {
	    g[count++] = q1;
	  }
	  if(!count) {
	    g[count++] = 0.0;  
	  }
	  g.length = count;
	  return g
	}

	var twoSum = fastTwoSum;

	function fastTwoSum(a, b, result) {
		var x = a + b;
		var bv = x - a;
		var av = x - bv;
		var br = b - bv;
		var ar = a - av;
		if(result) {
			result[0] = ar + br;
			result[1] = x;
			return result
		}
		return [ar+br, x]
	}

	var robustScale = scaleLinearExpansion;

	function scaleLinearExpansion(e, scale) {
	  var n = e.length;
	  if(n === 1) {
	    var ts = twoProduct_1(e[0], scale);
	    if(ts[0]) {
	      return ts
	    }
	    return [ ts[1] ]
	  }
	  var g = new Array(2 * n);
	  var q = [0.1, 0.1];
	  var t = [0.1, 0.1];
	  var count = 0;
	  twoProduct_1(e[0], scale, q);
	  if(q[0]) {
	    g[count++] = q[0];
	  }
	  for(var i=1; i<n; ++i) {
	    twoProduct_1(e[i], scale, t);
	    var pq = q[1];
	    twoSum(pq, t[0], q);
	    if(q[0]) {
	      g[count++] = q[0];
	    }
	    var a = t[1];
	    var b = q[1];
	    var x = a + b;
	    var bv = x - a;
	    var y = b - bv;
	    q[1] = x;
	    if(y) {
	      g[count++] = y;
	    }
	  }
	  if(q[1]) {
	    g[count++] = q[1];
	  }
	  if(count === 0) {
	    g[count++] = 0.0;
	  }
	  g.length = count;
	  return g
	}

	var robustDiff = robustSubtract;

	//Easy case: Add two scalars
	function scalarScalar$1(a, b) {
	  var x = a + b;
	  var bv = x - a;
	  var av = x - bv;
	  var br = b - bv;
	  var ar = a - av;
	  var y = ar + br;
	  if(y) {
	    return [y, x]
	  }
	  return [x]
	}

	function robustSubtract(e, f) {
	  var ne = e.length|0;
	  var nf = f.length|0;
	  if(ne === 1 && nf === 1) {
	    return scalarScalar$1(e[0], -f[0])
	  }
	  var n = ne + nf;
	  var g = new Array(n);
	  var count = 0;
	  var eptr = 0;
	  var fptr = 0;
	  var abs = Math.abs;
	  var ei = e[eptr];
	  var ea = abs(ei);
	  var fi = -f[fptr];
	  var fa = abs(fi);
	  var a, b;
	  if(ea < fa) {
	    b = ei;
	    eptr += 1;
	    if(eptr < ne) {
	      ei = e[eptr];
	      ea = abs(ei);
	    }
	  } else {
	    b = fi;
	    fptr += 1;
	    if(fptr < nf) {
	      fi = -f[fptr];
	      fa = abs(fi);
	    }
	  }
	  if((eptr < ne && ea < fa) || (fptr >= nf)) {
	    a = ei;
	    eptr += 1;
	    if(eptr < ne) {
	      ei = e[eptr];
	      ea = abs(ei);
	    }
	  } else {
	    a = fi;
	    fptr += 1;
	    if(fptr < nf) {
	      fi = -f[fptr];
	      fa = abs(fi);
	    }
	  }
	  var x = a + b;
	  var bv = x - a;
	  var y = b - bv;
	  var q0 = y;
	  var q1 = x;
	  var _x, _bv, _av, _br, _ar;
	  while(eptr < ne && fptr < nf) {
	    if(ea < fa) {
	      a = ei;
	      eptr += 1;
	      if(eptr < ne) {
	        ei = e[eptr];
	        ea = abs(ei);
	      }
	    } else {
	      a = fi;
	      fptr += 1;
	      if(fptr < nf) {
	        fi = -f[fptr];
	        fa = abs(fi);
	      }
	    }
	    b = q0;
	    x = a + b;
	    bv = x - a;
	    y = b - bv;
	    if(y) {
	      g[count++] = y;
	    }
	    _x = q1 + x;
	    _bv = _x - q1;
	    _av = _x - _bv;
	    _br = x - _bv;
	    _ar = q1 - _av;
	    q0 = _ar + _br;
	    q1 = _x;
	  }
	  while(eptr < ne) {
	    a = ei;
	    b = q0;
	    x = a + b;
	    bv = x - a;
	    y = b - bv;
	    if(y) {
	      g[count++] = y;
	    }
	    _x = q1 + x;
	    _bv = _x - q1;
	    _av = _x - _bv;
	    _br = x - _bv;
	    _ar = q1 - _av;
	    q0 = _ar + _br;
	    q1 = _x;
	    eptr += 1;
	    if(eptr < ne) {
	      ei = e[eptr];
	    }
	  }
	  while(fptr < nf) {
	    a = fi;
	    b = q0;
	    x = a + b;
	    bv = x - a;
	    y = b - bv;
	    if(y) {
	      g[count++] = y;
	    } 
	    _x = q1 + x;
	    _bv = _x - q1;
	    _av = _x - _bv;
	    _br = x - _bv;
	    _ar = q1 - _av;
	    q0 = _ar + _br;
	    q1 = _x;
	    fptr += 1;
	    if(fptr < nf) {
	      fi = -f[fptr];
	    }
	  }
	  if(q0) {
	    g[count++] = q0;
	  }
	  if(q1) {
	    g[count++] = q1;
	  }
	  if(!count) {
	    g[count++] = 0.0;  
	  }
	  g.length = count;
	  return g
	}

	var orientation_1 = createCommonjsModule(function (module) {
	var NUM_EXPAND = 5;

	var EPSILON     = 1.1102230246251565e-16;
	var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON;
	var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON;

	function cofactor(m, c) {
	  var result = new Array(m.length-1);
	  for(var i=1; i<m.length; ++i) {
	    var r = result[i-1] = new Array(m.length-1);
	    for(var j=0,k=0; j<m.length; ++j) {
	      if(j === c) {
	        continue
	      }
	      r[k++] = m[i][j];
	    }
	  }
	  return result
	}

	function matrix(n) {
	  var result = new Array(n);
	  for(var i=0; i<n; ++i) {
	    result[i] = new Array(n);
	    for(var j=0; j<n; ++j) {
	      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("");
	    }
	  }
	  return result
	}

	function sign(n) {
	  if(n & 1) {
	    return "-"
	  }
	  return ""
	}

	function generateSum(expr) {
	  if(expr.length === 1) {
	    return expr[0]
	  } else if(expr.length === 2) {
	    return ["sum(", expr[0], ",", expr[1], ")"].join("")
	  } else {
	    var m = expr.length>>1;
	    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
	  }
	}

	function determinant(m) {
	  if(m.length === 2) {
	    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
	  } else {
	    var expr = [];
	    for(var i=0; i<m.length; ++i) {
	      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
	    }
	    return expr
	  }
	}

	function orientation(n) {
	  var pos = [];
	  var neg = [];
	  var m = matrix(n);
	  var args = [];
	  for(var i=0; i<n; ++i) {
	    if((i&1)===0) {
	      pos.push.apply(pos, determinant(cofactor(m, i)));
	    } else {
	      neg.push.apply(neg, determinant(cofactor(m, i)));
	    }
	    args.push("m" + i);
	  }
	  var posExpr = generateSum(pos);
	  var negExpr = generateSum(neg);
	  var funcName = "orientation" + n + "Exact";
	  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("");
	  var proc = new Function("sum", "prod", "scale", "sub", code);
	  return proc(robustSum, twoProduct_1, robustScale, robustDiff)
	}

	var orientation3Exact = orientation(3);
	var orientation4Exact = orientation(4);

	var CACHED = [
	  function orientation0() { return 0 },
	  function orientation1() { return 0 },
	  function orientation2(a, b) { 
	    return b[0] - a[0]
	  },
	  function orientation3(a, b, c) {
	    var l = (a[1] - c[1]) * (b[0] - c[0]);
	    var r = (a[0] - c[0]) * (b[1] - c[1]);
	    var det = l - r;
	    var s;
	    if(l > 0) {
	      if(r <= 0) {
	        return det
	      } else {
	        s = l + r;
	      }
	    } else if(l < 0) {
	      if(r >= 0) {
	        return det
	      } else {
	        s = -(l + r);
	      }
	    } else {
	      return det
	    }
	    var tol = ERRBOUND3 * s;
	    if(det >= tol || det <= -tol) {
	      return det
	    }
	    return orientation3Exact(a, b, c)
	  },
	  function orientation4(a,b,c,d) {
	    var adx = a[0] - d[0];
	    var bdx = b[0] - d[0];
	    var cdx = c[0] - d[0];
	    var ady = a[1] - d[1];
	    var bdy = b[1] - d[1];
	    var cdy = c[1] - d[1];
	    var adz = a[2] - d[2];
	    var bdz = b[2] - d[2];
	    var cdz = c[2] - d[2];
	    var bdxcdy = bdx * cdy;
	    var cdxbdy = cdx * bdy;
	    var cdxady = cdx * ady;
	    var adxcdy = adx * cdy;
	    var adxbdy = adx * bdy;
	    var bdxady = bdx * ady;
	    var det = adz * (bdxcdy - cdxbdy) 
	            + bdz * (cdxady - adxcdy)
	            + cdz * (adxbdy - bdxady);
	    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
	                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
	                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
	    var tol = ERRBOUND4 * permanent;
	    if ((det > tol) || (-det > tol)) {
	      return det
	    }
	    return orientation4Exact(a,b,c,d)
	  }
	];

	function slowOrient(args) {
	  var proc = CACHED[args.length];
	  if(!proc) {
	    proc = CACHED[args.length] = orientation(args.length);
	  }
	  return proc.apply(undefined, args)
	}

	function generateOrientationProc() {
	  while(CACHED.length <= NUM_EXPAND) {
	    CACHED.push(orientation(CACHED.length));
	  }
	  var args = [];
	  var procArgs = ["slow"];
	  for(var i=0; i<=NUM_EXPAND; ++i) {
	    args.push("a" + i);
	    procArgs.push("o" + i);
	  }
	  var code = [
	    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
	  ];
	  for(var i=2; i<=NUM_EXPAND; ++i) {
	    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
	  }
	  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation");
	  procArgs.push(code.join(""));

	  var proc = Function.apply(undefined, procArgs);
	  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));
	  for(var i=0; i<=NUM_EXPAND; ++i) {
	    module.exports[i] = CACHED[i];
	  }
	}

	generateOrientationProc();
	});

	var monotoneConvexHull2d = monotoneConvexHull2D;

	var orient$1 = orientation_1[3];

	function monotoneConvexHull2D(points) {
	  var n = points.length;

	  if(n < 3) {
	    var result = new Array(n);
	    for(var i=0; i<n; ++i) {
	      result[i] = i;
	    }

	    if(n === 2 &&
	       points[0][0] === points[1][0] &&
	       points[0][1] === points[1][1]) {
	      return [0]
	    }

	    return result
	  }

	  //Sort point indices along x-axis
	  var sorted = new Array(n);
	  for(var i=0; i<n; ++i) {
	    sorted[i] = i;
	  }
	  sorted.sort(function(a,b) {
	    var d = points[a][0]-points[b][0];
	    if(d) {
	      return d
	    }
	    return points[a][1] - points[b][1]
	  });

	  //Construct upper and lower hulls
	  var lower = [sorted[0], sorted[1]];
	  var upper = [sorted[0], sorted[1]];

	  for(var i=2; i<n; ++i) {
	    var idx = sorted[i];
	    var p   = points[idx];

	    //Insert into lower list
	    var m = lower.length;
	    while(m > 1 && orient$1(
	        points[lower[m-2]], 
	        points[lower[m-1]], 
	        p) <= 0) {
	      m -= 1;
	      lower.pop();
	    }
	    lower.push(idx);

	    //Insert into upper list
	    m = upper.length;
	    while(m > 1 && orient$1(
	        points[upper[m-2]], 
	        points[upper[m-1]], 
	        p) >= 0) {
	      m -= 1;
	      upper.pop();
	    }
	    upper.push(idx);
	  }

	  //Merge lists together
	  var result = new Array(upper.length + lower.length - 2);
	  var ptr    = 0;
	  for(var i=0, nl=lower.length; i<nl; ++i) {
	    result[ptr++] = lower[i];
	  }
	  for(var j=upper.length-2; j>0; --j) {
	    result[ptr++] = upper[j];
	  }

	  //Return result
	  return result
	}

	var tinyqueue = TinyQueue;
	var default_1$1 = TinyQueue;

	function TinyQueue(data, compare) {
	    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

	    this.data = data || [];
	    this.length = this.data.length;
	    this.compare = compare || defaultCompare$1$1;

	    if (this.length > 0) {
	        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
	    }
	}

	function defaultCompare$1$1(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	TinyQueue.prototype = {

	    push: function (item) {
	        this.data.push(item);
	        this.length++;
	        this._up(this.length - 1);
	    },

	    pop: function () {
	        if (this.length === 0) return undefined;

	        var top = this.data[0];
	        this.length--;

	        if (this.length > 0) {
	            this.data[0] = this.data[this.length];
	            this._down(0);
	        }
	        this.data.pop();

	        return top;
	    },

	    peek: function () {
	        return this.data[0];
	    },

	    _up: function (pos) {
	        var data = this.data;
	        var compare = this.compare;
	        var item = data[pos];

	        while (pos > 0) {
	            var parent = (pos - 1) >> 1;
	            var current = data[parent];
	            if (compare(item, current) >= 0) break;
	            data[pos] = current;
	            pos = parent;
	        }

	        data[pos] = item;
	    },

	    _down: function (pos) {
	        var data = this.data;
	        var compare = this.compare;
	        var halfLength = this.length >> 1;
	        var item = data[pos];

	        while (pos < halfLength) {
	            var left = (pos << 1) + 1;
	            var right = left + 1;
	            var best = data[left];

	            if (right < this.length && compare(data[right], best) < 0) {
	                left = right;
	                best = data[right];
	            }
	            if (compare(best, item) >= 0) break;

	            data[pos] = best;
	            pos = left;
	        }

	        data[pos] = item;
	    }
	};

	tinyqueue.default = default_1$1;

	var pointInPolygon = function (point, vs) {
	    // ray-casting algorithm based on
	    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
	    
	    var x = point[0], y = point[1];
	    
	    var inside = false;
	    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
	        var xi = vs[i][0], yi = vs[i][1];
	        var xj = vs[j][0], yj = vs[j][1];
	        
	        var intersect = ((yi > y) != (yj > y))
	            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
	        if (intersect) inside = !inside;
	    }
	    
	    return inside;
	};

	var orient = orientation_1[3];

	var concaveman_1 = concaveman;
	var default_1 = concaveman;

	function concaveman(points, concavity, lengthThreshold) {
	    // a relative measure of concavity; higher value means simpler hull
	    concavity = Math.max(0, concavity === undefined ? 2 : concavity);

	    // when a segment goes below this length threshold, it won't be drilled down further
	    lengthThreshold = lengthThreshold || 0;

	    // start with a convex hull of the points
	    var hull = fastConvexHull(points);

	    // index the points with an R-tree
	    var tree = rbush_1(16, ['[0]', '[1]', '[0]', '[1]']).load(points);

	    // turn the convex hull into a linked list and populate the initial edge queue with the nodes
	    var queue = [];
	    for (var i = 0, last; i < hull.length; i++) {
	        var p = hull[i];
	        tree.remove(p);
	        last = insertNode(p, last);
	        queue.push(last);
	    }

	    // index the segments with an R-tree (for intersection checks)
	    var segTree = rbush_1(16);
	    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));

	    var sqConcavity = concavity * concavity;
	    var sqLenThreshold = lengthThreshold * lengthThreshold;

	    // process edges one by one
	    while (queue.length) {
	        var node = queue.shift();
	        var a = node.p;
	        var b = node.next.p;

	        // skip the edge if it's already short enough
	        var sqLen = getSqDist(a, b);
	        if (sqLen < sqLenThreshold) continue;

	        var maxSqLen = sqLen / sqConcavity;

	        // find the best connection point for the current edge to flex inward to
	        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);

	        // if we found a connection and it satisfies our concavity measure
	        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
	            // connect the edge endpoints through this point and add 2 new edges to the queue
	            queue.push(node);
	            queue.push(insertNode(p, node));

	            // update point and segment indexes
	            tree.remove(p);
	            segTree.remove(node);
	            segTree.insert(updateBBox(node));
	            segTree.insert(updateBBox(node.next));
	        }
	    }

	    // convert the resulting hull linked list to an array of points
	    node = last;
	    var concave = [];
	    do {
	        concave.push(node.p);
	        node = node.next;
	    } while (node !== last);

	    concave.push(node.p);

	    return concave;
	}

	function findCandidate(tree, a, b, c, d, maxDist, segTree) {
	    var queue = new tinyqueue(null, compareDist);
	    var node = tree.data;

	    // search through the point R-tree with a depth-first search using a priority queue
	    // in the order of distance to the edge (b, c)
	    while (node) {
	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];

	            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
	            if (dist > maxDist) continue; // skip the node if it's farther than we ever need

	            queue.push({
	                node: child,
	                dist: dist
	            });
	        }

	        while (queue.length && !queue.peek().node.children) {
	            var item = queue.pop();
	            var p = item.node;

	            // skip all points that are as close to adjacent edges (a,b) and (c,d),
	            // and points that would introduce self-intersections when connected
	            var d0 = sqSegDist(p, a, b);
	            var d1 = sqSegDist(p, c, d);
	            if (item.dist < d0 && item.dist < d1 &&
	                noIntersections(b, p, segTree) &&
	                noIntersections(c, p, segTree)) return p;
	        }

	        node = queue.pop();
	        if (node) node = node.node;
	    }

	    return null;
	}

	function compareDist(a, b) {
	    return a.dist - b.dist;
	}

	// square distance from a segment bounding box to the given one
	function sqSegBoxDist(a, b, bbox) {
	    if (inside(a, bbox) || inside(b, bbox)) return 0;
	    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
	    if (d1 === 0) return 0;
	    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
	    if (d2 === 0) return 0;
	    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
	    if (d3 === 0) return 0;
	    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
	    if (d4 === 0) return 0;
	    return Math.min(d1, d2, d3, d4);
	}

	function inside(a, bbox) {
	    return a[0] >= bbox.minX &&
	           a[0] <= bbox.maxX &&
	           a[1] >= bbox.minY &&
	           a[1] <= bbox.maxY;
	}

	// check if the edge (a,b) doesn't intersect any other edges
	function noIntersections(a, b, segTree) {
	    var minX = Math.min(a[0], b[0]);
	    var minY = Math.min(a[1], b[1]);
	    var maxX = Math.max(a[0], b[0]);
	    var maxY = Math.max(a[1], b[1]);

	    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});
	    for (var i = 0; i < edges.length; i++) {
	        if (intersects$2(edges[i].p, edges[i].next.p, a, b)) return false;
	    }
	    return true;
	}

	// check if the edges (p1,q1) and (p2,q2) intersect
	function intersects$2(p1, q1, p2, q2) {
	    return p1 !== q2 && q1 !== p2 &&
	        orient(p1, q1, p2) > 0 !== orient(p1, q1, q2) > 0 &&
	        orient(p2, q2, p1) > 0 !== orient(p2, q2, q1) > 0;
	}

	// update the bounding box of a node's edge
	function updateBBox(node) {
	    var p1 = node.p;
	    var p2 = node.next.p;
	    node.minX = Math.min(p1[0], p2[0]);
	    node.minY = Math.min(p1[1], p2[1]);
	    node.maxX = Math.max(p1[0], p2[0]);
	    node.maxY = Math.max(p1[1], p2[1]);
	    return node;
	}

	// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points
	function fastConvexHull(points) {
	    var left = points[0];
	    var top = points[0];
	    var right = points[0];
	    var bottom = points[0];

	    // find the leftmost, rightmost, topmost and bottommost points
	    for (var i = 0; i < points.length; i++) {
	        var p = points[i];
	        if (p[0] < left[0]) left = p;
	        if (p[0] > right[0]) right = p;
	        if (p[1] < top[1]) top = p;
	        if (p[1] > bottom[1]) bottom = p;
	    }

	    // filter out points that are inside the resulting quadrilateral
	    var cull = [left, top, right, bottom];
	    var filtered = cull.slice();
	    for (i = 0; i < points.length; i++) {
	        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);
	    }

	    // get convex hull around the filtered points
	    var indices = monotoneConvexHull2d(filtered);

	    // return the hull as array of points (rather than indices)
	    var hull = [];
	    for (i = 0; i < indices.length; i++) hull.push(filtered[indices[i]]);
	    return hull;
	}

	// create a new node in a doubly linked list
	function insertNode(p, prev) {
	    var node = {
	        p: p,
	        prev: null,
	        next: null,
	        minX: 0,
	        minY: 0,
	        maxX: 0,
	        maxY: 0
	    };

	    if (!prev) {
	        node.prev = node;
	        node.next = node;

	    } else {
	        node.next = prev.next;
	        node.prev = prev;
	        prev.next.prev = node;
	        prev.next = node;
	    }
	    return node;
	}

	// square distance between 2 points
	function getSqDist(p1, p2) {

	    var dx = p1[0] - p2[0],
	        dy = p1[1] - p2[1];

	    return dx * dx + dy * dy;
	}

	// square distance from a point to a segment
	function sqSegDist(p, p1, p2) {

	    var x = p1[0],
	        y = p1[1],
	        dx = p2[0] - x,
	        dy = p2[1] - y;

	    if (dx !== 0 || dy !== 0) {

	        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

	        if (t > 1) {
	            x = p2[0];
	            y = p2[1];

	        } else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }

	    dx = p[0] - x;
	    dy = p[1] - y;

	    return dx * dx + dy * dy;
	}

	// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday
	function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
	    var ux = x1 - x0;
	    var uy = y1 - y0;
	    var vx = x3 - x2;
	    var vy = y3 - y2;
	    var wx = x0 - x2;
	    var wy = y0 - y2;
	    var a = ux * ux + uy * uy;
	    var b = ux * vx + uy * vy;
	    var c = vx * vx + vy * vy;
	    var d = ux * wx + uy * wy;
	    var e = vx * wx + vy * wy;
	    var D = a * c - b * b;

	    var sc, sN, tc, tN;
	    var sD = D;
	    var tD = D;

	    if (D === 0) {
	        sN = 0;
	        sD = 1;
	        tN = e;
	        tD = c;
	    } else {
	        sN = b * e - c * d;
	        tN = a * e - b * d;
	        if (sN < 0) {
	            sN = 0;
	            tN = e;
	            tD = c;
	        } else if (sN > sD) {
	            sN = sD;
	            tN = e + b;
	            tD = c;
	        }
	    }

	    if (tN < 0.0) {
	        tN = 0.0;
	        if (-d < 0.0) sN = 0.0;
	        else if (-d > a) sN = sD;
	        else {
	            sN = -d;
	            sD = a;
	        }
	    } else if (tN > tD) {
	        tN = tD;
	        if ((-d + b) < 0.0) sN = 0;
	        else if (-d + b > a) sN = sD;
	        else {
	            sN = -d + b;
	            sD = a;
	        }
	    }

	    sc = sN === 0 ? 0 : sN / sD;
	    tc = tN === 0 ? 0 : tN / tD;

	    var cx = (1 - sc) * x0 + sc * x1;
	    var cy = (1 - sc) * y0 + sc * y1;
	    var cx2 = (1 - tc) * x2 + tc * x3;
	    var cy2 = (1 - tc) * y2 + tc * y3;
	    var dx = cx2 - cx;
	    var dy = cy2 - cy;

	    return dx * dx + dy * dy;
	}

	concaveman_1.default = default_1;

	// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
	// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
	// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

	/**
	 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
	 * be convex or concave. The function accounts for holes.
	 *
	 * @name booleanPointInPolygon
	 * @param {Coord} point input point
	 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
	 * @param {Object} [options={}] Optional parameters
	 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.
	 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
	 * @example
	 * var pt = turf.point([-77, 44]);
	 * var poly = turf.polygon([[
	 *   [-81, 41],
	 *   [-81, 47],
	 *   [-72, 47],
	 *   [-72, 41],
	 *   [-81, 41]
	 * ]]);
	 *
	 * turf.booleanPointInPolygon(pt, poly);
	 * //= true
	 */
	function booleanPointInPolygon(point, polygon, options) {
	    // Optional parameters
	    options = options || {};
	    if (typeof options !== 'object') throw new Error('options is invalid');
	    var ignoreBoundary = options.ignoreBoundary;

	    // validation
	    if (!point) throw new Error('point is required');
	    if (!polygon) throw new Error('polygon is required');

	    var pt = getCoord(point);
	    var polys = getCoords(polygon);
	    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;
	    var bbox = polygon.bbox;

	    // Quick elimination if point is not inside bbox
	    if (bbox && inBBox(pt, bbox) === false) return false;

	    // normalize to multipolygon
	    if (type === 'Polygon') polys = [polys];

	    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
	        // check if it is in the outer ring first
	        if (inRing(pt, polys[i][0], ignoreBoundary)) {
	            var inHole = false;
	            var k = 1;
	            // check for the point in any of the holes
	            while (k < polys[i].length && !inHole) {
	                if (inRing(pt, polys[i][k], !ignoreBoundary)) {
	                    inHole = true;
	                }
	                k++;
	            }
	            if (!inHole) insidePoly = true;
	        }
	    }
	    return insidePoly;
	}

	/**
	 * inRing
	 *
	 * @private
	 * @param {Array<number>} pt [x,y]
	 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
	 * @param {boolean} ignoreBoundary ignoreBoundary
	 * @returns {boolean} inRing
	 */
	function inRing(pt, ring, ignoreBoundary) {
	    var isInside = false;
	    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);

	    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
	        var xi = ring[i][0], yi = ring[i][1];
	        var xj = ring[j][0], yj = ring[j][1];
	        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
	            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
	        if (onBoundary) return !ignoreBoundary;
	        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
	        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
	        if (intersect) isInside = !isInside;
	    }
	    return isInside;
	}

	/**
	 * inBBox
	 *
	 * @private
	 * @param {Position} pt point [x,y]
	 * @param {BBox} bbox BBox [west, south, east, north]
	 * @returns {boolean} true/false if point is inside BBox
	 */
	function inBBox(pt, bbox) {
	    return bbox[0] <= pt[0] &&
	           bbox[1] <= pt[1] &&
	           bbox[2] >= pt[0] &&
	           bbox[3] >= pt[1];
	}

	//http://en.wikipedia.org/wiki/Haversine_formula
	//http://www.movable-type.co.uk/scripts/latlong.html

	/**
	 * Calculates the distance between two {@link Point|points} in degrees, radians,
	 * miles, or kilometers. This uses the
	 * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
	 * to account for global curvature.
	 *
	 * @name distance
	 * @param {Coord} from origin point
	 * @param {Coord} to destination point
	 * @param {Object} [options={}] Optional parameters
	 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
	 * @returns {number} distance between the two points
	 * @example
	 * var from = turf.point([-75.343, 39.984]);
	 * var to = turf.point([-75.534, 39.123]);
	 * var options = {units: 'miles'};
	 *
	 * var distance = turf.distance(from, to, options);
	 *
	 * //addToMap
	 * var addToMap = [from, to];
	 * from.properties.distance = distance;
	 * to.properties.distance = distance;
	 */
	function distance(from, to, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var units = options.units;

	    var coordinates1 = getCoord(from);
	    var coordinates2 = getCoord(to);
	    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));
	    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));
	    var lat1 = degreesToRadians(coordinates1[1]);
	    var lat2 = degreesToRadians(coordinates2[1]);

	    var a = Math.pow(Math.sin(dLat / 2), 2) +
	          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

	    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
	}

	/**
	 * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
	 * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
	 *
	 * @name clone
	 * @param {GeoJSON} geojson GeoJSON Object
	 * @returns {GeoJSON} cloned GeoJSON Object
	 * @example
	 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
	 *
	 * var lineCloned = turf.clone(line);
	 */
	function clone(geojson) {
	    if (!geojson) throw new Error('geojson is required');

	    switch (geojson.type) {
	    case 'Feature':
	        return cloneFeature(geojson);
	    case 'FeatureCollection':
	        return cloneFeatureCollection(geojson);
	    case 'Point':
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiPoint':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	    case 'GeometryCollection':
	        return cloneGeometry(geojson);
	    default:
	        throw new Error('unknown GeoJSON type');
	    }
	}

	/**
	 * Clone Feature
	 *
	 * @private
	 * @param {Feature<any>} geojson GeoJSON Feature
	 * @returns {Feature<any>} cloned Feature
	 */
	function cloneFeature(geojson) {
	    var cloned = {type: 'Feature'};
	    // Preserve Foreign Members
	    Object.keys(geojson).forEach(function (key) {
	        switch (key) {
	        case 'type':
	        case 'properties':
	        case 'geometry':
	            return;
	        default:
	            cloned[key] = geojson[key];
	        }
	    });
	    // Add properties & geometry last
	    cloned.properties = cloneProperties(geojson.properties);
	    cloned.geometry = cloneGeometry(geojson.geometry);
	    return cloned;
	}

	/**
	 * Clone Properties
	 *
	 * @private
	 * @param {Object} properties GeoJSON Properties
	 * @returns {Object} cloned Properties
	 */
	function cloneProperties(properties) {
	    var cloned = {};
	    if (!properties) return cloned;
	    Object.keys(properties).forEach(function (key) {
	        var value = properties[key];
	        if (typeof value === 'object') {
	            if (value === null) {
	                // handle null
	                cloned[key] = null;
	            } else if (value.length) {
	                // handle Array
	                cloned[key] = value.map(function (item) {
	                    return item;
	                });
	            } else {
	                // handle generic Object
	                cloned[key] = cloneProperties(value);
	            }
	        } else cloned[key] = value;
	    });
	    return cloned;
	}

	/**
	 * Clone Feature Collection
	 *
	 * @private
	 * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
	 * @returns {FeatureCollection<any>} cloned Feature Collection
	 */
	function cloneFeatureCollection(geojson) {
	    var cloned = {type: 'FeatureCollection'};

	    // Preserve Foreign Members
	    Object.keys(geojson).forEach(function (key) {
	        switch (key) {
	        case 'type':
	        case 'features':
	            return;
	        default:
	            cloned[key] = geojson[key];
	        }
	    });
	    // Add features
	    cloned.features = geojson.features.map(function (feature) {
	        return cloneFeature(feature);
	    });
	    return cloned;
	}

	/**
	 * Clone Geometry
	 *
	 * @private
	 * @param {Geometry<any>} geometry GeoJSON Geometry
	 * @returns {Geometry<any>} cloned Geometry
	 */
	function cloneGeometry(geometry) {
	    var geom = {type: geometry.type};
	    if (geometry.bbox) geom.bbox = geometry.bbox;

	    if (geometry.type === 'GeometryCollection') {
	        geom.geometries = geometry.geometries.map(function (geom) {
	            return cloneGeometry(geom);
	        });
	        return geom;
	    }
	    geom.coordinates = deepSlice(geometry.coordinates);
	    return geom;
	}

	/**
	 * Deep Slice coordinates
	 *
	 * @private
	 * @param {Coordinates} coords Coordinates
	 * @returns {Coordinates} all coordinates sliced
	 */
	function deepSlice(coords) {
	    if (typeof coords[0] !== 'object') { return coords.slice(); }
	    return coords.map(function (coord) {
	        return deepSlice(coord);
	    });
	}

	/**
	 * Removes redundant coordinates from any GeoJSON Geometry.
	 *
	 * @name cleanCoords
	 * @param {Geometry|Feature} geojson Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated
	 * @returns {Geometry|Feature} the cleaned input Feature/Geometry
	 * @example
	 * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);
	 * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);
	 *
	 * turf.cleanCoords(line).geometry.coordinates;
	 * //= [[0, 0], [0, 10]]
	 *
	 * turf.cleanCoords(multiPoint).geometry.coordinates;
	 * //= [[0, 0], [2, 2]]
	 */
	function cleanCoords(geojson, options) {
	    // Backwards compatible with v4.0
	    var mutate = (typeof options === 'object') ? options.mutate : options;
	    if (!geojson) throw new Error('geojson is required');
	    var type = getType(geojson);

	    // Store new "clean" points in this Array
	    var newCoords = [];

	    switch (type) {
	    case 'LineString':
	        newCoords = cleanLine(geojson);
	        break;
	    case 'MultiLineString':
	    case 'Polygon':
	        getCoords(geojson).forEach(function (line) {
	            newCoords.push(cleanLine(line));
	        });
	        break;
	    case 'MultiPolygon':
	        getCoords(geojson).forEach(function (polygons$$1) {
	            var polyPoints = [];
	            polygons$$1.forEach(function (ring) {
	                polyPoints.push(cleanLine(ring));
	            });
	            newCoords.push(polyPoints);
	        });
	        break;
	    case 'Point':
	        return geojson;
	    case 'MultiPoint':
	        var existing = {};
	        getCoords(geojson).forEach(function (coord) {
	            var key = coord.join('-');
	            if (!existing.hasOwnProperty(key)) {
	                newCoords.push(coord);
	                existing[key] = true;
	            }
	        });
	        break;
	    default:
	        throw new Error(type + ' geometry not supported');
	    }

	    // Support input mutation
	    if (geojson.coordinates) {
	        if (mutate === true) {
	            geojson.coordinates = newCoords;
	            return geojson;
	        }
	        return {type: type, coordinates: newCoords};
	    } else {
	        if (mutate === true) {
	            geojson.geometry.coordinates = newCoords;
	            return geojson;
	        }
	        return feature({type: type, coordinates: newCoords}, geojson.properties, geojson.bbox, geojson.id);
	    }
	}

	/**
	 * Clean Coords
	 *
	 * @private
	 * @param {Array<number>|LineString} line Line
	 * @returns {Array<number>} Cleaned coordinates
	 */
	function cleanLine(line) {
	    var points$$1 = getCoords(line);
	    // handle "clean" segment
	    if (points$$1.length === 2 && !equals$1(points$$1[0], points$$1[1])) return points$$1;

	    var prevPoint, point$$1, nextPoint;
	    var newPoints = [];
	    var secondToLast = points$$1.length - 1;

	    newPoints.push(points$$1[0]);
	    for (var i = 1; i < secondToLast; i++) {
	        prevPoint = points$$1[i - 1];
	        point$$1 = points$$1[i];
	        nextPoint = points$$1[i + 1];

	        if (!isPointOnLineSegment(prevPoint, nextPoint, point$$1)) {
	            newPoints.push(point$$1);
	        }
	    }
	    newPoints.push(nextPoint);
	    return newPoints;
	}

	/**
	 * Compares two points and returns if they are equals
	 *
	 * @private
	 * @param {Position} pt1 point
	 * @param {Position} pt2 point
	 * @returns {boolean} true if they are equals
	 */
	function equals$1(pt1, pt2) {
	    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
	}

	/**
	 * Returns if `point` is on the segment between `start` and `end`.
	 * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)
	 *
	 * @private
	 * @param {Position} start coord pair of start of line
	 * @param {Position} end coord pair of end of line
	 * @param {Position} point coord pair of point to check
	 * @returns {boolean} true/false
	 */
	function isPointOnLineSegment(start, end, point$$1) {
	    var x = point$$1[0], y = point$$1[1];
	    var startX = start[0], startY = start[1];
	    var endX = end[0], endY = end[1];

	    var dxc = x - startX;
	    var dyc = y - startY;
	    var dxl = endX - startX;
	    var dyl = endY - startY;
	    var cross = dxc * dyl - dyc * dxl;

	    if (cross !== 0) return false;
	    else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
	    else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
	}

	/**
	 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
	 *
	 * @name bboxPolygon
	 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
	 * @returns {Feature<Polygon>} a Polygon representation of the bounding box
	 * @example
	 * var bbox = [0, 0, 10, 10];
	 *
	 * var poly = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [poly]
	 */
	function bboxPolygon$1(bbox) {
	    validateBBox(bbox);
	    // Convert BBox positions to Numbers
	    // No performance loss for including Number()
	    // https://github.com/Turfjs/turf/issues/1119
	    var west = Number(bbox[0]);
	    var south = Number(bbox[1]);
	    var east = Number(bbox[2]);
	    var north = Number(bbox[3]);

	    if (bbox.length === 6) throw new Error('@turf/bbox-polygon does not support BBox with 6 positions');

	    var lowLeft = [west, south];
	    var topLeft = [west, north];
	    var topRight = [east, north];
	    var lowRight = [east, south];

	    return polygon$8([[
	        lowLeft,
	        lowRight,
	        topRight,
	        topLeft,
	        lowLeft
	    ]]);
	}

	/**
	 * Takes any number of features and returns a rectangular {@link Polygon} that encompasses all vertices.
	 *
	 * @name envelope
	 * @param {GeoJSON} geojson input features
	 * @returns {Feature<Polygon>} a rectangular Polygon feature that encompasses all vertices
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([-75.343, 39.984], {"name": "Location A"}),
	 *   turf.point([-75.833, 39.284], {"name": "Location B"}),
	 *   turf.point([-75.534, 39.123], {"name": "Location C"})
	 * ]);
	 *
	 * var enveloped = turf.envelope(features);
	 *
	 * //addToMap
	 * var addToMap = [features, enveloped];
	 */
	function envelope(geojson) {
	    return bboxPolygon$1(bbox(geojson));
	}

	//http://en.wikipedia.org/wiki/Haversine_formula
	//http://www.movable-type.co.uk/scripts/latlong.html
	/**
	 * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
	 *
	 * @name destination
	 * @param {Coord} origin starting point
	 * @param {number} distance distance from the origin point
	 * @param {number} bearing ranging from -180 to 180
	 * @param {Object} [options={}] Optional parameters
	 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
	 * @param {Object} [options.properties={}] Translate properties to Point
	 * @returns {Feature<Point>} destination point
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 * var distance = 50;
	 * var bearing = 90;
	 * var options = {units: 'miles'};
	 *
	 * var destination = turf.destination(point, distance, bearing, options);
	 *
	 * //addToMap
	 * var addToMap = [point, destination]
	 * destination.properties['marker-color'] = '#f00';
	 * point.properties['marker-color'] = '#0f0';
	 */
	function destination(origin, distance, bearing, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var units = options.units;
	    var properties = options.properties;

	    // Handle input
	    var coordinates1 = getCoord(origin);
	    var longitude1 = degreesToRadians(coordinates1[0]);
	    var latitude1 = degreesToRadians(coordinates1[1]);
	    var bearing_rad = degreesToRadians(bearing);
	    var radians = lengthToRadians(distance, units);

	    // Main
	    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
	        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
	    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),
	        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
	    var lng = radiansToDegrees(longitude2);
	    var lat = radiansToDegrees(latitude2);

	    return point$7([lng, lat], properties);
	}

	//http://en.wikipedia.org/wiki/Haversine_formula
	//http://www.movable-type.co.uk/scripts/latlong.html

	/**
	 * Takes two {@link Point|points} and finds the geographic bearing between them,
	 * i.e. the angle measured in degrees from the north line (0 degrees)
	 *
	 * @name bearing
	 * @param {Coord} start starting Point
	 * @param {Coord} end ending Point
	 * @param {Object} [options={}] Optional parameters
	 * @param {boolean} [options.final=false] calculates the final bearing if true
	 * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
	 * @example
	 * var point1 = turf.point([-75.343, 39.984]);
	 * var point2 = turf.point([-75.534, 39.123]);
	 *
	 * var bearing = turf.bearing(point1, point2);
	 *
	 * //addToMap
	 * var addToMap = [point1, point2]
	 * point1.properties['marker-color'] = '#f00'
	 * point2.properties['marker-color'] = '#0f0'
	 * point1.properties.bearing = bearing
	 */
	function bearing(start, end, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var final = options.final;

	    // Reverse calculation
	    if (final === true) return calculateFinalBearing(start, end);

	    var coordinates1 = getCoord(start);
	    var coordinates2 = getCoord(end);

	    var lon1 = degreesToRadians(coordinates1[0]);
	    var lon2 = degreesToRadians(coordinates2[0]);
	    var lat1 = degreesToRadians(coordinates1[1]);
	    var lat2 = degreesToRadians(coordinates2[1]);
	    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
	    var b = Math.cos(lat1) * Math.sin(lat2) -
	        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

	    return radiansToDegrees(Math.atan2(a, b));
	}

	/**
	 * Calculates Final Bearing
	 *
	 * @private
	 * @param {Coord} start starting Point
	 * @param {Coord} end ending Point
	 * @returns {number} bearing
	 */
	function calculateFinalBearing(start, end) {
	    // Swap start & end
	    var bear = bearing(end, start);
	    bear = (bear + 180) % 360;
	    return bear;
	}

	/**
	 * Takes one or more features and calculates the centroid using the mean of all vertices.
	 * This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.
	 *
	 * @name centroid
	 * @param {GeoJSON} geojson GeoJSON to be centered
	 * @param {Object} [properties={}] an Object that is used as the {@link Feature}'s properties
	 * @returns {Feature<Point>} the centroid of the input features
	 * @example
	 * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
	 *
	 * var centroid = turf.centroid(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon, centroid]
	 */
	function centroid(geojson, properties) {
	    var xSum = 0;
	    var ySum = 0;
	    var len = 0;
	    coordEach$1(geojson, function (coord) {
	        xSum += coord[0];
	        ySum += coord[1];
	        len++;
	    }, true);
	    return point$7([xSum / len, ySum / len], properties);
	}

	var earcut_1 = earcut;
	var default_1$2 = earcut;

	function earcut(data, holeIndices, dim) {

	    dim = dim || 2;

	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];

	    if (!outerNode) return triangles;

	    var minX, minY, maxX, maxY, x, y, invSize;

	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];

	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }

	        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
	        invSize = Math.max(maxX - minX, maxY - minY);
	        invSize = invSize !== 0 ? 1 / invSize : 0;
	    }

	    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

	    return triangles;
	}

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;

	    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
	        for (i = start; i < end; i += dim) last = insertNode$1(i, data[i], data[i + 1], last);
	    } else {
	        for (i = end - dim; i >= start; i -= dim) last = insertNode$1(i, data[i], data[i + 1], last);
	    }

	    if (last && equals$1$1(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }

	    return last;
	}

	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;

	    var p = start,
	        again;
	    do {
	        again = false;

	        if (!p.steiner && (equals$1$1(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) break;
	            again = true;

	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);

	    return end;
	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	    if (!ear) return;

	    // interlink polygon nodes in z-order
	    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

	    var stop = ear,
	        prev, next;

	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;

	        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
	            // cut off the triangle
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);

	            removeNode(ear);

	            // skipping the next vertice leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;

	            continue;
	        }

	        ear = next;

	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

	            // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(ear, triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

	            // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, invSize);
	            }

	            break;
	        }
	    }
	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // now make sure we don't have other points inside the potential ear
	    var p = ear.next.next;

	    while (p !== ear.prev) {
	        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }

	    return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // triangle bbox; min & max are calculated like this for speed
	    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
	        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
	        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
	        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

	    // z-order range for the current triangle bbox;
	    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
	        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

	    // first look for points inside the triangle in increasing z-order
	    var p = ear.nextZ;

	    while (p && p.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.nextZ;
	    }

	    // then look for points in decreasing z-order
	    p = ear.prevZ;

	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }

	    return true;
	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;

	        if (!equals$1$1(a, b) && intersects$2$1(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);

	            // remove two nodes involved
	            removeNode(p);
	            removeNode(p.next);

	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);

	    return p;
	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	    // look for a valid diagonal that divides the polygon into two
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                // split the polygon in two by the diagonal
	                var c = splitPolygon(a, b);

	                // filter colinear points around the cuts
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);

	                // run earcut on each half
	                earcutLinked(a, triangles, dim, minX, minY, invSize);
	                earcutLinked(c, triangles, dim, minX, minY, invSize);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i, len, start, end, list;

	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }

	    queue.sort(compareX);

	    // process holes from left to right
	    for (i = 0; i < queue.length; i++) {
	        eliminateHole(queue[i], outerNode);
	        outerNode = filterPoints(outerNode, outerNode.next);
	    }

	    return outerNode;
	}

	function compareX(a, b) {
	    return a.x - b.x;
	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole(hole, outerNode) {
	    outerNode = findHoleBridge(hole, outerNode);
	    if (outerNode) {
	        var b = splitPolygon(outerNode, hole);
	        filterPoints(b, b.next);
	    }
	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;

	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) return p;
	                    if (hy === p.next.y) return p.next;
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);

	    if (!m) return null;

	    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point

	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;

	    p = m.next;

	    while (p !== stop) {
	        if (hx >= p.x && p.x >= mx && hx !== p.x &&
	                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

	            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

	            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
	                m = p;
	                tanMin = tan;
	            }
	        }

	        p = p.next;
	    }

	    return m;
	}

	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, invSize) {
	    var p = start;
	    do {
	        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);

	    p.prevZ.nextZ = null;
	    p.prevZ = null;

	    sortLinked(p);
	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize,
	        inSize = 1;

	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;

	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }
	            qSize = inSize;

	            while (pSize > 0 || (qSize > 0 && q)) {

	                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }

	                if (tail) tail.nextZ = e;
	                else list = e;

	                e.prevZ = tail;
	                tail = e;
	            }

	            p = q;
	        }

	        tail.nextZ = null;
	        inSize *= 2;

	    } while (numMerges > 1);

	    return list;
	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder(x, y, minX, minY, invSize) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = 32767 * (x - minX) * invSize;
	    y = 32767 * (y - minY) * invSize;

	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;

	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;

	    return x | (y << 1);
	}

	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x) leftmost = p;
	        p = p.next;
	    } while (p !== start);

	    return leftmost;
	}

	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
	           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
	           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon$3(a, b) &&
	           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}

	// signed area of a triangle
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	// check if two points are equal
	function equals$1$1(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}

	// check if two segments intersect
	function intersects$2$1(p1, q1, p2, q2) {
	    if ((equals$1$1(p1, q1) && equals$1$1(p2, q2)) ||
	        (equals$1$1(p1, q2) && equals$1$1(p2, q1))) return true;
	    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
	           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon$3(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects$2$1(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);

	    return false;
	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ?
	        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
	        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
	                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);

	    return inside;
	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
	    var a2 = new Node$1(a.i, a.x, a.y),
	        b2 = new Node$1(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;

	    a.next = b;
	    b.prev = a;

	    a2.next = an;
	    an.prev = a2;

	    b2.next = a2;
	    a2.prev = b2;

	    bp.next = b2;
	    b2.prev = bp;

	    return b2;
	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode$1(i, x, y, last) {
	    var p = new Node$1(i, x, y);

	    if (!last) {
	        p.prev = p;
	        p.next = p;

	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}

	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;

	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node$1(i, x, y) {
	    // vertice index in coordinates array
	    this.i = i;

	    // vertex coordinates
	    this.x = x;
	    this.y = y;

	    // previous and next vertice nodes in a polygon ring
	    this.prev = null;
	    this.next = null;

	    // z-order curve value
	    this.z = null;

	    // previous and next nodes in z-order
	    this.prevZ = null;
	    this.nextZ = null;

	    // indicates whether this is a steiner point
	    this.steiner = false;
	}

	// return a percentage difference between the polygon area and its triangulation area;
	// used to verify correctness of triangulation
	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }

	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs(
	            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
	            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }

	    return polygonArea === 0 && trianglesArea === 0 ? 0 :
	        Math.abs((trianglesArea - polygonArea) / polygonArea);
	};

	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}

	// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
	earcut.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = {vertices: [], holes: [], dimensions: dim},
	        holeIndex = 0;

	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};

	earcut_1.default = default_1$2;

	function quickselect$3(arr, k, left, right, compare) {
	    quickselectStep$1(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare$2);
	}

	function quickselectStep$1(arr, k, left, right, compare) {

	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            quickselectStep$1(arr, k, newLeft, newRight, compare);
	        }

	        var t = arr[k];
	        var i = left;
	        var j = right;

	        swap$1$1(arr, left, k);
	        if (compare(arr[right], t) > 0) swap$1$1(arr, left, right);

	        while (i < j) {
	            swap$1$1(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) i++;
	            while (compare(arr[j], t) > 0) j--;
	        }

	        if (compare(arr[left], t) === 0) swap$1$1(arr, left, j);
	        else {
	            j++;
	            swap$1$1(arr, j, right);
	        }

	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}

	function swap$1$1(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultCompare$2(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	function rbush$4(maxEntries, format) {
	    if (!(this instanceof rbush$4)) return new rbush$4(maxEntries, format);

	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

	    if (format) {
	        this._initFormat(format);
	    }

	    this.clear();
	}

	rbush$4.prototype = {

	    all: function () {
	        return this._all(this.data, []);
	    },

	    search: function (bbox) {

	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;

	        if (!intersects$4(bbox, node)) return result;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects$4(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);
	                    else if (contains$1$1(bbox, childBBox)) this._all(child, result);
	                    else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return result;
	    },

	    collides: function (bbox) {

	        var node = this.data,
	            toBBox = this.toBBox;

	        if (!intersects$4(bbox, node)) return false;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects$4(bbox, childBBox)) {
	                    if (node.leaf || contains$1$1(bbox, childBBox)) return true;
	                    nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return false;
	    },

	    load: function (data) {
	        if (!(data && data.length)) return this;

	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }

	        // recursively build the tree with the given data from scratch using OMT algorithm
	        var node = this._build(data.slice(), 0, data.length - 1, 0);

	        if (!this.data.children.length) {
	            // save as is if tree is empty
	            this.data = node;

	        } else if (this.data.height === node.height) {
	            // split root if trees have the same height
	            this._splitRoot(this.data, node);

	        } else {
	            if (this.data.height < node.height) {
	                // swap trees if inserted one is bigger
	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }

	            // insert the small tree into the large tree at appropriate level
	            this._insert(node, this.data.height - node.height - 1, true);
	        }

	        return this;
	    },

	    insert: function (item) {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },

	    clear: function () {
	        this.data = createNode$1$1([]);
	        return this;
	    },

	    remove: function (item, equalsFn) {
	        if (!item) return this;

	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i, parent, index, goingUp;

	        // depth-first iterative tree traversal
	        while (node || path.length) {

	            if (!node) { // go up
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }

	            if (node.leaf) { // check current node
	                index = findItem$1$1(item, node.children, equalsFn);

	                if (index !== -1) {
	                    // item found, remove the item and condense tree upwards
	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }

	            if (!goingUp && !node.leaf && contains$1$1(node, bbox)) { // go down
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];

	            } else if (parent) { // go right
	                i++;
	                node = parent.children[i];
	                goingUp = false;

	            } else node = null; // nothing found
	        }

	        return this;
	    },

	    toBBox: function (item) { return item; },

	    compareMinX: compareNodeMinX$1$1,
	    compareMinY: compareNodeMinY$1$1,

	    toJSON: function () { return this.data; },

	    fromJSON: function (data) {
	        this.data = data;
	        return this;
	    },

	    _all: function (node, result) {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);
	            else nodesToSearch.push.apply(nodesToSearch, node.children);

	            node = nodesToSearch.pop();
	        }
	        return result;
	    },

	    _build: function (items, left, right, height) {

	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;

	        if (N <= M) {
	            // reached leaf level; return leaf
	            node = createNode$1$1(items.slice(left, right + 1));
	            calcBBox$1$1(node, this.toBBox);
	            return node;
	        }

	        if (!height) {
	            // target height of the bulk-loaded tree
	            height = Math.ceil(Math.log(N) / Math.log(M));

	            // target number of root entries to maximize storage utilization
	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }

	        node = createNode$1$1([]);
	        node.leaf = false;
	        node.height = height;

	        // split the items into M mostly square tiles

	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i, j, right2, right3;

	        multiSelect$1$1(items, left, right, N1, this.compareMinX);

	        for (i = left; i <= right; i += N1) {

	            right2 = Math.min(i + N1 - 1, right);

	            multiSelect$1$1(items, i, right2, N2, this.compareMinY);

	            for (j = i; j <= right2; j += N2) {

	                right3 = Math.min(j + N2 - 1, right2);

	                // pack each entry recursively
	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }

	        calcBBox$1$1(node, this.toBBox);

	        return node;
	    },

	    _chooseSubtree: function (bbox, node, level, path) {

	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

	        while (true) {
	            path.push(node);

	            if (node.leaf || path.length - 1 === level) break;

	            minArea = minEnlargement = Infinity;

	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea$1$1(child);
	                enlargement = enlargedArea$1$1(bbox, child) - area;

	                // choose entry with the least area enlargement
	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;

	                } else if (enlargement === minEnlargement) {
	                    // otherwise choose one with the smallest area
	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }

	            node = targetNode || node.children[0];
	        }

	        return node;
	    },

	    _insert: function (item, level, isNode) {

	        var toBBox = this.toBBox,
	            bbox = isNode ? item : toBBox(item),
	            insertPath = [];

	        // find the best node for accommodating the item, saving all nodes along the path too
	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

	        // put the item into the node
	        node.children.push(item);
	        extend$1$1(node, bbox);

	        // split on node overflow; propagate upwards if necessary
	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }

	        // adjust bboxes along the insertion path
	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },

	    // split overflowed node into two
	    _split: function (insertPath, level) {

	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;

	        this._chooseSplitAxis(node, m, M);

	        var splitIndex = this._chooseSplitIndex(node, m, M);

	        var newNode = createNode$1$1(node.children.splice(splitIndex, node.children.length - splitIndex));
	        newNode.height = node.height;
	        newNode.leaf = node.leaf;

	        calcBBox$1$1(node, this.toBBox);
	        calcBBox$1$1(newNode, this.toBBox);

	        if (level) insertPath[level - 1].children.push(newNode);
	        else this._splitRoot(node, newNode);
	    },

	    _splitRoot: function (node, newNode) {
	        // split root node
	        this.data = createNode$1$1([node, newNode]);
	        this.data.height = node.height + 1;
	        this.data.leaf = false;
	        calcBBox$1$1(this.data, this.toBBox);
	    },

	    _chooseSplitIndex: function (node, m, M) {

	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

	        minOverlap = minArea = Infinity;

	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox$1$1(node, 0, i, this.toBBox);
	            bbox2 = distBBox$1$1(node, i, M, this.toBBox);

	            overlap = intersectionArea$1$1(bbox1, bbox2);
	            area = bboxArea$1$1(bbox1) + bboxArea$1$1(bbox2);

	            // choose distribution with minimum overlap
	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;

	                minArea = area < minArea ? area : minArea;

	            } else if (overlap === minOverlap) {
	                // otherwise choose distribution with minimum area
	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }

	        return index;
	    },

	    // sorts node children by the best axis for split
	    _chooseSplitAxis: function (node, m, M) {

	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX$1$1,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY$1$1,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);

	        // if total distributions margin value is minimal for x, sort by minX,
	        // otherwise it's already sorted by minY
	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },

	    // total margin of all possible split distributions where each node is at least m full
	    _allDistMargin: function (node, m, M, compare) {

	        node.children.sort(compare);

	        var toBBox = this.toBBox,
	            leftBBox = distBBox$1$1(node, 0, m, toBBox),
	            rightBBox = distBBox$1$1(node, M - m, M, toBBox),
	            margin = bboxMargin$1$1(leftBBox) + bboxMargin$1$1(rightBBox),
	            i, child;

	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend$1$1(leftBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin$1$1(leftBBox);
	        }

	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend$1$1(rightBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin$1$1(rightBBox);
	        }

	        return margin;
	    },

	    _adjustParentBBoxes: function (bbox, path, level) {
	        // adjust bboxes along the given tree path
	        for (var i = level; i >= 0; i--) {
	            extend$1$1(path[i], bbox);
	        }
	    },

	    _condense: function (path) {
	        // go through the path, removing empty nodes and updating bboxes
	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);

	                } else this.clear();

	            } else calcBBox$1$1(path[i], this.toBBox);
	        }
	    },

	    _initFormat: function (format) {
	        // data format (minX, minY, maxX, maxY accessors)

	        // uses eval-type function compilation instead of just accepting a toBBox function
	        // because the algorithms are very sensitive to sorting functions performance,
	        // so they should be dead simple and without inner calls

	        var compareArr = ['return a', ' - b', ';'];

	        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
	        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

	        this.toBBox = new Function('a',
	            'return {minX: a' + format[0] +
	            ', minY: a' + format[1] +
	            ', maxX: a' + format[2] +
	            ', maxY: a' + format[3] + '};');
	    }
	};

	function findItem$1$1(item, items, equalsFn) {
	    if (!equalsFn) return items.indexOf(item);

	    for (var i = 0; i < items.length; i++) {
	        if (equalsFn(item, items[i])) return i;
	    }
	    return -1;
	}

	// calculate node's bbox from bboxes of its children
	function calcBBox$1$1(node, toBBox) {
	    distBBox$1$1(node, 0, node.children.length, toBBox, node);
	}

	// min bounding rectangle of node children from k to p-1
	function distBBox$1$1(node, k, p, toBBox, destNode) {
	    if (!destNode) destNode = createNode$1$1(null);
	    destNode.minX = Infinity;
	    destNode.minY = Infinity;
	    destNode.maxX = -Infinity;
	    destNode.maxY = -Infinity;

	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend$1$1(destNode, node.leaf ? toBBox(child) : child);
	    }

	    return destNode;
	}

	function extend$1$1(a, b) {
	    a.minX = Math.min(a.minX, b.minX);
	    a.minY = Math.min(a.minY, b.minY);
	    a.maxX = Math.max(a.maxX, b.maxX);
	    a.maxY = Math.max(a.maxY, b.maxY);
	    return a;
	}

	function compareNodeMinX$1$1(a, b) { return a.minX - b.minX; }
	function compareNodeMinY$1$1(a, b) { return a.minY - b.minY; }

	function bboxArea$1$1(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
	function bboxMargin$1$1(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

	function enlargedArea$1$1(a, b) {
	    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
	           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
	}

	function intersectionArea$1$1(a, b) {
	    var minX = Math.max(a.minX, b.minX),
	        minY = Math.max(a.minY, b.minY),
	        maxX = Math.min(a.maxX, b.maxX),
	        maxY = Math.min(a.maxY, b.maxY);

	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}

	function contains$1$1(a, b) {
	    return a.minX <= b.minX &&
	           a.minY <= b.minY &&
	           b.maxX <= a.maxX &&
	           b.maxY <= a.maxY;
	}

	function intersects$4(a, b) {
	    return b.minX <= a.maxX &&
	           b.minY <= a.maxY &&
	           b.maxX >= a.minX &&
	           b.maxY >= a.minY;
	}

	function createNode$1$1(children) {
	    return {
	        children: children,
	        height: 1,
	        leaf: true,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	}

	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach

	function multiSelect$1$1(arr, left, right, n, compare) {
	    var stack = [left, right],
	        mid;

	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();

	        if (right - left <= n) continue;

	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        quickselect$3(arr, mid, left, right, compare);

	        stack.push(left, mid, mid, right);
	    }
	}

	/**
	 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
	 *
	 * @name rbush
	 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
	 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
	 * @returns {RBush} GeoJSON RBush
	 * @example
	 * import geojsonRbush from 'geojson-rbush';
	 * var tree = geojsonRbush();
	 */
	function geojsonRbush$1(maxEntries) {
	    var tree = rbush$4(maxEntries);
	    /**
	     * [insert](https://github.com/mourner/rbush#data-format)
	     *
	     * @param {Feature<any>} feature insert single GeoJSON Feature
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.insert(polygon)
	     */
	    tree.insert = function (feature) {
	        if (Array.isArray(feature)) {
	            var bbox = feature;
	            feature = bboxPolygon$2(bbox);
	            feature.bbox = bbox;
	        } else {
	            feature.bbox = feature.bbox ? feature.bbox : turfBBox$1(feature);
	        }
	        return rbush$4.prototype.insert.call(this, feature);
	    };

	    /**
	     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
	     *
	     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var polygons = {
	     *   "type": "FeatureCollection",
	     *   "features": [
	     *     {
	     *       "type": "Feature",
	     *       "properties": {},
	     *       "geometry": {
	     *         "type": "Polygon",
	     *         "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *       }
	     *     },
	     *     {
	     *       "type": "Feature",
	     *       "properties": {},
	     *       "geometry": {
	     *         "type": "Polygon",
	     *         "coordinates": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
	     *       }
	     *     }
	     *   ]
	     * }
	     * tree.load(polygons)
	     */
	    tree.load = function (features) {
	        var load = [];
	        // Load an Array of BBox
	        if (Array.isArray(features)) {
	            features.forEach(function (bbox) {
	                var feature = bboxPolygon$2(bbox);
	                feature.bbox = bbox;
	                load.push(feature);
	            });
	        } else {
	            // Load FeatureCollection
	            featureEach$1(features, function (feature) {
	                feature.bbox = feature.bbox ? feature.bbox : turfBBox$1(feature);
	                load.push(feature);
	            });
	        }
	        return rbush$4.prototype.load.call(this, load);
	    };

	    /**
	     * [remove](https://github.com/mourner/rbush#removing-data)
	     *
	     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.remove(polygon)
	     */
	    tree.remove = function (feature) {
	        if (Array.isArray(feature)) {
	            var bbox = feature;
	            feature = bboxPolygon$2(bbox);
	            feature.bbox = bbox;
	        }
	        return rbush$4.prototype.remove.call(this, feature);
	    };

	    /**
	     * [clear](https://github.com/mourner/rbush#removing-data)
	     *
	     * @returns {RBush} GeoJSON Rbush
	     * @example
	     * tree.clear()
	     */
	    tree.clear = function () {
	        return rbush$4.prototype.clear.call(this);
	    };

	    /**
	     * [search](https://github.com/mourner/rbush#search)
	     *
	     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON
	     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.search(polygon)
	     */
	    tree.search = function (geojson) {
	        var features = rbush$4.prototype.search.call(this, this.toBBox(geojson));
	        return {
	            type: 'FeatureCollection',
	            features: features
	        };
	    };

	    /**
	     * [collides](https://github.com/mourner/rbush#collisions)
	     *
	     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON
	     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.collides(polygon)
	     */
	    tree.collides = function (geojson) {
	        return rbush$4.prototype.collides.call(this, this.toBBox(geojson));
	    };

	    /**
	     * [all](https://github.com/mourner/rbush#search)
	     *
	     * @returns {FeatureCollection<any>} all the features in RBush
	     * @example
	     * tree.all()
	     * //=FeatureCollection
	     */
	    tree.all = function () {
	        var features = rbush$4.prototype.all.call(this);
	        return {
	            type: 'FeatureCollection',
	            features: features
	        };
	    };

	    /**
	     * [toJSON](https://github.com/mourner/rbush#export-and-import)
	     *
	     * @returns {any} export data as JSON object
	     * @example
	     * var exported = tree.toJSON()
	     * //=JSON object
	     */
	    tree.toJSON = function () {
	        return rbush$4.prototype.toJSON.call(this);
	    };

	    /**
	     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
	     *
	     * @param {any} json import previously exported data
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var exported = {
	     *   "children": [
	     *     {
	     *       "type": "Feature",
	     *       "geometry": {
	     *         "type": "Point",
	     *         "coordinates": [110, 50]
	     *       },
	     *       "properties": {},
	     *       "bbox": [110, 50, 110, 50]
	     *     }
	     *   ],
	     *   "height": 1,
	     *   "leaf": true,
	     *   "minX": 110,
	     *   "minY": 50,
	     *   "maxX": 110,
	     *   "maxY": 50
	     * }
	     * tree.fromJSON(exported)
	     */
	    tree.fromJSON = function (json) {
	        return rbush$4.prototype.fromJSON.call(this, json);
	    };

	    /**
	     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
	     *
	     * @private
	     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from
	     * @returns {Object} converted to {minX, minY, maxX, maxY}
	     */
	    tree.toBBox = function (geojson) {
	        var bbox;
	        if (geojson.bbox) bbox = geojson.bbox;
	        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
	        else bbox = turfBBox$1(geojson);

	        return {
	            minX: bbox[0],
	            minY: bbox[1],
	            maxX: bbox[2],
	            maxY: bbox[3]
	        };
	    };
	    return tree;
	}

	/**
	 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
	 *
	 * @private
	 * @name bboxPolygon
	 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
	 * @returns {Feature<Polygon>} a Polygon representation of the bounding box
	 * @example
	 * var bbox = [0, 0, 10, 10];
	 *
	 * var poly = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [poly]
	 */
	function bboxPolygon$2(bbox) {
	    var lowLeft = [bbox[0], bbox[1]];
	    var topLeft = [bbox[0], bbox[3]];
	    var topRight = [bbox[2], bbox[3]];
	    var lowRight = [bbox[2], bbox[1]];
	    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];

	    return {
	        type: 'Feature',
	        bbox: bbox,
	        properties: {},
	        geometry: {
	            type: 'Polygon',
	            coordinates: coordinates
	        }
	    };
	}

	/**
	 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
	 *
	 * @private
	 * @name bbox
	 * @param {FeatureCollection|Feature<any>} geojson input features
	 * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
	 * @example
	 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
	 * var bbox = turf.bbox(line);
	 * var bboxPolygon = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [line, bboxPolygon]
	 */
	function turfBBox$1(geojson) {
	    var bbox = [Infinity, Infinity, -Infinity, -Infinity];
	    coordEach$1(geojson, function (coord) {
	        if (bbox[0] > coord[0]) bbox[0] = coord[0];
	        if (bbox[1] > coord[1]) bbox[1] = coord[1];
	        if (bbox[2] < coord[0]) bbox[2] = coord[0];
	        if (bbox[3] < coord[1]) bbox[3] = coord[1];
	    });
	    return bbox;
	}

	/**
	 * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
	 *
	 * @name lineSegment
	 * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString
	 * @returns {FeatureCollection<LineString>} 2-vertex line segments
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 * var segments = turf.lineSegment(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon, segments]
	 */
	function lineSegment(geojson) {
	    if (!geojson) throw new Error('geojson is required');

	    var results = [];
	    flattenEach(geojson, function (feature$$1) {
	        lineSegmentFeature(feature$$1, results);
	    });
	    return featureCollection(results);
	}

	/**
	 * Line Segment
	 *
	 * @private
	 * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
	 * @param {Array} results push to results
	 * @returns {void}
	 */
	function lineSegmentFeature(geojson, results) {
	    var coords = [];
	    var geometry$$1 = geojson.geometry;
	    switch (geometry$$1.type) {
	    case 'Polygon':
	        coords = getCoords(geometry$$1);
	        break;
	    case 'LineString':
	        coords = [getCoords(geometry$$1)];
	    }
	    coords.forEach(function (coord) {
	        var segments = createSegments(coord, geojson.properties);
	        segments.forEach(function (segment) {
	            segment.id = results.length;
	            results.push(segment);
	        });
	    });
	}

	/**
	 * Create Segments from LineString coordinates
	 *
	 * @private
	 * @param {LineString} coords LineString coordinates
	 * @param {*} properties GeoJSON properties
	 * @returns {Array<Feature<LineString>>} line segments
	 */
	function createSegments(coords, properties) {
	    var segments = [];
	    coords.reduce(function (previousCoords, currentCoords) {
	        var segment = lineString([previousCoords, currentCoords], properties);
	        segment.bbox = bbox$3(previousCoords, currentCoords);
	        segments.push(segment);
	        return currentCoords;
	    });
	    return segments;
	}

	/**
	 * Create BBox between two coordinates (faster than @turf/bbox)
	 *
	 * @private
	 * @param {Array<number>} coords1 Point coordinate
	 * @param {Array<number>} coords2 Point coordinate
	 * @returns {BBox} [west, south, east, north]
	 */
	function bbox$3(coords1, coords2) {
	    var x1 = coords1[0];
	    var y1 = coords1[1];
	    var x2 = coords2[0];
	    var y2 = coords2[1];
	    var west = (x1 < x2) ? x1 : x2;
	    var south = (y1 < y2) ? y1 : y2;
	    var east = (x1 > x2) ? x1 : x2;
	    var north = (y1 > y2) ? y1 : y2;
	    return [west, south, east, north];
	}

	/**
	 * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
	 *
	 * @name lineIntersect
	 * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
	 * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
	 * @returns {FeatureCollection<Point>} point(s) that intersect both
	 * @example
	 * var line1 = turf.lineString([[126, -11], [129, -21]]);
	 * var line2 = turf.lineString([[123, -18], [131, -14]]);
	 * var intersects = turf.lineIntersect(line1, line2);
	 *
	 * //addToMap
	 * var addToMap = [line1, line2, intersects]
	 */
	function lineIntersect(line1, line2) {
	    var unique = {};
	    var results = [];

	    // First, normalize geometries to features
	    // Then, handle simple 2-vertex segments
	    if (line1.type === 'LineString') line1 = feature(line1);
	    if (line2.type === 'LineString') line2 = feature(line2);
	    if (line1.type === 'Feature' &&
	        line2.type === 'Feature' &&
	        line1.geometry.type === 'LineString' &&
	        line2.geometry.type === 'LineString' &&
	        line1.geometry.coordinates.length === 2 &&
	        line2.geometry.coordinates.length === 2) {
	        var intersect = intersects$3(line1, line2);
	        if (intersect) results.push(intersect);
	        return featureCollection(results);
	    }

	    // Handles complex GeoJSON Geometries
	    var tree = geojsonRbush$1();
	    tree.load(lineSegment(line2));
	    featureEach$1(lineSegment(line1), function (segment) {
	        featureEach$1(tree.search(segment), function (match) {
	            var intersect = intersects$3(segment, match);
	            if (intersect) {
	                // prevent duplicate points https://github.com/Turfjs/turf/issues/688
	                var key = getCoords(intersect).join(',');
	                if (!unique[key]) {
	                    unique[key] = true;
	                    results.push(intersect);
	                }
	            }
	        });
	    });
	    return featureCollection(results);
	}

	/**
	 * Find a point that intersects LineStrings with two coordinates each
	 *
	 * @private
	 * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
	 * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
	 * @returns {Feature<Point>} intersecting GeoJSON Point
	 */
	function intersects$3(line1, line2) {
	    var coords1 = getCoords(line1);
	    var coords2 = getCoords(line2);
	    if (coords1.length !== 2) {
	        throw new Error('<intersects> line1 must only contain 2 coordinates');
	    }
	    if (coords2.length !== 2) {
	        throw new Error('<intersects> line2 must only contain 2 coordinates');
	    }
	    var x1 = coords1[0][0];
	    var y1 = coords1[0][1];
	    var x2 = coords1[1][0];
	    var y2 = coords1[1][1];
	    var x3 = coords2[0][0];
	    var y3 = coords2[0][1];
	    var x4 = coords2[1][0];
	    var y4 = coords2[1][1];
	    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
	    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));
	    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));

	    if (denom === 0) {
	        if (numeA === 0 && numeB === 0) {
	            return null;
	        }
	        return null;
	    }

	    var uA = numeA / denom;
	    var uB = numeB / denom;

	    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
	        var x = x1 + (uA * (x2 - x1));
	        var y = y1 + (uA * (y2 - y1));
	        return point$7([x, y]);
	    }
	    return null;
	}

	/**
	 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
	 *
	 * @name nearestPointOnLine
	 * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
	 * @param {Geometry|Feature<Point>|number[]} pt point to snap from
	 * @param {Object} [options={}] Optional parameters
	 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
	 * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
	 * @example
	 * var line = turf.lineString([
	 *     [-77.031669, 38.878605],
	 *     [-77.029609, 38.881946],
	 *     [-77.020339, 38.884084],
	 *     [-77.025661, 38.885821],
	 *     [-77.021884, 38.889563],
	 *     [-77.019824, 38.892368]
	 * ]);
	 * var pt = turf.point([-77.037076, 38.884017]);
	 *
	 * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});
	 *
	 * //addToMap
	 * var addToMap = [line, pt, snapped];
	 * snapped.properties['marker-color'] = '#00f';
	 */
	function nearestPointOnLine(lines, pt, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');

	    // validation
	    var type = (lines.geometry) ? lines.geometry.type : lines.type;
	    if (type !== 'LineString' && type !== 'MultiLineString') {
	        throw new Error('lines must be LineString or MultiLineString');
	    }

	    var closestPt = point$7([Infinity, Infinity], {
	        dist: Infinity
	    });

	    var length = 0.0;
	    flattenEach(lines, function (line) {
	        var coords = getCoords(line);

	        for (var i = 0; i < coords.length - 1; i++) {
	            //start
	            var start = point$7(coords[i]);
	            start.properties.dist = distance(pt, start, options);
	            //stop
	            var stop = point$7(coords[i + 1]);
	            stop.properties.dist = distance(pt, stop, options);
	            // sectionLength
	            var sectionLength = distance(start, stop, options);
	            //perpendicular
	            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
	            var direction = bearing(start, stop);
	            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);
	            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);
	            var intersect = lineIntersect(
	                lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]),
	                lineString([start.geometry.coordinates, stop.geometry.coordinates])
	            );
	            var intersectPt = null;
	            if (intersect.features.length > 0) {
	                intersectPt = intersect.features[0];
	                intersectPt.properties.dist = distance(pt, intersectPt, options);
	                intersectPt.properties.location = length + distance(start, intersectPt, options);
	            }

	            if (start.properties.dist < closestPt.properties.dist) {
	                closestPt = start;
	                closestPt.properties.index = i;
	                closestPt.properties.location = length;
	            }
	            if (stop.properties.dist < closestPt.properties.dist) {
	                closestPt = stop;
	                closestPt.properties.index = i + 1;
	                closestPt.properties.location = length + sectionLength;
	            }
	            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
	                closestPt = intersectPt;
	                closestPt.properties.index = i;
	            }
	            // update length
	            length += sectionLength;
	        }

	    });

	    return closestPt;
	}

	/**
	 * Converts a WGS84 GeoJSON object into Mercator (EPSG:900913) projection
	 *
	 * @name toMercator
	 * @param {GeoJSON|Position} geojson WGS84 GeoJSON object
	 * @param {Object} [options] Optional parameters
	 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
	 * @returns {GeoJSON} true/false
	 * @example
	 * var pt = turf.point([-71,41]);
	 * var converted = turf.toMercator(pt);
	 *
	 * //addToMap
	 * var addToMap = [pt, converted];
	 */
	function toMercator(geojson, options) {
	    return convert$1(geojson, 'mercator', options);
	}

	/**
	 * Converts a Mercator (EPSG:900913) GeoJSON object into WGS84 projection
	 *
	 * @name toWgs84
	 * @param {GeoJSON|Position} geojson Mercator GeoJSON object
	 * @param {Object} [options] Optional parameters
	 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
	 * @returns {GeoJSON} true/false
	 * @example
	 * var pt = turf.point([-7903683.846322424, 5012341.663847514]);
	 * var converted = turf.toWgs84(pt);
	 *
	 * //addToMap
	 * var addToMap = [pt, converted];
	 */
	function toWgs84(geojson, options) {
	    return convert$1(geojson, 'wgs84', options);
	}


	/**
	 * Converts a GeoJSON coordinates to the defined `projection`
	 *
	 * @private
	 * @param {GeoJSON} geojson GeoJSON Feature or Geometry
	 * @param {string} projection defines the projection system to convert the coordinates to
	 * @param {Object} [options] Optional parameters
	 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
	 * @returns {GeoJSON} true/false
	 */
	function convert$1(geojson, projection, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var mutate = options.mutate;

	    // Validation
	    if (!geojson) throw new Error('geojson is required');

	    // Handle Position
	    if (Array.isArray(geojson) && isNumber(geojson[0])) geojson = (projection === 'mercator') ? convertToMercator(geojson) : convertToWgs84(geojson);

	    // Handle GeoJSON
	    else {
	        // Handle possible data mutation
	        if (mutate !== true) geojson = clone(geojson);

	        coordEach$1(geojson, function (coord) {
	            var newCoord = (projection === 'mercator') ? convertToMercator(coord) : convertToWgs84(coord);
	            coord[0] = newCoord[0];
	            coord[1] = newCoord[1];
	        });
	    }
	    return geojson;
	}

	/**
	 * Convert lon/lat values to 900913 x/y.
	 * (from https://github.com/mapbox/sphericalmercator)
	 *
	 * @private
	 * @param {Array<number>} lonLat WGS84 point
	 * @returns {Array<number>} Mercator [x, y] point
	 */
	function convertToMercator(lonLat) {
	    var D2R = Math.PI / 180,
	        // 900913 properties
	        A = 6378137.0,
	        MAXEXTENT = 20037508.342789244;

	    // compensate longitudes passing the 180th meridian
	    // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js
	    var adjusted = (Math.abs(lonLat[0]) <= 180) ? lonLat[0] : (lonLat[0] - (sign(lonLat[0]) * 360));
	    var xy = [
	        A * adjusted * D2R,
	        A * Math.log(Math.tan((Math.PI * 0.25) + (0.5 * lonLat[1] * D2R)))
	    ];

	    // if xy value is beyond maxextent (e.g. poles), return maxextent
	    if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;
	    if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;
	    if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;
	    if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;

	    return xy;
	}

	/**
	 * Convert 900913 x/y values to lon/lat.
	 * (from https://github.com/mapbox/sphericalmercator)
	 *
	 * @private
	 * @param {Array<number>} xy Mercator [x, y] point
	 * @returns {Array<number>} WGS84 [lon, lat] point
	 */
	function convertToWgs84(xy) {
	    // 900913 properties.
	    var R2D = 180 / Math.PI;
	    var A = 6378137.0;

	    return [
	        (xy[0] * R2D / A),
	        ((Math.PI * 0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D
	    ];
	}

	/**
	 * Returns the sign of the input, or zero
	 *
	 * @private
	 * @param {number} x input
	 * @returns {number} -1|0|1 output
	 */
	function sign(x) {
	    return (x < 0) ? -1 : (x > 0) ? 1 : 0;
	}




	Object.freeze({
		toMercator: toMercator,
		toWgs84: toWgs84
	});

	/**
	 * Takes one or more features and returns their area in square meters.
	 *
	 * @name area
	 * @param {GeoJSON} geojson input GeoJSON feature(s)
	 * @returns {number} area in square meters
	 * @example
	 * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
	 *
	 * var area = turf.area(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon]
	 * polygon.properties.area = area
	 */
	function area$1(geojson) {
	    return geomReduce(geojson, function (value, geom) {
	        return value + calculateArea(geom);
	    }, 0);
	}

	var RADIUS = 6378137;
	// var FLATTENING_DENOM = 298.257223563;
	// var FLATTENING = 1 / FLATTENING_DENOM;
	// var POLAR_RADIUS = RADIUS * (1 - FLATTENING);

	/**
	 * Calculate Area
	 *
	 * @private
	 * @param {GeoJSON} geojson GeoJSON
	 * @returns {number} area
	 */
	function calculateArea(geojson) {
	    var area = 0, i;
	    switch (geojson.type) {
	    case 'Polygon':
	        return polygonArea(geojson.coordinates);
	    case 'MultiPolygon':
	        for (i = 0; i < geojson.coordinates.length; i++) {
	            area += polygonArea(geojson.coordinates[i]);
	        }
	        return area;
	    case 'Point':
	    case 'MultiPoint':
	    case 'LineString':
	    case 'MultiLineString':
	        return 0;
	    case 'GeometryCollection':
	        for (i = 0; i < geojson.geometries.length; i++) {
	            area += calculateArea(geojson.geometries[i]);
	        }
	        return area;
	    }
	}

	function polygonArea(coords) {
	    var area = 0;
	    if (coords && coords.length > 0) {
	        area += Math.abs(ringArea(coords[0]));
	        for (var i = 1; i < coords.length; i++) {
	            area -= Math.abs(ringArea(coords[i]));
	        }
	    }
	    return area;
	}

	/**
	 * @private
	 * Calculate the approximate area of the polygon were it projected onto the earth.
	 * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
	 *
	 * Reference:
	 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
	 * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	 *
	 * @param {Array<Array<number>>} coords Ring Coordinates
	 * @returns {number} The approximate signed geodesic area of the polygon in square meters.
	 */
	function ringArea(coords) {
	    var p1;
	    var p2;
	    var p3;
	    var lowerIndex;
	    var middleIndex;
	    var upperIndex;
	    var i;
	    var area = 0;
	    var coordsLength = coords.length;

	    if (coordsLength > 2) {
	        for (i = 0; i < coordsLength; i++) {
	            if (i === coordsLength - 2) { // i = N-2
	                lowerIndex = coordsLength - 2;
	                middleIndex = coordsLength - 1;
	                upperIndex = 0;
	            } else if (i === coordsLength - 1) { // i = N-1
	                lowerIndex = coordsLength - 1;
	                middleIndex = 0;
	                upperIndex = 1;
	            } else { // i = 0 to N-3
	                lowerIndex = i;
	                middleIndex = i + 1;
	                upperIndex = i + 2;
	            }
	            p1 = coords[lowerIndex];
	            p2 = coords[middleIndex];
	            p3 = coords[upperIndex];
	            area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
	        }

	        area = area * RADIUS * RADIUS / 2;
	    }

	    return area;
	}

	function rad(_) {
	    return _ * Math.PI / 180;
	}

	/**
	 * Returns true if a point is on a line. Accepts a optional parameter to ignore the start and end vertices of the linestring.
	 *
	 * @name booleanPointOnLine
	 * @param {Coord} pt GeoJSON Point
	 * @param {Feature<LineString>} line GeoJSON LineString
	 * @param {Object} [options={}] Optional parameters
	 * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.
	 * @returns {boolean} true/false
	 * @example
	 * var pt = turf.point([0, 0]);
	 * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
	 * var isPointOnLine = turf.booleanPointOnLine(pt, line);
	 * //=true
	 */
	function booleanPointOnLine(pt, line, options) {
	    // Optional parameters
	    options = options || {};
	    var ignoreEndVertices = options.ignoreEndVertices;
	    if (!isObject(options)) throw new Error('invalid options');

	    // Validate input
	    if (!pt) throw new Error('pt is required');
	    if (!line) throw new Error('line is required');

	    // Normalize inputs
	    var ptCoords = getCoord(pt);
	    var lineCoords = getCoords(line);

	    // Main
	    for (var i = 0; i < lineCoords.length - 1; i++) {
	        var ignoreBoundary = false;
	        if (ignoreEndVertices) {
	            if (i === 0) ignoreBoundary = 'start';
	            if (i === lineCoords.length - 2) ignoreBoundary = 'end';
	            if (i === 0 && i + 1 === lineCoords.length - 1) ignoreBoundary = 'both';
	        }
	        if (isPointOnLineSegment$1(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) return true;
	    }
	    return false;
	}

	// See http://stackoverflow.com/a/4833823/1979085
	/**
	 * @private
	 * @param {Position} lineSegmentStart coord pair of start of line
	 * @param {Position} lineSegmentEnd coord pair of end of line
	 * @param {Position} pt coord pair of point to check
	 * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends. If true which end to ignore.
	 * @returns {boolean} true/false
	 */
	function isPointOnLineSegment$1(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {
	    var x = pt[0];
	    var y = pt[1];
	    var x1 = lineSegmentStart[0];
	    var y1 = lineSegmentStart[1];
	    var x2 = lineSegmentEnd[0];
	    var y2 = lineSegmentEnd[1];
	    var dxc = pt[0] - x1;
	    var dyc = pt[1] - y1;
	    var dxl = x2 - x1;
	    var dyl = y2 - y1;
	    var cross = dxc * dyl - dyc * dxl;
	    if (cross !== 0) {
	        return false;
	    }
	    if (!excludeBoundary) {
	        if (Math.abs(dxl) >= Math.abs(dyl)) {
	            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
	        }
	        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
	    } else if (excludeBoundary === 'start') {
	        if (Math.abs(dxl) >= Math.abs(dyl)) {
	            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
	        }
	        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
	    } else if (excludeBoundary === 'end') {
	        if (Math.abs(dxl) >= Math.abs(dyl)) {
	            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
	        }
	        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
	    } else if (excludeBoundary === 'both') {
	        if (Math.abs(dxl) >= Math.abs(dyl)) {
	            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
	        }
	        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
	    }
	}

	/**
	 * Takes a GeoJSON Feature or FeatureCollection and truncates the precision of the geometry.
	 *
	 * @name truncate
	 * @param {GeoJSON} geojson any GeoJSON Feature, FeatureCollection, Geometry or GeometryCollection.
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.precision=6] coordinate decimal precision
	 * @param {number} [options.coordinates=3] maximum number of coordinates (primarly used to remove z coordinates)
	 * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
	 * @returns {GeoJSON} layer with truncated geometry
	 * @example
	 * var point = turf.point([
	 *     70.46923055566859,
	 *     58.11088890802906,
	 *     1508
	 * ]);
	 * var options = {precision: 3, coordinates: 2};
	 * var truncated = turf.truncate(point, options);
	 * //=truncated.geometry.coordinates => [70.469, 58.111]
	 *
	 * //addToMap
	 * var addToMap = [truncated];
	 */
	function truncate(geojson, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var precision = options.precision;
	    var coordinates = options.coordinates;
	    var mutate = options.mutate;

	    // default params
	    precision = (precision === undefined || precision === null || isNaN(precision)) ? 6 : precision;
	    coordinates = (coordinates === undefined || coordinates === null || isNaN(coordinates)) ? 3 : coordinates;

	    // validation
	    if (!geojson) throw new Error('<geojson> is required');
	    if (typeof precision !== 'number') throw new Error('<precision> must be a number');
	    if (typeof coordinates !== 'number') throw new Error('<coordinates> must be a number');

	    // prevent input mutation
	    if (mutate === false || mutate === undefined) geojson = JSON.parse(JSON.stringify(geojson));

	    var factor = Math.pow(10, precision);

	    // Truncate Coordinates
	    coordEach$1(geojson, function (coords) {
	        truncateCoords(coords, factor, coordinates);
	    });
	    return geojson;
	}

	/**
	 * Truncate Coordinates - Mutates coordinates in place
	 *
	 * @private
	 * @param {Array<any>} coords Geometry Coordinates
	 * @param {number} factor rounding factor for coordinate decimal precision
	 * @param {number} coordinates maximum number of coordinates (primarly used to remove z coordinates)
	 * @returns {Array<any>} mutated coordinates
	 */
	function truncateCoords(coords, factor, coordinates) {
	    // Remove extra coordinates (usually elevation coordinates and more)
	    if (coords.length > coordinates) coords.splice(coordinates, coords.length);

	    // Truncate coordinate decimals
	    for (var i = 0; i < coords.length; i++) {
	        coords[i] = Math.round(coords[i] * factor) / factor;
	    }
	    return coords;
	}

	// Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving
	Number.prototype.modulo = function (n) {
	    return ((this % n) + n) % n;
	};

	/**
	 * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a {@link FeatureCollection} of {@link LineString|(Multi)LineString}.
	 *
	 * @name polygonToLine
	 * @param {Feature<Polygon|MultiPolygon>} polygon Feature to convert
	 * @param {Object} [options={}] Optional parameters
	 * @param {Object} [options.properties={}] translates GeoJSON properties to Feature
	 * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString
	 * @example
	 * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);
	 *
	 * var line = turf.polygonToLine(poly);
	 *
	 * //addToMap
	 * var addToMap = [line];
	 */
	function polygonToLine(polygon$$1, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var properties = options.properties;

	    // Variables
	    var geom = getType(polygon$$1);
	    var coords = getCoords(polygon$$1);
	    properties = properties || polygon$$1.properties || {};

	    if (!coords.length) throw new Error('polygon must contain coordinates');

	    switch (geom) {
	    case 'Polygon':
	        return coordsToLine(coords, properties);
	    case 'MultiPolygon':
	        var lines = [];
	        coords.forEach(function (coord) {
	            lines.push(coordsToLine(coord, properties));
	        });
	        return featureCollection(lines);
	    default:
	        throw new Error('geom ' + geom + ' not supported');
	    }
	}

	function coordsToLine(coords, properties) {
	    if (coords.length > 1) return multiLineString(coords, properties);
	    return lineString(coords[0], properties);
	}

	lineclip.polyline = lineclip;
	lineclip.polygon = polygonclip;


	// Cohen-Sutherland line clippign algorithm, adapted to efficiently
	// handle polylines rather than just segments

	function lineclip(points, bbox, result) {

	    var len = points.length,
	        codeA = bitCode(points[0], bbox),
	        part = [],
	        i, a, b, codeB, lastCode;

	    if (!result) result = [];

	    for (i = 1; i < len; i++) {
	        a = points[i - 1];
	        b = points[i];
	        codeB = lastCode = bitCode(b, bbox);

	        while (true) {

	            if (!(codeA | codeB)) { // accept
	                part.push(a);

	                if (codeB !== lastCode) { // segment went outside
	                    part.push(b);

	                    if (i < len - 1) { // start a new line
	                        result.push(part);
	                        part = [];
	                    }
	                } else if (i === len - 1) {
	                    part.push(b);
	                }
	                break;

	            } else if (codeA & codeB) { // trivial reject
	                break;

	            } else if (codeA) { // a outside, intersect with clip edge
	                a = intersect$1(a, b, codeA, bbox);
	                codeA = bitCode(a, bbox);

	            } else { // b outside
	                b = intersect$1(a, b, codeB, bbox);
	                codeB = bitCode(b, bbox);
	            }
	        }

	        codeA = lastCode;
	    }

	    if (part.length) result.push(part);

	    return result;
	}

	// Sutherland-Hodgeman polygon clipping algorithm

	function polygonclip(points, bbox) {

	    var result, edge, prev, prevInside, i, p, inside;

	    // clip against each side of the clip rectangle
	    for (edge = 1; edge <= 8; edge *= 2) {
	        result = [];
	        prev = points[points.length - 1];
	        prevInside = !(bitCode(prev, bbox) & edge);

	        for (i = 0; i < points.length; i++) {
	            p = points[i];
	            inside = !(bitCode(p, bbox) & edge);

	            // if segment goes through the clip window, add an intersection
	            if (inside !== prevInside) result.push(intersect$1(prev, p, edge, bbox));

	            if (inside) result.push(p); // add a point if it's inside

	            prev = p;
	            prevInside = inside;
	        }

	        points = result;

	        if (!points.length) break;
	    }

	    return result;
	}

	// intersect a segment against one of the 4 lines that make up the bbox

	function intersect$1(a, b, edge, bbox) {
	    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
	           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
	           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
	           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
	           null;
	}

	// bit code reflects the point position relative to the bbox:

	//         left  mid  right
	//    top  1001  1000  1010
	//    mid  0001  0000  0010
	// bottom  0101  0100  0110

	function bitCode(p, bbox) {
	    var code = 0;

	    if (p[0] < bbox[0]) code |= 1; // left
	    else if (p[0] > bbox[2]) code |= 2; // right

	    if (p[1] < bbox[1]) code |= 4; // bottom
	    else if (p[1] > bbox[3]) code |= 8; // top

	    return code;
	}

	/**
	 * Returns the direction of the point q relative to the vector p1 -> p2.
	 *
	 * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()
	 * (same as geos::algorithm::CGAlgorithm::computeOrientation())
	 *
	 * @param {number[]} p1 - the origin point of the vector
	 * @param {number[]} p2 - the final point of the vector
	 * @param {number[]} q - the point to compute the direction to
	 *
	 * @returns {number} - 1 if q is ccw (left) from p1->p2,
	 *    -1 if q is cw (right) from p1->p2,
	 *     0 if q is colinear with p1->p2
	 */
	function orientationIndex(p1, p2, q) {
	    var dx1 = p2[0] - p1[0],
	        dy1 = p2[1] - p1[1],
	        dx2 = q[0] - p2[0],
	        dy2 = q[1] - p2[1];

	    return Math.sign(dx1 * dy2 - dx2 * dy1);
	}

	/**
	 * Checks if two envelopes are equal.
	 *
	 * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon
	 *
	 * @param {Feature<Polygon>} env1 - Envelope
	 * @param {Feature<Polygon>} env2 - Envelope
	 * @returns {boolean} - True if the envelopes are equal
	 */
	function envelopeIsEqual(env1, env2) {
	    var envX1 = env1.geometry.coordinates.map(function (c) { return c[0]; }),
	        envY1 = env1.geometry.coordinates.map(function (c) { return c[1]; }),
	        envX2 = env2.geometry.coordinates.map(function (c) { return c[0]; }),
	        envY2 = env2.geometry.coordinates.map(function (c) { return c[1]; });

	    return Math.max(null, envX1) === Math.max(null, envX2) &&
	    Math.max(null, envY1) === Math.max(null, envY2) &&
	    Math.min(null, envX1) === Math.min(null, envX2) &&
	    Math.min(null, envY1) === Math.min(null, envY2);
	}

	/**
	 * Check if a envelope is contained in other one.
	 *
	 * The function assumes that the arguments are envelopes, i.e.: Convex polygon
	 * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,
	 * this could be further improved.
	 *
	 * @param {Feature<Polygon>} self - Envelope
	 * @param {Feature<Polygon>} env - Envelope
	 * @returns {boolean} - True if env is contained in self
	 */
	function envelopeContains(self, env) {
	    return env.geometry.coordinates[0].every(function (c) { return booleanPointInPolygon(point$7(c), self); });
	}

	/**
	 * Checks if two coordinates are equal.
	 *
	 * @param {number[]} coord1 - First coordinate
	 * @param {number[]} coord2 - Second coordinate
	 * @returns {boolean} - True if coordinates are equal
	 */
	function coordinatesEqual(coord1, coord2) {
	    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
	}

	/**
	 * Ring of edges which form a polygon.
	 *
	 * The ring may be either an outer shell or a hole.
	 *
	 * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing
	 */
	var EdgeRing = function EdgeRing() {
	    this.edges = [];
	    this.polygon = undefined; //< Caches Polygon representation
	    this.envelope = undefined; //< Caches Envelope representation
	};

	var prototypeAccessors$1 = { length: { configurable: true } };

	/**
	 * Add an edge to the ring, inserting it in the last position.
	 *
	 * @memberof EdgeRing
	 * @param {Edge} edge - Edge to be inserted
	 */
	EdgeRing.prototype.push = function push (edge) {
	// Emulate Array getter ([]) behaviour
	    this[this.edges.length] = edge;
	    this.edges.push(edge);
	    this.polygon = this.envelope = undefined;
	};

	/**
	 * Get Edge.
	 *
	 * @memberof EdgeRing
	 * @param {number} i - Index
	 * @returns {Edge} - Edge in the i position
	 */
	EdgeRing.prototype.get = function get (i) {
	    return this.edges[i];
	};

	/**
	 * Getter of length property.
	 *
	 * @memberof EdgeRing
	 * @returns {number} - Length of the edge ring.
	 */
	prototypeAccessors$1.length.get = function () {
	    return this.edges.length;
	};

	/**
	 * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.
	 *
	 * @memberof EdgeRing
	 * @param {Function} f - The same function to be passed to Array.prototype.forEach
	 */
	EdgeRing.prototype.forEach = function forEach (f) {
	    this.edges.forEach(f);
	};

	/**
	 * Similar to Array.prototype.map for the list of Edges in the EdgeRing.
	 *
	 * @memberof EdgeRing
	 * @param {Function} f - The same function to be passed to Array.prototype.map
	 * @returns {Array} - The mapped values in the function
	 */
	EdgeRing.prototype.map = function map (f) {
	    return this.edges.map(f);
	};

	/**
	 * Similar to Array.prototype.some for the list of Edges in the EdgeRing.
	 *
	 * @memberof EdgeRing
	 * @param {Function} f - The same function to be passed to Array.prototype.some
	 * @returns {boolean} - True if an Edge check the condition
	 */
	EdgeRing.prototype.some = function some (f) {
	    return this.edges.some(f);
	};

	/**
	 * Check if the ring is valid in geomtry terms.
	 *
	 * A ring must have either 0 or 4 or more points. The first and the last must be
	 * equal (in 2D)
	 * geos::geom::LinearRing::validateConstruction
	 *
	 * @memberof EdgeRing
	 * @returns {boolean} - Validity of the EdgeRing
	 */
	EdgeRing.prototype.isValid = function isValid () {
	// TODO: stub
	    return true;
	};

	/**
	 * Tests whether this ring is a hole.
	 *
	 * A ring is a hole if it is oriented counter-clockwise.
	 * Similar implementation of geos::algorithm::CGAlgorithms::isCCW
	 *
	 * @memberof EdgeRing
	 * @returns {boolean} - true: if it is a hole
	 */
	EdgeRing.prototype.isHole = function isHole () {
	        var this$1$1 = this;

	// XXX: Assuming Ring is valid
	// Find highest point
	    var hiIndex = this.edges.reduce(function (high, edge, i) {
	            if (edge.from.coordinates[1] > this$1$1.edges[high].from.coordinates[1])
	                { high = i; }
	            return high;
	        }, 0),
	        iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1,
	        iNext = (hiIndex + 1) % this.length,
	        disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);

	    if (disc === 0)
	        { return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0]; }
	    return disc > 0;
	};

	/**
	 * Creates a MultiPoint representing the EdgeRing (discarts edges directions).
	 *
	 * @memberof EdgeRing
	 * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing
	 */
	EdgeRing.prototype.toMultiPoint = function toMultiPoint () {
	    return multiPoint(this.edges.map(function (edge) { return edge.from.coordinates; }));
	};

	/**
	 * Creates a Polygon representing the EdgeRing.
	 *
	 * @memberof EdgeRing
	 * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring
	 */
	EdgeRing.prototype.toPolygon = function toPolygon () {
	    if (this.polygon)
	        { return this.polygon; }
	    var coordinates = this.edges.map(function (edge) { return edge.from.coordinates; });
	    coordinates.push(this.edges[0].from.coordinates);
	    return (this.polygon = polygon$8([coordinates]));
	};

	/**
	 * Calculates the envelope of the EdgeRing.
	 *
	 * @memberof EdgeRing
	 * @returns {Feature<Polygon>} - envelope
	 */
	EdgeRing.prototype.getEnvelope = function getEnvelope () {
	    if (this.envelope)
	        { return this.envelope; }
	    return (this.envelope = envelope(this.toPolygon()));
	};

	/**
	 * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`
	 *
	 * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list
	 * @param {EdgeRing[]} shellList - List of EdgeRing in which to search
	 *
	 * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing
	 */
	EdgeRing.findEdgeRingContaining = function findEdgeRingContaining (testEdgeRing, shellList) {
	    var testEnvelope = testEdgeRing.getEnvelope();

	    var minEnvelope,
	        minShell;
	    shellList.forEach(function (shell) {
	        var tryEnvelope = shell.getEnvelope();

	        if (minShell)
	            { minEnvelope = minShell.getEnvelope(); }

	        // the hole envelope cannot equal the shell envelope
	        if (envelopeIsEqual(tryEnvelope, testEnvelope))
	            { return; }

	        if (envelopeContains(tryEnvelope, testEnvelope)) {
	            var testPoint = testEdgeRing.map(function (edge) { return edge.from.coordinates; })
	                .find(function (pt) { return !shell.some(function (edge) { return coordinatesEqual(pt, edge.from.coordinates); }); });

	            if (testPoint && shell.inside(point$7(testPoint))) {
	                if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
	                    { minShell = shell; }
	            }
	        }
	    });

	    return minShell;
	};

	/**
	 * Checks if the point is inside the edgeRing
	 *
	 * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing
	 * @returns {boolean} - True if it is inside, False otherwise
	 */
	EdgeRing.prototype.inside = function inside (pt) {
	    return booleanPointInPolygon(pt, this.toPolygon());
	};

	Object.defineProperties( EdgeRing.prototype, prototypeAccessors$1 );

	var keys = createCommonjsModule(function (module, exports) {
	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	});

	keys.shim;

	var is_arguments = createCommonjsModule(function (module, exports) {
	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	}
	});

	is_arguments.supported;
	is_arguments.unsupported;

	createCommonjsModule(function (module) {
	var pSlice = Array.prototype.slice;



	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (is_arguments(a)) {
	    if (!is_arguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = keys(a),
	        kb = keys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}
	});

	var DBSCAN_1 = createCommonjsModule(function (module) {
	/**
	 * DBSCAN - Density based clustering
	 *
	 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
	 * @copyright MIT
	 */

	/**
	 * DBSCAN class construcotr
	 * @constructor
	 *
	 * @param {Array} dataset
	 * @param {number} epsilon
	 * @param {number} minPts
	 * @param {function} distanceFunction
	 * @returns {DBSCAN}
	 */
	function DBSCAN(dataset, epsilon, minPts, distanceFunction) {
	  /** @type {Array} */
	  this.dataset = [];
	  /** @type {number} */
	  this.epsilon = 1;
	  /** @type {number} */
	  this.minPts = 2;
	  /** @type {function} */
	  this.distance = this._euclideanDistance;
	  /** @type {Array} */
	  this.clusters = [];
	  /** @type {Array} */
	  this.noise = [];

	  // temporary variables used during computation

	  /** @type {Array} */
	  this._visited = [];
	  /** @type {Array} */
	  this._assigned = [];
	  /** @type {number} */
	  this._datasetLength = 0;

	  this._init(dataset, epsilon, minPts, distanceFunction);
	}

	/******************************************************************************/
	// public functions

	/**
	 * Start clustering
	 *
	 * @param {Array} dataset
	 * @param {number} epsilon
	 * @param {number} minPts
	 * @param {function} distanceFunction
	 * @returns {undefined}
	 * @access public
	 */
	DBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
	  this._init(dataset, epsilon, minPts, distanceFunction);

	  for (var pointId = 0; pointId < this._datasetLength; pointId++) {
	    // if point is not visited, check if it forms a cluster
	    if (this._visited[pointId] !== 1) {
	      this._visited[pointId] = 1;

	      // if closest neighborhood is too small to form a cluster, mark as noise
	      var neighbors = this._regionQuery(pointId);

	      if (neighbors.length < this.minPts) {
	        this.noise.push(pointId);
	      } else {
	        // create new cluster and add point
	        var clusterId = this.clusters.length;
	        this.clusters.push([]);
	        this._addToCluster(pointId, clusterId);

	        this._expandCluster(clusterId, neighbors);
	      }
	    }
	  }

	  return this.clusters;
	};

	/******************************************************************************/
	// protected functions

	/**
	 * Set object properties
	 *
	 * @param {Array} dataset
	 * @param {number} epsilon
	 * @param {number} minPts
	 * @param {function} distance
	 * @returns {undefined}
	 * @access protected
	 */
	DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {

	  if (dataset) {

	    if (!(dataset instanceof Array)) {
	      throw Error('Dataset must be of type array, ' +
	        typeof dataset + ' given');
	    }

	    this.dataset = dataset;
	    this.clusters = [];
	    this.noise = [];

	    this._datasetLength = dataset.length;
	    this._visited = new Array(this._datasetLength);
	    this._assigned = new Array(this._datasetLength);
	  }

	  if (epsilon) {
	    this.epsilon = epsilon;
	  }

	  if (minPts) {
	    this.minPts = minPts;
	  }

	  if (distance) {
	    this.distance = distance;
	  }
	};

	/**
	 * Expand cluster to closest points of given neighborhood
	 *
	 * @param {number} clusterId
	 * @param {Array} neighbors
	 * @returns {undefined}
	 * @access protected
	 */
	DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {

	  /**
	   * It's very important to calculate length of neighbors array each time,
	   * as the number of elements changes over time
	   */
	  for (var i = 0; i < neighbors.length; i++) {
	    var pointId2 = neighbors[i];

	    if (this._visited[pointId2] !== 1) {
	      this._visited[pointId2] = 1;
	      var neighbors2 = this._regionQuery(pointId2);

	      if (neighbors2.length >= this.minPts) {
	        neighbors = this._mergeArrays(neighbors, neighbors2);
	      }
	    }

	    // add to cluster
	    if (this._assigned[pointId2] !== 1) {
	      this._addToCluster(pointId2, clusterId);
	    }
	  }
	};

	/**
	 * Add new point to cluster
	 *
	 * @param {number} pointId
	 * @param {number} clusterId
	 */
	DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
	  this.clusters[clusterId].push(pointId);
	  this._assigned[pointId] = 1;
	};

	/**
	 * Find all neighbors around given point
	 *
	 * @param {number} pointId,
	 * @param {number} epsilon
	 * @returns {Array}
	 * @access protected
	 */
	DBSCAN.prototype._regionQuery = function(pointId) {
	  var neighbors = [];

	  for (var id = 0; id < this._datasetLength; id++) {
	    var dist = this.distance(this.dataset[pointId], this.dataset[id]);
	    if (dist < this.epsilon) {
	      neighbors.push(id);
	    }
	  }

	  return neighbors;
	};

	/******************************************************************************/
	// helpers

	/**
	 * @param {Array} a
	 * @param {Array} b
	 * @returns {Array}
	 * @access protected
	 */
	DBSCAN.prototype._mergeArrays = function(a, b) {
	  var len = b.length;

	  for (var i = 0; i < len; i++) {
	    var P = b[i];
	    if (a.indexOf(P) < 0) {
	      a.push(P);
	    }
	  }

	  return a;
	};

	/**
	 * Calculate euclidean distance in multidimensional space
	 *
	 * @param {Array} p
	 * @param {Array} q
	 * @returns {number}
	 * @access protected
	 */
	DBSCAN.prototype._euclideanDistance = function(p, q) {
	  var sum = 0;
	  var i = Math.min(p.length, q.length);

	  while (i--) {
	    sum += (p[i] - q[i]) * (p[i] - q[i]);
	  }

	  return Math.sqrt(sum);
	};

	if (module.exports) {
	  module.exports = DBSCAN;
	}
	});

	var KMEANS_1 = createCommonjsModule(function (module) {
	/**
	 * KMEANS clustering
	 *
	 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
	 * @copyright MIT
	 */

	/**
	 * KMEANS class constructor
	 * @constructor
	 *
	 * @param {Array} dataset
	 * @param {number} k - number of clusters
	 * @param {function} distance - distance function
	 * @returns {KMEANS}
	 */
	 function KMEANS(dataset, k, distance) {
	  this.k = 3; // number of clusters
	  this.dataset = []; // set of feature vectors
	  this.assignments = []; // set of associated clusters for each feature vector
	  this.centroids = []; // vectors for our clusters

	  this.init(dataset, k, distance);
	}

	/**
	 * @returns {undefined}
	 */
	KMEANS.prototype.init = function(dataset, k, distance) {
	  this.assignments = [];
	  this.centroids = [];

	  if (typeof dataset !== 'undefined') {
	    this.dataset = dataset;
	  }

	  if (typeof k !== 'undefined') {
	    this.k = k;
	  }

	  if (typeof distance !== 'undefined') {
	    this.distance = distance;
	  }
	};

	/**
	 * @returns {undefined}
	 */
	KMEANS.prototype.run = function(dataset, k) {
	  this.init(dataset, k);

	  var len = this.dataset.length;

	  // initialize centroids
	  for (var i = 0; i < this.k; i++) {
	    this.centroids[i] = this.randomCentroid();
		}

	  var change = true;
	  while(change) {

	    // assign feature vectors to clusters
	    change = this.assign();

	    // adjust location of centroids
	    for (var centroidId = 0; centroidId < this.k; centroidId++) {
	      var mean = new Array(maxDim);
	      var count = 0;

	      // init mean vector
	      for (var dim = 0; dim < maxDim; dim++) {
	        mean[dim] = 0;
	      }

	      for (var j = 0; j < len; j++) {
	        var maxDim = this.dataset[j].length;

	        // if current cluster id is assigned to point
	        if (centroidId === this.assignments[j]) {
	          for (var dim = 0; dim < maxDim; dim++) {
	            mean[dim] += this.dataset[j][dim];
	          }
	          count++;
	        }
	      }

	      if (count > 0) {
	        // if cluster contain points, adjust centroid position
	        for (var dim = 0; dim < maxDim; dim++) {
	          mean[dim] /= count;
	        }
	        this.centroids[centroidId] = mean;
	      } else {
	        // if cluster is empty, generate new random centroid
	        this.centroids[centroidId] = this.randomCentroid();
	        change = true;
	      }
	    }
	  }

	  return this.getClusters();
	};

	/**
	 * Generate random centroid
	 *
	 * @returns {Array}
	 */
	KMEANS.prototype.randomCentroid = function() {
	  var maxId = this.dataset.length -1;
	  var centroid;
	  var id;

	  do {
	    id = Math.round(Math.random() * maxId);
	    centroid = this.dataset[id];
	  } while (this.centroids.indexOf(centroid) >= 0);

	  return centroid;
	};

	/**
	 * Assign points to clusters
	 *
	 * @returns {boolean}
	 */
	KMEANS.prototype.assign = function() {
	  var change = false;
	  var len = this.dataset.length;
	  var closestCentroid;

	  for (var i = 0; i < len; i++) {
	    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);

	    if (closestCentroid != this.assignments[i]) {
	      this.assignments[i] = closestCentroid;
	      change = true;
	    }
	  }

	  return change;
	};

	/**
	 * Extract information about clusters
	 *
	 * @returns {undefined}
	 */
	KMEANS.prototype.getClusters = function() {
	  var clusters = new Array(this.k);
	  var centroidId;

	  for (var pointId = 0; pointId < this.assignments.length; pointId++) {
	    centroidId = this.assignments[pointId];

	    // init empty cluster
	    if (typeof clusters[centroidId] === 'undefined') {
	      clusters[centroidId] = [];
	    }

	    clusters[centroidId].push(pointId);
	  }

	  return clusters;
	};

	// utils

	/**
	 * @params {Array} point
	 * @params {Array.<Array>} set
	 * @params {Function} f
	 * @returns {number}
	 */
	KMEANS.prototype.argmin = function(point, set, f) {
	  var min = Number.MAX_VALUE;
	  var arg = 0;
	  var len = set.length;
	  var d;

	  for (var i = 0; i < len; i++) {
	    d = f(point, set[i]);
	    if (d < min) {
	      min = d;
	      arg = i;
	    }
	  }

	  return arg;
	};

	/**
	 * Euclidean distance
	 *
	 * @params {number} p
	 * @params {number} q
	 * @returns {number}
	 */
	KMEANS.prototype.distance = function(p, q) {
	  var sum = 0;
	  var i = Math.min(p.length, q.length);

	  while (i--) {
	    var diff = p[i] - q[i];
	    sum += diff * diff;
	  }

	  return Math.sqrt(sum);
	};

	if (module.exports) {
	  module.exports = KMEANS;
	}
	});

	var PriorityQueue_1 = createCommonjsModule(function (module) {
	/**
	 * PriorityQueue
	 * Elements in this queue are sorted according to their value
	 *
	 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
	 * @copyright MIT
	 */

	/**
	 * PriorityQueue class construcotr
	 * @constructor
	 *
	 * @example
	 * queue: [1,2,3,4]
	 * priorities: [4,1,2,3]
	 * > result = [1,4,2,3]
	 *
	 * @param {Array} elements
	 * @param {Array} priorities
	 * @param {string} sorting - asc / desc
	 * @returns {PriorityQueue}
	 */
	function PriorityQueue(elements, priorities, sorting) {
	  /** @type {Array} */
	  this._queue = [];
	  /** @type {Array} */
	  this._priorities = [];
	  /** @type {string} */
	  this._sorting = 'desc';

	  this._init(elements, priorities, sorting);
	}

	/**
	 * Insert element
	 *
	 * @param {Object} ele
	 * @param {Object} priority
	 * @returns {undefined}
	 * @access public
	 */
	PriorityQueue.prototype.insert = function(ele, priority) {
	  var indexToInsert = this._queue.length;
	  var index = indexToInsert;

	  while (index--) {
	    var priority2 = this._priorities[index];
	    if (this._sorting === 'desc') {
	      if (priority > priority2) {
	        indexToInsert = index;
	      }
	    } else {
	      if (priority < priority2) {
	        indexToInsert = index;
	      }
	    }
	  }

	  this._insertAt(ele, priority, indexToInsert);
	};

	/**
	 * Remove element
	 *
	 * @param {Object} ele
	 * @returns {undefined}
	 * @access public
	 */
	PriorityQueue.prototype.remove = function(ele) {
	  var index = this._queue.length;

	  while (index--) {
	    var ele2 = this._queue[index];
	    if (ele === ele2) {
	      this._queue.splice(index, 1);
	      this._priorities.splice(index, 1);
	      break;
	    }
	  }
	};

	/**
	 * For each loop wrapper
	 *
	 * @param {function} func
	 * @returs {undefined}
	 * @access public
	 */
	PriorityQueue.prototype.forEach = function(func) {
	  this._queue.forEach(func);
	};

	/**
	 * @returns {Array}
	 * @access public
	 */
	PriorityQueue.prototype.getElements = function() {
	  return this._queue;
	};

	/**
	 * @param {number} index
	 * @returns {Object}
	 * @access public
	 */
	PriorityQueue.prototype.getElementPriority = function(index) {
	  return this._priorities[index];
	};

	/**
	 * @returns {Array}
	 * @access public
	 */
	PriorityQueue.prototype.getPriorities = function() {
	  return this._priorities;
	};

	/**
	 * @returns {Array}
	 * @access public
	 */
	PriorityQueue.prototype.getElementsWithPriorities = function() {
	  var result = [];

	  for (var i = 0, l = this._queue.length; i < l; i++) {
	    result.push([this._queue[i], this._priorities[i]]);
	  }

	  return result;
	};

	/**
	 * Set object properties
	 *
	 * @param {Array} elements
	 * @param {Array} priorities
	 * @returns {undefined}
	 * @access protected
	 */
	PriorityQueue.prototype._init = function(elements, priorities, sorting) {

	  if (elements && priorities) {
	    this._queue = [];
	    this._priorities = [];

	    if (elements.length !== priorities.length) {
	      throw new Error('Arrays must have the same length');
	    }

	    for (var i = 0; i < elements.length; i++) {
	      this.insert(elements[i], priorities[i]);
	    }
	  }

	  if (sorting) {
	    this._sorting = sorting;
	  }
	};

	/**
	 * Insert element at given position
	 *
	 * @param {Object} ele
	 * @param {number} index
	 * @returns {undefined}
	 * @access protected
	 */
	PriorityQueue.prototype._insertAt = function(ele, priority, index) {
	  if (this._queue.length === index) {
	    this._queue.push(ele);
	    this._priorities.push(priority);
	  } else {
	    this._queue.splice(index, 0, ele);
	    this._priorities.splice(index, 0, priority);
	  }
	};

	if (module.exports) {
	  module.exports = PriorityQueue;
	}
	});

	var OPTICS_1 = createCommonjsModule(function (module) {
	/**
	 * @requires ./PriorityQueue.js
	 */

	if (module.exports) {
	      var PriorityQueue = PriorityQueue_1;
	}

	/**
	 * OPTICS - Ordering points to identify the clustering structure
	 *
	 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
	 * @copyright MIT
	 */

	/**
	 * OPTICS class constructor
	 * @constructor
	 *
	 * @param {Array} dataset
	 * @param {number} epsilon
	 * @param {number} minPts
	 * @param {function} distanceFunction
	 * @returns {OPTICS}
	 */
	function OPTICS(dataset, epsilon, minPts, distanceFunction) {
	  /** @type {number} */
	  this.epsilon = 1;
	  /** @type {number} */
	  this.minPts = 1;
	  /** @type {function} */
	  this.distance = this._euclideanDistance;

	  // temporary variables used during computation

	  /** @type {Array} */
	  this._reachability = [];
	  /** @type {Array} */
	  this._processed = [];
	  /** @type {number} */
	  this._coreDistance = 0;
	  /** @type {Array} */
	  this._orderedList = [];

	  this._init(dataset, epsilon, minPts, distanceFunction);
	}

	/******************************************************************************/
	// pulic functions

	/**
	 * Start clustering
	 *
	 * @param {Array} dataset
	 * @returns {undefined}
	 * @access public
	 */
	OPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
	  this._init(dataset, epsilon, minPts, distanceFunction);

	  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
	    if (this._processed[pointId] !== 1) {
	      this._processed[pointId] = 1;
	      this.clusters.push([pointId]);
	      var clusterId = this.clusters.length - 1;

	      this._orderedList.push(pointId);
	      var priorityQueue = new PriorityQueue(null, null, 'asc');
	      var neighbors = this._regionQuery(pointId);

	      // using priority queue assign elements to new cluster
	      if (this._distanceToCore(pointId) !== undefined) {
	        this._updateQueue(pointId, neighbors, priorityQueue);
	        this._expandCluster(clusterId, priorityQueue);
	      }
	    }
	  }

	  return this.clusters;
	};

	/**
	 * Generate reachability plot for all points
	 *
	 * @returns {array}
	 * @access public
	 */
	OPTICS.prototype.getReachabilityPlot = function() {
	  var reachabilityPlot = [];

	  for (var i = 0, l = this._orderedList.length; i < l; i++) {
	    var pointId = this._orderedList[i];
	    var distance = this._reachability[pointId];

	    reachabilityPlot.push([pointId, distance]);
	  }

	  return reachabilityPlot;
	};

	/******************************************************************************/
	// protected functions

	/**
	 * Set object properties
	 *
	 * @param {Array} dataset
	 * @param {number} epsilon
	 * @param {number} minPts
	 * @param {function} distance
	 * @returns {undefined}
	 * @access protected
	 */
	OPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {

	  if (dataset) {

	    if (!(dataset instanceof Array)) {
	      throw Error('Dataset must be of type array, ' +
	        typeof dataset + ' given');
	    }

	    this.dataset = dataset;
	    this.clusters = [];
	    this._reachability = new Array(this.dataset.length);
	    this._processed = new Array(this.dataset.length);
	    this._coreDistance = 0;
	    this._orderedList = [];
	  }

	  if (epsilon) {
	    this.epsilon = epsilon;
	  }

	  if (minPts) {
	    this.minPts = minPts;
	  }

	  if (distance) {
	    this.distance = distance;
	  }
	};

	/**
	 * Update information in queue
	 *
	 * @param {number} pointId
	 * @param {Array} neighbors
	 * @param {PriorityQueue} queue
	 * @returns {undefined}
	 * @access protected
	 */
	OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
	  var self = this;

	  this._coreDistance = this._distanceToCore(pointId);
	  neighbors.forEach(function(pointId2) {
	    if (self._processed[pointId2] === undefined) {
	      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);
	      var newReachableDistance = Math.max(self._coreDistance, dist);

	      if (self._reachability[pointId2] === undefined) {
	        self._reachability[pointId2] = newReachableDistance;
	        queue.insert(pointId2, newReachableDistance);
	      } else {
	        if (newReachableDistance < self._reachability[pointId2]) {
	          self._reachability[pointId2] = newReachableDistance;
	          queue.remove(pointId2);
	          queue.insert(pointId2, newReachableDistance);
	        }
	      }
	    }
	  });
	};

	/**
	 * Expand cluster
	 *
	 * @param {number} clusterId
	 * @param {PriorityQueue} queue
	 * @returns {undefined}
	 * @access protected
	 */
	OPTICS.prototype._expandCluster = function(clusterId, queue) {
	  var queueElements = queue.getElements();

	  for (var p = 0, l = queueElements.length; p < l; p++) {
	    var pointId = queueElements[p];
	    if (this._processed[pointId] === undefined) {
	      var neighbors = this._regionQuery(pointId);
	      this._processed[pointId] = 1;

	      this.clusters[clusterId].push(pointId);
	      this._orderedList.push(pointId);

	      if (this._distanceToCore(pointId) !== undefined) {
	        this._updateQueue(pointId, neighbors, queue);
	        this._expandCluster(clusterId, queue);
	      }
	    }
	  }
	};

	/**
	 * Calculating distance to cluster core
	 *
	 * @param {number} pointId
	 * @returns {number}
	 * @access protected
	 */
	OPTICS.prototype._distanceToCore = function(pointId) {
	  var l = this.epsilon;
	  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
	    var neighbors = this._regionQuery(pointId, coreDistCand);
	    if (neighbors.length >= this.minPts) {
	      return coreDistCand;
	    }
	  }

	  return;
	};

	/**
	 * Find all neighbors around given point
	 *
	 * @param {number} pointId
	 * @param {number} epsilon
	 * @returns {Array}
	 * @access protected
	 */
	OPTICS.prototype._regionQuery = function(pointId, epsilon) {
	  epsilon = epsilon || this.epsilon;
	  var neighbors = [];

	  for (var id = 0, l = this.dataset.length; id < l; id++) {
	    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {
	      neighbors.push(id);
	    }
	  }

	  return neighbors;
	};

	/******************************************************************************/
	// helpers

	/**
	 * Calculate euclidean distance in multidimensional space
	 *
	 * @param {Array} p
	 * @param {Array} q
	 * @returns {number}
	 * @access protected
	 */
	OPTICS.prototype._euclideanDistance = function(p, q) {
	  var sum = 0;
	  var i = Math.min(p.length, q.length);

	  while (i--) {
	    sum += (p[i] - q[i]) * (p[i] - q[i]);
	  }

	  return Math.sqrt(sum);
	};

	if (module.exports) {
	  module.exports = OPTICS;
	}
	});

	var lib$3 = createCommonjsModule(function (module) {
	if (module.exports) {
	    module.exports = {
	      DBSCAN: DBSCAN_1,
	      KMEANS: KMEANS_1,
	      OPTICS: OPTICS_1,
	      PriorityQueue: PriorityQueue_1
	    };
	}
	});

	lib$3.DBSCAN;
	lib$3.KMEANS;
	lib$3.OPTICS;
	lib$3.PriorityQueue;

	function RedBlackTree() {
	  this._ = null; // root node
	}

	function RedBlackNode(node) {
	  node.U = // parent node
	  node.C = // color - true for red, false for black
	  node.L = // left node
	  node.R = // right node
	  node.P = // previous node
	  node.N = null; // next node
	}

	RedBlackTree.prototype = {
	  constructor: RedBlackTree,

	  insert: function(after, node) {
	    var parent, grandpa, uncle;

	    if (after) {
	      node.P = after;
	      node.N = after.N;
	      if (after.N) after.N.P = node;
	      after.N = node;
	      if (after.R) {
	        after = after.R;
	        while (after.L) after = after.L;
	        after.L = node;
	      } else {
	        after.R = node;
	      }
	      parent = after;
	    } else if (this._) {
	      after = RedBlackFirst(this._);
	      node.P = null;
	      node.N = after;
	      after.P = after.L = node;
	      parent = after;
	    } else {
	      node.P = node.N = null;
	      this._ = node;
	      parent = null;
	    }
	    node.L = node.R = null;
	    node.U = parent;
	    node.C = true;

	    after = node;
	    while (parent && parent.C) {
	      grandpa = parent.U;
	      if (parent === grandpa.L) {
	        uncle = grandpa.R;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.R) {
	            RedBlackRotateLeft(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateRight(this, grandpa);
	        }
	      } else {
	        uncle = grandpa.L;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.L) {
	            RedBlackRotateRight(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateLeft(this, grandpa);
	        }
	      }
	      parent = after.U;
	    }
	    this._.C = false;
	  },

	  remove: function(node) {
	    if (node.N) node.N.P = node.P;
	    if (node.P) node.P.N = node.N;
	    node.N = node.P = null;

	    var parent = node.U,
	        sibling,
	        left = node.L,
	        right = node.R,
	        next,
	        red;

	    if (!left) next = right;
	    else if (!right) next = left;
	    else next = RedBlackFirst(right);

	    if (parent) {
	      if (parent.L === node) parent.L = next;
	      else parent.R = next;
	    } else {
	      this._ = next;
	    }

	    if (left && right) {
	      red = next.C;
	      next.C = node.C;
	      next.L = left;
	      left.U = next;
	      if (next !== right) {
	        parent = next.U;
	        next.U = node.U;
	        node = next.R;
	        parent.L = node;
	        next.R = right;
	        right.U = next;
	      } else {
	        next.U = parent;
	        parent = next;
	        node = next.R;
	      }
	    } else {
	      red = node.C;
	      node = next;
	    }

	    if (node) node.U = parent;
	    if (red) return;
	    if (node && node.C) { node.C = false; return; }

	    do {
	      if (node === this._) break;
	      if (node === parent.L) {
	        sibling = parent.R;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateLeft(this, parent);
	          sibling = parent.R;
	        }
	        if ((sibling.L && sibling.L.C)
	            || (sibling.R && sibling.R.C)) {
	          if (!sibling.R || !sibling.R.C) {
	            sibling.L.C = false;
	            sibling.C = true;
	            RedBlackRotateRight(this, sibling);
	            sibling = parent.R;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.R.C = false;
	          RedBlackRotateLeft(this, parent);
	          node = this._;
	          break;
	        }
	      } else {
	        sibling = parent.L;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateRight(this, parent);
	          sibling = parent.L;
	        }
	        if ((sibling.L && sibling.L.C)
	          || (sibling.R && sibling.R.C)) {
	          if (!sibling.L || !sibling.L.C) {
	            sibling.R.C = false;
	            sibling.C = true;
	            RedBlackRotateLeft(this, sibling);
	            sibling = parent.L;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.L.C = false;
	          RedBlackRotateRight(this, parent);
	          node = this._;
	          break;
	        }
	      }
	      sibling.C = true;
	      node = parent;
	      parent = parent.U;
	    } while (!node.C);

	    if (node) node.C = false;
	  }
	};

	function RedBlackRotateLeft(tree, node) {
	  var p = node,
	      q = node.R,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.R = q.L;
	  if (p.R) p.R.U = p;
	  q.L = p;
	}

	function RedBlackRotateRight(tree, node) {
	  var p = node,
	      q = node.L,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.L = q.R;
	  if (p.L) p.L.U = p;
	  q.R = p;
	}

	function RedBlackFirst(node) {
	  while (node.L) node = node.L;
	  return node;
	}

	function createEdge(left, right, v0, v1) {
	  var edge = [null, null],
	      index = edges.push(edge) - 1;
	  edge.left = left;
	  edge.right = right;
	  if (v0) setEdgeEnd(edge, left, right, v0);
	  if (v1) setEdgeEnd(edge, right, left, v1);
	  cells$1[left.index].halfedges.push(index);
	  cells$1[right.index].halfedges.push(index);
	  return edge;
	}

	function createBorderEdge(left, v0, v1) {
	  var edge = [v0, v1];
	  edge.left = left;
	  return edge;
	}

	function setEdgeEnd(edge, left, right, vertex) {
	  if (!edge[0] && !edge[1]) {
	    edge[0] = vertex;
	    edge.left = left;
	    edge.right = right;
	  } else if (edge.left === right) {
	    edge[1] = vertex;
	  } else {
	    edge[0] = vertex;
	  }
	}

	// LiangBarsky line clipping.
	function clipEdge(edge, x0, y0, x1, y1) {
	  var a = edge[0],
	      b = edge[1],
	      ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

	  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
	  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
	  return true;
	}

	function connectEdge(edge, x0, y0, x1, y1) {
	  var v1 = edge[1];
	  if (v1) return true;

	  var v0 = edge[0],
	      left = edge.left,
	      right = edge.right,
	      lx = left[0],
	      ly = left[1],
	      rx = right[0],
	      ry = right[1],
	      fx = (lx + rx) / 2,
	      fy = (ly + ry) / 2,
	      fm,
	      fb;

	  if (ry === ly) {
	    if (fx < x0 || fx >= x1) return;
	    if (lx > rx) {
	      if (!v0) v0 = [fx, y0];
	      else if (v0[1] >= y1) return;
	      v1 = [fx, y1];
	    } else {
	      if (!v0) v0 = [fx, y1];
	      else if (v0[1] < y0) return;
	      v1 = [fx, y0];
	    }
	  } else {
	    fm = (lx - rx) / (ry - ly);
	    fb = fy - fm * fx;
	    if (fm < -1 || fm > 1) {
	      if (lx > rx) {
	        if (!v0) v0 = [(y0 - fb) / fm, y0];
	        else if (v0[1] >= y1) return;
	        v1 = [(y1 - fb) / fm, y1];
	      } else {
	        if (!v0) v0 = [(y1 - fb) / fm, y1];
	        else if (v0[1] < y0) return;
	        v1 = [(y0 - fb) / fm, y0];
	      }
	    } else {
	      if (ly < ry) {
	        if (!v0) v0 = [x0, fm * x0 + fb];
	        else if (v0[0] >= x1) return;
	        v1 = [x1, fm * x1 + fb];
	      } else {
	        if (!v0) v0 = [x1, fm * x1 + fb];
	        else if (v0[0] < x0) return;
	        v1 = [x0, fm * x0 + fb];
	      }
	    }
	  }

	  edge[0] = v0;
	  edge[1] = v1;
	  return true;
	}

	function clipEdges(x0, y0, x1, y1) {
	  var i = edges.length,
	      edge;

	  while (i--) {
	    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
	        || !clipEdge(edge, x0, y0, x1, y1)
	        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
	            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
	      delete edges[i];
	    }
	  }
	}

	function createCell(site) {
	  return cells$1[site.index] = {
	    site: site,
	    halfedges: []
	  };
	}

	function cellHalfedgeAngle(cell, edge) {
	  var site = cell.site,
	      va = edge.left,
	      vb = edge.right;
	  if (site === vb) vb = va, va = site;
	  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
	  if (site === va) va = edge[1], vb = edge[0];
	  else va = edge[0], vb = edge[1];
	  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
	}

	function cellHalfedgeStart(cell, edge) {
	  return edge[+(edge.left !== cell.site)];
	}

	function cellHalfedgeEnd(cell, edge) {
	  return edge[+(edge.left === cell.site)];
	}

	function sortCellHalfedges() {
	  for (var i = 0, n = cells$1.length, cell, halfedges, j, m; i < n; ++i) {
	    if ((cell = cells$1[i]) && (m = (halfedges = cell.halfedges).length)) {
	      var index = new Array(m),
	          array = new Array(m);
	      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
	      index.sort(function(i, j) { return array[j] - array[i]; });
	      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
	      for (j = 0; j < m; ++j) halfedges[j] = array[j];
	    }
	  }
	}

	function clipCells(x0, y0, x1, y1) {
	  var nCells = cells$1.length,
	      iCell,
	      cell,
	      site,
	      iHalfedge,
	      halfedges,
	      nHalfedges,
	      start,
	      startX,
	      startY,
	      end,
	      endX,
	      endY,
	      cover = true;

	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells$1[iCell]) {
	      site = cell.site;
	      halfedges = cell.halfedges;
	      iHalfedge = halfedges.length;

	      // Remove any dangling clipped edges.
	      while (iHalfedge--) {
	        if (!edges[halfedges[iHalfedge]]) {
	          halfedges.splice(iHalfedge, 1);
	        }
	      }

	      // Insert any border edges as necessary.
	      iHalfedge = 0, nHalfedges = halfedges.length;
	      while (iHalfedge < nHalfedges) {
	        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
	        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
	        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
	          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
	              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
	              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
	              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
	              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
	              : null)) - 1);
	          ++nHalfedges;
	        }
	      }

	      if (nHalfedges) cover = false;
	    }
	  }

	  // If there werent any edges, have the closest site cover the extent.
	  // It doesnt matter which corner of the extent we measure!
	  if (cover) {
	    var dx, dy, d2, dc = Infinity;

	    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
	      if (cell = cells$1[iCell]) {
	        site = cell.site;
	        dx = site[0] - x0;
	        dy = site[1] - y0;
	        d2 = dx * dx + dy * dy;
	        if (d2 < dc) dc = d2, cover = cell;
	      }
	    }

	    if (cover) {
	      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
	      cover.halfedges.push(
	        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
	        edges.push(createBorderEdge(site, v01, v11)) - 1,
	        edges.push(createBorderEdge(site, v11, v10)) - 1,
	        edges.push(createBorderEdge(site, v10, v00)) - 1
	      );
	    }
	  }

	  // Lastly delete any cells with no edges; these were entirely clipped.
	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells$1[iCell]) {
	      if (!cell.halfedges.length) {
	        delete cells$1[iCell];
	      }
	    }
	  }
	}

	var circlePool = [];

	var firstCircle;

	function Circle() {
	  RedBlackNode(this);
	  this.x =
	  this.y =
	  this.arc =
	  this.site =
	  this.cy = null;
	}

	function attachCircle(arc) {
	  var lArc = arc.P,
	      rArc = arc.N;

	  if (!lArc || !rArc) return;

	  var lSite = lArc.site,
	      cSite = arc.site,
	      rSite = rArc.site;

	  if (lSite === rSite) return;

	  var bx = cSite[0],
	      by = cSite[1],
	      ax = lSite[0] - bx,
	      ay = lSite[1] - by,
	      cx = rSite[0] - bx,
	      cy = rSite[1] - by;

	  var d = 2 * (ax * cy - ay * cx);
	  if (d >= -epsilon2) return;

	  var ha = ax * ax + ay * ay,
	      hc = cx * cx + cy * cy,
	      x = (cy * ha - ay * hc) / d,
	      y = (ax * hc - cx * ha) / d;

	  var circle = circlePool.pop() || new Circle;
	  circle.arc = arc;
	  circle.site = cSite;
	  circle.x = x + bx;
	  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

	  arc.circle = circle;

	  var before = null,
	      node = circles._;

	  while (node) {
	    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
	      if (node.L) node = node.L;
	      else { before = node.P; break; }
	    } else {
	      if (node.R) node = node.R;
	      else { before = node; break; }
	    }
	  }

	  circles.insert(before, circle);
	  if (!before) firstCircle = circle;
	}

	function detachCircle(arc) {
	  var circle = arc.circle;
	  if (circle) {
	    if (!circle.P) firstCircle = circle.N;
	    circles.remove(circle);
	    circlePool.push(circle);
	    RedBlackNode(circle);
	    arc.circle = null;
	  }
	}

	var beachPool = [];

	function Beach() {
	  RedBlackNode(this);
	  this.edge =
	  this.site =
	  this.circle = null;
	}

	function createBeach(site) {
	  var beach = beachPool.pop() || new Beach;
	  beach.site = site;
	  return beach;
	}

	function detachBeach(beach) {
	  detachCircle(beach);
	  beaches.remove(beach);
	  beachPool.push(beach);
	  RedBlackNode(beach);
	}

	function removeBeach(beach) {
	  var circle = beach.circle,
	      x = circle.x,
	      y = circle.cy,
	      vertex = [x, y],
	      previous = beach.P,
	      next = beach.N,
	      disappearing = [beach];

	  detachBeach(beach);

	  var lArc = previous;
	  while (lArc.circle
	      && Math.abs(x - lArc.circle.x) < epsilon
	      && Math.abs(y - lArc.circle.cy) < epsilon) {
	    previous = lArc.P;
	    disappearing.unshift(lArc);
	    detachBeach(lArc);
	    lArc = previous;
	  }

	  disappearing.unshift(lArc);
	  detachCircle(lArc);

	  var rArc = next;
	  while (rArc.circle
	      && Math.abs(x - rArc.circle.x) < epsilon
	      && Math.abs(y - rArc.circle.cy) < epsilon) {
	    next = rArc.N;
	    disappearing.push(rArc);
	    detachBeach(rArc);
	    rArc = next;
	  }

	  disappearing.push(rArc);
	  detachCircle(rArc);

	  var nArcs = disappearing.length,
	      iArc;
	  for (iArc = 1; iArc < nArcs; ++iArc) {
	    rArc = disappearing[iArc];
	    lArc = disappearing[iArc - 1];
	    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	  }

	  lArc = disappearing[0];
	  rArc = disappearing[nArcs - 1];
	  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function addBeach(site) {
	  var x = site[0],
	      directrix = site[1],
	      lArc,
	      rArc,
	      dxl,
	      dxr,
	      node = beaches._;

	  while (node) {
	    dxl = leftBreakPoint(node, directrix) - x;
	    if (dxl > epsilon) node = node.L; else {
	      dxr = x - rightBreakPoint(node, directrix);
	      if (dxr > epsilon) {
	        if (!node.R) {
	          lArc = node;
	          break;
	        }
	        node = node.R;
	      } else {
	        if (dxl > -epsilon) {
	          lArc = node.P;
	          rArc = node;
	        } else if (dxr > -epsilon) {
	          lArc = node;
	          rArc = node.N;
	        } else {
	          lArc = rArc = node;
	        }
	        break;
	      }
	    }
	  }

	  createCell(site);
	  var newArc = createBeach(site);
	  beaches.insert(lArc, newArc);

	  if (!lArc && !rArc) return;

	  if (lArc === rArc) {
	    detachCircle(lArc);
	    rArc = createBeach(lArc.site);
	    beaches.insert(newArc, rArc);
	    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
	    attachCircle(lArc);
	    attachCircle(rArc);
	    return;
	  }

	  if (!rArc) { // && lArc
	    newArc.edge = createEdge(lArc.site, newArc.site);
	    return;
	  }

	  // else lArc !== rArc
	  detachCircle(lArc);
	  detachCircle(rArc);

	  var lSite = lArc.site,
	      ax = lSite[0],
	      ay = lSite[1],
	      bx = site[0] - ax,
	      by = site[1] - ay,
	      rSite = rArc.site,
	      cx = rSite[0] - ax,
	      cy = rSite[1] - ay,
	      d = 2 * (bx * cy - by * cx),
	      hb = bx * bx + by * by,
	      hc = cx * cx + cy * cy,
	      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

	  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
	  newArc.edge = createEdge(lSite, site, null, vertex);
	  rArc.edge = createEdge(site, rSite, null, vertex);
	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function leftBreakPoint(arc, directrix) {
	  var site = arc.site,
	      rfocx = site[0],
	      rfocy = site[1],
	      pby2 = rfocy - directrix;

	  if (!pby2) return rfocx;

	  var lArc = arc.P;
	  if (!lArc) return -Infinity;

	  site = lArc.site;
	  var lfocx = site[0],
	      lfocy = site[1],
	      plby2 = lfocy - directrix;

	  if (!plby2) return lfocx;

	  var hl = lfocx - rfocx,
	      aby2 = 1 / pby2 - 1 / plby2,
	      b = hl / plby2;

	  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

	  return (rfocx + lfocx) / 2;
	}

	function rightBreakPoint(arc, directrix) {
	  var rArc = arc.N;
	  if (rArc) return leftBreakPoint(rArc, directrix);
	  var site = arc.site;
	  return site[1] === directrix ? site[0] : Infinity;
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var beaches;
	var cells$1;
	var circles;
	var edges;

	function triangleArea(a, b, c) {
	  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
	}

	function lexicographic(a, b) {
	  return b[1] - a[1]
	      || b[0] - a[0];
	}

	function Diagram(sites, extent) {
	  var site = sites.sort(lexicographic).pop(),
	      x,
	      y,
	      circle;

	  edges = [];
	  cells$1 = new Array(sites.length);
	  beaches = new RedBlackTree;
	  circles = new RedBlackTree;

	  while (true) {
	    circle = firstCircle;
	    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
	      if (site[0] !== x || site[1] !== y) {
	        addBeach(site);
	        x = site[0], y = site[1];
	      }
	      site = sites.pop();
	    } else if (circle) {
	      removeBeach(circle.arc);
	    } else {
	      break;
	    }
	  }

	  sortCellHalfedges();

	  if (extent) {
	    var x0 = +extent[0][0],
	        y0 = +extent[0][1],
	        x1 = +extent[1][0],
	        y1 = +extent[1][1];
	    clipEdges(x0, y0, x1, y1);
	    clipCells(x0, y0, x1, y1);
	  }

	  this.edges = edges;
	  this.cells = cells$1;

	  beaches =
	  circles =
	  edges =
	  cells$1 = null;
	}

	Diagram.prototype = {
	  constructor: Diagram,

	  polygons: function() {
	    var edges = this.edges;

	    return this.cells.map(function(cell) {
	      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
	      polygon.data = cell.site.data;
	      return polygon;
	    });
	  },

	  triangles: function() {
	    var triangles = [],
	        edges = this.edges;

	    this.cells.forEach(function(cell, i) {
	      if (!(m = (halfedges = cell.halfedges).length)) return;
	      var site = cell.site,
	          halfedges,
	          j = -1,
	          m,
	          s0,
	          e1 = edges[halfedges[m - 1]],
	          s1 = e1.left === site ? e1.right : e1.left;

	      while (++j < m) {
	        s0 = s1;
	        e1 = edges[halfedges[j]];
	        s1 = e1.left === site ? e1.right : e1.left;
	        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
	          triangles.push([site.data, s0.data, s1.data]);
	        }
	      }
	    });

	    return triangles;
	  },

	  links: function() {
	    return this.edges.filter(function(edge) {
	      return edge.right;
	    }).map(function(edge) {
	      return {
	        source: edge.left.data,
	        target: edge.right.data
	      };
	    });
	  },

	  find: function(x, y, radius) {
	    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

	    // Use the previously-found cell, or start with an arbitrary one.
	    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
	    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

	    // Traverse the half-edges to find a closer cell, if any.
	    do {
	      cell = that.cells[i0 = i1], i1 = null;
	      cell.halfedges.forEach(function(e) {
	        var edge = that.edges[e], v = edge.left;
	        if ((v === cell.site || !v) && !(v = edge.right)) return;
	        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
	        if (v2 < d2) d2 = v2, i1 = v.index;
	      });
	    } while (i1 !== null);

	    that._found = i0;

	    return radius == null || d2 <= radius * radius ? cell.site : null;
	  }
	};

	/**
	 * Returns a random position within a {@link bounding box}.
	 *
	 * @name randomPosition
	 * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.
	 * @returns {Array<number>} Position [longitude, latitude]
	 * @example
	 * var position = turf.randomPosition([-180, -90, 180, 90])
	 * //=position
	 */
	function randomPosition(bbox) {
	    if (isObject(bbox)) bbox = bbox.bbox;
	    if (bbox && !Array.isArray(bbox)) throw new Error('bbox is invalid');
	    if (bbox) return coordInBBox(bbox);
	    else return [lon(), lat()];
	}

	/**
	 * Returns a random {@link point}.
	 *
	 * @name randomPoint
	 * @param {number} [count=1] how many geometries will be generated
	 * @param {Object} [options={}] Optional parameters
	 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
	 * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points
	 * @example
	 * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})
	 * //=points
	 */
	function randomPoint(count, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    if (count === undefined || count === null) count = 1;

	    var features = [];
	    for (var i = 0; i < count; i++) {
	        features.push(point$7(randomPosition(bbox)));
	    }
	    return featureCollection(features);
	}

	/**
	 * Returns a random {@link polygon}.
	 *
	 * @name randomPolygon
	 * @param {number} [count=1] how many geometries will be generated
	 * @param {Object} [options={}] Optional parameters
	 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
	 * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.
	 * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a vertex can reach out of the center of the Polygon.
	 * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points
	 * @example
	 * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})
	 * //=polygons
	 */
	function randomPolygon(count, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var num_vertices = options.num_vertices;
	    var max_radial_length = options.max_radial_length;
	    if (count === undefined || count === null) count = 1;

	    // Validation
	    if (!isNumber(num_vertices)) num_vertices = 10;
	    if (!isNumber(max_radial_length)) max_radial_length = 10;

	    var features = [];
	    for (var i = 0; i < count; i++) {
	        var vertices = [],
	            circle_offsets = Array.apply(null,
	                new Array(num_vertices + 1)).map(Math.random);

	        circle_offsets.forEach(sumOffsets);
	        circle_offsets.forEach(scaleOffsets);
	        vertices[vertices.length - 1] = vertices[0]; // close the ring

	        // center the polygon around something
	        vertices = vertices.map(vertexToCoordinate(randomPosition(bbox)));
	        features.push(polygon$8([vertices]));
	    }

	    function sumOffsets(cur, index, arr) {
	        arr[index] = (index > 0) ? cur + arr[index - 1] : cur;
	    }

	    function scaleOffsets(cur) {
	        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];
	        var radial_scaler = Math.random();
	        vertices.push([
	            radial_scaler * max_radial_length * Math.sin(cur),
	            radial_scaler * max_radial_length * Math.cos(cur)
	        ]);
	    }

	    return featureCollection(features);
	}

	/**
	 * Returns a random {@link linestring}.
	 *
	 * @name randomLineString
	 * @param {number} [count=1] how many geometries will be generated
	 * @param {Object} [options={}] Optional parameters
	 * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
	 * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.
	 * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a vertex can be from its predecessor
	 * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a line segment can turn from the previous segment.
	 * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points
	 * @example
	 * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})
	 * //=lineStrings
	 */
	function randomLineString(count, options) {
	    // Optional parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var num_vertices = options.num_vertices;
	    var max_length = options.max_length;
	    var max_rotation = options.max_rotation;
	    if (count === undefined || count === null) count = 1;

	    // Default parameters
	    if (!isNumber(num_vertices) || num_vertices < 2) num_vertices = 10;
	    if (!isNumber(max_length)) max_length = 0.0001;
	    if (!isNumber(max_rotation)) max_rotation = Math.PI / 8;

	    var features = [];
	    for (var i = 0; i < count; i++) {
	        var startingPoint = randomPosition(bbox);
	        var vertices = [startingPoint];
	        for (var j = 0; j < num_vertices - 1; j++) {
	            var priorAngle = (j === 0) ?
	                Math.random() * 2 * Math.PI :
	                Math.tan(
	                    (vertices[j][1] - vertices[j - 1][1]) /
	              (vertices[j][0] - vertices[j - 1][0])
	                );
	            var angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
	            var distance = Math.random() * max_length;
	            vertices.push([
	                vertices[j][0] + distance * Math.cos(angle),
	                vertices[j][1] + distance * Math.sin(angle)
	            ]);
	        }
	        features.push(lineString(vertices));
	    }

	    return featureCollection(features);
	}

	function vertexToCoordinate(hub) {
	    return function (cur) { return [cur[0] + hub[0], cur[1] + hub[1]]; };
	}

	function rnd() { return Math.random() - 0.5; }
	function lon() { return rnd() * 360; }
	function lat() { return rnd() * 180; }

	function coordInBBox(bbox) {
	    return [
	        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],
	        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]];
	}




	Object.freeze({
		randomPosition: randomPosition,
		randomPoint: randomPoint,
		randomPolygon: randomPolygon,
		randomLineString: randomLineString
	});

	/**
	 * Get Cluster
	 *
	 * @name getCluster
	 * @param {FeatureCollection} geojson GeoJSON Features
	 * @param {*} filter Filter used on GeoJSON properties to get Cluster
	 * @returns {FeatureCollection} Single Cluster filtered by GeoJSON Properties
	 * @example
	 * var geojson = turf.featureCollection([
	 *     turf.point([0, 0], {'marker-symbol': 'circle'}),
	 *     turf.point([2, 4], {'marker-symbol': 'star'}),
	 *     turf.point([3, 6], {'marker-symbol': 'star'}),
	 *     turf.point([5, 1], {'marker-symbol': 'square'}),
	 *     turf.point([4, 2], {'marker-symbol': 'circle'})
	 * ]);
	 *
	 * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
	 * var clustered = turf.clustersKmeans(geojson);
	 *
	 * // Retrieve first cluster (0)
	 * var cluster = turf.getCluster(clustered, {cluster: 0});
	 * //= cluster
	 *
	 * // Retrieve cluster based on custom properties
	 * turf.getCluster(clustered, {'marker-symbol': 'circle'}).length;
	 * //= 2
	 * turf.getCluster(clustered, {'marker-symbol': 'square'}).length;
	 * //= 1
	 */
	function getCluster(geojson, filter) {
	    // Validation
	    if (!geojson) throw new Error('geojson is required');
	    if (geojson.type !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');
	    if (filter === undefined || filter === null) throw new Error('filter is required');

	    // Filter Features
	    var features = [];
	    featureEach$1(geojson, function (feature$$1) {
	        if (applyFilter(feature$$1.properties, filter)) features.push(feature$$1);
	    });
	    return featureCollection(features);
	}

	/**
	 * Callback for clusterEach
	 *
	 * @callback clusterEachCallback
	 * @param {FeatureCollection} [cluster] The current cluster being processed.
	 * @param {*} [clusterValue] Value used to create cluster being processed.
	 * @param {number} [currentIndex] The index of the current element being processed in the array.Starts at index 0
	 * @returns {void}
	 */

	/**
	 * clusterEach
	 *
	 * @name clusterEach
	 * @param {FeatureCollection} geojson GeoJSON Features
	 * @param {string|number} property GeoJSON property key/value used to create clusters
	 * @param {Function} callback a method that takes (cluster, clusterValue, currentIndex)
	 * @returns {void}
	 * @example
	 * var geojson = turf.featureCollection([
	 *     turf.point([0, 0]),
	 *     turf.point([2, 4]),
	 *     turf.point([3, 6]),
	 *     turf.point([5, 1]),
	 *     turf.point([4, 2])
	 * ]);
	 *
	 * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
	 * var clustered = turf.clustersKmeans(geojson);
	 *
	 * // Iterate over each cluster
	 * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue, currentIndex) {
	 *     //= cluster
	 *     //= clusterValue
	 *     //= currentIndex
	 * })
	 *
	 * // Calculate the total number of clusters
	 * var total = 0
	 * turf.clusterEach(clustered, 'cluster', function () {
	 *     total++;
	 * });
	 *
	 * // Create an Array of all the values retrieved from the 'cluster' property
	 * var values = []
	 * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue) {
	 *     values.push(clusterValue);
	 * });
	 */
	function clusterEach(geojson, property, callback) {
	    // Validation
	    if (!geojson) throw new Error('geojson is required');
	    if (geojson.type !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');
	    if (property === undefined || property === null) throw new Error('property is required');

	    // Create clusters based on property values
	    var bins = createBins(geojson, property);
	    var values = Object.keys(bins);
	    for (var index = 0; index < values.length; index++) {
	        var value = values[index];
	        var bin = bins[value];
	        var features = [];
	        for (var i = 0; i < bin.length; i++) {
	            features.push(geojson.features[bin[i]]);
	        }
	        callback(featureCollection(features), value, index);
	    }
	}

	/**
	 * Callback for clusterReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback clusterReduceCallback
	 * @param {*} [previousValue] The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {FeatureCollection} [cluster] The current cluster being processed.
	 * @param {*} [clusterValue] Value used to create cluster being processed.
	 * @param {number} [currentIndex] The index of the current element being processed in the
	 * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
	 */

	/**
	 * Reduce clusters in GeoJSON Features, similar to Array.reduce()
	 *
	 * @name clusterReduce
	 * @param {FeatureCollection} geojson GeoJSON Features
	 * @param {string|number} property GeoJSON property key/value used to create clusters
	 * @param {Function} callback a method that takes (previousValue, cluster, clusterValue, currentIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var geojson = turf.featureCollection([
	 *     turf.point([0, 0]),
	 *     turf.point([2, 4]),
	 *     turf.point([3, 6]),
	 *     turf.point([5, 1]),
	 *     turf.point([4, 2])
	 * ]);
	 *
	 * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
	 * var clustered = turf.clustersKmeans(geojson);
	 *
	 * // Iterate over each cluster and perform a calculation
	 * var initialValue = 0
	 * turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue, currentIndex) {
	 *     //=previousValue
	 *     //=cluster
	 *     //=clusterValue
	 *     //=currentIndex
	 *     return previousValue++;
	 * }, initialValue);
	 *
	 * // Calculate the total number of clusters
	 * var total = turf.clusterReduce(clustered, 'cluster', function (previousValue) {
	 *     return previousValue++;
	 * }, 0);
	 *
	 * // Create an Array of all the values retrieved from the 'cluster' property
	 * var values = turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue) {
	 *     return previousValue.concat(clusterValue);
	 * }, []);
	 */
	function clusterReduce(geojson, property, callback, initialValue) {
	    var previousValue = initialValue;
	    clusterEach(geojson, property, function (cluster, clusterValue, currentIndex) {
	        if (currentIndex === 0 && initialValue === undefined) previousValue = cluster;
	        else previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
	    });
	    return previousValue;
	}

	/**
	 * Create Bins
	 *
	 * @private
	 * @param {FeatureCollection} geojson GeoJSON Features
	 * @param {string|number} property Property values are used to create bins
	 * @returns {Object} bins with Feature IDs
	 * @example
	 * var geojson = turf.featureCollection([
	 *     turf.point([0, 0], {cluster: 0, foo: 'null'}),
	 *     turf.point([2, 4], {cluster: 1, foo: 'bar'}),
	 *     turf.point([5, 1], {0: 'foo'}),
	 *     turf.point([3, 6], {cluster: 1}),
	 * ]);
	 * createBins(geojson, 'cluster');
	 * //= { '0': [ 0 ], '1': [ 1, 3 ] }
	 */
	function createBins(geojson, property) {
	    var bins = {};

	    featureEach$1(geojson, function (feature$$1, i) {
	        var properties = feature$$1.properties || {};
	        if (properties.hasOwnProperty(property)) {
	            var value = properties[property];
	            if (bins.hasOwnProperty(value)) bins[value].push(i);
	            else bins[value] = [i];
	        }
	    });
	    return bins;
	}

	/**
	 * Apply Filter
	 *
	 * @private
	 * @param {*} properties Properties
	 * @param {*} filter Filter
	 * @returns {boolean} applied Filter to properties
	 */
	function applyFilter(properties, filter) {
	    if (properties === undefined) return false;
	    var filterType = typeof filter;

	    // String & Number
	    if (filterType === 'number' || filterType === 'string') return properties.hasOwnProperty(filter);
	    // Array
	    else if (Array.isArray(filter)) {
	        for (var i = 0; i < filter.length; i++) {
	            if (!applyFilter(properties, filter[i])) return false;
	        }
	        return true;
	    // Object
	    } else {
	        return propertiesContainsFilter(properties, filter);
	    }
	}

	/**
	 * Properties contains filter (does not apply deepEqual operations)
	 *
	 * @private
	 * @param {*} properties Properties
	 * @param {Object} filter Filter
	 * @returns {boolean} does filter equal Properties
	 * @example
	 * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 0})
	 * //= true
	 * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 1})
	 * //= false
	 */
	function propertiesContainsFilter(properties, filter) {
	    var keys = Object.keys(filter);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        if (properties[key] !== filter[key]) return false;
	    }
	    return true;
	}

	/**
	 * Filter Properties
	 *
	 * @private
	 * @param {*} properties Properties
	 * @param {Array<string>} keys Used to filter Properties
	 * @returns {*} filtered Properties
	 * @example
	 * filterProperties({foo: 'bar', cluster: 0}, ['cluster'])
	 * //= {cluster: 0}
	 */
	function filterProperties(properties, keys) {
	    if (!keys) return {};
	    if (!keys.length) return {};

	    var newProperties = {};
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        if (properties.hasOwnProperty(key)) newProperties[key] = properties[key];
	    }
	    return newProperties;
	}




	Object.freeze({
		getCluster: getCluster,
		clusterEach: clusterEach,
		clusterReduce: clusterReduce,
		createBins: createBins,
		applyFilter: applyFilter,
		propertiesContainsFilter: propertiesContainsFilter,
		filterProperties: filterProperties
	});

	/* Polyfill service v3.13.0
	 * For detailed credits and licence information see http://github.com/financial-times/polyfill-service
	 *
	 * - Array.prototype.fill, License: CC0 */

	if (!('fill' in Array.prototype)) {
	  Object.defineProperty(Array.prototype, 'fill', {
	    configurable: true,
	    value: function fill (value) {
	      if (this === undefined || this === null) {
	        throw new TypeError(this + ' is not an object')
	      }

	      var arrayLike = Object(this);

	      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;

	      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;

	      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);

	      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;

	      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);

	      while (relativeStart < relativeEnd) {
	        arrayLike[relativeStart] = value;

	        ++relativeStart;
	      }

	      return arrayLike
	    },
	    writable: true
	  });
	}

	/**
	 * Polyfill for IE support
	 */
	Number.isFinite = Number.isFinite || function (value) {
	  return typeof value === 'number' && isFinite(value)
	};

	Number.isInteger = Number.isInteger || function (val) {
	  return typeof val === 'number' &&
	  isFinite(val) &&
	  Math.floor(val) === val
	};

	Number.parseFloat = Number.parseFloat || parseFloat;

	Number.isNaN = Number.isNaN || function (value) {
	  return value !== value // eslint-disable-line
	};

	/**
	 * Polyfill for IE support
	 */
	Math.trunc = Math.trunc || function (x) {
	  return x < 0 ? Math.ceil(x) : Math.floor(x)
	};

	var NumberUtil = function NumberUtil () {};

	NumberUtil.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	NumberUtil.prototype.getClass = function getClass () {
	  return NumberUtil
	};
	NumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance (x1, x2, tolerance) {
	  return Math.abs(x1 - x2) <= tolerance
	};

	var IllegalArgumentException = function IllegalArgumentException () {};

	var Double = function Double () {};

	var staticAccessors$1 = { MAX_VALUE: { configurable: true } };

	Double.isNaN = function isNaN (n) { return Number.isNaN(n) };
	Double.doubleToLongBits = function doubleToLongBits (n) { return n };
	Double.longBitsToDouble = function longBitsToDouble (n) { return n };
	Double.isInfinite = function isInfinite (n) { return !Number.isFinite(n) };
	staticAccessors$1.MAX_VALUE.get = function () { return Number.MAX_VALUE };

	Object.defineProperties( Double, staticAccessors$1 );

	var Comparable = function Comparable () {};

	var Clonable = function Clonable () {};

	var Comparator = function Comparator () {};

	function Serializable () {}

	// import Assert from '../util/Assert'

	var Coordinate = function Coordinate () {
	  this.x = null;
	  this.y = null;
	  this.z = null;
	  if (arguments.length === 0) {
	    this.x = 0.0;
	    this.y = 0.0;
	    this.z = Coordinate.NULL_ORDINATE;
	  } else if (arguments.length === 1) {
	    var c = arguments[0];
	    this.x = c.x;
	    this.y = c.y;
	    this.z = c.z;
	  } else if (arguments.length === 2) {
	    this.x = arguments[0];
	    this.y = arguments[1];
	    this.z = Coordinate.NULL_ORDINATE;
	  } else if (arguments.length === 3) {
	    this.x = arguments[0];
	    this.y = arguments[1];
	    this.z = arguments[2];
	  }
	};

	var staticAccessors = { DimensionalComparator: { configurable: true },serialVersionUID: { configurable: true },NULL_ORDINATE: { configurable: true },X: { configurable: true },Y: { configurable: true },Z: { configurable: true } };
	Coordinate.prototype.setOrdinate = function setOrdinate (ordinateIndex, value) {
	  switch (ordinateIndex) {
	    case Coordinate.X:
	      this.x = value;
	      break
	    case Coordinate.Y:
	      this.y = value;
	      break
	    case Coordinate.Z:
	      this.z = value;
	      break
	    default:
	      throw new IllegalArgumentException()
	  }
	};
	Coordinate.prototype.equals2D = function equals2D () {
	  if (arguments.length === 1) {
	    var other = arguments[0];
	    if (this.x !== other.x) {
	      return false
	    }
	    if (this.y !== other.y) {
	      return false
	    }
	    return true
	  } else if (arguments.length === 2) {
	    var c = arguments[0];
	    var tolerance = arguments[1];
	    if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
	      return false
	    }
	    if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
	      return false
	    }
	    return true
	  }
	};
	Coordinate.prototype.getOrdinate = function getOrdinate (ordinateIndex) {
	  switch (ordinateIndex) {
	    case Coordinate.X:
	      return this.x
	    case Coordinate.Y:
	      return this.y
	    case Coordinate.Z:
	      return this.z
	  }
	  throw new IllegalArgumentException()
	};
	Coordinate.prototype.equals3D = function equals3D (other) {
	  return this.x === other.x &&
	         this.y === other.y &&
	         ((this.z === other.z || Double.isNaN(this.z)) &&
	         Double.isNaN(other.z))
	};
	Coordinate.prototype.equals = function equals (other) {
	  if (!(other instanceof Coordinate)) {
	    return false
	  }
	  return this.equals2D(other)
	};
	Coordinate.prototype.equalInZ = function equalInZ (c, tolerance) {
	  return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)
	};
	Coordinate.prototype.compareTo = function compareTo (o) {
	  var other = o;
	  if (this.x < other.x) { return -1 }
	  if (this.x > other.x) { return 1 }
	  if (this.y < other.y) { return -1 }
	  if (this.y > other.y) { return 1 }
	  return 0
	};
	Coordinate.prototype.clone = function clone () {
	  // try {
	  // var coord = null
	  // return coord
	  // } catch (e) {
	  // if (e instanceof CloneNotSupportedException) {
	  //   Assert.shouldNeverReachHere("this shouldn't happen because this class is Cloneable")
	  //   return null
	  // } else throw e
	  // } finally {}
	};
	Coordinate.prototype.copy = function copy () {
	  return new Coordinate(this)
	};
	Coordinate.prototype.toString = function toString () {
	  return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'
	};
	Coordinate.prototype.distance3D = function distance3D (c) {
	  var dx = this.x - c.x;
	  var dy = this.y - c.y;
	  var dz = this.z - c.z;
	  return Math.sqrt(dx * dx + dy * dy + dz * dz)
	};
	Coordinate.prototype.distance = function distance (c) {
	  var dx = this.x - c.x;
	  var dy = this.y - c.y;
	  return Math.sqrt(dx * dx + dy * dy)
	};
	Coordinate.prototype.hashCode = function hashCode () {
	  var result = 17;
	  result = 37 * result + Coordinate.hashCode(this.x);
	  result = 37 * result + Coordinate.hashCode(this.y);
	  return result
	};
	Coordinate.prototype.setCoordinate = function setCoordinate (other) {
	  this.x = other.x;
	  this.y = other.y;
	  this.z = other.z;
	};
	Coordinate.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable, Clonable, Serializable]
	};
	Coordinate.prototype.getClass = function getClass () {
	  return Coordinate
	};
	Coordinate.hashCode = function hashCode () {
	  if (arguments.length === 1) {
	    var x = arguments[0];
	    var f = Double.doubleToLongBits(x);
	    return Math.trunc((f ^ f) >>> 32)
	  }
	};
	staticAccessors.DimensionalComparator.get = function () { return DimensionalComparator };
	staticAccessors.serialVersionUID.get = function () { return 6683108902428366910 };
	staticAccessors.NULL_ORDINATE.get = function () { return Double.NaN };
	staticAccessors.X.get = function () { return 0 };
	staticAccessors.Y.get = function () { return 1 };
	staticAccessors.Z.get = function () { return 2 };

	Object.defineProperties( Coordinate, staticAccessors );

	var DimensionalComparator = function DimensionalComparator (dimensionsToTest) {
	  this._dimensionsToTest = 2;
	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    var dimensionsToTest$1 = arguments[0];
	    if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) { throw new IllegalArgumentException() }
	    this._dimensionsToTest = dimensionsToTest$1;
	  }
	};
	DimensionalComparator.prototype.compare = function compare (o1, o2) {
	  var c1 = o1;
	  var c2 = o2;
	  var compX = DimensionalComparator.compare(c1.x, c2.x);
	  if (compX !== 0) { return compX }
	  var compY = DimensionalComparator.compare(c1.y, c2.y);
	  if (compY !== 0) { return compY }
	  if (this._dimensionsToTest <= 2) { return 0 }
	  var compZ = DimensionalComparator.compare(c1.z, c2.z);
	  return compZ
	};
	DimensionalComparator.prototype.interfaces_ = function interfaces_ () {
	  return [Comparator]
	};
	DimensionalComparator.prototype.getClass = function getClass () {
	  return DimensionalComparator
	};
	DimensionalComparator.compare = function compare (a, b) {
	  if (a < b) { return -1 }
	  if (a > b) { return 1 }
	  if (Double.isNaN(a)) {
	    if (Double.isNaN(b)) { return 0 }
	    return -1
	  }
	  if (Double.isNaN(b)) { return 1 }
	  return 0
	};

	// import hasInterface from '../../../../hasInterface'
	// import CoordinateSequence from './CoordinateSequence'

	var CoordinateSequenceFactory = function CoordinateSequenceFactory () {};

	CoordinateSequenceFactory.prototype.create = function create () {
	  // if (arguments.length === 1) {
	  // if (arguments[0] instanceof Array) {
	  //   let coordinates = arguments[0]
	  // } else if (hasInterface(arguments[0], CoordinateSequence)) {
	  //   let coordSeq = arguments[0]
	  // }
	  // } else if (arguments.length === 2) {
	  // let size = arguments[0]
	  // let dimension = arguments[1]
	  // }
	};
	CoordinateSequenceFactory.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CoordinateSequenceFactory.prototype.getClass = function getClass () {
	  return CoordinateSequenceFactory
	};

	var Location = function Location () {};

	var staticAccessors$4 = { INTERIOR: { configurable: true },BOUNDARY: { configurable: true },EXTERIOR: { configurable: true },NONE: { configurable: true } };

	Location.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Location.prototype.getClass = function getClass () {
	  return Location
	};
	Location.toLocationSymbol = function toLocationSymbol (locationValue) {
	  switch (locationValue) {
	    case Location.EXTERIOR:
	      return 'e'
	    case Location.BOUNDARY:
	      return 'b'
	    case Location.INTERIOR:
	      return 'i'
	    case Location.NONE:
	      return '-'
	  }
	  throw new IllegalArgumentException()
	};
	staticAccessors$4.INTERIOR.get = function () { return 0 };
	staticAccessors$4.BOUNDARY.get = function () { return 1 };
	staticAccessors$4.EXTERIOR.get = function () { return 2 };
	staticAccessors$4.NONE.get = function () { return -1 };

	Object.defineProperties( Location, staticAccessors$4 );

	var hasInterface = function (o, i) {
	  return o.interfaces_ && o.interfaces_().indexOf(i) > -1
	};

	var MathUtil = function MathUtil () {};

	var staticAccessors$5 = { LOG_10: { configurable: true } };

	MathUtil.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MathUtil.prototype.getClass = function getClass () {
	  return MathUtil
	};
	MathUtil.log10 = function log10 (x) {
	  var ln = Math.log(x);
	  if (Double.isInfinite(ln)) { return ln }
	  if (Double.isNaN(ln)) { return ln }
	  return ln / MathUtil.LOG_10
	};
	MathUtil.min = function min (v1, v2, v3, v4) {
	  var min = v1;
	  if (v2 < min) { min = v2; }
	  if (v3 < min) { min = v3; }
	  if (v4 < min) { min = v4; }
	  return min
	};
	MathUtil.clamp = function clamp () {
	  if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {
	    var x = arguments[0];
	    var min = arguments[1];
	    var max = arguments[2];
	    if (x < min) { return min }
	    if (x > max) { return max }
	    return x
	  } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
	    var x$1 = arguments[0];
	    var min$1 = arguments[1];
	    var max$1 = arguments[2];
	    if (x$1 < min$1) { return min$1 }
	    if (x$1 > max$1) { return max$1 }
	    return x$1
	  }
	};
	MathUtil.wrap = function wrap (index, max) {
	  if (index < 0) {
	    return max - -index % max
	  }
	  return index % max
	};
	MathUtil.max = function max () {
	  if (arguments.length === 3) {
	    var v1 = arguments[0];
	    var v2 = arguments[1];
	    var v3 = arguments[2];
	    var max = v1;
	    if (v2 > max) { max = v2; }
	    if (v3 > max) { max = v3; }
	    return max
	  } else if (arguments.length === 4) {
	    var v1$1 = arguments[0];
	    var v2$1 = arguments[1];
	    var v3$1 = arguments[2];
	    var v4 = arguments[3];
	    var max$1 = v1$1;
	    if (v2$1 > max$1) { max$1 = v2$1; }
	    if (v3$1 > max$1) { max$1 = v3$1; }
	    if (v4 > max$1) { max$1 = v4; }
	    return max$1
	  }
	};
	MathUtil.average = function average (x1, x2) {
	  return (x1 + x2) / 2.0
	};
	staticAccessors$5.LOG_10.get = function () { return Math.log(10) };

	Object.defineProperties( MathUtil, staticAccessors$5 );

	var StringBuffer = function StringBuffer (str) {
	  this.str = str;
	};
	StringBuffer.prototype.append = function append (e) {
	  this.str += e;
	};

	StringBuffer.prototype.setCharAt = function setCharAt (i, c) {
	  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
	};

	StringBuffer.prototype.toString = function toString (e) {
	  return this.str
	};

	var Integer = function Integer (value) {
	  this.value = value;
	};
	Integer.prototype.intValue = function intValue () {
	  return this.value
	};
	Integer.prototype.compareTo = function compareTo (o) {
	  if (this.value < o) { return -1 }
	  if (this.value > o) { return 1 }
	  return 0
	};
	Integer.isNaN = function isNaN (n) { return Number.isNaN(n) };

	var Character = function Character () {};

	Character.isWhitespace = function isWhitespace (c) { return ((c <= 32 && c >= 0) || c === 127) };
	Character.toUpperCase = function toUpperCase (c) { return c.toUpperCase() };

	var DD = function DD () {
	  this._hi = 0.0;
	  this._lo = 0.0;
	  if (arguments.length === 0) {
	    this.init(0.0);
	  } else if (arguments.length === 1) {
	    if (typeof arguments[0] === 'number') {
	      var x = arguments[0];
	      this.init(x);
	    } else if (arguments[0] instanceof DD) {
	      var dd = arguments[0];
	      this.init(dd);
	    } else if (typeof arguments[0] === 'string') {
	      var str = arguments[0];
	      DD.call(this, DD.parse(str));
	    }
	  } else if (arguments.length === 2) {
	    var hi = arguments[0];
	    var lo = arguments[1];
	    this.init(hi, lo);
	  }
	};

	var staticAccessors$7 = { PI: { configurable: true },TWO_PI: { configurable: true },PI_2: { configurable: true },E: { configurable: true },NaN: { configurable: true },EPS: { configurable: true },SPLIT: { configurable: true },MAX_PRINT_DIGITS: { configurable: true },TEN: { configurable: true },ONE: { configurable: true },SCI_NOT_EXPONENT_CHAR: { configurable: true },SCI_NOT_ZERO: { configurable: true } };
	DD.prototype.le = function le (y) {
	  return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo
	};
	DD.prototype.extractSignificantDigits = function extractSignificantDigits (insertDecimalPoint, magnitude) {
	  var y = this.abs();
	  var mag = DD.magnitude(y._hi);
	  var scale = DD.TEN.pow(mag);
	  y = y.divide(scale);
	  if (y.gt(DD.TEN)) {
	    y = y.divide(DD.TEN);
	    mag += 1;
	  } else if (y.lt(DD.ONE)) {
	    y = y.multiply(DD.TEN);
	    mag -= 1;
	  }
	  var decimalPointPos = mag + 1;
	  var buf = new StringBuffer();
	  var numDigits = DD.MAX_PRINT_DIGITS - 1;
	  for (var i = 0; i <= numDigits; i++) {
	    if (insertDecimalPoint && i === decimalPointPos) {
	      buf.append('.');
	    }
	    var digit = Math.trunc(y._hi);
	    if (digit < 0) {
	      break
	    }
	    var rebiasBy10 = false;
	    var digitChar = 0;
	    if (digit > 9) {
	      rebiasBy10 = true;
	      digitChar = '9';
	    } else {
	      digitChar = '0' + digit;
	    }
	    buf.append(digitChar);
	    y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
	    if (rebiasBy10) { y.selfAdd(DD.TEN); }
	    var continueExtractingDigits = true;
	    var remMag = DD.magnitude(y._hi);
	    if (remMag < 0 && Math.abs(remMag) >= numDigits - i) { continueExtractingDigits = false; }
	    if (!continueExtractingDigits) { break }
	  }
	  magnitude[0] = mag;
	  return buf.toString()
	};
	DD.prototype.sqr = function sqr () {
	  return this.multiply(this)
	};
	DD.prototype.doubleValue = function doubleValue () {
	  return this._hi + this._lo
	};
	DD.prototype.subtract = function subtract () {
	  if (arguments[0] instanceof DD) {
	    var y = arguments[0];
	    return this.add(y.negate())
	  } else if (typeof arguments[0] === 'number') {
	    var y$1 = arguments[0];
	    return this.add(-y$1)
	  }
	};
	DD.prototype.equals = function equals () {
	  if (arguments.length === 1) {
	    var y = arguments[0];
	    return this._hi === y._hi && this._lo === y._lo
	  }
	};
	DD.prototype.isZero = function isZero () {
	  return this._hi === 0.0 && this._lo === 0.0
	};
	DD.prototype.selfSubtract = function selfSubtract () {
	  if (arguments[0] instanceof DD) {
	    var y = arguments[0];
	    if (this.isNaN()) { return this }
	    return this.selfAdd(-y._hi, -y._lo)
	  } else if (typeof arguments[0] === 'number') {
	    var y$1 = arguments[0];
	    if (this.isNaN()) { return this }
	    return this.selfAdd(-y$1, 0.0)
	  }
	};
	DD.prototype.getSpecialNumberString = function getSpecialNumberString () {
	  if (this.isZero()) { return '0.0' }
	  if (this.isNaN()) { return 'NaN ' }
	  return null
	};
	DD.prototype.min = function min (x) {
	  if (this.le(x)) {
	    return this
	  } else {
	    return x
	  }
	};
	DD.prototype.selfDivide = function selfDivide () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof DD) {
	      var y = arguments[0];
	      return this.selfDivide(y._hi, y._lo)
	    } else if (typeof arguments[0] === 'number') {
	      var y$1 = arguments[0];
	      return this.selfDivide(y$1, 0.0)
	    }
	  } else if (arguments.length === 2) {
	    var yhi = arguments[0];
	    var ylo = arguments[1];
	    var hc = null;
	    var tc = null;
	    var hy = null;
	    var ty = null;
	    var C = null;
	    var c = null;
	    var U = null;
	    var u = null;
	    C = this._hi / yhi;
	    c = DD.SPLIT * C;
	    hc = c - C;
	    u = DD.SPLIT * yhi;
	    hc = c - hc;
	    tc = C - hc;
	    hy = u - yhi;
	    U = C * yhi;
	    hy = u - hy;
	    ty = yhi - hy;
	    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
	    c = (this._hi - U - u + this._lo - C * ylo) / yhi;
	    u = C + c;
	    this._hi = u;
	    this._lo = C - u + c;
	    return this
	  }
	};
	DD.prototype.dump = function dump () {
	  return 'DD<' + this._hi + ', ' + this._lo + '>'
	};
	DD.prototype.divide = function divide () {
	  if (arguments[0] instanceof DD) {
	    var y = arguments[0];
	    var hc = null;
	    var tc = null;
	    var hy = null;
	    var ty = null;
	    var C = null;
	    var c = null;
	    var U = null;
	    var u = null;
	    C = this._hi / y._hi;
	    c = DD.SPLIT * C;
	    hc = c - C;
	    u = DD.SPLIT * y._hi;
	    hc = c - hc;
	    tc = C - hc;
	    hy = u - y._hi;
	    U = C * y._hi;
	    hy = u - hy;
	    ty = y._hi - hy;
	    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
	    c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
	    u = C + c;
	    var zhi = u;
	    var zlo = C - u + c;
	    return new DD(zhi, zlo)
	  } else if (typeof arguments[0] === 'number') {
	    var y$1 = arguments[0];
	    if (Double.isNaN(y$1)) { return DD.createNaN() }
	    return DD.copy(this).selfDivide(y$1, 0.0)
	  }
	};
	DD.prototype.ge = function ge (y) {
	  return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo
	};
	DD.prototype.pow = function pow (exp) {
	  if (exp === 0.0) { return DD.valueOf(1.0) }
	  var r = new DD(this);
	  var s = DD.valueOf(1.0);
	  var n = Math.abs(exp);
	  if (n > 1) {
	    while (n > 0) {
	      if (n % 2 === 1) {
	        s.selfMultiply(r);
	      }
	      n /= 2;
	      if (n > 0) { r = r.sqr(); }
	    }
	  } else {
	    s = r;
	  }
	  if (exp < 0) { return s.reciprocal() }
	  return s
	};
	DD.prototype.ceil = function ceil () {
	  if (this.isNaN()) { return DD.NaN }
	  var fhi = Math.ceil(this._hi);
	  var flo = 0.0;
	  if (fhi === this._hi) {
	    flo = Math.ceil(this._lo);
	  }
	  return new DD(fhi, flo)
	};
	DD.prototype.compareTo = function compareTo (o) {
	  var other = o;
	  if (this._hi < other._hi) { return -1 }
	  if (this._hi > other._hi) { return 1 }
	  if (this._lo < other._lo) { return -1 }
	  if (this._lo > other._lo) { return 1 }
	  return 0
	};
	DD.prototype.rint = function rint () {
	  if (this.isNaN()) { return this }
	  var plus5 = this.add(0.5);
	  return plus5.floor()
	};
	DD.prototype.setValue = function setValue () {
	  if (arguments[0] instanceof DD) {
	    var value = arguments[0];
	    this.init(value);
	    return this
	  } else if (typeof arguments[0] === 'number') {
	    var value$1 = arguments[0];
	    this.init(value$1);
	    return this
	  }
	};
	DD.prototype.max = function max (x) {
	  if (this.ge(x)) {
	    return this
	  } else {
	    return x
	  }
	};
	DD.prototype.sqrt = function sqrt () {
	  if (this.isZero()) { return DD.valueOf(0.0) }
	  if (this.isNegative()) {
	    return DD.NaN
	  }
	  var x = 1.0 / Math.sqrt(this._hi);
	  var ax = this._hi * x;
	  var axdd = DD.valueOf(ax);
	  var diffSq = this.subtract(axdd.sqr());
	  var d2 = diffSq._hi * (x * 0.5);
	  return axdd.add(d2)
	};
	DD.prototype.selfAdd = function selfAdd () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof DD) {
	      var y = arguments[0];
	      return this.selfAdd(y._hi, y._lo)
	    } else if (typeof arguments[0] === 'number') {
	      var y$1 = arguments[0];
	      var H = null;
	      var h = null;
	      var S = null;
	      var s = null;
	      var e = null;
	      var f = null;
	      S = this._hi + y$1;
	      e = S - this._hi;
	      s = S - e;
	      s = y$1 - e + (this._hi - s);
	      f = s + this._lo;
	      H = S + f;
	      h = f + (S - H);
	      this._hi = H + h;
	      this._lo = h + (H - this._hi);
	      return this
	    }
	  } else if (arguments.length === 2) {
	    var yhi = arguments[0];
	    var ylo = arguments[1];
	    var H$1 = null;
	    var h$1 = null;
	    var T = null;
	    var t = null;
	    var S$1 = null;
	    var s$1 = null;
	    var e$1 = null;
	    var f$1 = null;
	    S$1 = this._hi + yhi;
	    T = this._lo + ylo;
	    e$1 = S$1 - this._hi;
	    f$1 = T - this._lo;
	    s$1 = S$1 - e$1;
	    t = T - f$1;
	    s$1 = yhi - e$1 + (this._hi - s$1);
	    t = ylo - f$1 + (this._lo - t);
	    e$1 = s$1 + T;
	    H$1 = S$1 + e$1;
	    h$1 = e$1 + (S$1 - H$1);
	    e$1 = t + h$1;
	    var zhi = H$1 + e$1;
	    var zlo = e$1 + (H$1 - zhi);
	    this._hi = zhi;
	    this._lo = zlo;
	    return this
	  }
	};
	DD.prototype.selfMultiply = function selfMultiply () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof DD) {
	      var y = arguments[0];
	      return this.selfMultiply(y._hi, y._lo)
	    } else if (typeof arguments[0] === 'number') {
	      var y$1 = arguments[0];
	      return this.selfMultiply(y$1, 0.0)
	    }
	  } else if (arguments.length === 2) {
	    var yhi = arguments[0];
	    var ylo = arguments[1];
	    var hx = null;
	    var tx = null;
	    var hy = null;
	    var ty = null;
	    var C = null;
	    var c = null;
	    C = DD.SPLIT * this._hi;
	    hx = C - this._hi;
	    c = DD.SPLIT * yhi;
	    hx = C - hx;
	    tx = this._hi - hx;
	    hy = c - yhi;
	    C = this._hi * yhi;
	    hy = c - hy;
	    ty = yhi - hy;
	    c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
	    var zhi = C + c;
	    hx = C - zhi;
	    var zlo = c + hx;
	    this._hi = zhi;
	    this._lo = zlo;
	    return this
	  }
	};
	DD.prototype.selfSqr = function selfSqr () {
	  return this.selfMultiply(this)
	};
	DD.prototype.floor = function floor () {
	  if (this.isNaN()) { return DD.NaN }
	  var fhi = Math.floor(this._hi);
	  var flo = 0.0;
	  if (fhi === this._hi) {
	    flo = Math.floor(this._lo);
	  }
	  return new DD(fhi, flo)
	};
	DD.prototype.negate = function negate () {
	  if (this.isNaN()) { return this }
	  return new DD(-this._hi, -this._lo)
	};
	DD.prototype.clone = function clone () {
	  // try {
	  // return null
	  // } catch (ex) {
	  // if (ex instanceof CloneNotSupportedException) {
	  //   return null
	  // } else throw ex
	  // } finally {}
	};
	DD.prototype.multiply = function multiply () {
	  if (arguments[0] instanceof DD) {
	    var y = arguments[0];
	    if (y.isNaN()) { return DD.createNaN() }
	    return DD.copy(this).selfMultiply(y)
	  } else if (typeof arguments[0] === 'number') {
	    var y$1 = arguments[0];
	    if (Double.isNaN(y$1)) { return DD.createNaN() }
	    return DD.copy(this).selfMultiply(y$1, 0.0)
	  }
	};
	DD.prototype.isNaN = function isNaN () {
	  return Double.isNaN(this._hi)
	};
	DD.prototype.intValue = function intValue () {
	  return Math.trunc(this._hi)
	};
	DD.prototype.toString = function toString () {
	  var mag = DD.magnitude(this._hi);
	  if (mag >= -3 && mag <= 20) { return this.toStandardNotation() }
	  return this.toSciNotation()
	};
	DD.prototype.toStandardNotation = function toStandardNotation () {
	  var specialStr = this.getSpecialNumberString();
	  if (specialStr !== null) { return specialStr }
	  var magnitude = new Array(1).fill(null);
	  var sigDigits = this.extractSignificantDigits(true, magnitude);
	  var decimalPointPos = magnitude[0] + 1;
	  var num = sigDigits;
	  if (sigDigits.charAt(0) === '.') {
	    num = '0' + sigDigits;
	  } else if (decimalPointPos < 0) {
	    num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
	  } else if (sigDigits.indexOf('.') === -1) {
	    var numZeroes = decimalPointPos - sigDigits.length;
	    var zeroes = DD.stringOfChar('0', numZeroes);
	    num = sigDigits + zeroes + '.0';
	  }
	  if (this.isNegative()) { return '-' + num }
	  return num
	};
	DD.prototype.reciprocal = function reciprocal () {
	  var hc = null;
	  var tc = null;
	  var hy = null;
	  var ty = null;
	  var C = null;
	  var c = null;
	  var U = null;
	  var u = null;
	  C = 1.0 / this._hi;
	  c = DD.SPLIT * C;
	  hc = c - C;
	  u = DD.SPLIT * this._hi;
	  hc = c - hc;
	  tc = C - hc;
	  hy = u - this._hi;
	  U = C * this._hi;
	  hy = u - hy;
	  ty = this._hi - hy;
	  u = hc * hy - U + hc * ty + tc * hy + tc * ty;
	  c = (1.0 - U - u - C * this._lo) / this._hi;
	  var zhi = C + c;
	  var zlo = C - zhi + c;
	  return new DD(zhi, zlo)
	};
	DD.prototype.toSciNotation = function toSciNotation () {
	  if (this.isZero()) { return DD.SCI_NOT_ZERO }
	  var specialStr = this.getSpecialNumberString();
	  if (specialStr !== null) { return specialStr }
	  var magnitude = new Array(1).fill(null);
	  var digits = this.extractSignificantDigits(false, magnitude);
	  var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
	  if (digits.charAt(0) === '0') {
	    throw new Error('Found leading zero: ' + digits)
	  }
	  var trailingDigits = '';
	  if (digits.length > 1) { trailingDigits = digits.substring(1); }
	  var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
	  if (this.isNegative()) { return '-' + digitsWithDecimal + expStr }
	  return digitsWithDecimal + expStr
	};
	DD.prototype.abs = function abs () {
	  if (this.isNaN()) { return DD.NaN }
	  if (this.isNegative()) { return this.negate() }
	  return new DD(this)
	};
	DD.prototype.isPositive = function isPositive () {
	  return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0
	};
	DD.prototype.lt = function lt (y) {
	  return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo
	};
	DD.prototype.add = function add () {
	  if (arguments[0] instanceof DD) {
	    var y = arguments[0];
	    return DD.copy(this).selfAdd(y)
	  } else if (typeof arguments[0] === 'number') {
	    var y$1 = arguments[0];
	    return DD.copy(this).selfAdd(y$1)
	  }
	};
	DD.prototype.init = function init () {
	  if (arguments.length === 1) {
	    if (typeof arguments[0] === 'number') {
	      var x = arguments[0];
	      this._hi = x;
	      this._lo = 0.0;
	    } else if (arguments[0] instanceof DD) {
	      var dd = arguments[0];
	      this._hi = dd._hi;
	      this._lo = dd._lo;
	    }
	  } else if (arguments.length === 2) {
	    var hi = arguments[0];
	    var lo = arguments[1];
	    this._hi = hi;
	    this._lo = lo;
	  }
	};
	DD.prototype.gt = function gt (y) {
	  return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo
	};
	DD.prototype.isNegative = function isNegative () {
	  return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0
	};
	DD.prototype.trunc = function trunc () {
	  if (this.isNaN()) { return DD.NaN }
	  if (this.isPositive()) { return this.floor(); } else { return this.ceil() }
	};
	DD.prototype.signum = function signum () {
	  if (this._hi > 0) { return 1 }
	  if (this._hi < 0) { return -1 }
	  if (this._lo > 0) { return 1 }
	  if (this._lo < 0) { return -1 }
	  return 0
	};
	DD.prototype.interfaces_ = function interfaces_ () {
	  return [Serializable, Comparable, Clonable]
	};
	DD.prototype.getClass = function getClass () {
	  return DD
	};
	DD.sqr = function sqr (x) {
	  return DD.valueOf(x).selfMultiply(x)
	};
	DD.valueOf = function valueOf () {
	  if (typeof arguments[0] === 'string') {
	    var str = arguments[0];
	    return DD.parse(str)
	  } else if (typeof arguments[0] === 'number') {
	    var x = arguments[0];
	    return new DD(x)
	  }
	};
	DD.sqrt = function sqrt (x) {
	  return DD.valueOf(x).sqrt()
	};
	DD.parse = function parse (str) {
	  var i = 0;
	  var strlen = str.length;
	  while (Character.isWhitespace(str.charAt(i))) { i++; }
	  var isNegative = false;
	  if (i < strlen) {
	    var signCh = str.charAt(i);
	    if (signCh === '-' || signCh === '+') {
	      i++;
	      if (signCh === '-') { isNegative = true; }
	    }
	  }
	  var val = new DD();
	  var numDigits = 0;
	  var numBeforeDec = 0;
	  var exp = 0;
	  while (true) {
	    if (i >= strlen) { break }
	    var ch = str.charAt(i);
	    i++;
	    if (Character.isDigit(ch)) {
	      var d = ch - '0';
	      val.selfMultiply(DD.TEN);
	      val.selfAdd(d);
	      numDigits++;
	      continue
	    }
	    if (ch === '.') {
	      numBeforeDec = numDigits;
	      continue
	    }
	    if (ch === 'e' || ch === 'E') {
	      var expStr = str.substring(i);
	      try {
	        exp = Integer.parseInt(expStr);
	      } catch (ex) {
	        if (ex instanceof Error) {
	          throw new Error('Invalid exponent ' + expStr + ' in string ' + str)
	        } else { throw ex }
	      } finally {}
	      break
	    }
	    throw new Error("Unexpected character '" + ch + "' at position " + i + ' in string ' + str)
	  }
	  var val2 = val;
	  var numDecPlaces = numDigits - numBeforeDec - exp;
	  if (numDecPlaces === 0) {
	    val2 = val;
	  } else if (numDecPlaces > 0) {
	    var scale = DD.TEN.pow(numDecPlaces);
	    val2 = val.divide(scale);
	  } else if (numDecPlaces < 0) {
	    var scale$1 = DD.TEN.pow(-numDecPlaces);
	    val2 = val.multiply(scale$1);
	  }
	  if (isNegative) {
	    return val2.negate()
	  }
	  return val2
	};
	DD.createNaN = function createNaN () {
	  return new DD(Double.NaN, Double.NaN)
	};
	DD.copy = function copy (dd) {
	  return new DD(dd)
	};
	DD.magnitude = function magnitude (x) {
	  var xAbs = Math.abs(x);
	  var xLog10 = Math.log(xAbs) / Math.log(10);
	  var xMag = Math.trunc(Math.floor(xLog10));
	  var xApprox = Math.pow(10, xMag);
	  if (xApprox * 10 <= xAbs) { xMag += 1; }
	  return xMag
	};
	DD.stringOfChar = function stringOfChar (ch, len) {
	  var buf = new StringBuffer();
	  for (var i = 0; i < len; i++) {
	    buf.append(ch);
	  }
	  return buf.toString()
	};
	staticAccessors$7.PI.get = function () { return new DD(3.141592653589793116e+00, 1.224646799147353207e-16) };
	staticAccessors$7.TWO_PI.get = function () { return new DD(6.283185307179586232e+00, 2.449293598294706414e-16) };
	staticAccessors$7.PI_2.get = function () { return new DD(1.570796326794896558e+00, 6.123233995736766036e-17) };
	staticAccessors$7.E.get = function () { return new DD(2.718281828459045091e+00, 1.445646891729250158e-16) };
	staticAccessors$7.NaN.get = function () { return new DD(Double.NaN, Double.NaN) };
	staticAccessors$7.EPS.get = function () { return 1.23259516440783e-32 };
	staticAccessors$7.SPLIT.get = function () { return 134217729.0 };
	staticAccessors$7.MAX_PRINT_DIGITS.get = function () { return 32 };
	staticAccessors$7.TEN.get = function () { return DD.valueOf(10.0) };
	staticAccessors$7.ONE.get = function () { return DD.valueOf(1.0) };
	staticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function () { return 'E' };
	staticAccessors$7.SCI_NOT_ZERO.get = function () { return '0.0E0' };

	Object.defineProperties( DD, staticAccessors$7 );

	var CGAlgorithmsDD = function CGAlgorithmsDD () {};

	var staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };

	CGAlgorithmsDD.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CGAlgorithmsDD.prototype.getClass = function getClass () {
	  return CGAlgorithmsDD
	};
	CGAlgorithmsDD.orientationIndex = function orientationIndex (p1, p2, q) {
	  var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
	  if (index <= 1) { return index }
	  var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
	  var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
	  var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
	  var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
	  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()
	};
	CGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {
	  var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
	  return det.signum()
	};
	CGAlgorithmsDD.intersection = function intersection (p1, p2, q1, q2) {
	  var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
	  var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
	  var denom = denom1.subtract(denom2);
	  var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
	  var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
	  var numx = numx1.subtract(numx2);
	  var fracP = numx.selfDivide(denom).doubleValue();
	  var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
	  var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
	  var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
	  var numy = numy1.subtract(numy2);
	  var fracQ = numy.selfDivide(denom).doubleValue();
	  var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
	  return new Coordinate(x, y)
	};
	CGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter (pa, pb, pc) {
	  var detsum = null;
	  var detleft = (pa.x - pc.x) * (pb.y - pc.y);
	  var detright = (pa.y - pc.y) * (pb.x - pc.x);
	  var det = detleft - detright;
	  if (detleft > 0.0) {
	    if (detright <= 0.0) {
	      return CGAlgorithmsDD.signum(det)
	    } else {
	      detsum = detleft + detright;
	    }
	  } else if (detleft < 0.0) {
	    if (detright >= 0.0) {
	      return CGAlgorithmsDD.signum(det)
	    } else {
	      detsum = -detleft - detright;
	    }
	  } else {
	    return CGAlgorithmsDD.signum(det)
	  }
	  var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
	  if (det >= errbound || -det >= errbound) {
	    return CGAlgorithmsDD.signum(det)
	  }
	  return 2
	};
	CGAlgorithmsDD.signum = function signum (x) {
	  if (x > 0) { return 1 }
	  if (x < 0) { return -1 }
	  return 0
	};
	staticAccessors$6.DP_SAFE_EPSILON.get = function () { return 1e-15 };

	Object.defineProperties( CGAlgorithmsDD, staticAccessors$6 );

	var CoordinateSequence = function CoordinateSequence () {};

	var staticAccessors$8 = { X: { configurable: true },Y: { configurable: true },Z: { configurable: true },M: { configurable: true } };

	staticAccessors$8.X.get = function () { return 0 };
	staticAccessors$8.Y.get = function () { return 1 };
	staticAccessors$8.Z.get = function () { return 2 };
	staticAccessors$8.M.get = function () { return 3 };
	CoordinateSequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {};
	CoordinateSequence.prototype.size = function size () {};
	CoordinateSequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {};
	CoordinateSequence.prototype.getCoordinate = function getCoordinate () {};
	CoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {};
	CoordinateSequence.prototype.getDimension = function getDimension () {};
	CoordinateSequence.prototype.getX = function getX (index) {};
	CoordinateSequence.prototype.clone = function clone () {};
	CoordinateSequence.prototype.expandEnvelope = function expandEnvelope (env) {};
	CoordinateSequence.prototype.copy = function copy () {};
	CoordinateSequence.prototype.getY = function getY (index) {};
	CoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray () {};
	CoordinateSequence.prototype.interfaces_ = function interfaces_ () {
	  return [Clonable]
	};
	CoordinateSequence.prototype.getClass = function getClass () {
	  return CoordinateSequence
	};

	Object.defineProperties( CoordinateSequence, staticAccessors$8 );

	var Exception = function Exception () {};

	var NotRepresentableException = (function (Exception$$1) {
	  function NotRepresentableException () {
	    Exception$$1.call(this, 'Projective point not representable on the Cartesian plane.');
	  }

	  if ( Exception$$1 ) NotRepresentableException.__proto__ = Exception$$1;
	  NotRepresentableException.prototype = Object.create( Exception$$1 && Exception$$1.prototype );
	  NotRepresentableException.prototype.constructor = NotRepresentableException;
	  NotRepresentableException.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  NotRepresentableException.prototype.getClass = function getClass () {
	    return NotRepresentableException
	  };

	  return NotRepresentableException;
	}(Exception));

	var System = function System () {};

	System.arraycopy = function arraycopy (src, srcPos, dest, destPos, len) {
	  var c = 0;
	  for (var i = srcPos; i < srcPos + len; i++) {
	    dest[destPos + c] = src[i];
	    c++;
	  }
	};

	System.getProperty = function getProperty (name) {
	  return {
	    'line.separator': '\n'
	  }[name]
	};

	var HCoordinate = function HCoordinate () {
	  this.x = null;
	  this.y = null;
	  this.w = null;
	  if (arguments.length === 0) {
	    this.x = 0.0;
	    this.y = 0.0;
	    this.w = 1.0;
	  } else if (arguments.length === 1) {
	    var p = arguments[0];
	    this.x = p.x;
	    this.y = p.y;
	    this.w = 1.0;
	  } else if (arguments.length === 2) {
	    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
	      var _x = arguments[0];
	      var _y = arguments[1];
	      this.x = _x;
	      this.y = _y;
	      this.w = 1.0;
	    } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
	      var p1 = arguments[0];
	      var p2 = arguments[1];
	      this.x = p1.y * p2.w - p2.y * p1.w;
	      this.y = p2.x * p1.w - p1.x * p2.w;
	      this.w = p1.x * p2.y - p2.x * p1.y;
	    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
	      var p1$1 = arguments[0];
	      var p2$1 = arguments[1];
	      this.x = p1$1.y - p2$1.y;
	      this.y = p2$1.x - p1$1.x;
	      this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;
	    }
	  } else if (arguments.length === 3) {
	    var _x$1 = arguments[0];
	    var _y$1 = arguments[1];
	    var _w = arguments[2];
	    this.x = _x$1;
	    this.y = _y$1;
	    this.w = _w;
	  } else if (arguments.length === 4) {
	    var p1$2 = arguments[0];
	    var p2$2 = arguments[1];
	    var q1 = arguments[2];
	    var q2 = arguments[3];
	    var px = p1$2.y - p2$2.y;
	    var py = p2$2.x - p1$2.x;
	    var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;
	    var qx = q1.y - q2.y;
	    var qy = q2.x - q1.x;
	    var qw = q1.x * q2.y - q2.x * q1.y;
	    this.x = py * qw - qy * pw;
	    this.y = qx * pw - px * qw;
	    this.w = px * qy - qx * py;
	  }
	};
	HCoordinate.prototype.getY = function getY () {
	  var a = this.y / this.w;
	  if (Double.isNaN(a) || Double.isInfinite(a)) {
	    throw new NotRepresentableException()
	  }
	  return a
	};
	HCoordinate.prototype.getX = function getX () {
	  var a = this.x / this.w;
	  if (Double.isNaN(a) || Double.isInfinite(a)) {
	    throw new NotRepresentableException()
	  }
	  return a
	};
	HCoordinate.prototype.getCoordinate = function getCoordinate () {
	  var p = new Coordinate();
	  p.x = this.getX();
	  p.y = this.getY();
	  return p
	};
	HCoordinate.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	HCoordinate.prototype.getClass = function getClass () {
	  return HCoordinate
	};
	HCoordinate.intersection = function intersection (p1, p2, q1, q2) {
	  var px = p1.y - p2.y;
	  var py = p2.x - p1.x;
	  var pw = p1.x * p2.y - p2.x * p1.y;
	  var qx = q1.y - q2.y;
	  var qy = q2.x - q1.x;
	  var qw = q1.x * q2.y - q2.x * q1.y;
	  var x = py * qw - qy * pw;
	  var y = qx * pw - px * qw;
	  var w = px * qy - qx * py;
	  var xInt = x / w;
	  var yInt = y / w;
	  if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
	    throw new NotRepresentableException()
	  }
	  return new Coordinate(xInt, yInt)
	};

	var Envelope = function Envelope () {
	  this._minx = null;
	  this._maxx = null;
	  this._miny = null;
	  this._maxy = null;
	  if (arguments.length === 0) {
	    this.init();
	  } else if (arguments.length === 1) {
	    if (arguments[0] instanceof Coordinate) {
	      var p = arguments[0];
	      this.init(p.x, p.x, p.y, p.y);
	    } else if (arguments[0] instanceof Envelope) {
	      var env = arguments[0];
	      this.init(env);
	    }
	  } else if (arguments.length === 2) {
	    var p1 = arguments[0];
	    var p2 = arguments[1];
	    this.init(p1.x, p2.x, p1.y, p2.y);
	  } else if (arguments.length === 4) {
	    var x1 = arguments[0];
	    var x2 = arguments[1];
	    var y1 = arguments[2];
	    var y2 = arguments[3];
	    this.init(x1, x2, y1, y2);
	  }
	};

	var staticAccessors$9 = { serialVersionUID: { configurable: true } };
	Envelope.prototype.getArea = function getArea () {
	  return this.getWidth() * this.getHeight()
	};
	Envelope.prototype.equals = function equals (other) {
	  if (!(other instanceof Envelope)) {
	    return false
	  }
	  var otherEnvelope = other;
	  if (this.isNull()) {
	    return otherEnvelope.isNull()
	  }
	  return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()
	};
	Envelope.prototype.intersection = function intersection (env) {
	  if (this.isNull() || env.isNull() || !this.intersects(env)) { return new Envelope() }
	  var intMinX = this._minx > env._minx ? this._minx : env._minx;
	  var intMinY = this._miny > env._miny ? this._miny : env._miny;
	  var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
	  var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
	  return new Envelope(intMinX, intMaxX, intMinY, intMaxY)
	};
	Envelope.prototype.isNull = function isNull () {
	  return this._maxx < this._minx
	};
	Envelope.prototype.getMaxX = function getMaxX () {
	  return this._maxx
	};
	Envelope.prototype.covers = function covers () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Coordinate) {
	      var p = arguments[0];
	      return this.covers(p.x, p.y)
	    } else if (arguments[0] instanceof Envelope) {
	      var other = arguments[0];
	      if (this.isNull() || other.isNull()) {
	        return false
	      }
	      return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy
	    }
	  } else if (arguments.length === 2) {
	    var x = arguments[0];
	    var y = arguments[1];
	    if (this.isNull()) { return false }
	    return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy
	  }
	};
	Envelope.prototype.intersects = function intersects () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Envelope) {
	      var other = arguments[0];
	      if (this.isNull() || other.isNull()) {
	        return false
	      }
	      return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)
	    } else if (arguments[0] instanceof Coordinate) {
	      var p = arguments[0];
	      return this.intersects(p.x, p.y)
	    }
	  } else if (arguments.length === 2) {
	    var x = arguments[0];
	    var y = arguments[1];
	    if (this.isNull()) { return false }
	    return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)
	  }
	};
	Envelope.prototype.getMinY = function getMinY () {
	  return this._miny
	};
	Envelope.prototype.getMinX = function getMinX () {
	  return this._minx
	};
	Envelope.prototype.expandToInclude = function expandToInclude () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Coordinate) {
	      var p = arguments[0];
	      this.expandToInclude(p.x, p.y);
	    } else if (arguments[0] instanceof Envelope) {
	      var other = arguments[0];
	      if (other.isNull()) {
	        return null
	      }
	      if (this.isNull()) {
	        this._minx = other.getMinX();
	        this._maxx = other.getMaxX();
	        this._miny = other.getMinY();
	        this._maxy = other.getMaxY();
	      } else {
	        if (other._minx < this._minx) {
	          this._minx = other._minx;
	        }
	        if (other._maxx > this._maxx) {
	          this._maxx = other._maxx;
	        }
	        if (other._miny < this._miny) {
	          this._miny = other._miny;
	        }
	        if (other._maxy > this._maxy) {
	          this._maxy = other._maxy;
	        }
	      }
	    }
	  } else if (arguments.length === 2) {
	    var x = arguments[0];
	    var y = arguments[1];
	    if (this.isNull()) {
	      this._minx = x;
	      this._maxx = x;
	      this._miny = y;
	      this._maxy = y;
	    } else {
	      if (x < this._minx) {
	        this._minx = x;
	      }
	      if (x > this._maxx) {
	        this._maxx = x;
	      }
	      if (y < this._miny) {
	        this._miny = y;
	      }
	      if (y > this._maxy) {
	        this._maxy = y;
	      }
	    }
	  }
	};
	Envelope.prototype.minExtent = function minExtent () {
	  if (this.isNull()) { return 0.0 }
	  var w = this.getWidth();
	  var h = this.getHeight();
	  if (w < h) { return w }
	  return h
	};
	Envelope.prototype.getWidth = function getWidth () {
	  if (this.isNull()) {
	    return 0
	  }
	  return this._maxx - this._minx
	};
	Envelope.prototype.compareTo = function compareTo (o) {
	  var env = o;
	  if (this.isNull()) {
	    if (env.isNull()) { return 0 }
	    return -1
	  } else {
	    if (env.isNull()) { return 1 }
	  }
	  if (this._minx < env._minx) { return -1 }
	  if (this._minx > env._minx) { return 1 }
	  if (this._miny < env._miny) { return -1 }
	  if (this._miny > env._miny) { return 1 }
	  if (this._maxx < env._maxx) { return -1 }
	  if (this._maxx > env._maxx) { return 1 }
	  if (this._maxy < env._maxy) { return -1 }
	  if (this._maxy > env._maxy) { return 1 }
	  return 0
	};
	Envelope.prototype.translate = function translate (transX, transY) {
	  if (this.isNull()) {
	    return null
	  }
	  this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
	};
	Envelope.prototype.toString = function toString () {
	  return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'
	};
	Envelope.prototype.setToNull = function setToNull () {
	  this._minx = 0;
	  this._maxx = -1;
	  this._miny = 0;
	  this._maxy = -1;
	};
	Envelope.prototype.getHeight = function getHeight () {
	  if (this.isNull()) {
	    return 0
	  }
	  return this._maxy - this._miny
	};
	Envelope.prototype.maxExtent = function maxExtent () {
	  if (this.isNull()) { return 0.0 }
	  var w = this.getWidth();
	  var h = this.getHeight();
	  if (w > h) { return w }
	  return h
	};
	Envelope.prototype.expandBy = function expandBy () {
	  if (arguments.length === 1) {
	    var distance = arguments[0];
	    this.expandBy(distance, distance);
	  } else if (arguments.length === 2) {
	    var deltaX = arguments[0];
	    var deltaY = arguments[1];
	    if (this.isNull()) { return null }
	    this._minx -= deltaX;
	    this._maxx += deltaX;
	    this._miny -= deltaY;
	    this._maxy += deltaY;
	    if (this._minx > this._maxx || this._miny > this._maxy) { this.setToNull(); }
	  }
	};
	Envelope.prototype.contains = function contains () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Envelope) {
	      var other = arguments[0];
	      return this.covers(other)
	    } else if (arguments[0] instanceof Coordinate) {
	      var p = arguments[0];
	      return this.covers(p)
	    }
	  } else if (arguments.length === 2) {
	    var x = arguments[0];
	    var y = arguments[1];
	    return this.covers(x, y)
	  }
	};
	Envelope.prototype.centre = function centre () {
	  if (this.isNull()) { return null }
	  return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)
	};
	Envelope.prototype.init = function init () {
	  if (arguments.length === 0) {
	    this.setToNull();
	  } else if (arguments.length === 1) {
	    if (arguments[0] instanceof Coordinate) {
	      var p = arguments[0];
	      this.init(p.x, p.x, p.y, p.y);
	    } else if (arguments[0] instanceof Envelope) {
	      var env = arguments[0];
	      this._minx = env._minx;
	      this._maxx = env._maxx;
	      this._miny = env._miny;
	      this._maxy = env._maxy;
	    }
	  } else if (arguments.length === 2) {
	    var p1 = arguments[0];
	    var p2 = arguments[1];
	    this.init(p1.x, p2.x, p1.y, p2.y);
	  } else if (arguments.length === 4) {
	    var x1 = arguments[0];
	    var x2 = arguments[1];
	    var y1 = arguments[2];
	    var y2 = arguments[3];
	    if (x1 < x2) {
	      this._minx = x1;
	      this._maxx = x2;
	    } else {
	      this._minx = x2;
	      this._maxx = x1;
	    }
	    if (y1 < y2) {
	      this._miny = y1;
	      this._maxy = y2;
	    } else {
	      this._miny = y2;
	      this._maxy = y1;
	    }
	  }
	};
	Envelope.prototype.getMaxY = function getMaxY () {
	  return this._maxy
	};
	Envelope.prototype.distance = function distance (env) {
	  if (this.intersects(env)) { return 0 }
	  var dx = 0.0;
	  if (this._maxx < env._minx) { dx = env._minx - this._maxx; } else if (this._minx > env._maxx) { dx = this._minx - env._maxx; }
	  var dy = 0.0;
	  if (this._maxy < env._miny) { dy = env._miny - this._maxy; } else if (this._miny > env._maxy) { dy = this._miny - env._maxy; }
	  if (dx === 0.0) { return dy }
	  if (dy === 0.0) { return dx }
	  return Math.sqrt(dx * dx + dy * dy)
	};
	Envelope.prototype.hashCode = function hashCode () {
	  var result = 17;
	  result = 37 * result + Coordinate.hashCode(this._minx);
	  result = 37 * result + Coordinate.hashCode(this._maxx);
	  result = 37 * result + Coordinate.hashCode(this._miny);
	  result = 37 * result + Coordinate.hashCode(this._maxy);
	  return result
	};
	Envelope.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable, Serializable]
	};
	Envelope.prototype.getClass = function getClass () {
	  return Envelope
	};
	Envelope.intersects = function intersects () {
	  if (arguments.length === 3) {
	    var p1 = arguments[0];
	    var p2 = arguments[1];
	    var q = arguments[2];
	    if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
	      return true
	    }
	    return false
	  } else if (arguments.length === 4) {
	    var p1$1 = arguments[0];
	    var p2$1 = arguments[1];
	    var q1 = arguments[2];
	    var q2 = arguments[3];
	    var minq = Math.min(q1.x, q2.x);
	    var maxq = Math.max(q1.x, q2.x);
	    var minp = Math.min(p1$1.x, p2$1.x);
	    var maxp = Math.max(p1$1.x, p2$1.x);
	    if (minp > maxq) { return false }
	    if (maxp < minq) { return false }
	    minq = Math.min(q1.y, q2.y);
	    maxq = Math.max(q1.y, q2.y);
	    minp = Math.min(p1$1.y, p2$1.y);
	    maxp = Math.max(p1$1.y, p2$1.y);
	    if (minp > maxq) { return false }
	    if (maxp < minq) { return false }
	    return true
	  }
	};
	staticAccessors$9.serialVersionUID.get = function () { return 5873921885273102420 };

	Object.defineProperties( Envelope, staticAccessors$9 );

	var regExes = {
	  'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
	  'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
	  'spaces': /\s+/,
	  'parenComma': /\)\s*,\s*\(/,
	  'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
	  'trimParens': /^\s*\(?(.*?)\)?\s*$/
	};

	/**
	 * Class for reading and writing Well-Known Text.
	 *
	 * NOTE: Adapted from OpenLayers 2.11 implementation.
	 */

	/** Create a new parser for WKT
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @return An instance of WKTParser.
	 * @constructor
	 * @private
	 */
	var WKTParser = function WKTParser (geometryFactory) {
	  this.geometryFactory = geometryFactory || new GeometryFactory();
	};
	/**
	 * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
	 * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
	 * and GEOMETRYCOLLECTION.
	 *
	 * @param {String} wkt A WKT string.
	 * @return {Geometry} A geometry instance.
	 * @private
	 */
	WKTParser.prototype.read = function read (wkt) {
	  var geometry, type, str;
	  wkt = wkt.replace(/[\n\r]/g, ' ');
	  var matches = regExes.typeStr.exec(wkt);
	  if (wkt.search('EMPTY') !== -1) {
	    matches = regExes.emptyTypeStr.exec(wkt);
	    matches[2] = undefined;
	  }
	  if (matches) {
	    type = matches[1].toLowerCase();
	    str = matches[2];
	    if (parse$1$1[type]) {
	      geometry = parse$1$1[type].apply(this, [str]);
	    }
	  }

	  if (geometry === undefined) { throw new Error('Could not parse WKT ' + wkt) }

	  return geometry
	};

	/**
	 * Serialize a geometry into a WKT string.
	 *
	 * @param {Geometry} geometry A feature or array of features.
	 * @return {String} The WKT string representation of the input geometries.
	 * @private
	 */
	WKTParser.prototype.write = function write (geometry) {
	  return this.extractGeometry(geometry)
	};

	/**
	 * Entry point to construct the WKT for a single Geometry object.
	 *
	 * @param {Geometry} geometry
	 * @return {String} A WKT string of representing the geometry.
	 * @private
	 */
	WKTParser.prototype.extractGeometry = function extractGeometry (geometry) {
	  var type = geometry.getGeometryType().toLowerCase();
	  if (!extract$1[type]) {
	    return null
	  }
	  var wktType = type.toUpperCase();
	  var data;
	  if (geometry.isEmpty()) {
	    data = wktType + ' EMPTY';
	  } else {
	    data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';
	  }
	  return data
	};

	/**
	 * Object with properties corresponding to the geometry types. Property values
	 * are functions that do the actual data extraction.
	 * @private
	 */
	var extract$1 = {
	  coordinate: function coordinate (coordinate$1) {
	    return coordinate$1.x + ' ' + coordinate$1.y
	  },

	  /**
	   * Return a space delimited string of point coordinates.
	   *
	   * @param {Point}
	   *          point
	   * @return {String} A string of coordinates representing the point.
	   */
	  point: function point (point$1) {
	    return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0])
	  },

	  /**
	   * Return a comma delimited string of point coordinates from a multipoint.
	   *
	   * @param {MultiPoint}
	   *          multipoint
	   * @return {String} A string of point coordinate strings representing the
	   *         multipoint.
	   */
	  multipoint: function multipoint (multipoint$1) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {
	      array.push('(' + extract$1.point.apply(this$1$1, [multipoint$1._geometries[i]]) + ')');
	    }
	    return array.join(',')
	  },

	  /**
	   * Return a comma delimited string of point coordinates from a line.
	   *
	   * @param {LineString} linestring
	   * @return {String} A string of point coordinate strings representing the linestring.
	   */
	  linestring: function linestring (linestring$1) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {
	      array.push(extract$1.coordinate.apply(this$1$1, [linestring$1._points._coordinates[i]]));
	    }
	    return array.join(',')
	  },

	  linearring: function linearring (linearring$1) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {
	      array.push(extract$1.coordinate.apply(this$1$1, [linearring$1._points._coordinates[i]]));
	    }
	    return array.join(',')
	  },

	  /**
	   * Return a comma delimited string of linestring strings from a
	   * multilinestring.
	   *
	   * @param {MultiLineString} multilinestring
	   * @return {String} A string of of linestring strings representing the multilinestring.
	   */
	  multilinestring: function multilinestring (multilinestring$1) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {
	      array.push('(' +
	        extract$1.linestring.apply(this$1$1, [multilinestring$1._geometries[i]]) +
	        ')');
	    }
	    return array.join(',')
	  },

	  /**
	   * Return a comma delimited string of linear ring arrays from a polygon.
	   *
	   * @param {Polygon} polygon
	   * @return {String} An array of linear ring arrays representing the polygon.
	   */
	  polygon: function polygon (polygon$1) {
	    var this$1$1 = this;

	    var array = [];
	    array.push('(' + extract$1.linestring.apply(this, [polygon$1._shell]) + ')');
	    for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {
	      array.push('(' + extract$1.linestring.apply(this$1$1, [polygon$1._holes[i]]) + ')');
	    }
	    return array.join(',')
	  },

	  /**
	   * Return an array of polygon arrays from a multipolygon.
	   *
	   * @param {MultiPolygon} multipolygon
	   * @return {String} An array of polygon arrays representing the multipolygon.
	   */
	  multipolygon: function multipolygon (multipolygon$1) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {
	      array.push('(' + extract$1.polygon.apply(this$1$1, [multipolygon$1._geometries[i]]) + ')');
	    }
	    return array.join(',')
	  },

	  /**
	   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
	   * geometrycollection.
	   *
	   * @param {GeometryCollection} collection
	   * @return {String} internal WKT representation of the collection.
	   */
	  geometrycollection: function geometrycollection (collection) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0, len = collection._geometries.length; i < len; ++i) {
	      array.push(this$1$1.extractGeometry(collection._geometries[i]));
	    }
	    return array.join(',')
	  }
	};

	/**
	 * Object with properties corresponding to the geometry types. Property values
	 * are functions that do the actual parsing.
	 * @private
	 */
	var parse$1$1 = {
	  /**
	   * Return point geometry given a point WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the point.
	   * @return {Point} A point geometry.
	   * @private
	   */
	  point: function point (str) {
	    if (str === undefined) {
	      return this.geometryFactory.createPoint()
	    }

	    var coords = str.trim().split(regExes.spaces);
	    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),
	      Number.parseFloat(coords[1])))
	  },

	  /**
	   * Return a multipoint geometry given a multipoint WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the multipoint.
	   * @return {Point} A multipoint feature.
	   * @private
	   */
	  multipoint: function multipoint (str) {
	    var this$1$1 = this;

	    if (str === undefined) {
	      return this.geometryFactory.createMultiPoint()
	    }

	    var point;
	    var points = str.trim().split(',');
	    var components = [];
	    for (var i = 0, len = points.length; i < len; ++i) {
	      point = points[i].replace(regExes.trimParens, '$1');
	      components.push(parse$1$1.point.apply(this$1$1, [point]));
	    }
	    return this.geometryFactory.createMultiPoint(components)
	  },

	  /**
	   * Return a linestring geometry given a linestring WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the linestring.
	   * @return {LineString} A linestring geometry.
	   * @private
	   */
	  linestring: function linestring (str) {
	    if (str === undefined) {
	      return this.geometryFactory.createLineString()
	    }

	    var points = str.trim().split(',');
	    var components = [];
	    var coords;
	    for (var i = 0, len = points.length; i < len; ++i) {
	      coords = points[i].trim().split(regExes.spaces);
	      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
	    }
	    return this.geometryFactory.createLineString(components)
	  },

	  /**
	   * Return a linearring geometry given a linearring WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the linearring.
	   * @return {LinearRing} A linearring geometry.
	   * @private
	   */
	  linearring: function linearring (str) {
	    if (str === undefined) {
	      return this.geometryFactory.createLinearRing()
	    }

	    var points = str.trim().split(',');
	    var components = [];
	    var coords;
	    for (var i = 0, len = points.length; i < len; ++i) {
	      coords = points[i].trim().split(regExes.spaces);
	      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
	    }
	    return this.geometryFactory.createLinearRing(components)
	  },

	  /**
	   * Return a multilinestring geometry given a multilinestring WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the multilinestring.
	   * @return {MultiLineString} A multilinestring geometry.
	   * @private
	   */
	  multilinestring: function multilinestring (str) {
	    var this$1$1 = this;

	    if (str === undefined) {
	      return this.geometryFactory.createMultiLineString()
	    }

	    var line;
	    var lines = str.trim().split(regExes.parenComma);
	    var components = [];
	    for (var i = 0, len = lines.length; i < len; ++i) {
	      line = lines[i].replace(regExes.trimParens, '$1');
	      components.push(parse$1$1.linestring.apply(this$1$1, [line]));
	    }
	    return this.geometryFactory.createMultiLineString(components)
	  },

	  /**
	   * Return a polygon geometry given a polygon WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the polygon.
	   * @return {Polygon} A polygon geometry.
	   * @private
	   */
	  polygon: function polygon (str) {
	    var this$1$1 = this;

	    if (str === undefined) {
	      return this.geometryFactory.createPolygon()
	    }

	    var ring, linestring, linearring;
	    var rings = str.trim().split(regExes.parenComma);
	    var shell;
	    var holes = [];
	    for (var i = 0, len = rings.length; i < len; ++i) {
	      ring = rings[i].replace(regExes.trimParens, '$1');
	      linestring = parse$1$1.linestring.apply(this$1$1, [ring]);
	      linearring = this$1$1.geometryFactory.createLinearRing(linestring._points);
	      if (i === 0) {
	        shell = linearring;
	      } else {
	        holes.push(linearring);
	      }
	    }
	    return this.geometryFactory.createPolygon(shell, holes)
	  },

	  /**
	   * Return a multipolygon geometry given a multipolygon WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the multipolygon.
	   * @return {MultiPolygon} A multipolygon geometry.
	   * @private
	   */
	  multipolygon: function multipolygon (str) {
	    var this$1$1 = this;

	    if (str === undefined) {
	      return this.geometryFactory.createMultiPolygon()
	    }

	    var polygon;
	    var polygons = str.trim().split(regExes.doubleParenComma);
	    var components = [];
	    for (var i = 0, len = polygons.length; i < len; ++i) {
	      polygon = polygons[i].replace(regExes.trimParens, '$1');
	      components.push(parse$1$1.polygon.apply(this$1$1, [polygon]));
	    }
	    return this.geometryFactory.createMultiPolygon(components)
	  },

	  /**
	   * Return a geometrycollection given a geometrycollection WKT fragment.
	   *
	   * @param {String} str A WKT fragment representing the geometrycollection.
	   * @return {GeometryCollection}
	   * @private
	   */
	  geometrycollection: function geometrycollection (str) {
	    var this$1$1 = this;

	    if (str === undefined) {
	      return this.geometryFactory.createGeometryCollection()
	    }

	    // separate components of the collection with |
	    str = str.replace(/,\s*([A-Za-z])/g, '|$1');
	    var wktArray = str.trim().split('|');
	    var components = [];
	    for (var i = 0, len = wktArray.length; i < len; ++i) {
	      components.push(this$1$1.read(wktArray[i]));
	    }
	    return this.geometryFactory.createGeometryCollection(components)
	  }
	};

	/**
	 * Writes the Well-Known Text representation of a {@link Geometry}. The
	 * Well-Known Text format is defined in the <A
	 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
	 * Specification for SQL</A>.
	 * <p>
	 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
	 * model. Only the maximum number of decimal places necessary to represent the
	 * ordinates to the required precision will be output.
	 * <p>
	 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
	 * Under the spec, rings are output as <code>LINESTRING</code>s.
	 */

	/**
	 * @param {GeometryFactory} geometryFactory
	 * @constructor
	 */
	var WKTWriter = function WKTWriter (geometryFactory) {
	  this.parser = new WKTParser(geometryFactory);
	};

	/**
	 * Converts a <code>Geometry</code> to its Well-known Text representation.
	 *
	 * @param {Geometry} geometry a <code>Geometry</code> to process.
	 * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
	 *       Features Specification).
	 * @memberof WKTWriter
	 */
	WKTWriter.prototype.write = function write (geometry) {
	  return this.parser.write(geometry)
	};
	/**
	 * Generates the WKT for a <tt>LINESTRING</tt> specified by two
	 * {@link Coordinate}s.
	 *
	 * @param p0 the first coordinate.
	 * @param p1 the second coordinate.
	 *
	 * @return the WKT.
	 * @private
	 */
	WKTWriter.toLineString = function toLineString (p0, p1) {
	  if (arguments.length !== 2) {
	    throw new Error('Not implemented')
	  }
	  return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'
	};

	var RuntimeException = (function (Error) {
	  function RuntimeException (message) {
	    Error.call(this, message);
	    this.name = 'RuntimeException';
	    this.message = message;
	    this.stack = (new Error()).stack;
	  }

	  if ( Error ) RuntimeException.__proto__ = Error;
	  RuntimeException.prototype = Object.create( Error && Error.prototype );
	  RuntimeException.prototype.constructor = RuntimeException;

	  return RuntimeException;
	}(Error));

	var AssertionFailedException = (function (RuntimeException$$1) {
	  function AssertionFailedException () {
	    RuntimeException$$1.call(this);
	    if (arguments.length === 0) {
	      RuntimeException$$1.call(this);
	    } else if (arguments.length === 1) {
	      var message = arguments[0];
	      RuntimeException$$1.call(this, message);
	    }
	  }

	  if ( RuntimeException$$1 ) AssertionFailedException.__proto__ = RuntimeException$$1;
	  AssertionFailedException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );
	  AssertionFailedException.prototype.constructor = AssertionFailedException;
	  AssertionFailedException.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  AssertionFailedException.prototype.getClass = function getClass () {
	    return AssertionFailedException
	  };

	  return AssertionFailedException;
	}(RuntimeException));

	var Assert = function Assert () {};

	Assert.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Assert.prototype.getClass = function getClass () {
	  return Assert
	};
	Assert.shouldNeverReachHere = function shouldNeverReachHere () {
	  if (arguments.length === 0) {
	    Assert.shouldNeverReachHere(null);
	  } else if (arguments.length === 1) {
	    var message = arguments[0];
	    throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))
	  }
	};
	Assert.isTrue = function isTrue () {
	  var assertion;
	  var message;
	  if (arguments.length === 1) {
	    assertion = arguments[0];
	    Assert.isTrue(assertion, null);
	  } else if (arguments.length === 2) {
	    assertion = arguments[0];
	    message = arguments[1];
	    if (!assertion) {
	      if (message === null) {
	        throw new AssertionFailedException()
	      } else {
	        throw new AssertionFailedException(message)
	      }
	    }
	  }
	};
	Assert.equals = function equals () {
	  var expectedValue;
	  var actualValue;
	  var message;
	  if (arguments.length === 2) {
	    expectedValue = arguments[0];
	    actualValue = arguments[1];
	    Assert.equals(expectedValue, actualValue, null);
	  } else if (arguments.length === 3) {
	    expectedValue = arguments[0];
	    actualValue = arguments[1];
	    message = arguments[2];
	    if (!actualValue.equals(expectedValue)) {
	      throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))
	    }
	  }
	};

	var LineIntersector = function LineIntersector () {
	  this._result = null;
	  this._inputLines = Array(2).fill().map(function () { return Array(2); });
	  this._intPt = new Array(2).fill(null);
	  this._intLineIndex = null;
	  this._isProper = null;
	  this._pa = null;
	  this._pb = null;
	  this._precisionModel = null;
	  this._intPt[0] = new Coordinate();
	  this._intPt[1] = new Coordinate();
	  this._pa = this._intPt[0];
	  this._pb = this._intPt[1];
	  this._result = 0;
	};

	var staticAccessors$10 = { DONT_INTERSECT: { configurable: true },DO_INTERSECT: { configurable: true },COLLINEAR: { configurable: true },NO_INTERSECTION: { configurable: true },POINT_INTERSECTION: { configurable: true },COLLINEAR_INTERSECTION: { configurable: true } };
	LineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment (segmentIndex, intIndex) {
	  this.computeIntLineIndex();
	  return this._intLineIndex[segmentIndex][intIndex]
	};
	LineIntersector.prototype.getTopologySummary = function getTopologySummary () {
	  var catBuf = new StringBuffer();
	  if (this.isEndPoint()) { catBuf.append(' endpoint'); }
	  if (this._isProper) { catBuf.append(' proper'); }
	  if (this.isCollinear()) { catBuf.append(' collinear'); }
	  return catBuf.toString()
	};
	LineIntersector.prototype.computeIntersection = function computeIntersection (p1, p2, p3, p4) {
	  this._inputLines[0][0] = p1;
	  this._inputLines[0][1] = p2;
	  this._inputLines[1][0] = p3;
	  this._inputLines[1][1] = p4;
	  this._result = this.computeIntersect(p1, p2, p3, p4);
	};
	LineIntersector.prototype.getIntersectionNum = function getIntersectionNum () {
	  return this._result
	};
	LineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex () {
	  if (arguments.length === 0) {
	    if (this._intLineIndex === null) {
	      this._intLineIndex = Array(2).fill().map(function () { return Array(2); });
	      this.computeIntLineIndex(0);
	      this.computeIntLineIndex(1);
	    }
	  } else if (arguments.length === 1) {
	    var segmentIndex = arguments[0];
	    var dist0 = this.getEdgeDistance(segmentIndex, 0);
	    var dist1 = this.getEdgeDistance(segmentIndex, 1);
	    if (dist0 > dist1) {
	      this._intLineIndex[segmentIndex][0] = 0;
	      this._intLineIndex[segmentIndex][1] = 1;
	    } else {
	      this._intLineIndex[segmentIndex][0] = 1;
	      this._intLineIndex[segmentIndex][1] = 0;
	    }
	  }
	};
	LineIntersector.prototype.isProper = function isProper () {
	  return this.hasIntersection() && this._isProper
	};
	LineIntersector.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {
	  this._precisionModel = precisionModel;
	};
	LineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    if (this.isInteriorIntersection(0)) { return true }
	    if (this.isInteriorIntersection(1)) { return true }
	    return false
	  } else if (arguments.length === 1) {
	    var inputLineIndex = arguments[0];
	    for (var i = 0; i < this._result; i++) {
	      if (!(this$1$1._intPt[i].equals2D(this$1$1._inputLines[inputLineIndex][0]) || this$1$1._intPt[i].equals2D(this$1$1._inputLines[inputLineIndex][1]))) {
	        return true
	      }
	    }
	    return false
	  }
	};
	LineIntersector.prototype.getIntersection = function getIntersection (intIndex) {
	  return this._intPt[intIndex]
	};
	LineIntersector.prototype.isEndPoint = function isEndPoint () {
	  return this.hasIntersection() && !this._isProper
	};
	LineIntersector.prototype.hasIntersection = function hasIntersection () {
	  return this._result !== LineIntersector.NO_INTERSECTION
	};
	LineIntersector.prototype.getEdgeDistance = function getEdgeDistance (segmentIndex, intIndex) {
	  var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
	  return dist
	};
	LineIntersector.prototype.isCollinear = function isCollinear () {
	  return this._result === LineIntersector.COLLINEAR_INTERSECTION
	};
	LineIntersector.prototype.toString = function toString () {
	  return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
	};
	LineIntersector.prototype.getEndpoint = function getEndpoint (segmentIndex, ptIndex) {
	  return this._inputLines[segmentIndex][ptIndex]
	};
	LineIntersector.prototype.isIntersection = function isIntersection (pt) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._result; i++) {
	    if (this$1$1._intPt[i].equals2D(pt)) {
	      return true
	    }
	  }
	  return false
	};
	LineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment (segmentIndex, intIndex) {
	  this.computeIntLineIndex();
	  return this._intPt[this._intLineIndex[segmentIndex][intIndex]]
	};
	LineIntersector.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	LineIntersector.prototype.getClass = function getClass () {
	  return LineIntersector
	};
	LineIntersector.computeEdgeDistance = function computeEdgeDistance (p, p0, p1) {
	  var dx = Math.abs(p1.x - p0.x);
	  var dy = Math.abs(p1.y - p0.y);
	  var dist = -1.0;
	  if (p.equals(p0)) {
	    dist = 0.0;
	  } else if (p.equals(p1)) {
	    if (dx > dy) { dist = dx; } else { dist = dy; }
	  } else {
	    var pdx = Math.abs(p.x - p0.x);
	    var pdy = Math.abs(p.y - p0.y);
	    if (dx > dy) { dist = pdx; } else { dist = pdy; }
	    if (dist === 0.0 && !p.equals(p0)) {
	      dist = Math.max(pdx, pdy);
	    }
	  }
	  Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
	  return dist
	};
	LineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance (p, p1, p2) {
	  var dx = p.x - p1.x;
	  var dy = p.y - p1.y;
	  var dist = Math.sqrt(dx * dx + dy * dy);
	  Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
	  return dist
	};
	staticAccessors$10.DONT_INTERSECT.get = function () { return 0 };
	staticAccessors$10.DO_INTERSECT.get = function () { return 1 };
	staticAccessors$10.COLLINEAR.get = function () { return 2 };
	staticAccessors$10.NO_INTERSECTION.get = function () { return 0 };
	staticAccessors$10.POINT_INTERSECTION.get = function () { return 1 };
	staticAccessors$10.COLLINEAR_INTERSECTION.get = function () { return 2 };

	Object.defineProperties( LineIntersector, staticAccessors$10 );

	var RobustLineIntersector = (function (LineIntersector$$1) {
	  function RobustLineIntersector () {
	    LineIntersector$$1.apply(this, arguments);
	  }

	  if ( LineIntersector$$1 ) RobustLineIntersector.__proto__ = LineIntersector$$1;
	  RobustLineIntersector.prototype = Object.create( LineIntersector$$1 && LineIntersector$$1.prototype );
	  RobustLineIntersector.prototype.constructor = RobustLineIntersector;

	  RobustLineIntersector.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes (intPt) {
	    var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
	    var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
	    return env0.contains(intPt) && env1.contains(intPt)
	  };
	  RobustLineIntersector.prototype.computeIntersection = function computeIntersection () {
	    if (arguments.length === 3) {
	      var p = arguments[0];
	      var p1 = arguments[1];
	      var p2 = arguments[2];
	      this._isProper = false;
	      if (Envelope.intersects(p1, p2, p)) {
	        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
	          this._isProper = true;
	          if (p.equals(p1) || p.equals(p2)) {
	            this._isProper = false;
	          }
	          this._result = LineIntersector$$1.POINT_INTERSECTION;
	          return null
	        }
	      }
	      this._result = LineIntersector$$1.NO_INTERSECTION;
	    } else { return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments) }
	  };
	  RobustLineIntersector.prototype.normalizeToMinimum = function normalizeToMinimum (n1, n2, n3, n4, normPt) {
	    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
	    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
	    n1.x -= normPt.x;
	    n1.y -= normPt.y;
	    n2.x -= normPt.x;
	    n2.y -= normPt.y;
	    n3.x -= normPt.x;
	    n3.y -= normPt.y;
	    n4.x -= normPt.x;
	    n4.y -= normPt.y;
	  };
	  RobustLineIntersector.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection (p1, p2, q1, q2) {
	    var intPt = null;
	    try {
	      intPt = HCoordinate.intersection(p1, p2, q1, q2);
	    } catch (e) {
	      if (e instanceof NotRepresentableException) {
	        intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
	      } else { throw e }
	    } finally {}
	    return intPt
	  };
	  RobustLineIntersector.prototype.intersection = function intersection (p1, p2, q1, q2) {
	    var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
	    if (!this.isInSegmentEnvelopes(intPt)) {
	      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
	    }
	    if (this._precisionModel !== null) {
	      this._precisionModel.makePrecise(intPt);
	    }
	    return intPt
	  };
	  RobustLineIntersector.prototype.smallestInAbsValue = function smallestInAbsValue (x1, x2, x3, x4) {
	    var x = x1;
	    var xabs = Math.abs(x);
	    if (Math.abs(x2) < xabs) {
	      x = x2;
	      xabs = Math.abs(x2);
	    }
	    if (Math.abs(x3) < xabs) {
	      x = x3;
	      xabs = Math.abs(x3);
	    }
	    if (Math.abs(x4) < xabs) {
	      x = x4;
	    }
	    return x
	  };
	  RobustLineIntersector.prototype.checkDD = function checkDD (p1, p2, q1, q2, intPt) {
	    var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
	    var isIn = this.isInSegmentEnvelopes(intPtDD);
	    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
	    if (intPt.distance(intPtDD) > 0.0001) {
	      System.out.println('Distance = ' + intPt.distance(intPtDD));
	    }
	  };
	  RobustLineIntersector.prototype.intersectionWithNormalization = function intersectionWithNormalization (p1, p2, q1, q2) {
	    var n1 = new Coordinate(p1);
	    var n2 = new Coordinate(p2);
	    var n3 = new Coordinate(q1);
	    var n4 = new Coordinate(q2);
	    var normPt = new Coordinate();
	    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
	    var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
	    intPt.x += normPt.x;
	    intPt.y += normPt.y;
	    return intPt
	  };
	  RobustLineIntersector.prototype.computeCollinearIntersection = function computeCollinearIntersection (p1, p2, q1, q2) {
	    var p1q1p2 = Envelope.intersects(p1, p2, q1);
	    var p1q2p2 = Envelope.intersects(p1, p2, q2);
	    var q1p1q2 = Envelope.intersects(q1, q2, p1);
	    var q1p2q2 = Envelope.intersects(q1, q2, p2);
	    if (p1q1p2 && p1q2p2) {
	      this._intPt[0] = q1;
	      this._intPt[1] = q2;
	      return LineIntersector$$1.COLLINEAR_INTERSECTION
	    }
	    if (q1p1q2 && q1p2q2) {
	      this._intPt[0] = p1;
	      this._intPt[1] = p2;
	      return LineIntersector$$1.COLLINEAR_INTERSECTION
	    }
	    if (p1q1p2 && q1p1q2) {
	      this._intPt[0] = q1;
	      this._intPt[1] = p1;
	      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
	    }
	    if (p1q1p2 && q1p2q2) {
	      this._intPt[0] = q1;
	      this._intPt[1] = p2;
	      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
	    }
	    if (p1q2p2 && q1p1q2) {
	      this._intPt[0] = q2;
	      this._intPt[1] = p1;
	      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
	    }
	    if (p1q2p2 && q1p2q2) {
	      this._intPt[0] = q2;
	      this._intPt[1] = p2;
	      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION
	    }
	    return LineIntersector$$1.NO_INTERSECTION
	  };
	  RobustLineIntersector.prototype.normalizeToEnvCentre = function normalizeToEnvCentre (n00, n01, n10, n11, normPt) {
	    var minX0 = n00.x < n01.x ? n00.x : n01.x;
	    var minY0 = n00.y < n01.y ? n00.y : n01.y;
	    var maxX0 = n00.x > n01.x ? n00.x : n01.x;
	    var maxY0 = n00.y > n01.y ? n00.y : n01.y;
	    var minX1 = n10.x < n11.x ? n10.x : n11.x;
	    var minY1 = n10.y < n11.y ? n10.y : n11.y;
	    var maxX1 = n10.x > n11.x ? n10.x : n11.x;
	    var maxY1 = n10.y > n11.y ? n10.y : n11.y;
	    var intMinX = minX0 > minX1 ? minX0 : minX1;
	    var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
	    var intMinY = minY0 > minY1 ? minY0 : minY1;
	    var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
	    var intMidX = (intMinX + intMaxX) / 2.0;
	    var intMidY = (intMinY + intMaxY) / 2.0;
	    normPt.x = intMidX;
	    normPt.y = intMidY;
	    n00.x -= normPt.x;
	    n00.y -= normPt.y;
	    n01.x -= normPt.x;
	    n01.y -= normPt.y;
	    n10.x -= normPt.x;
	    n10.y -= normPt.y;
	    n11.x -= normPt.x;
	    n11.y -= normPt.y;
	  };
	  RobustLineIntersector.prototype.computeIntersect = function computeIntersect (p1, p2, q1, q2) {
	    this._isProper = false;
	    if (!Envelope.intersects(p1, p2, q1, q2)) { return LineIntersector$$1.NO_INTERSECTION }
	    var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
	    var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
	    if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
	      return LineIntersector$$1.NO_INTERSECTION
	    }
	    var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
	    var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
	    if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
	      return LineIntersector$$1.NO_INTERSECTION
	    }
	    var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
	    if (collinear) {
	      return this.computeCollinearIntersection(p1, p2, q1, q2)
	    }
	    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
	      this._isProper = false;
	      if (p1.equals2D(q1) || p1.equals2D(q2)) {
	        this._intPt[0] = p1;
	      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
	        this._intPt[0] = p2;
	      } else if (Pq1 === 0) {
	        this._intPt[0] = new Coordinate(q1);
	      } else if (Pq2 === 0) {
	        this._intPt[0] = new Coordinate(q2);
	      } else if (Qp1 === 0) {
	        this._intPt[0] = new Coordinate(p1);
	      } else if (Qp2 === 0) {
	        this._intPt[0] = new Coordinate(p2);
	      }
	    } else {
	      this._isProper = true;
	      this._intPt[0] = this.intersection(p1, p2, q1, q2);
	    }
	    return LineIntersector$$1.POINT_INTERSECTION
	  };
	  RobustLineIntersector.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  RobustLineIntersector.prototype.getClass = function getClass () {
	    return RobustLineIntersector
	  };
	  RobustLineIntersector.nearestEndpoint = function nearestEndpoint (p1, p2, q1, q2) {
	    var nearestPt = p1;
	    var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
	    var dist = CGAlgorithms.distancePointLine(p2, q1, q2);
	    if (dist < minDist) {
	      minDist = dist;
	      nearestPt = p2;
	    }
	    dist = CGAlgorithms.distancePointLine(q1, p1, p2);
	    if (dist < minDist) {
	      minDist = dist;
	      nearestPt = q1;
	    }
	    dist = CGAlgorithms.distancePointLine(q2, p1, p2);
	    if (dist < minDist) {
	      minDist = dist;
	      nearestPt = q2;
	    }
	    return nearestPt
	  };

	  return RobustLineIntersector;
	}(LineIntersector));

	var RobustDeterminant = function RobustDeterminant () {};

	RobustDeterminant.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	RobustDeterminant.prototype.getClass = function getClass () {
	  return RobustDeterminant
	};
	RobustDeterminant.orientationIndex = function orientationIndex (p1, p2, q) {
	  var dx1 = p2.x - p1.x;
	  var dy1 = p2.y - p1.y;
	  var dx2 = q.x - p2.x;
	  var dy2 = q.y - p2.y;
	  return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2)
	};
	RobustDeterminant.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {
	  var sign = null;
	  var swap = null;
	  var k = null;
	  sign = 1;
	  if (x1 === 0.0 || y2 === 0.0) {
	    if (y1 === 0.0 || x2 === 0.0) {
	      return 0
	    } else if (y1 > 0) {
	      if (x2 > 0) {
	        return -sign
	      } else {
	        return sign
	      }
	    } else {
	      if (x2 > 0) {
	        return sign
	      } else {
	        return -sign
	      }
	    }
	  }
	  if (y1 === 0.0 || x2 === 0.0) {
	    if (y2 > 0) {
	      if (x1 > 0) {
	        return sign
	      } else {
	        return -sign
	      }
	    } else {
	      if (x1 > 0) {
	        return -sign
	      } else {
	        return sign
	      }
	    }
	  }
	  if (y1 > 0.0) {
	    if (y2 > 0.0) {
	      if (y1 <= y2) ; else {
	        sign = -sign;
	        swap = x1;
	        x1 = x2;
	        x2 = swap;
	        swap = y1;
	        y1 = y2;
	        y2 = swap;
	      }
	    } else {
	      if (y1 <= -y2) {
	        sign = -sign;
	        x2 = -x2;
	        y2 = -y2;
	      } else {
	        swap = x1;
	        x1 = -x2;
	        x2 = swap;
	        swap = y1;
	        y1 = -y2;
	        y2 = swap;
	      }
	    }
	  } else {
	    if (y2 > 0.0) {
	      if (-y1 <= y2) {
	        sign = -sign;
	        x1 = -x1;
	        y1 = -y1;
	      } else {
	        swap = -x1;
	        x1 = x2;
	        x2 = swap;
	        swap = -y1;
	        y1 = y2;
	        y2 = swap;
	      }
	    } else {
	      if (y1 >= y2) {
	        x1 = -x1;
	        y1 = -y1;
	        x2 = -x2;
	        y2 = -y2;
	      } else {
	        sign = -sign;
	        swap = -x1;
	        x1 = -x2;
	        x2 = swap;
	        swap = -y1;
	        y1 = -y2;
	        y2 = swap;
	      }
	    }
	  }
	  if (x1 > 0.0) {
	    if (x2 > 0.0) {
	      if (x1 <= x2) ; else {
	        return sign
	      }
	    } else {
	      return sign
	    }
	  } else {
	    if (x2 > 0.0) {
	      return -sign
	    } else {
	      if (x1 >= x2) {
	        sign = -sign;
	        x1 = -x1;
	        x2 = -x2;
	      } else {
	        return -sign
	      }
	    }
	  }
	  while (true) {
	    k = Math.floor(x2 / x1);
	    x2 = x2 - k * x1;
	    y2 = y2 - k * y1;
	    if (y2 < 0.0) {
	      return -sign
	    }
	    if (y2 > y1) {
	      return sign
	    }
	    if (x1 > x2 + x2) {
	      if (y1 < y2 + y2) {
	        return sign
	      }
	    } else {
	      if (y1 > y2 + y2) {
	        return -sign
	      } else {
	        x2 = x1 - x2;
	        y2 = y1 - y2;
	        sign = -sign;
	      }
	    }
	    if (y2 === 0.0) {
	      if (x2 === 0.0) {
	        return 0
	      } else {
	        return -sign
	      }
	    }
	    if (x2 === 0.0) {
	      return sign
	    }
	    k = Math.floor(x1 / x2);
	    x1 = x1 - k * x2;
	    y1 = y1 - k * y2;
	    if (y1 < 0.0) {
	      return sign
	    }
	    if (y1 > y2) {
	      return -sign
	    }
	    if (x2 > x1 + x1) {
	      if (y2 < y1 + y1) {
	        return -sign
	      }
	    } else {
	      if (y2 > y1 + y1) {
	        return sign
	      } else {
	        x1 = x2 - x1;
	        y1 = y2 - y1;
	        sign = -sign;
	      }
	    }
	    if (y1 === 0.0) {
	      if (x1 === 0.0) {
	        return 0
	      } else {
	        return sign
	      }
	    }
	    if (x1 === 0.0) {
	      return -sign
	    }
	  }
	};

	var RayCrossingCounter = function RayCrossingCounter () {
	  this._p = null;
	  this._crossingCount = 0;
	  this._isPointOnSegment = false;
	  var p = arguments[0];
	  this._p = p;
	};
	RayCrossingCounter.prototype.countSegment = function countSegment (p1, p2) {
	  if (p1.x < this._p.x && p2.x < this._p.x) { return null }
	  if (this._p.x === p2.x && this._p.y === p2.y) {
	    this._isPointOnSegment = true;
	    return null
	  }
	  if (p1.y === this._p.y && p2.y === this._p.y) {
	    var minx = p1.x;
	    var maxx = p2.x;
	    if (minx > maxx) {
	      minx = p2.x;
	      maxx = p1.x;
	    }
	    if (this._p.x >= minx && this._p.x <= maxx) {
	      this._isPointOnSegment = true;
	    }
	    return null
	  }
	  if ((p1.y > this._p.y && p2.y <= this._p.y) || (p2.y > this._p.y && p1.y <= this._p.y)) {
	    var x1 = p1.x - this._p.x;
	    var y1 = p1.y - this._p.y;
	    var x2 = p2.x - this._p.x;
	    var y2 = p2.y - this._p.y;
	    var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
	    if (xIntSign === 0.0) {
	      this._isPointOnSegment = true;
	      return null
	    }
	    if (y2 < y1) { xIntSign = -xIntSign; }
	    if (xIntSign > 0.0) {
	      this._crossingCount++;
	    }
	  }
	};
	RayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon () {
	  return this.getLocation() !== Location.EXTERIOR
	};
	RayCrossingCounter.prototype.getLocation = function getLocation () {
	  if (this._isPointOnSegment) { return Location.BOUNDARY }
	  if (this._crossingCount % 2 === 1) {
	    return Location.INTERIOR
	  }
	  return Location.EXTERIOR
	};
	RayCrossingCounter.prototype.isOnSegment = function isOnSegment () {
	  return this._isPointOnSegment
	};
	RayCrossingCounter.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	RayCrossingCounter.prototype.getClass = function getClass () {
	  return RayCrossingCounter
	};
	RayCrossingCounter.locatePointInRing = function locatePointInRing () {
	  if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
	    var p = arguments[0];
	    var ring = arguments[1];
	    var counter = new RayCrossingCounter(p);
	    var p1 = new Coordinate();
	    var p2 = new Coordinate();
	    for (var i = 1; i < ring.size(); i++) {
	      ring.getCoordinate(i, p1);
	      ring.getCoordinate(i - 1, p2);
	      counter.countSegment(p1, p2);
	      if (counter.isOnSegment()) { return counter.getLocation() }
	    }
	    return counter.getLocation()
	  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
	    var p$1 = arguments[0];
	    var ring$1 = arguments[1];
	    var counter$1 = new RayCrossingCounter(p$1);
	    for (var i$1 = 1; i$1 < ring$1.length; i$1++) {
	      var p1$1 = ring$1[i$1];
	      var p2$1 = ring$1[i$1 - 1];
	      counter$1.countSegment(p1$1, p2$1);
	      if (counter$1.isOnSegment()) { return counter$1.getLocation() }
	    }
	    return counter$1.getLocation()
	  }
	};

	var CGAlgorithms = function CGAlgorithms () {};

	var staticAccessors$3 = { CLOCKWISE: { configurable: true },RIGHT: { configurable: true },COUNTERCLOCKWISE: { configurable: true },LEFT: { configurable: true },COLLINEAR: { configurable: true },STRAIGHT: { configurable: true } };

	CGAlgorithms.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CGAlgorithms.prototype.getClass = function getClass () {
	  return CGAlgorithms
	};
	CGAlgorithms.orientationIndex = function orientationIndex (p1, p2, q) {
	  return CGAlgorithmsDD.orientationIndex(p1, p2, q)
	};
	CGAlgorithms.signedArea = function signedArea () {
	  if (arguments[0] instanceof Array) {
	    var ring = arguments[0];
	    if (ring.length < 3) { return 0.0 }
	    var sum = 0.0;
	    var x0 = ring[0].x;
	    for (var i = 1; i < ring.length - 1; i++) {
	      var x = ring[i].x - x0;
	      var y1 = ring[i + 1].y;
	      var y2 = ring[i - 1].y;
	      sum += x * (y2 - y1);
	    }
	    return sum / 2.0
	  } else if (hasInterface(arguments[0], CoordinateSequence)) {
	    var ring$1 = arguments[0];
	    var n = ring$1.size();
	    if (n < 3) { return 0.0 }
	    var p0 = new Coordinate();
	    var p1 = new Coordinate();
	    var p2 = new Coordinate();
	    ring$1.getCoordinate(0, p1);
	    ring$1.getCoordinate(1, p2);
	    var x0$1 = p1.x;
	    p2.x -= x0$1;
	    var sum$1 = 0.0;
	    for (var i$1 = 1; i$1 < n - 1; i$1++) {
	      p0.y = p1.y;
	      p1.x = p2.x;
	      p1.y = p2.y;
	      ring$1.getCoordinate(i$1 + 1, p2);
	      p2.x -= x0$1;
	      sum$1 += p1.x * (p0.y - p2.y);
	    }
	    return sum$1 / 2.0
	  }
	};
	CGAlgorithms.distanceLineLine = function distanceLineLine (A, B, C, D) {
	  if (A.equals(B)) { return CGAlgorithms.distancePointLine(A, C, D) }
	  if (C.equals(D)) { return CGAlgorithms.distancePointLine(D, A, B) }
	  var noIntersection = false;
	  if (!Envelope.intersects(A, B, C, D)) {
	    noIntersection = true;
	  } else {
	    var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
	    if (denom === 0) {
	      noIntersection = true;
	    } else {
	      var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
	      var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
	      var s = sNum / denom;
	      var r = rNumb / denom;
	      if (r < 0 || r > 1 || s < 0 || s > 1) {
	        noIntersection = true;
	      }
	    }
	  }
	  if (noIntersection) {
	    return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B))
	  }
	  return 0.0
	};
	CGAlgorithms.isPointInRing = function isPointInRing (p, ring) {
	  return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR
	};
	CGAlgorithms.computeLength = function computeLength (pts) {
	  var n = pts.size();
	  if (n <= 1) { return 0.0 }
	  var len = 0.0;
	  var p = new Coordinate();
	  pts.getCoordinate(0, p);
	  var x0 = p.x;
	  var y0 = p.y;
	  for (var i = 1; i < n; i++) {
	    pts.getCoordinate(i, p);
	    var x1 = p.x;
	    var y1 = p.y;
	    var dx = x1 - x0;
	    var dy = y1 - y0;
	    len += Math.sqrt(dx * dx + dy * dy);
	    x0 = x1;
	    y0 = y1;
	  }
	  return len
	};
	CGAlgorithms.isCCW = function isCCW (ring) {
	  var nPts = ring.length - 1;
	  if (nPts < 3) { throw new IllegalArgumentException() }
	  var hiPt = ring[0];
	  var hiIndex = 0;
	  for (var i = 1; i <= nPts; i++) {
	    var p = ring[i];
	    if (p.y > hiPt.y) {
	      hiPt = p;
	      hiIndex = i;
	    }
	  }
	  var iPrev = hiIndex;
	  do {
	    iPrev = iPrev - 1;
	    if (iPrev < 0) { iPrev = nPts; }
	  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)
	  var iNext = hiIndex;
	  do {
	    iNext = (iNext + 1) % nPts;
	  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)
	  var prev = ring[iPrev];
	  var next = ring[iNext];
	  if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) { return false }
	  var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
	  var isCCW = false;
	  if (disc === 0) {
	    isCCW = prev.x > next.x;
	  } else {
	    isCCW = disc > 0;
	  }
	  return isCCW
	};
	CGAlgorithms.locatePointInRing = function locatePointInRing (p, ring) {
	  return RayCrossingCounter.locatePointInRing(p, ring)
	};
	CGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular (p, A, B) {
	  var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
	  var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
	  return Math.abs(s) * Math.sqrt(len2)
	};
	CGAlgorithms.computeOrientation = function computeOrientation (p1, p2, q) {
	  return CGAlgorithms.orientationIndex(p1, p2, q)
	};
	CGAlgorithms.distancePointLine = function distancePointLine () {
	  if (arguments.length === 2) {
	    var p = arguments[0];
	    var line = arguments[1];
	    if (line.length === 0) { throw new IllegalArgumentException() }
	    var minDistance = p.distance(line[0]);
	    for (var i = 0; i < line.length - 1; i++) {
	      var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
	      if (dist < minDistance) {
	        minDistance = dist;
	      }
	    }
	    return minDistance
	  } else if (arguments.length === 3) {
	    var p$1 = arguments[0];
	    var A = arguments[1];
	    var B = arguments[2];
	    if (A.x === B.x && A.y === B.y) { return p$1.distance(A) }
	    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
	    var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;
	    if (r <= 0.0) { return p$1.distance(A) }
	    if (r >= 1.0) { return p$1.distance(B) }
	    var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;
	    return Math.abs(s) * Math.sqrt(len2)
	  }
	};
	CGAlgorithms.isOnLine = function isOnLine (p, pt) {
	  var lineIntersector = new RobustLineIntersector();
	  for (var i = 1; i < pt.length; i++) {
	    var p0 = pt[i - 1];
	    var p1 = pt[i];
	    lineIntersector.computeIntersection(p, p0, p1);
	    if (lineIntersector.hasIntersection()) {
	      return true
	    }
	  }
	  return false
	};
	staticAccessors$3.CLOCKWISE.get = function () { return -1 };
	staticAccessors$3.RIGHT.get = function () { return CGAlgorithms.CLOCKWISE };
	staticAccessors$3.COUNTERCLOCKWISE.get = function () { return 1 };
	staticAccessors$3.LEFT.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };
	staticAccessors$3.COLLINEAR.get = function () { return 0 };
	staticAccessors$3.STRAIGHT.get = function () { return CGAlgorithms.COLLINEAR };

	Object.defineProperties( CGAlgorithms, staticAccessors$3 );

	var GeometryComponentFilter = function GeometryComponentFilter () {};

	GeometryComponentFilter.prototype.filter = function filter (geom) {};
	GeometryComponentFilter.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryComponentFilter.prototype.getClass = function getClass () {
	  return GeometryComponentFilter
	};

	var Geometry = function Geometry () {
	  var factory = arguments[0];

	  this._envelope = null;
	  this._factory = null;
	  this._SRID = null;
	  this._userData = null;
	  this._factory = factory;
	  this._SRID = factory.getSRID();
	};

	var staticAccessors$11 = { serialVersionUID: { configurable: true },SORTINDEX_POINT: { configurable: true },SORTINDEX_MULTIPOINT: { configurable: true },SORTINDEX_LINESTRING: { configurable: true },SORTINDEX_LINEARRING: { configurable: true },SORTINDEX_MULTILINESTRING: { configurable: true },SORTINDEX_POLYGON: { configurable: true },SORTINDEX_MULTIPOLYGON: { configurable: true },SORTINDEX_GEOMETRYCOLLECTION: { configurable: true },geometryChangedFilter: { configurable: true } };
	Geometry.prototype.isGeometryCollection = function isGeometryCollection () {
	  return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION
	};
	Geometry.prototype.getFactory = function getFactory () {
	  return this._factory
	};
	Geometry.prototype.getGeometryN = function getGeometryN (n) {
	  return this
	};
	Geometry.prototype.getArea = function getArea () {
	  return 0.0
	};
	Geometry.prototype.isRectangle = function isRectangle () {
	  return false
	};
	Geometry.prototype.equals = function equals () {
	  if (arguments[0] instanceof Geometry) {
	    var g$1 = arguments[0];
	    if (g$1 === null) { return false }
	    return this.equalsTopo(g$1)
	  } else if (arguments[0] instanceof Object) {
	    var o = arguments[0];
	    if (!(o instanceof Geometry)) { return false }
	    var g = o;
	    return this.equalsExact(g)
	  }
	};
	Geometry.prototype.equalsExact = function equalsExact (other) {
	  return this === other || this.equalsExact(other, 0)
	};
	Geometry.prototype.geometryChanged = function geometryChanged () {
	  this.apply(Geometry.geometryChangedFilter);
	};
	Geometry.prototype.geometryChangedAction = function geometryChangedAction () {
	  this._envelope = null;
	};
	Geometry.prototype.equalsNorm = function equalsNorm (g) {
	  if (g === null) { return false }
	  return this.norm().equalsExact(g.norm())
	};
	Geometry.prototype.getLength = function getLength () {
	  return 0.0
	};
	Geometry.prototype.getNumGeometries = function getNumGeometries () {
	  return 1
	};
	Geometry.prototype.compareTo = function compareTo () {
	  if (arguments.length === 1) {
	    var o = arguments[0];
	    var other = o;
	    if (this.getSortIndex() !== other.getSortIndex()) {
	      return this.getSortIndex() - other.getSortIndex()
	    }
	    if (this.isEmpty() && other.isEmpty()) {
	      return 0
	    }
	    if (this.isEmpty()) {
	      return -1
	    }
	    if (other.isEmpty()) {
	      return 1
	    }
	    return this.compareToSameClass(o)
	  } else if (arguments.length === 2) {
	    var other$1 = arguments[0];
	    var comp = arguments[1];
	    if (this.getSortIndex() !== other$1.getSortIndex()) {
	      return this.getSortIndex() - other$1.getSortIndex()
	    }
	    if (this.isEmpty() && other$1.isEmpty()) {
	      return 0
	    }
	    if (this.isEmpty()) {
	      return -1
	    }
	    if (other$1.isEmpty()) {
	      return 1
	    }
	    return this.compareToSameClass(other$1, comp)
	  }
	};
	Geometry.prototype.getUserData = function getUserData () {
	  return this._userData
	};
	Geometry.prototype.getSRID = function getSRID () {
	  return this._SRID
	};
	Geometry.prototype.getEnvelope = function getEnvelope () {
	  return this.getFactory().toGeometry(this.getEnvelopeInternal())
	};
	Geometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection (g) {
	  if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
	    throw new IllegalArgumentException()
	  }
	};
	Geometry.prototype.equal = function equal (a, b, tolerance) {
	  if (tolerance === 0) {
	    return a.equals(b)
	  }
	  return a.distance(b) <= tolerance
	};
	Geometry.prototype.norm = function norm () {
	  var copy = this.copy();
	  copy.normalize();
	  return copy
	};
	Geometry.prototype.getPrecisionModel = function getPrecisionModel () {
	  return this._factory.getPrecisionModel()
	};
	Geometry.prototype.getEnvelopeInternal = function getEnvelopeInternal () {
	  if (this._envelope === null) {
	    this._envelope = this.computeEnvelopeInternal();
	  }
	  return new Envelope(this._envelope)
	};
	Geometry.prototype.setSRID = function setSRID (SRID) {
	  this._SRID = SRID;
	};
	Geometry.prototype.setUserData = function setUserData (userData) {
	  this._userData = userData;
	};
	Geometry.prototype.compare = function compare (a, b) {
	  var i = a.iterator();
	  var j = b.iterator();
	  while (i.hasNext() && j.hasNext()) {
	    var aElement = i.next();
	    var bElement = j.next();
	    var comparison = aElement.compareTo(bElement);
	    if (comparison !== 0) {
	      return comparison
	    }
	  }
	  if (i.hasNext()) {
	    return 1
	  }
	  if (j.hasNext()) {
	    return -1
	  }
	  return 0
	};
	Geometry.prototype.hashCode = function hashCode () {
	  return this.getEnvelopeInternal().hashCode()
	};
	Geometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived () {
	  if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
	    return true
	  }
	  return false
	};
	Geometry.prototype.interfaces_ = function interfaces_ () {
	  return [Clonable, Comparable, Serializable]
	};
	Geometry.prototype.getClass = function getClass () {
	  return Geometry
	};
	Geometry.hasNonEmptyElements = function hasNonEmptyElements (geometries) {
	  for (var i = 0; i < geometries.length; i++) {
	    if (!geometries[i].isEmpty()) {
	      return true
	    }
	  }
	  return false
	};
	Geometry.hasNullElements = function hasNullElements (array) {
	  for (var i = 0; i < array.length; i++) {
	    if (array[i] === null) {
	      return true
	    }
	  }
	  return false
	};
	staticAccessors$11.serialVersionUID.get = function () { return 8763622679187376702 };
	staticAccessors$11.SORTINDEX_POINT.get = function () { return 0 };
	staticAccessors$11.SORTINDEX_MULTIPOINT.get = function () { return 1 };
	staticAccessors$11.SORTINDEX_LINESTRING.get = function () { return 2 };
	staticAccessors$11.SORTINDEX_LINEARRING.get = function () { return 3 };
	staticAccessors$11.SORTINDEX_MULTILINESTRING.get = function () { return 4 };
	staticAccessors$11.SORTINDEX_POLYGON.get = function () { return 5 };
	staticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function () { return 6 };
	staticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function () { return 7 };
	staticAccessors$11.geometryChangedFilter.get = function () { return geometryChangedFilter };

	Object.defineProperties( Geometry, staticAccessors$11 );

	var geometryChangedFilter = function geometryChangedFilter () {};

	geometryChangedFilter.interfaces_ = function interfaces_ () {
	  return [GeometryComponentFilter]
	};
	geometryChangedFilter.filter = function filter (geom) {
	  geom.geometryChangedAction();
	};

	var CoordinateFilter = function CoordinateFilter () {};

	CoordinateFilter.prototype.filter = function filter (coord) {};
	CoordinateFilter.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CoordinateFilter.prototype.getClass = function getClass () {
	  return CoordinateFilter
	};

	var BoundaryNodeRule = function BoundaryNodeRule () {};

	var staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true },EndPointBoundaryNodeRule: { configurable: true },MultiValentEndPointBoundaryNodeRule: { configurable: true },MonoValentEndPointBoundaryNodeRule: { configurable: true },MOD2_BOUNDARY_RULE: { configurable: true },ENDPOINT_BOUNDARY_RULE: { configurable: true },MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },OGC_SFS_BOUNDARY_RULE: { configurable: true } };

	BoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {};
	BoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BoundaryNodeRule.prototype.getClass = function getClass () {
	  return BoundaryNodeRule
	};
	staticAccessors$12.Mod2BoundaryNodeRule.get = function () { return Mod2BoundaryNodeRule };
	staticAccessors$12.EndPointBoundaryNodeRule.get = function () { return EndPointBoundaryNodeRule };
	staticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function () { return MultiValentEndPointBoundaryNodeRule };
	staticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function () { return MonoValentEndPointBoundaryNodeRule };
	staticAccessors$12.MOD2_BOUNDARY_RULE.get = function () { return new Mod2BoundaryNodeRule() };
	staticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function () { return new EndPointBoundaryNodeRule() };
	staticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MultiValentEndPointBoundaryNodeRule() };
	staticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MonoValentEndPointBoundaryNodeRule() };
	staticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function () { return BoundaryNodeRule.MOD2_BOUNDARY_RULE };

	Object.defineProperties( BoundaryNodeRule, staticAccessors$12 );

	var Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule () {};

	Mod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {
	  return boundaryCount % 2 === 1
	};
	Mod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {
	  return [BoundaryNodeRule]
	};
	Mod2BoundaryNodeRule.prototype.getClass = function getClass () {
	  return Mod2BoundaryNodeRule
	};

	var EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule () {};

	EndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {
	  return boundaryCount > 0
	};
	EndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {
	  return [BoundaryNodeRule]
	};
	EndPointBoundaryNodeRule.prototype.getClass = function getClass () {
	  return EndPointBoundaryNodeRule
	};

	var MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule () {};

	MultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {
	  return boundaryCount > 1
	};
	MultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {
	  return [BoundaryNodeRule]
	};
	MultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {
	  return MultiValentEndPointBoundaryNodeRule
	};

	var MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule () {};

	MonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {
	  return boundaryCount === 1
	};
	MonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {
	  return [BoundaryNodeRule]
	};
	MonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {
	  return MonoValentEndPointBoundaryNodeRule
	};

	// import Iterator from './Iterator'

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
	 *
	 * @constructor
	 * @private
	 */
	var Collection = function Collection () {};

	Collection.prototype.add = function add () {};

	/**
	 * Appends all of the elements in the specified collection to the end of this
	 * list, in the order that they are returned by the specified collection's
	 * iterator (optional operation).
	 * @param {javascript.util.Collection} c
	 * @return {boolean}
	 */
	Collection.prototype.addAll = function addAll () {};

	/**
	 * Returns true if this collection contains no elements.
	 * @return {boolean}
	 */
	Collection.prototype.isEmpty = function isEmpty () {};

	/**
	 * Returns an iterator over the elements in this collection.
	 * @return {javascript.util.Iterator}
	 */
	Collection.prototype.iterator = function iterator () {};

	/**
	 * Returns an iterator over the elements in this collection.
	 * @return {number}
	 */
	Collection.prototype.size = function size () {};

	/**
	 * Returns an array containing all of the elements in this collection.
	 * @return {Array}
	 */
	Collection.prototype.toArray = function toArray () {};

	/**
	 * Removes a single instance of the specified element from this collection if it
	 * is present. (optional)
	 * @param {Object} e
	 * @return {boolean}
	 */
	Collection.prototype.remove = function remove () {};

	/**
	 * @param {string} [message] Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	var IndexOutOfBoundsException = (function (Error) {
	  function IndexOutOfBoundsException (message) {
	    Error.call(this);
	    this.message = message || '';
	  }

	  if ( Error ) IndexOutOfBoundsException.__proto__ = Error;
	  IndexOutOfBoundsException.prototype = Object.create( Error && Error.prototype );
	  IndexOutOfBoundsException.prototype.constructor = IndexOutOfBoundsException;

	  var staticAccessors = { name: { configurable: true } };

	  /**
	   * @type {string}
	   */
	  staticAccessors.name.get = function () { return 'IndexOutOfBoundsException' };

	  Object.defineProperties( IndexOutOfBoundsException, staticAccessors );

	  return IndexOutOfBoundsException;
	}(Error));

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
	 * @constructor
	 * @private
	 */
	var Iterator = function Iterator () {};

	Iterator.prototype.hasNext = function hasNext () {};

	/**
	 * Returns the next element in the iteration.
	 * @return {Object}
	 */
	Iterator.prototype.next = function next () {};

	/**
	 * Removes from the underlying collection the last element returned by the
	 * iterator (optional operation).
	 */
	Iterator.prototype.remove = function remove () {};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
	 *
	 * @extends {javascript.util.Collection}
	 * @constructor
	 * @private
	 */
	var List = (function (Collection$$1) {
	  function List () {
	    Collection$$1.apply(this, arguments);
	  }

	  if ( Collection$$1 ) List.__proto__ = Collection$$1;
	  List.prototype = Object.create( Collection$$1 && Collection$$1.prototype );
	  List.prototype.constructor = List;

	  List.prototype.get = function get () { };

	  /**
	   * Replaces the element at the specified position in this list with the
	   * specified element (optional operation).
	   * @param {number} index
	   * @param {Object} e
	   * @return {Object}
	   */
	  List.prototype.set = function set () { };

	  /**
	   * Returns true if this collection contains no elements.
	   * @return {boolean}
	   */
	  List.prototype.isEmpty = function isEmpty () { };

	  return List;
	}(Collection));

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function NoSuchElementException (message) {
	  this.message = message || '';
	}
	NoSuchElementException.prototype = new Error();

	/**
	 * @type {string}
	 */
	NoSuchElementException.prototype.name = 'NoSuchElementException';

	// import OperationNotSupported from './OperationNotSupported'

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
	 *
	 * @extends List
	 * @private
	 */
	var ArrayList = (function (List$$1) {
	  function ArrayList () {
	    List$$1.call(this);
	    this.array_ = [];

	    if (arguments[0] instanceof Collection) {
	      this.addAll(arguments[0]);
	    }
	  }

	  if ( List$$1 ) ArrayList.__proto__ = List$$1;
	  ArrayList.prototype = Object.create( List$$1 && List$$1.prototype );
	  ArrayList.prototype.constructor = ArrayList;

	  ArrayList.prototype.ensureCapacity = function ensureCapacity () {};
	  ArrayList.prototype.interfaces_ = function interfaces_ () { return [List$$1, Collection] };

	  /**
	   * @override
	   */
	  ArrayList.prototype.add = function add (e) {
	    if (arguments.length === 1) {
	      this.array_.push(e);
	    } else {
	      this.array_.splice(arguments[0], arguments[1]);
	    }
	    return true
	  };

	  ArrayList.prototype.clear = function clear () {
	    this.array_ = [];
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.addAll = function addAll (c) {
	    var this$1$1 = this;

	    for (var i = c.iterator(); i.hasNext();) {
	      this$1$1.add(i.next());
	    }
	    return true
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.set = function set (index, element) {
	    var oldElement = this.array_[index];
	    this.array_[index] = element;
	    return oldElement
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.iterator = function iterator () {
	    return new Iterator_(this)
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.get = function get (index) {
	    if (index < 0 || index >= this.size()) {
	      throw new IndexOutOfBoundsException()
	    }

	    return this.array_[index]
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.isEmpty = function isEmpty () {
	    return this.array_.length === 0
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.size = function size () {
	    return this.array_.length
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.toArray = function toArray () {
	    var this$1$1 = this;

	    var array = [];

	    for (var i = 0, len = this.array_.length; i < len; i++) {
	      array.push(this$1$1.array_[i]);
	    }

	    return array
	  };

	  /**
	   * @override
	   */
	  ArrayList.prototype.remove = function remove (o) {
	    var this$1$1 = this;

	    var found = false;

	    for (var i = 0, len = this.array_.length; i < len; i++) {
	      if (this$1$1.array_[i] === o) {
	        this$1$1.array_.splice(i, 1);
	        found = true;
	        break
	      }
	    }

	    return found
	  };

	  return ArrayList;
	}(List));

	/**
	 * @extends {Iterator}
	 * @param {ArrayList} arrayList
	 * @constructor
	 * @private
	 */
	var Iterator_ = (function (Iterator$$1) {
	  function Iterator_ (arrayList) {
	    Iterator$$1.call(this);
	    /**
	     * @type {ArrayList}
	     * @private
	    */
	    this.arrayList_ = arrayList;
	    /**
	     * @type {number}
	     * @private
	    */
	    this.position_ = 0;
	  }

	  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;
	  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );
	  Iterator_.prototype.constructor = Iterator_;

	  /**
	   * @override
	   */
	  Iterator_.prototype.next = function next () {
	    if (this.position_ === this.arrayList_.size()) {
	      throw new NoSuchElementException()
	    }
	    return this.arrayList_.get(this.position_++)
	  };

	  /**
	   * @override
	   */
	  Iterator_.prototype.hasNext = function hasNext () {
	    if (this.position_ < this.arrayList_.size()) {
	      return true
	    } else {
	      return false
	    }
	  };

	  /**
	   * TODO: should be in ListIterator
	   * @override
	   */
	  Iterator_.prototype.set = function set (element) {
	    return this.arrayList_.set(this.position_ - 1, element)
	  };

	  /**
	   * @override
	   */
	  Iterator_.prototype.remove = function remove () {
	    this.arrayList_.remove(this.arrayList_.get(this.position_));
	  };

	  return Iterator_;
	}(Iterator));

	var CoordinateList = (function (ArrayList$$1) {
	  function CoordinateList () {
	    ArrayList$$1.call(this);
	    if (arguments.length === 0) ; else if (arguments.length === 1) {
	      var coord = arguments[0];
	      this.ensureCapacity(coord.length);
	      this.add(coord, true);
	    } else if (arguments.length === 2) {
	      var coord$1 = arguments[0];
	      var allowRepeated = arguments[1];
	      this.ensureCapacity(coord$1.length);
	      this.add(coord$1, allowRepeated);
	    }
	  }

	  if ( ArrayList$$1 ) CoordinateList.__proto__ = ArrayList$$1;
	  CoordinateList.prototype = Object.create( ArrayList$$1 && ArrayList$$1.prototype );
	  CoordinateList.prototype.constructor = CoordinateList;

	  var staticAccessors = { coordArrayType: { configurable: true } };
	  staticAccessors.coordArrayType.get = function () { return new Array(0).fill(null) };
	  CoordinateList.prototype.getCoordinate = function getCoordinate (i) {
	    return this.get(i)
	  };
	  CoordinateList.prototype.addAll = function addAll () {
	    var this$1$1 = this;

	    if (arguments.length === 2) {
	      var coll = arguments[0];
	      var allowRepeated = arguments[1];
	      var isChanged = false;
	      for (var i = coll.iterator(); i.hasNext();) {
	        this$1$1.add(i.next(), allowRepeated);
	        isChanged = true;
	      }
	      return isChanged
	    } else { return ArrayList$$1.prototype.addAll.apply(this, arguments) }
	  };
	  CoordinateList.prototype.clone = function clone () {
	    var this$1$1 = this;

	    var clone = ArrayList$$1.prototype.clone.call(this);
	    for (var i = 0; i < this.size(); i++) {
	      clone.add(i, this$1$1.get(i).copy());
	    }
	    return clone
	  };
	  CoordinateList.prototype.toCoordinateArray = function toCoordinateArray () {
	    return this.toArray(CoordinateList.coordArrayType)
	  };
	  CoordinateList.prototype.add = function add () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var coord = arguments[0];
	      ArrayList$$1.prototype.add.call(this, coord);
	    } else if (arguments.length === 2) {
	      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
	        var coord$1 = arguments[0];
	        var allowRepeated = arguments[1];
	        this.add(coord$1, allowRepeated, true);
	        return true
	      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {
	        var coord$2 = arguments[0];
	        var allowRepeated$1 = arguments[1];
	        if (!allowRepeated$1) {
	          if (this.size() >= 1) {
	            var last = this.get(this.size() - 1);
	            if (last.equals2D(coord$2)) { return null }
	          }
	        }
	        ArrayList$$1.prototype.add.call(this, coord$2);
	      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
	        var obj = arguments[0];
	        var allowRepeated$2 = arguments[1];
	        this.add(obj, allowRepeated$2);
	        return true
	      }
	    } else if (arguments.length === 3) {
	      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {
	        var coord$3 = arguments[0];
	        var allowRepeated$3 = arguments[1];
	        var direction = arguments[2];
	        if (direction) {
	          for (var i$1 = 0; i$1 < coord$3.length; i$1++) {
	            this$1$1.add(coord$3[i$1], allowRepeated$3);
	          }
	        } else {
	          for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {
	            this$1$1.add(coord$3[i$2], allowRepeated$3);
	          }
	        }
	        return true
	      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
	        var i$3 = arguments[0];
	        var coord$4 = arguments[1];
	        var allowRepeated$4 = arguments[2];
	        if (!allowRepeated$4) {
	          var size = this.size();
	          if (size > 0) {
	            if (i$3 > 0) {
	              var prev = this.get(i$3 - 1);
	              if (prev.equals2D(coord$4)) { return null }
	            }
	            if (i$3 < size) {
	              var next = this.get(i$3);
	              if (next.equals2D(coord$4)) { return null }
	            }
	          }
	        }
	        ArrayList$$1.prototype.add.call(this, i$3, coord$4);
	      }
	    } else if (arguments.length === 4) {
	      var coord$5 = arguments[0];
	      var allowRepeated$5 = arguments[1];
	      var start = arguments[2];
	      var end = arguments[3];
	      var inc = 1;
	      if (start > end) { inc = -1; }
	      for (var i = start; i !== end; i += inc) {
	        this$1$1.add(coord$5[i], allowRepeated$5);
	      }
	      return true
	    }
	  };
	  CoordinateList.prototype.closeRing = function closeRing () {
	    if (this.size() > 0) { this.add(new Coordinate(this.get(0)), false); }
	  };
	  CoordinateList.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  CoordinateList.prototype.getClass = function getClass () {
	    return CoordinateList
	  };

	  Object.defineProperties( CoordinateList, staticAccessors );

	  return CoordinateList;
	}(ArrayList));

	var CoordinateArrays = function CoordinateArrays () {};

	var staticAccessors$13 = { ForwardComparator: { configurable: true },BidirectionalComparator: { configurable: true },coordArrayType: { configurable: true } };

	staticAccessors$13.ForwardComparator.get = function () { return ForwardComparator };
	staticAccessors$13.BidirectionalComparator.get = function () { return BidirectionalComparator };
	staticAccessors$13.coordArrayType.get = function () { return new Array(0).fill(null) };

	CoordinateArrays.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CoordinateArrays.prototype.getClass = function getClass () {
	  return CoordinateArrays
	};
	CoordinateArrays.isRing = function isRing (pts) {
	  if (pts.length < 4) { return false }
	  if (!pts[0].equals2D(pts[pts.length - 1])) { return false }
	  return true
	};
	CoordinateArrays.ptNotInList = function ptNotInList (testPts, pts) {
	  for (var i = 0; i < testPts.length; i++) {
	    var testPt = testPts[i];
	    if (CoordinateArrays.indexOf(testPt, pts) < 0) { return testPt }
	  }
	  return null
	};
	CoordinateArrays.scroll = function scroll (coordinates, firstCoordinate) {
	  var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
	  if (i < 0) { return null }
	  var newCoordinates = new Array(coordinates.length).fill(null);
	  System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
	  System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
	  System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
	};
	CoordinateArrays.equals = function equals () {
	  if (arguments.length === 2) {
	    var coord1 = arguments[0];
	    var coord2 = arguments[1];
	    if (coord1 === coord2) { return true }
	    if (coord1 === null || coord2 === null) { return false }
	    if (coord1.length !== coord2.length) { return false }
	    for (var i = 0; i < coord1.length; i++) {
	      if (!coord1[i].equals(coord2[i])) { return false }
	    }
	    return true
	  } else if (arguments.length === 3) {
	    var coord1$1 = arguments[0];
	    var coord2$1 = arguments[1];
	    var coordinateComparator = arguments[2];
	    if (coord1$1 === coord2$1) { return true }
	    if (coord1$1 === null || coord2$1 === null) { return false }
	    if (coord1$1.length !== coord2$1.length) { return false }
	    for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {
	      if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) { return false }
	    }
	    return true
	  }
	};
	CoordinateArrays.intersection = function intersection (coordinates, env) {
	  var coordList = new CoordinateList();
	  for (var i = 0; i < coordinates.length; i++) {
	    if (env.intersects(coordinates[i])) { coordList.add(coordinates[i], true); }
	  }
	  return coordList.toCoordinateArray()
	};
	CoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints (coord) {
	  for (var i = 1; i < coord.length; i++) {
	    if (coord[i - 1].equals(coord[i])) {
	      return true
	    }
	  }
	  return false
	};
	CoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints (coord) {
	  if (!CoordinateArrays.hasRepeatedPoints(coord)) { return coord }
	  var coordList = new CoordinateList(coord, false);
	  return coordList.toCoordinateArray()
	};
	CoordinateArrays.reverse = function reverse (coord) {
	  var last = coord.length - 1;
	  var mid = Math.trunc(last / 2);
	  for (var i = 0; i <= mid; i++) {
	    var tmp = coord[i];
	    coord[i] = coord[last - i];
	    coord[last - i] = tmp;
	  }
	};
	CoordinateArrays.removeNull = function removeNull (coord) {
	  var nonNull = 0;
	  for (var i = 0; i < coord.length; i++) {
	    if (coord[i] !== null) { nonNull++; }
	  }
	  var newCoord = new Array(nonNull).fill(null);
	  if (nonNull === 0) { return newCoord }
	  var j = 0;
	  for (var i$1 = 0; i$1 < coord.length; i$1++) {
	    if (coord[i$1] !== null) { newCoord[j++] = coord[i$1]; }
	  }
	  return newCoord
	};
	CoordinateArrays.copyDeep = function copyDeep () {
	  if (arguments.length === 1) {
	    var coordinates = arguments[0];
	    var copy = new Array(coordinates.length).fill(null);
	    for (var i = 0; i < coordinates.length; i++) {
	      copy[i] = new Coordinate(coordinates[i]);
	    }
	    return copy
	  } else if (arguments.length === 5) {
	    var src = arguments[0];
	    var srcStart = arguments[1];
	    var dest = arguments[2];
	    var destStart = arguments[3];
	    var length = arguments[4];
	    for (var i$1 = 0; i$1 < length; i$1++) {
	      dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);
	    }
	  }
	};
	CoordinateArrays.isEqualReversed = function isEqualReversed (pts1, pts2) {
	  for (var i = 0; i < pts1.length; i++) {
	    var p1 = pts1[i];
	    var p2 = pts2[pts1.length - i - 1];
	    if (p1.compareTo(p2) !== 0) { return false }
	  }
	  return true
	};
	CoordinateArrays.envelope = function envelope (coordinates) {
	  var env = new Envelope();
	  for (var i = 0; i < coordinates.length; i++) {
	    env.expandToInclude(coordinates[i]);
	  }
	  return env
	};
	CoordinateArrays.toCoordinateArray = function toCoordinateArray (coordList) {
	  return coordList.toArray(CoordinateArrays.coordArrayType)
	};
	CoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing (n, c) {
	  return c.length >= n ? c : []
	};
	CoordinateArrays.indexOf = function indexOf (coordinate, coordinates) {
	  for (var i = 0; i < coordinates.length; i++) {
	    if (coordinate.equals(coordinates[i])) {
	      return i
	    }
	  }
	  return -1
	};
	CoordinateArrays.increasingDirection = function increasingDirection (pts) {
	  for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
	    var j = pts.length - 1 - i;
	    var comp = pts[i].compareTo(pts[j]);
	    if (comp !== 0) { return comp }
	  }
	  return 1
	};
	CoordinateArrays.compare = function compare (pts1, pts2) {
	  var i = 0;
	  while (i < pts1.length && i < pts2.length) {
	    var compare = pts1[i].compareTo(pts2[i]);
	    if (compare !== 0) { return compare }
	    i++;
	  }
	  if (i < pts2.length) { return -1 }
	  if (i < pts1.length) { return 1 }
	  return 0
	};
	CoordinateArrays.minCoordinate = function minCoordinate (coordinates) {
	  var minCoord = null;
	  for (var i = 0; i < coordinates.length; i++) {
	    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
	      minCoord = coordinates[i];
	    }
	  }
	  return minCoord
	};
	CoordinateArrays.extract = function extract (pts, start, end) {
	  start = MathUtil.clamp(start, 0, pts.length);
	  end = MathUtil.clamp(end, -1, pts.length);
	  var npts = end - start + 1;
	  if (end < 0) { npts = 0; }
	  if (start >= pts.length) { npts = 0; }
	  if (end < start) { npts = 0; }
	  var extractPts = new Array(npts).fill(null);
	  if (npts === 0) { return extractPts }
	  var iPts = 0;
	  for (var i = start; i <= end; i++) {
	    extractPts[iPts++] = pts[i];
	  }
	  return extractPts
	};

	Object.defineProperties( CoordinateArrays, staticAccessors$13 );

	var ForwardComparator = function ForwardComparator () {};

	ForwardComparator.prototype.compare = function compare (o1, o2) {
	  var pts1 = o1;
	  var pts2 = o2;
	  return CoordinateArrays.compare(pts1, pts2)
	};
	ForwardComparator.prototype.interfaces_ = function interfaces_ () {
	  return [Comparator]
	};
	ForwardComparator.prototype.getClass = function getClass () {
	  return ForwardComparator
	};

	var BidirectionalComparator = function BidirectionalComparator () {};

	BidirectionalComparator.prototype.compare = function compare (o1, o2) {
	  var pts1 = o1;
	  var pts2 = o2;
	  if (pts1.length < pts2.length) { return -1 }
	  if (pts1.length > pts2.length) { return 1 }
	  if (pts1.length === 0) { return 0 }
	  var forwardComp = CoordinateArrays.compare(pts1, pts2);
	  var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
	  if (isEqualRev) { return 0 }
	  return forwardComp
	};
	BidirectionalComparator.prototype.OLDcompare = function OLDcompare (o1, o2) {
	  var pts1 = o1;
	  var pts2 = o2;
	  if (pts1.length < pts2.length) { return -1 }
	  if (pts1.length > pts2.length) { return 1 }
	  if (pts1.length === 0) { return 0 }
	  var dir1 = CoordinateArrays.increasingDirection(pts1);
	  var dir2 = CoordinateArrays.increasingDirection(pts2);
	  var i1 = dir1 > 0 ? 0 : pts1.length - 1;
	  var i2 = dir2 > 0 ? 0 : pts1.length - 1;
	  for (var i = 0; i < pts1.length; i++) {
	    var comparePt = pts1[i1].compareTo(pts2[i2]);
	    if (comparePt !== 0) { return comparePt }
	    i1 += dir1;
	    i2 += dir2;
	  }
	  return 0
	};
	BidirectionalComparator.prototype.interfaces_ = function interfaces_ () {
	  return [Comparator]
	};
	BidirectionalComparator.prototype.getClass = function getClass () {
	  return BidirectionalComparator
	};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
	 *
	 * @constructor
	 * @private
	 */
	var Map$1 = function Map () {};

	Map$1.prototype.get = function get () {};
	/**
	 * Associates the specified value with the specified key in this map (optional
	 * operation).
	 * @param {Object} key
	 * @param {Object} value
	 * @return {Object}
	 */
	Map$1.prototype.put = function put () {};

	/**
	 * Returns the number of key-value mappings in this map.
	 * @return {number}
	 */
	Map$1.prototype.size = function size () {};

	/**
	 * Returns a Collection view of the values contained in this map.
	 * @return {javascript.util.Collection}
	 */
	Map$1.prototype.values = function values () {};

	/**
	 * Returns a {@link Set} view of the mappings contained in this map.
	 * The set is backed by the map, so changes to the map are
	 * reflected in the set, and vice-versa.If the map is modified
	 * while an iteration over the set is in progress (except through
	 * the iterator's own <tt>remove</tt> operation, or through the
	 * <tt>setValue</tt> operation on a map entry returned by the
	 * iterator) the results of the iteration are undefined.The set
	 * supports element removal, which removes the corresponding
	 * mapping from the map, via the <tt>Iterator.remove</tt>,
	 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
	 * <tt>clear</tt> operations.It does not support the
	 * <tt>add</tt> or <tt>addAll</tt> operations.
	 *
	 * @return {Set} a set view of the mappings contained in this map
	 */
	Map$1.prototype.entrySet = function entrySet () {};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
	 *
	 * @extends {Map}
	 * @constructor
	 * @private
	 */
	var SortedMap = (function (Map) {
		function SortedMap () {
			Map.apply(this, arguments);
		}if ( Map ) SortedMap.__proto__ = Map;
		SortedMap.prototype = Object.create( Map && Map.prototype );
		SortedMap.prototype.constructor = SortedMap;

		

		return SortedMap;
	}(Map$1));

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function OperationNotSupported (message) {
	  this.message = message || '';
	}
	OperationNotSupported.prototype = new Error();

	/**
	 * @type {string}
	 */
	OperationNotSupported.prototype.name = 'OperationNotSupported';

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
	 *
	 * @extends {Collection}
	 * @constructor
	 * @private
	 */
	function Set$1() {}
	Set$1.prototype = new Collection();


	/**
	 * Returns true if this set contains the specified element. More formally,
	 * returns true if and only if this set contains an element e such that (o==null ?
	 * e==null : o.equals(e)).
	 * @param {Object} e
	 * @return {boolean}
	 */
	Set$1.prototype.contains = function() {};

	/**
	 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
	 *
	 * @extends {javascript.util.Set}
	 * @constructor
	 * @private
	 */
	var HashSet = (function (Set$$1) {
	  function HashSet () {
	    Set$$1.call(this);
	    this.array_ = [];

	    if (arguments[0] instanceof Collection) {
	      this.addAll(arguments[0]);
	    }
	  }

	  if ( Set$$1 ) HashSet.__proto__ = Set$$1;
	  HashSet.prototype = Object.create( Set$$1 && Set$$1.prototype );
	  HashSet.prototype.constructor = HashSet;

	  /**
	   * @override
	   */
	  HashSet.prototype.contains = function contains (o) {
	    var this$1$1 = this;

	    for (var i = 0, len = this.array_.length; i < len; i++) {
	      var e = this$1$1.array_[i];
	      if (e === o) {
	        return true
	      }
	    }
	    return false
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.add = function add (o) {
	    if (this.contains(o)) {
	      return false
	    }

	    this.array_.push(o);

	    return true
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.addAll = function addAll (c) {
	    var this$1$1 = this;

	    for (var i = c.iterator(); i.hasNext();) {
	      this$1$1.add(i.next());
	    }
	    return true
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.remove = function remove (o) {
	    // throw new javascript.util.OperationNotSupported()
	    throw new Error()
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.size = function size () {
	    return this.array_.length
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.isEmpty = function isEmpty () {
	    return this.array_.length === 0
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.toArray = function toArray () {
	    var this$1$1 = this;

	    var array = [];

	    for (var i = 0, len = this.array_.length; i < len; i++) {
	      array.push(this$1$1.array_[i]);
	    }

	    return array
	  };

	  /**
	   * @override
	   */
	  HashSet.prototype.iterator = function iterator () {
	    return new Iterator_$1(this)
	  };

	  return HashSet;
	}(Set$1));

	/**
	   * @extends {Iterator}
	   * @param {HashSet} hashSet
	   * @constructor
	   * @private
	   */
	var Iterator_$1 = (function (Iterator$$1) {
	  function Iterator_ (hashSet) {
	    Iterator$$1.call(this);
	    /**
	     * @type {HashSet}
	     * @private
	     */
	    this.hashSet_ = hashSet;
	    /**
	     * @type {number}
	     * @private
	     */
	    this.position_ = 0;
	  }

	  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;
	  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );
	  Iterator_.prototype.constructor = Iterator_;

	  /**
	   * @override
	   */
	  Iterator_.prototype.next = function next () {
	    if (this.position_ === this.hashSet_.size()) {
	      throw new NoSuchElementException()
	    }
	    return this.hashSet_.array_[this.position_++]
	  };

	  /**
	   * @override
	   */
	  Iterator_.prototype.hasNext = function hasNext () {
	    if (this.position_ < this.hashSet_.size()) {
	      return true
	    } else {
	      return false
	    }
	  };

	  /**
	   * @override
	   */
	  Iterator_.prototype.remove = function remove () {
	    throw new OperationNotSupported()
	  };

	  return Iterator_;
	}(Iterator));

	var BLACK = 0;
	var RED = 1;
	function colorOf (p) { return (p === null ? BLACK : p.color) }
	function parentOf (p) { return (p === null ? null : p.parent) }
	function setColor (p, c) { if (p !== null) { p.color = c; } }
	function leftOf (p) { return (p === null ? null : p.left) }
	function rightOf (p) { return (p === null ? null : p.right) }

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
	 *
	 * @extends {SortedMap}
	 * @constructor
	 * @private
	 */
	function TreeMap () {
	  /**
	   * @type {Object}
	   * @private
	   */
	  this.root_ = null;
	  /**
	   * @type {number}
	   * @private
	  */
	  this.size_ = 0;
	}
	TreeMap.prototype = new SortedMap();

	/**
	 * @override
	 */
	TreeMap.prototype.get = function (key) {
	  var p = this.root_;
	  while (p !== null) {
	    var cmp = key['compareTo'](p.key);
	    if (cmp < 0) { p = p.left; }
	    else if (cmp > 0) { p = p.right; }
	    else { return p.value }
	  }
	  return null
	};

	/**
	 * @override
	 */
	TreeMap.prototype.put = function (key, value) {
	  if (this.root_ === null) {
	    this.root_ = {
	      key: key,
	      value: value,
	      left: null,
	      right: null,
	      parent: null,
	      color: BLACK,
	      getValue: function getValue () { return this.value },
	      getKey: function getKey () { return this.key }
	    };
	    this.size_ = 1;
	    return null
	  }
	  var t = this.root_;
	  var parent;
	  var cmp;
	  do {
	    parent = t;
	    cmp = key['compareTo'](t.key);
	    if (cmp < 0) {
	      t = t.left;
	    } else if (cmp > 0) {
	      t = t.right;
	    } else {
	      var oldValue = t.value;
	      t.value = value;
	      return oldValue
	    }
	  } while (t !== null)
	  var e = {
	    key: key,
	    left: null,
	    right: null,
	    value: value,
	    parent: parent,
	    color: BLACK,
	    getValue: function getValue () { return this.value },
	    getKey: function getKey () { return this.key }
	  };
	  if (cmp < 0) {
	    parent.left = e;
	  } else {
	    parent.right = e;
	  }
	  this.fixAfterInsertion(e);
	  this.size_++;
	  return null
	};

	/**
	 * @param {Object} x
	 */
	TreeMap.prototype.fixAfterInsertion = function (x) {
	  var this$1$1 = this;

	  x.color = RED;
	  while (x != null && x !== this.root_ && x.parent.color === RED) {
	    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
	      var y = rightOf(parentOf(parentOf(x)));
	      if (colorOf(y) === RED) {
	        setColor(parentOf(x), BLACK);
	        setColor(y, BLACK);
	        setColor(parentOf(parentOf(x)), RED);
	        x = parentOf(parentOf(x));
	      } else {
	        if (x === rightOf(parentOf(x))) {
	          x = parentOf(x);
	          this$1$1.rotateLeft(x);
	        }
	        setColor(parentOf(x), BLACK);
	        setColor(parentOf(parentOf(x)), RED);
	        this$1$1.rotateRight(parentOf(parentOf(x)));
	      }
	    } else {
	      var y$1 = leftOf(parentOf(parentOf(x)));
	      if (colorOf(y$1) === RED) {
	        setColor(parentOf(x), BLACK);
	        setColor(y$1, BLACK);
	        setColor(parentOf(parentOf(x)), RED);
	        x = parentOf(parentOf(x));
	      } else {
	        if (x === leftOf(parentOf(x))) {
	          x = parentOf(x);
	          this$1$1.rotateRight(x);
	        }
	        setColor(parentOf(x), BLACK);
	        setColor(parentOf(parentOf(x)), RED);
	        this$1$1.rotateLeft(parentOf(parentOf(x)));
	      }
	    }
	  }
	  this.root_.color = BLACK;
	};

	/**
	 * @override
	 */
	TreeMap.prototype.values = function () {
	  var arrayList = new ArrayList();
	  var p = this.getFirstEntry();
	  if (p !== null) {
	    arrayList.add(p.value);
	    while ((p = TreeMap.successor(p)) !== null) {
	      arrayList.add(p.value);
	    }
	  }
	  return arrayList
	};

	/**
	 * @override
	 */
	TreeMap.prototype.entrySet = function () {
	  var hashSet = new HashSet();
	  var p = this.getFirstEntry();
	  if (p !== null) {
	    hashSet.add(p);
	    while ((p = TreeMap.successor(p)) !== null) {
	      hashSet.add(p);
	    }
	  }
	  return hashSet
	};

	/**
	 * @param {Object} p
	 */
	TreeMap.prototype.rotateLeft = function (p) {
	  if (p != null) {
	    var r = p.right;
	    p.right = r.left;
	    if (r.left != null) { r.left.parent = p; }
	    r.parent = p.parent;
	    if (p.parent === null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }
	    r.left = p;
	    p.parent = r;
	  }
	};

	/**
	 * @param {Object} p
	 */
	TreeMap.prototype.rotateRight = function (p) {
	  if (p != null) {
	    var l = p.left;
	    p.left = l.right;
	    if (l.right != null) { l.right.parent = p; }
	    l.parent = p.parent;
	    if (p.parent === null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else { p.parent.left = l; }
	    l.right = p;
	    p.parent = l;
	  }
	};

	/**
	 * @return {Object}
	 */
	TreeMap.prototype.getFirstEntry = function () {
	  var p = this.root_;
	  if (p != null) {
	    while (p.left != null) {
	      p = p.left;
	    }
	  }
	  return p
	};

	/**
	 * @param {Object} t
	 * @return {Object}
	 * @private
	 */
	TreeMap.successor = function (t) {
	  if (t === null) { return null } else if (t.right !== null) {
	    var p = t.right;
	    while (p.left !== null) {
	      p = p.left;
	    }
	    return p
	  } else {
	    var p$1 = t.parent;
	    var ch = t;
	    while (p$1 !== null && ch === p$1.right) {
	      ch = p$1;
	      p$1 = p$1.parent;
	    }
	    return p$1
	  }
	};

	/**
	 * @override
	 */
	TreeMap.prototype.size = function () {
	  return this.size_
	};

	var Lineal = function Lineal () {};

	Lineal.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Lineal.prototype.getClass = function getClass () {
	  return Lineal
	};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
	 *
	 * @extends {Set}
	 * @constructor
	 * @private
	 */
	function SortedSet () {}
	SortedSet.prototype = new Set$1();

	// import Iterator from './Iterator'
	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
	 *
	 * @extends {SortedSet}
	 * @constructor
	 * @private
	 */
	function TreeSet () {
	  /**
	   * @type {Array}
	   * @private
	  */
	  this.array_ = [];

	  if (arguments[0] instanceof Collection) {
	    this.addAll(arguments[0]);
	  }
	}
	TreeSet.prototype = new SortedSet();

	/**
	 * @override
	 */
	TreeSet.prototype.contains = function (o) {
	  var this$1$1 = this;

	  for (var i = 0, len = this.array_.length; i < len; i++) {
	    var e = this$1$1.array_[i];
	    if (e['compareTo'](o) === 0) {
	      return true
	    }
	  }
	  return false
	};

	/**
	 * @override
	 */
	TreeSet.prototype.add = function (o) {
	  var this$1$1 = this;

	  if (this.contains(o)) {
	    return false
	  }

	  for (var i = 0, len = this.array_.length; i < len; i++) {
	    var e = this$1$1.array_[i];
	    if (e['compareTo'](o) === 1) {
	      this$1$1.array_.splice(i, 0, o);
	      return true
	    }
	  }

	  this.array_.push(o);

	  return true
	};

	/**
	 * @override
	 */
	TreeSet.prototype.addAll = function (c) {
	  var this$1$1 = this;

	  for (var i = c.iterator(); i.hasNext();) {
	    this$1$1.add(i.next());
	  }
	  return true
	};

	/**
	 * @override
	 */
	TreeSet.prototype.remove = function (e) {
	  throw new OperationNotSupported()
	};

	/**
	 * @override
	 */
	TreeSet.prototype.size = function () {
	  return this.array_.length
	};

	/**
	 * @override
	 */
	TreeSet.prototype.isEmpty = function () {
	  return this.array_.length === 0
	};

	/**
	 * @override
	 */
	TreeSet.prototype.toArray = function () {
	  var this$1$1 = this;

	  var array = [];

	  for (var i = 0, len = this.array_.length; i < len; i++) {
	    array.push(this$1$1.array_[i]);
	  }

	  return array
	};

	/**
	 * @override
	 */
	TreeSet.prototype.iterator = function () {
	  return new Iterator_$2(this)
	};

	/**
	 * @extends {javascript.util.Iterator}
	 * @param {javascript.util.TreeSet} treeSet
	 * @constructor
	 * @private
	 */
	var Iterator_$2 = function (treeSet) {
	  /**
	   * @type {javascript.util.TreeSet}
	   * @private
	   */
	  this.treeSet_ = treeSet;
	  /**
	   * @type {number}
	   * @private
	   */
	  this.position_ = 0;
	};

	/**
	 * @override
	 */
	Iterator_$2.prototype.next = function () {
	  if (this.position_ === this.treeSet_.size()) {
	    throw new NoSuchElementException()
	  }
	  return this.treeSet_.array_[this.position_++]
	};

	/**
	 * @override
	 */
	Iterator_$2.prototype.hasNext = function () {
	  if (this.position_ < this.treeSet_.size()) {
	    return true
	  } else {
	    return false
	  }
	};

	/**
	 * @override
	 */
	Iterator_$2.prototype.remove = function () {
	  throw new OperationNotSupported()
	};

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
	 *
	 * @constructor
	 * @private
	 */
	var Arrays = function Arrays () {};

	Arrays.sort = function sort () {
	  var a = arguments[0];
	  var i;
	  var t;
	  var comparator;
	  var compare;
	  if (arguments.length === 1) {
	    compare = function (a, b) {
	      return a.compareTo(b)
	    };
	    a.sort(compare);
	  } else if (arguments.length === 2) {
	    comparator = arguments[1];
	    compare = function (a, b) {
	      return comparator['compare'](a, b)
	    };
	    a.sort(compare);
	  } else if (arguments.length === 3) {
	    t = a.slice(arguments[1], arguments[2]);
	    t.sort();
	    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
	    a.splice(0, a.length);
	    for (i = 0; i < r.length; i++) {
	      a.push(r[i]);
	    }
	  } else if (arguments.length === 4) {
	    t = a.slice(arguments[1], arguments[2]);
	    comparator = arguments[3];
	    compare = function (a, b) {
	      return comparator['compare'](a, b)
	    };
	    t.sort(compare);
	    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
	    a.splice(0, a.length);
	    for (i = 0; i < r.length; i++) {
	      a.push(r[i]);
	    }
	  }
	};
	/**
	 * @param {Array} array
	 * @return {ArrayList}
	 */
	Arrays.asList = function asList (array) {
	  var arrayList = new ArrayList();
	  for (var i = 0, len = array.length; i < len; i++) {
	    arrayList.add(array[i]);
	  }
	  return arrayList
	};

	var Dimension = function Dimension () {};

	var staticAccessors$14 = { P: { configurable: true },L: { configurable: true },A: { configurable: true },FALSE: { configurable: true },TRUE: { configurable: true },DONTCARE: { configurable: true },SYM_FALSE: { configurable: true },SYM_TRUE: { configurable: true },SYM_DONTCARE: { configurable: true },SYM_P: { configurable: true },SYM_L: { configurable: true },SYM_A: { configurable: true } };

	staticAccessors$14.P.get = function () { return 0 };
	staticAccessors$14.L.get = function () { return 1 };
	staticAccessors$14.A.get = function () { return 2 };
	staticAccessors$14.FALSE.get = function () { return -1 };
	staticAccessors$14.TRUE.get = function () { return -2 };
	staticAccessors$14.DONTCARE.get = function () { return -3 };
	staticAccessors$14.SYM_FALSE.get = function () { return 'F' };
	staticAccessors$14.SYM_TRUE.get = function () { return 'T' };
	staticAccessors$14.SYM_DONTCARE.get = function () { return '*' };
	staticAccessors$14.SYM_P.get = function () { return '0' };
	staticAccessors$14.SYM_L.get = function () { return '1' };
	staticAccessors$14.SYM_A.get = function () { return '2' };

	Dimension.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Dimension.prototype.getClass = function getClass () {
	  return Dimension
	};
	Dimension.toDimensionSymbol = function toDimensionSymbol (dimensionValue) {
	  switch (dimensionValue) {
	    case Dimension.FALSE:
	      return Dimension.SYM_FALSE
	    case Dimension.TRUE:
	      return Dimension.SYM_TRUE
	    case Dimension.DONTCARE:
	      return Dimension.SYM_DONTCARE
	    case Dimension.P:
	      return Dimension.SYM_P
	    case Dimension.L:
	      return Dimension.SYM_L
	    case Dimension.A:
	      return Dimension.SYM_A
	  }
	  throw new IllegalArgumentException()
	};
	Dimension.toDimensionValue = function toDimensionValue (dimensionSymbol) {
	  switch (Character.toUpperCase(dimensionSymbol)) {
	    case Dimension.SYM_FALSE:
	      return Dimension.FALSE
	    case Dimension.SYM_TRUE:
	      return Dimension.TRUE
	    case Dimension.SYM_DONTCARE:
	      return Dimension.DONTCARE
	    case Dimension.SYM_P:
	      return Dimension.P
	    case Dimension.SYM_L:
	      return Dimension.L
	    case Dimension.SYM_A:
	      return Dimension.A
	  }
	  throw new IllegalArgumentException()
	};

	Object.defineProperties( Dimension, staticAccessors$14 );

	var GeometryFilter = function GeometryFilter () {};

	GeometryFilter.prototype.filter = function filter (geom) {};
	GeometryFilter.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryFilter.prototype.getClass = function getClass () {
	  return GeometryFilter
	};

	var CoordinateSequenceFilter = function CoordinateSequenceFilter () {};

	CoordinateSequenceFilter.prototype.filter = function filter (seq, i) {};
	CoordinateSequenceFilter.prototype.isDone = function isDone () {};
	CoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged () {};
	CoordinateSequenceFilter.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CoordinateSequenceFilter.prototype.getClass = function getClass () {
	  return CoordinateSequenceFilter
	};

	var GeometryCollection = (function (Geometry$$1) {
	  function GeometryCollection (geometries, factory) {
	    Geometry$$1.call(this, factory);
	    this._geometries = geometries || [];

	    if (Geometry$$1.hasNullElements(this._geometries)) {
	      throw new IllegalArgumentException()
	    }
	  }

	  if ( Geometry$$1 ) GeometryCollection.__proto__ = Geometry$$1;
	  GeometryCollection.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );
	  GeometryCollection.prototype.constructor = GeometryCollection;

	  var staticAccessors = { serialVersionUID: { configurable: true } };
	  GeometryCollection.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {
	    var this$1$1 = this;

	    var envelope = new Envelope();
	    for (var i = 0; i < this._geometries.length; i++) {
	      envelope.expandToInclude(this$1$1._geometries[i].getEnvelopeInternal());
	    }
	    return envelope
	  };
	  GeometryCollection.prototype.getGeometryN = function getGeometryN (n) {
	    return this._geometries[n]
	  };
	  GeometryCollection.prototype.getSortIndex = function getSortIndex () {
	    return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION
	  };
	  GeometryCollection.prototype.getCoordinates = function getCoordinates () {
	    var this$1$1 = this;

	    var coordinates = new Array(this.getNumPoints()).fill(null);
	    var k = -1;
	    for (var i = 0; i < this._geometries.length; i++) {
	      var childCoordinates = this$1$1._geometries[i].getCoordinates();
	      for (var j = 0; j < childCoordinates.length; j++) {
	        k++;
	        coordinates[k] = childCoordinates[j];
	      }
	    }
	    return coordinates
	  };
	  GeometryCollection.prototype.getArea = function getArea () {
	    var this$1$1 = this;

	    var area = 0.0;
	    for (var i = 0; i < this._geometries.length; i++) {
	      area += this$1$1._geometries[i].getArea();
	    }
	    return area
	  };
	  GeometryCollection.prototype.equalsExact = function equalsExact () {
	    var this$1$1 = this;

	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      var otherCollection = other;
	      if (this._geometries.length !== otherCollection._geometries.length) {
	        return false
	      }
	      for (var i = 0; i < this._geometries.length; i++) {
	        if (!this$1$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
	          return false
	        }
	      }
	      return true
	    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  GeometryCollection.prototype.normalize = function normalize () {
	    var this$1$1 = this;

	    for (var i = 0; i < this._geometries.length; i++) {
	      this$1$1._geometries[i].normalize();
	    }
	    Arrays.sort(this._geometries);
	  };
	  GeometryCollection.prototype.getCoordinate = function getCoordinate () {
	    if (this.isEmpty()) { return null }
	    return this._geometries[0].getCoordinate()
	  };
	  GeometryCollection.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    var this$1$1 = this;

	    var dimension = Dimension.FALSE;
	    for (var i = 0; i < this._geometries.length; i++) {
	      dimension = Math.max(dimension, this$1$1._geometries[i].getBoundaryDimension());
	    }
	    return dimension
	  };
	  GeometryCollection.prototype.getDimension = function getDimension () {
	    var this$1$1 = this;

	    var dimension = Dimension.FALSE;
	    for (var i = 0; i < this._geometries.length; i++) {
	      dimension = Math.max(dimension, this$1$1._geometries[i].getDimension());
	    }
	    return dimension
	  };
	  GeometryCollection.prototype.getLength = function getLength () {
	    var this$1$1 = this;

	    var sum = 0.0;
	    for (var i = 0; i < this._geometries.length; i++) {
	      sum += this$1$1._geometries[i].getLength();
	    }
	    return sum
	  };
	  GeometryCollection.prototype.getNumPoints = function getNumPoints () {
	    var this$1$1 = this;

	    var numPoints = 0;
	    for (var i = 0; i < this._geometries.length; i++) {
	      numPoints += this$1$1._geometries[i].getNumPoints();
	    }
	    return numPoints
	  };
	  GeometryCollection.prototype.getNumGeometries = function getNumGeometries () {
	    return this._geometries.length
	  };
	  GeometryCollection.prototype.reverse = function reverse () {
	    var this$1$1 = this;

	    var n = this._geometries.length;
	    var revGeoms = new Array(n).fill(null);
	    for (var i = 0; i < this._geometries.length; i++) {
	      revGeoms[i] = this$1$1._geometries[i].reverse();
	    }
	    return this.getFactory().createGeometryCollection(revGeoms)
	  };
	  GeometryCollection.prototype.compareToSameClass = function compareToSameClass () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var o = arguments[0];
	      var theseElements = new TreeSet(Arrays.asList(this._geometries));
	      var otherElements = new TreeSet(Arrays.asList(o._geometries));
	      return this.compare(theseElements, otherElements)
	    } else if (arguments.length === 2) {
	      var o$1 = arguments[0];
	      var comp = arguments[1];
	      var gc = o$1;
	      var n1 = this.getNumGeometries();
	      var n2 = gc.getNumGeometries();
	      var i = 0;
	      while (i < n1 && i < n2) {
	        var thisGeom = this$1$1.getGeometryN(i);
	        var otherGeom = gc.getGeometryN(i);
	        var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
	        if (holeComp !== 0) { return holeComp }
	        i++;
	      }
	      if (i < n1) { return 1 }
	      if (i < n2) { return -1 }
	      return 0
	    }
	  };
	  GeometryCollection.prototype.apply = function apply () {
	    var this$1$1 = this;

	    if (hasInterface(arguments[0], CoordinateFilter)) {
	      var filter = arguments[0];
	      for (var i = 0; i < this._geometries.length; i++) {
	        this$1$1._geometries[i].apply(filter);
	      }
	    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
	      var filter$1 = arguments[0];
	      if (this._geometries.length === 0) { return null }
	      for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {
	        this$1$1._geometries[i$1].apply(filter$1);
	        if (filter$1.isDone()) {
	          break
	        }
	      }
	      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }
	    } else if (hasInterface(arguments[0], GeometryFilter)) {
	      var filter$2 = arguments[0];
	      filter$2.filter(this);
	      for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {
	        this$1$1._geometries[i$2].apply(filter$2);
	      }
	    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
	      var filter$3 = arguments[0];
	      filter$3.filter(this);
	      for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {
	        this$1$1._geometries[i$3].apply(filter$3);
	      }
	    }
	  };
	  GeometryCollection.prototype.getBoundary = function getBoundary () {
	    this.checkNotGeometryCollection(this);
	    Assert.shouldNeverReachHere();
	    return null
	  };
	  GeometryCollection.prototype.clone = function clone () {
	    var this$1$1 = this;

	    var gc = Geometry$$1.prototype.clone.call(this);
	    gc._geometries = new Array(this._geometries.length).fill(null);
	    for (var i = 0; i < this._geometries.length; i++) {
	      gc._geometries[i] = this$1$1._geometries[i].clone();
	    }
	    return gc
	  };
	  GeometryCollection.prototype.getGeometryType = function getGeometryType () {
	    return 'GeometryCollection'
	  };
	  GeometryCollection.prototype.copy = function copy () {
	    var this$1$1 = this;

	    var geometries = new Array(this._geometries.length).fill(null);
	    for (var i = 0; i < geometries.length; i++) {
	      geometries[i] = this$1$1._geometries[i].copy();
	    }
	    return new GeometryCollection(geometries, this._factory)
	  };
	  GeometryCollection.prototype.isEmpty = function isEmpty () {
	    var this$1$1 = this;

	    for (var i = 0; i < this._geometries.length; i++) {
	      if (!this$1$1._geometries[i].isEmpty()) {
	        return false
	      }
	    }
	    return true
	  };
	  GeometryCollection.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  GeometryCollection.prototype.getClass = function getClass () {
	    return GeometryCollection
	  };
	  staticAccessors.serialVersionUID.get = function () { return -5694727726395021467 };

	  Object.defineProperties( GeometryCollection, staticAccessors );

	  return GeometryCollection;
	}(Geometry));

	var MultiLineString = (function (GeometryCollection$$1) {
	  function MultiLineString () {
	    GeometryCollection$$1.apply(this, arguments);
	  }

	  if ( GeometryCollection$$1 ) MultiLineString.__proto__ = GeometryCollection$$1;
	  MultiLineString.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );
	  MultiLineString.prototype.constructor = MultiLineString;

	  var staticAccessors = { serialVersionUID: { configurable: true } };

	  MultiLineString.prototype.getSortIndex = function getSortIndex () {
	    return Geometry.SORTINDEX_MULTILINESTRING
	  };
	  MultiLineString.prototype.equalsExact = function equalsExact () {
	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)
	    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  MultiLineString.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    if (this.isClosed()) {
	      return Dimension.FALSE
	    }
	    return 0
	  };
	  MultiLineString.prototype.isClosed = function isClosed () {
	    var this$1$1 = this;

	    if (this.isEmpty()) {
	      return false
	    }
	    for (var i = 0; i < this._geometries.length; i++) {
	      if (!this$1$1._geometries[i].isClosed()) {
	        return false
	      }
	    }
	    return true
	  };
	  MultiLineString.prototype.getDimension = function getDimension () {
	    return 1
	  };
	  MultiLineString.prototype.reverse = function reverse () {
	    var this$1$1 = this;

	    var nLines = this._geometries.length;
	    var revLines = new Array(nLines).fill(null);
	    for (var i = 0; i < this._geometries.length; i++) {
	      revLines[nLines - 1 - i] = this$1$1._geometries[i].reverse();
	    }
	    return this.getFactory().createMultiLineString(revLines)
	  };
	  MultiLineString.prototype.getBoundary = function getBoundary () {
	    return new BoundaryOp(this).getBoundary()
	  };
	  MultiLineString.prototype.getGeometryType = function getGeometryType () {
	    return 'MultiLineString'
	  };
	  MultiLineString.prototype.copy = function copy () {
	    var this$1$1 = this;

	    var lineStrings = new Array(this._geometries.length).fill(null);
	    for (var i = 0; i < lineStrings.length; i++) {
	      lineStrings[i] = this$1$1._geometries[i].copy();
	    }
	    return new MultiLineString(lineStrings, this._factory)
	  };
	  MultiLineString.prototype.interfaces_ = function interfaces_ () {
	    return [Lineal]
	  };
	  MultiLineString.prototype.getClass = function getClass () {
	    return MultiLineString
	  };
	  staticAccessors.serialVersionUID.get = function () { return 8166665132445433741 };

	  Object.defineProperties( MultiLineString, staticAccessors );

	  return MultiLineString;
	}(GeometryCollection));

	var BoundaryOp = function BoundaryOp () {
	  this._geom = null;
	  this._geomFact = null;
	  this._bnRule = null;
	  this._endpointMap = null;
	  if (arguments.length === 1) {
	    var geom = arguments[0];
	    var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
	    this._geom = geom;
	    this._geomFact = geom.getFactory();
	    this._bnRule = bnRule;
	  } else if (arguments.length === 2) {
	    var geom$1 = arguments[0];
	    var bnRule$1 = arguments[1];
	    this._geom = geom$1;
	    this._geomFact = geom$1.getFactory();
	    this._bnRule = bnRule$1;
	  }
	};
	BoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString (mLine) {
	  if (this._geom.isEmpty()) {
	    return this.getEmptyMultiPoint()
	  }
	  var bdyPts = this.computeBoundaryCoordinates(mLine);
	  if (bdyPts.length === 1) {
	    return this._geomFact.createPoint(bdyPts[0])
	  }
	  return this._geomFact.createMultiPointFromCoords(bdyPts)
	};
	BoundaryOp.prototype.getBoundary = function getBoundary () {
	  if (this._geom instanceof LineString$1) { return this.boundaryLineString(this._geom) }
	  if (this._geom instanceof MultiLineString) { return this.boundaryMultiLineString(this._geom) }
	  return this._geom.getBoundary()
	};
	BoundaryOp.prototype.boundaryLineString = function boundaryLineString (line) {
	  if (this._geom.isEmpty()) {
	    return this.getEmptyMultiPoint()
	  }
	  if (line.isClosed()) {
	    var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
	    if (closedEndpointOnBoundary) {
	      return line.getStartPoint()
	    } else {
	      return this._geomFact.createMultiPoint()
	    }
	  }
	  return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])
	};
	BoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint () {
	  return this._geomFact.createMultiPoint()
	};
	BoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates (mLine) {
	    var this$1$1 = this;

	  var bdyPts = new ArrayList();
	  this._endpointMap = new TreeMap();
	  for (var i = 0; i < mLine.getNumGeometries(); i++) {
	    var line = mLine.getGeometryN(i);
	    if (line.getNumPoints() === 0) { continue }
	    this$1$1.addEndpoint(line.getCoordinateN(0));
	    this$1$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
	  }
	  for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {
	    var entry = it.next();
	    var counter = entry.getValue();
	    var valence = counter.count;
	    if (this$1$1._bnRule.isInBoundary(valence)) {
	      bdyPts.add(entry.getKey());
	    }
	  }
	  return CoordinateArrays.toCoordinateArray(bdyPts)
	};
	BoundaryOp.prototype.addEndpoint = function addEndpoint (pt) {
	  var counter = this._endpointMap.get(pt);
	  if (counter === null) {
	    counter = new Counter();
	    this._endpointMap.put(pt, counter);
	  }
	  counter.count++;
	};
	BoundaryOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BoundaryOp.prototype.getClass = function getClass () {
	  return BoundaryOp
	};
	BoundaryOp.getBoundary = function getBoundary () {
	  if (arguments.length === 1) {
	    var g = arguments[0];
	    var bop = new BoundaryOp(g);
	    return bop.getBoundary()
	  } else if (arguments.length === 2) {
	    var g$1 = arguments[0];
	    var bnRule = arguments[1];
	    var bop$1 = new BoundaryOp(g$1, bnRule);
	    return bop$1.getBoundary()
	  }
	};

	var Counter = function Counter () {
	  this.count = null;
	};
	Counter.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Counter.prototype.getClass = function getClass () {
	  return Counter
	};

	// boundary

	function PrintStream () {}

	function StringReader () {}

	var DecimalFormat = function DecimalFormat () {};

	function ByteArrayOutputStream () {}

	function IOException () {}

	function LineNumberReader () {}

	var StringUtil = function StringUtil () {};

	var staticAccessors$15 = { NEWLINE: { configurable: true },SIMPLE_ORDINATE_FORMAT: { configurable: true } };

	StringUtil.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	StringUtil.prototype.getClass = function getClass () {
	  return StringUtil
	};
	StringUtil.chars = function chars (c, n) {
	  var ch = new Array(n).fill(null);
	  for (var i = 0; i < n; i++) {
	    ch[i] = c;
	  }
	  return String(ch)
	};
	StringUtil.getStackTrace = function getStackTrace () {
	  if (arguments.length === 1) {
	    var t = arguments[0];
	    var os = new ByteArrayOutputStream();
	    var ps = new PrintStream();
	    t.printStackTrace(ps);
	    return os.toString()
	  } else if (arguments.length === 2) {
	    var t$1 = arguments[0];
	    var depth = arguments[1];
	    var stackTrace = '';
	    new StringReader(StringUtil.getStackTrace(t$1));
	    var lineNumberReader = new LineNumberReader();
	    for (var i = 0; i < depth; i++) {
	      try {
	        stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
	      } catch (e) {
	        if (e instanceof IOException) {
	          Assert.shouldNeverReachHere();
	        } else { throw e }
	      } finally {}
	    }
	    return stackTrace
	  }
	};
	StringUtil.split = function split (s, separator) {
	  var separatorlen = separator.length;
	  var tokenList = new ArrayList();
	  var tmpString = '' + s;
	  var pos = tmpString.indexOf(separator);
	  while (pos >= 0) {
	    var token = tmpString.substring(0, pos);
	    tokenList.add(token);
	    tmpString = tmpString.substring(pos + separatorlen);
	    pos = tmpString.indexOf(separator);
	  }
	  if (tmpString.length > 0) { tokenList.add(tmpString); }
	  var res = new Array(tokenList.size()).fill(null);
	  for (var i = 0; i < res.length; i++) {
	    res[i] = tokenList.get(i);
	  }
	  return res
	};
	StringUtil.toString = function toString () {
	  if (arguments.length === 1) {
	    var d = arguments[0];
	    return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)
	  }
	};
	StringUtil.spaces = function spaces (n) {
	  return StringUtil.chars(' ', n)
	};
	staticAccessors$15.NEWLINE.get = function () { return System.getProperty('line.separator') };
	staticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function () { return new DecimalFormat() };

	Object.defineProperties( StringUtil, staticAccessors$15 );

	var CoordinateSequences = function CoordinateSequences () {};

	CoordinateSequences.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CoordinateSequences.prototype.getClass = function getClass () {
	  return CoordinateSequences
	};
	CoordinateSequences.copyCoord = function copyCoord (src, srcPos, dest, destPos) {
	  var minDim = Math.min(src.getDimension(), dest.getDimension());
	  for (var dim = 0; dim < minDim; dim++) {
	    dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
	  }
	};
	CoordinateSequences.isRing = function isRing (seq) {
	  var n = seq.size();
	  if (n === 0) { return true }
	  if (n <= 3) { return false }
	  return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)
	};
	CoordinateSequences.isEqual = function isEqual (cs1, cs2) {
	  var cs1Size = cs1.size();
	  var cs2Size = cs2.size();
	  if (cs1Size !== cs2Size) { return false }
	  var dim = Math.min(cs1.getDimension(), cs2.getDimension());
	  for (var i = 0; i < cs1Size; i++) {
	    for (var d = 0; d < dim; d++) {
	      var v1 = cs1.getOrdinate(i, d);
	      var v2 = cs2.getOrdinate(i, d);
	      if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) { continue }
	      if (Double.isNaN(v1) && Double.isNaN(v2)) { continue }
	      return false
	    }
	  }
	  return true
	};
	CoordinateSequences.extend = function extend (fact, seq, size) {
	  var newseq = fact.create(size, seq.getDimension());
	  var n = seq.size();
	  CoordinateSequences.copy(seq, 0, newseq, 0, n);
	  if (n > 0) {
	    for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, n - 1, newseq, i, 1); }
	  }
	  return newseq
	};
	CoordinateSequences.reverse = function reverse (seq) {
	  var last = seq.size() - 1;
	  var mid = Math.trunc(last / 2);
	  for (var i = 0; i <= mid; i++) {
	    CoordinateSequences.swap(seq, i, last - i);
	  }
	};
	CoordinateSequences.swap = function swap (seq, i, j) {
	  if (i === j) { return null }
	  for (var dim = 0; dim < seq.getDimension(); dim++) {
	    var tmp = seq.getOrdinate(i, dim);
	    seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
	    seq.setOrdinate(j, dim, tmp);
	  }
	};
	CoordinateSequences.copy = function copy (src, srcPos, dest, destPos, length) {
	  for (var i = 0; i < length; i++) {
	    CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
	  }
	};
	CoordinateSequences.toString = function toString () {
	  if (arguments.length === 1) {
	    var cs = arguments[0];
	    var size = cs.size();
	    if (size === 0) { return '()' }
	    var dim = cs.getDimension();
	    var buf = new StringBuffer();
	    buf.append('(');
	    for (var i = 0; i < size; i++) {
	      if (i > 0) { buf.append(' '); }
	      for (var d = 0; d < dim; d++) {
	        if (d > 0) { buf.append(','); }
	        buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
	      }
	    }
	    buf.append(')');
	    return buf.toString()
	  }
	};
	CoordinateSequences.ensureValidRing = function ensureValidRing (fact, seq) {
	  var n = seq.size();
	  if (n === 0) { return seq }
	  if (n <= 3) { return CoordinateSequences.createClosedRing(fact, seq, 4) }
	  var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
	  if (isClosed) { return seq }
	  return CoordinateSequences.createClosedRing(fact, seq, n + 1)
	};
	CoordinateSequences.createClosedRing = function createClosedRing (fact, seq, size) {
	  var newseq = fact.create(size, seq.getDimension());
	  var n = seq.size();
	  CoordinateSequences.copy(seq, 0, newseq, 0, n);
	  for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, 0, newseq, i, 1); }
	  return newseq
	};

	var LineString$1 = (function (Geometry$$1) {
	  function LineString (points, factory) {
	    Geometry$$1.call(this, factory);
	    this._points = null;
	    this.init(points);
	  }

	  if ( Geometry$$1 ) LineString.__proto__ = Geometry$$1;
	  LineString.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );
	  LineString.prototype.constructor = LineString;

	  var staticAccessors = { serialVersionUID: { configurable: true } };
	  LineString.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {
	    if (this.isEmpty()) {
	      return new Envelope()
	    }
	    return this._points.expandEnvelope(new Envelope())
	  };
	  LineString.prototype.isRing = function isRing () {
	    return this.isClosed() && this.isSimple()
	  };
	  LineString.prototype.getSortIndex = function getSortIndex () {
	    return Geometry$$1.SORTINDEX_LINESTRING
	  };
	  LineString.prototype.getCoordinates = function getCoordinates () {
	    return this._points.toCoordinateArray()
	  };
	  LineString.prototype.equalsExact = function equalsExact () {
	    var this$1$1 = this;

	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      var otherLineString = other;
	      if (this._points.size() !== otherLineString._points.size()) {
	        return false
	      }
	      for (var i = 0; i < this._points.size(); i++) {
	        if (!this$1$1.equal(this$1$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
	          return false
	        }
	      }
	      return true
	    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  LineString.prototype.normalize = function normalize () {
	    var this$1$1 = this;

	    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
	      var j = this$1$1._points.size() - 1 - i;
	      if (!this$1$1._points.getCoordinate(i).equals(this$1$1._points.getCoordinate(j))) {
	        if (this$1$1._points.getCoordinate(i).compareTo(this$1$1._points.getCoordinate(j)) > 0) {
	          CoordinateSequences.reverse(this$1$1._points);
	        }
	        return null
	      }
	    }
	  };
	  LineString.prototype.getCoordinate = function getCoordinate () {
	    if (this.isEmpty()) { return null }
	    return this._points.getCoordinate(0)
	  };
	  LineString.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    if (this.isClosed()) {
	      return Dimension.FALSE
	    }
	    return 0
	  };
	  LineString.prototype.isClosed = function isClosed () {
	    if (this.isEmpty()) {
	      return false
	    }
	    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
	  };
	  LineString.prototype.getEndPoint = function getEndPoint () {
	    if (this.isEmpty()) {
	      return null
	    }
	    return this.getPointN(this.getNumPoints() - 1)
	  };
	  LineString.prototype.getDimension = function getDimension () {
	    return 1
	  };
	  LineString.prototype.getLength = function getLength () {
	    return CGAlgorithms.computeLength(this._points)
	  };
	  LineString.prototype.getNumPoints = function getNumPoints () {
	    return this._points.size()
	  };
	  LineString.prototype.reverse = function reverse () {
	    var seq = this._points.copy();
	    CoordinateSequences.reverse(seq);
	    var revLine = this.getFactory().createLineString(seq);
	    return revLine
	  };
	  LineString.prototype.compareToSameClass = function compareToSameClass () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var o = arguments[0];
	      var line = o;
	      var i = 0;
	      var j = 0;
	      while (i < this._points.size() && j < line._points.size()) {
	        var comparison = this$1$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
	        if (comparison !== 0) {
	          return comparison
	        }
	        i++;
	        j++;
	      }
	      if (i < this._points.size()) {
	        return 1
	      }
	      if (j < line._points.size()) {
	        return -1
	      }
	      return 0
	    } else if (arguments.length === 2) {
	      var o$1 = arguments[0];
	      var comp = arguments[1];
	      var line$1 = o$1;
	      return comp.compare(this._points, line$1._points)
	    }
	  };
	  LineString.prototype.apply = function apply () {
	    var this$1$1 = this;

	    if (hasInterface(arguments[0], CoordinateFilter)) {
	      var filter = arguments[0];
	      for (var i = 0; i < this._points.size(); i++) {
	        filter.filter(this$1$1._points.getCoordinate(i));
	      }
	    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
	      var filter$1 = arguments[0];
	      if (this._points.size() === 0) { return null }
	      for (var i$1 = 0; i$1 < this._points.size(); i$1++) {
	        filter$1.filter(this$1$1._points, i$1);
	        if (filter$1.isDone()) { break }
	      }
	      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }
	    } else if (hasInterface(arguments[0], GeometryFilter)) {
	      var filter$2 = arguments[0];
	      filter$2.filter(this);
	    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
	      var filter$3 = arguments[0];
	      filter$3.filter(this);
	    }
	  };
	  LineString.prototype.getBoundary = function getBoundary () {
	    return new BoundaryOp(this).getBoundary()
	  };
	  LineString.prototype.isEquivalentClass = function isEquivalentClass (other) {
	    return other instanceof LineString
	  };
	  LineString.prototype.clone = function clone () {
	    var ls = Geometry$$1.prototype.clone.call(this);
	    ls._points = this._points.clone();
	    return ls
	  };
	  LineString.prototype.getCoordinateN = function getCoordinateN (n) {
	    return this._points.getCoordinate(n)
	  };
	  LineString.prototype.getGeometryType = function getGeometryType () {
	    return 'LineString'
	  };
	  LineString.prototype.copy = function copy () {
	    return new LineString(this._points.copy(), this._factory)
	  };
	  LineString.prototype.getCoordinateSequence = function getCoordinateSequence () {
	    return this._points
	  };
	  LineString.prototype.isEmpty = function isEmpty () {
	    return this._points.size() === 0
	  };
	  LineString.prototype.init = function init (points) {
	    if (points === null) {
	      points = this.getFactory().getCoordinateSequenceFactory().create([]);
	    }
	    if (points.size() === 1) {
	      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')
	    }
	    this._points = points;
	  };
	  LineString.prototype.isCoordinate = function isCoordinate (pt) {
	    var this$1$1 = this;

	    for (var i = 0; i < this._points.size(); i++) {
	      if (this$1$1._points.getCoordinate(i).equals(pt)) {
	        return true
	      }
	    }
	    return false
	  };
	  LineString.prototype.getStartPoint = function getStartPoint () {
	    if (this.isEmpty()) {
	      return null
	    }
	    return this.getPointN(0)
	  };
	  LineString.prototype.getPointN = function getPointN (n) {
	    return this.getFactory().createPoint(this._points.getCoordinate(n))
	  };
	  LineString.prototype.interfaces_ = function interfaces_ () {
	    return [Lineal]
	  };
	  LineString.prototype.getClass = function getClass () {
	    return LineString
	  };
	  staticAccessors.serialVersionUID.get = function () { return 3110669828065365560 };

	  Object.defineProperties( LineString, staticAccessors );

	  return LineString;
	}(Geometry));

	var Puntal = function Puntal () {};

	Puntal.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Puntal.prototype.getClass = function getClass () {
	  return Puntal
	};

	var Point = (function (Geometry$$1) {
	  function Point (coordinates, factory) {
	    Geometry$$1.call(this, factory);
	    this._coordinates = coordinates || null;
	    this.init(this._coordinates);
	  }

	  if ( Geometry$$1 ) Point.__proto__ = Geometry$$1;
	  Point.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );
	  Point.prototype.constructor = Point;

	  var staticAccessors = { serialVersionUID: { configurable: true } };
	  Point.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {
	    if (this.isEmpty()) {
	      return new Envelope()
	    }
	    var env = new Envelope();
	    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
	    return env
	  };
	  Point.prototype.getSortIndex = function getSortIndex () {
	    return Geometry$$1.SORTINDEX_POINT
	  };
	  Point.prototype.getCoordinates = function getCoordinates () {
	    return this.isEmpty() ? [] : [this.getCoordinate()]
	  };
	  Point.prototype.equalsExact = function equalsExact () {
	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      if (this.isEmpty() && other.isEmpty()) {
	        return true
	      }
	      if (this.isEmpty() !== other.isEmpty()) {
	        return false
	      }
	      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)
	    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  Point.prototype.normalize = function normalize () {};
	  Point.prototype.getCoordinate = function getCoordinate () {
	    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null
	  };
	  Point.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    return Dimension.FALSE
	  };
	  Point.prototype.getDimension = function getDimension () {
	    return 0
	  };
	  Point.prototype.getNumPoints = function getNumPoints () {
	    return this.isEmpty() ? 0 : 1
	  };
	  Point.prototype.reverse = function reverse () {
	    return this.copy()
	  };
	  Point.prototype.getX = function getX () {
	    if (this.getCoordinate() === null) {
	      throw new Error('getX called on empty Point')
	    }
	    return this.getCoordinate().x
	  };
	  Point.prototype.compareToSameClass = function compareToSameClass () {
	    if (arguments.length === 1) {
	      var other = arguments[0];
	      var point$1 = other;
	      return this.getCoordinate().compareTo(point$1.getCoordinate())
	    } else if (arguments.length === 2) {
	      var other$1 = arguments[0];
	      var comp = arguments[1];
	      var point = other$1;
	      return comp.compare(this._coordinates, point._coordinates)
	    }
	  };
	  Point.prototype.apply = function apply () {
	    if (hasInterface(arguments[0], CoordinateFilter)) {
	      var filter = arguments[0];
	      if (this.isEmpty()) {
	        return null
	      }
	      filter.filter(this.getCoordinate());
	    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
	      var filter$1 = arguments[0];
	      if (this.isEmpty()) { return null }
	      filter$1.filter(this._coordinates, 0);
	      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }
	    } else if (hasInterface(arguments[0], GeometryFilter)) {
	      var filter$2 = arguments[0];
	      filter$2.filter(this);
	    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
	      var filter$3 = arguments[0];
	      filter$3.filter(this);
	    }
	  };
	  Point.prototype.getBoundary = function getBoundary () {
	    return this.getFactory().createGeometryCollection(null)
	  };
	  Point.prototype.clone = function clone () {
	    var p = Geometry$$1.prototype.clone.call(this);
	    p._coordinates = this._coordinates.clone();
	    return p
	  };
	  Point.prototype.getGeometryType = function getGeometryType () {
	    return 'Point'
	  };
	  Point.prototype.copy = function copy () {
	    return new Point(this._coordinates.copy(), this._factory)
	  };
	  Point.prototype.getCoordinateSequence = function getCoordinateSequence () {
	    return this._coordinates
	  };
	  Point.prototype.getY = function getY () {
	    if (this.getCoordinate() === null) {
	      throw new Error('getY called on empty Point')
	    }
	    return this.getCoordinate().y
	  };
	  Point.prototype.isEmpty = function isEmpty () {
	    return this._coordinates.size() === 0
	  };
	  Point.prototype.init = function init (coordinates) {
	    if (coordinates === null) {
	      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
	    }
	    Assert.isTrue(coordinates.size() <= 1);
	    this._coordinates = coordinates;
	  };
	  Point.prototype.isSimple = function isSimple () {
	    return true
	  };
	  Point.prototype.interfaces_ = function interfaces_ () {
	    return [Puntal]
	  };
	  Point.prototype.getClass = function getClass () {
	    return Point
	  };
	  staticAccessors.serialVersionUID.get = function () { return 4902022702746614570 };

	  Object.defineProperties( Point, staticAccessors );

	  return Point;
	}(Geometry));

	var Polygonal = function Polygonal () {};

	Polygonal.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Polygonal.prototype.getClass = function getClass () {
	  return Polygonal
	};

	var Polygon = (function (Geometry$$1) {
	  function Polygon (shell, holes, factory) {
	    Geometry$$1.call(this, factory);
	    this._shell = null;
	    this._holes = null;
	    if (shell === null) {
	      shell = this.getFactory().createLinearRing();
	    }
	    if (holes === null) {
	      holes = [];
	    }
	    if (Geometry$$1.hasNullElements(holes)) {
	      throw new IllegalArgumentException()
	    }
	    if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {
	      throw new IllegalArgumentException()
	    }
	    this._shell = shell;
	    this._holes = holes;
	  }

	  if ( Geometry$$1 ) Polygon.__proto__ = Geometry$$1;
	  Polygon.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );
	  Polygon.prototype.constructor = Polygon;

	  var staticAccessors = { serialVersionUID: { configurable: true } };
	  Polygon.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {
	    return this._shell.getEnvelopeInternal()
	  };
	  Polygon.prototype.getSortIndex = function getSortIndex () {
	    return Geometry$$1.SORTINDEX_POLYGON
	  };
	  Polygon.prototype.getCoordinates = function getCoordinates () {
	    var this$1$1 = this;

	    if (this.isEmpty()) {
	      return []
	    }
	    var coordinates = new Array(this.getNumPoints()).fill(null);
	    var k = -1;
	    var shellCoordinates = this._shell.getCoordinates();
	    for (var x = 0; x < shellCoordinates.length; x++) {
	      k++;
	      coordinates[k] = shellCoordinates[x];
	    }
	    for (var i = 0; i < this._holes.length; i++) {
	      var childCoordinates = this$1$1._holes[i].getCoordinates();
	      for (var j = 0; j < childCoordinates.length; j++) {
	        k++;
	        coordinates[k] = childCoordinates[j];
	      }
	    }
	    return coordinates
	  };
	  Polygon.prototype.getArea = function getArea () {
	    var this$1$1 = this;

	    var area = 0.0;
	    area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
	    for (var i = 0; i < this._holes.length; i++) {
	      area -= Math.abs(CGAlgorithms.signedArea(this$1$1._holes[i].getCoordinateSequence()));
	    }
	    return area
	  };
	  Polygon.prototype.isRectangle = function isRectangle () {
	    if (this.getNumInteriorRing() !== 0) { return false }
	    if (this._shell === null) { return false }
	    if (this._shell.getNumPoints() !== 5) { return false }
	    var seq = this._shell.getCoordinateSequence();
	    var env = this.getEnvelopeInternal();
	    for (var i = 0; i < 5; i++) {
	      var x = seq.getX(i);
	      if (!(x === env.getMinX() || x === env.getMaxX())) { return false }
	      var y = seq.getY(i);
	      if (!(y === env.getMinY() || y === env.getMaxY())) { return false }
	    }
	    var prevX = seq.getX(0);
	    var prevY = seq.getY(0);
	    for (var i$1 = 1; i$1 <= 4; i$1++) {
	      var x$1 = seq.getX(i$1);
	      var y$1 = seq.getY(i$1);
	      var xChanged = x$1 !== prevX;
	      var yChanged = y$1 !== prevY;
	      if (xChanged === yChanged) { return false }
	      prevX = x$1;
	      prevY = y$1;
	    }
	    return true
	  };
	  Polygon.prototype.equalsExact = function equalsExact () {
	    var this$1$1 = this;

	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      var otherPolygon = other;
	      var thisShell = this._shell;
	      var otherPolygonShell = otherPolygon._shell;
	      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
	        return false
	      }
	      if (this._holes.length !== otherPolygon._holes.length) {
	        return false
	      }
	      for (var i = 0; i < this._holes.length; i++) {
	        if (!this$1$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
	          return false
	        }
	      }
	      return true
	    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  Polygon.prototype.normalize = function normalize () {
	    var this$1$1 = this;

	    if (arguments.length === 0) {
	      this.normalize(this._shell, true);
	      for (var i = 0; i < this._holes.length; i++) {
	        this$1$1.normalize(this$1$1._holes[i], false);
	      }
	      Arrays.sort(this._holes);
	    } else if (arguments.length === 2) {
	      var ring = arguments[0];
	      var clockwise = arguments[1];
	      if (ring.isEmpty()) {
	        return null
	      }
	      var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
	      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
	      var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
	      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
	      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
	      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
	      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
	        CoordinateArrays.reverse(ring.getCoordinates());
	      }
	    }
	  };
	  Polygon.prototype.getCoordinate = function getCoordinate () {
	    return this._shell.getCoordinate()
	  };
	  Polygon.prototype.getNumInteriorRing = function getNumInteriorRing () {
	    return this._holes.length
	  };
	  Polygon.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    return 1
	  };
	  Polygon.prototype.getDimension = function getDimension () {
	    return 2
	  };
	  Polygon.prototype.getLength = function getLength () {
	    var this$1$1 = this;

	    var len = 0.0;
	    len += this._shell.getLength();
	    for (var i = 0; i < this._holes.length; i++) {
	      len += this$1$1._holes[i].getLength();
	    }
	    return len
	  };
	  Polygon.prototype.getNumPoints = function getNumPoints () {
	    var this$1$1 = this;

	    var numPoints = this._shell.getNumPoints();
	    for (var i = 0; i < this._holes.length; i++) {
	      numPoints += this$1$1._holes[i].getNumPoints();
	    }
	    return numPoints
	  };
	  Polygon.prototype.reverse = function reverse () {
	    var this$1$1 = this;

	    var poly = this.copy();
	    poly._shell = this._shell.copy().reverse();
	    poly._holes = new Array(this._holes.length).fill(null);
	    for (var i = 0; i < this._holes.length; i++) {
	      poly._holes[i] = this$1$1._holes[i].copy().reverse();
	    }
	    return poly
	  };
	  Polygon.prototype.convexHull = function convexHull () {
	    return this.getExteriorRing().convexHull()
	  };
	  Polygon.prototype.compareToSameClass = function compareToSameClass () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var o = arguments[0];
	      var thisShell = this._shell;
	      var otherShell = o._shell;
	      return thisShell.compareToSameClass(otherShell)
	    } else if (arguments.length === 2) {
	      var o$1 = arguments[0];
	      var comp = arguments[1];
	      var poly = o$1;
	      var thisShell$1 = this._shell;
	      var otherShell$1 = poly._shell;
	      var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);
	      if (shellComp !== 0) { return shellComp }
	      var nHole1 = this.getNumInteriorRing();
	      var nHole2 = poly.getNumInteriorRing();
	      var i = 0;
	      while (i < nHole1 && i < nHole2) {
	        var thisHole = this$1$1.getInteriorRingN(i);
	        var otherHole = poly.getInteriorRingN(i);
	        var holeComp = thisHole.compareToSameClass(otherHole, comp);
	        if (holeComp !== 0) { return holeComp }
	        i++;
	      }
	      if (i < nHole1) { return 1 }
	      if (i < nHole2) { return -1 }
	      return 0
	    }
	  };
	  Polygon.prototype.apply = function apply (filter) {
	    var this$1$1 = this;

	    if (hasInterface(filter, CoordinateFilter)) {
	      this._shell.apply(filter);
	      for (var i$1 = 0; i$1 < this._holes.length; i$1++) {
	        this$1$1._holes[i$1].apply(filter);
	      }
	    } else if (hasInterface(filter, CoordinateSequenceFilter)) {
	      this._shell.apply(filter);
	      if (!filter.isDone()) {
	        for (var i$2 = 0; i$2 < this._holes.length; i$2++) {
	          this$1$1._holes[i$2].apply(filter);
	          if (filter.isDone()) { break }
	        }
	      }
	      if (filter.isGeometryChanged()) { this.geometryChanged(); }
	    } else if (hasInterface(filter, GeometryFilter)) {
	      filter.filter(this);
	    } else if (hasInterface(filter, GeometryComponentFilter)) {
	      filter.filter(this);
	      this._shell.apply(filter);
	      for (var i = 0; i < this._holes.length; i++) {
	        this$1$1._holes[i].apply(filter);
	      }
	    }
	  };
	  Polygon.prototype.getBoundary = function getBoundary () {
	    var this$1$1 = this;

	    if (this.isEmpty()) {
	      return this.getFactory().createMultiLineString()
	    }
	    var rings = new Array(this._holes.length + 1).fill(null);
	    rings[0] = this._shell;
	    for (var i = 0; i < this._holes.length; i++) {
	      rings[i + 1] = this$1$1._holes[i];
	    }
	    if (rings.length <= 1) { return this.getFactory().createLinearRing(rings[0].getCoordinateSequence()) }
	    return this.getFactory().createMultiLineString(rings)
	  };
	  Polygon.prototype.clone = function clone () {
	    var this$1$1 = this;

	    var poly = Geometry$$1.prototype.clone.call(this);
	    poly._shell = this._shell.clone();
	    poly._holes = new Array(this._holes.length).fill(null);
	    for (var i = 0; i < this._holes.length; i++) {
	      poly._holes[i] = this$1$1._holes[i].clone();
	    }
	    return poly
	  };
	  Polygon.prototype.getGeometryType = function getGeometryType () {
	    return 'Polygon'
	  };
	  Polygon.prototype.copy = function copy () {
	    var this$1$1 = this;

	    var shell = this._shell.copy();
	    var holes = new Array(this._holes.length).fill(null);
	    for (var i = 0; i < holes.length; i++) {
	      holes[i] = this$1$1._holes[i].copy();
	    }
	    return new Polygon(shell, holes, this._factory)
	  };
	  Polygon.prototype.getExteriorRing = function getExteriorRing () {
	    return this._shell
	  };
	  Polygon.prototype.isEmpty = function isEmpty () {
	    return this._shell.isEmpty()
	  };
	  Polygon.prototype.getInteriorRingN = function getInteriorRingN (n) {
	    return this._holes[n]
	  };
	  Polygon.prototype.interfaces_ = function interfaces_ () {
	    return [Polygonal]
	  };
	  Polygon.prototype.getClass = function getClass () {
	    return Polygon
	  };
	  staticAccessors.serialVersionUID.get = function () { return -3494792200821764533 };

	  Object.defineProperties( Polygon, staticAccessors );

	  return Polygon;
	}(Geometry));

	var MultiPoint = (function (GeometryCollection$$1) {
	  function MultiPoint () {
	    GeometryCollection$$1.apply(this, arguments);
	  }

	  if ( GeometryCollection$$1 ) MultiPoint.__proto__ = GeometryCollection$$1;
	  MultiPoint.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );
	  MultiPoint.prototype.constructor = MultiPoint;

	  var staticAccessors = { serialVersionUID: { configurable: true } };

	  MultiPoint.prototype.getSortIndex = function getSortIndex () {
	    return Geometry.SORTINDEX_MULTIPOINT
	  };
	  MultiPoint.prototype.isValid = function isValid () {
	    return true
	  };
	  MultiPoint.prototype.equalsExact = function equalsExact () {
	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)
	    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  MultiPoint.prototype.getCoordinate = function getCoordinate () {
	    if (arguments.length === 1) {
	      var n = arguments[0];
	      return this._geometries[n].getCoordinate()
	    } else { return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments) }
	  };
	  MultiPoint.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    return Dimension.FALSE
	  };
	  MultiPoint.prototype.getDimension = function getDimension () {
	    return 0
	  };
	  MultiPoint.prototype.getBoundary = function getBoundary () {
	    return this.getFactory().createGeometryCollection(null)
	  };
	  MultiPoint.prototype.getGeometryType = function getGeometryType () {
	    return 'MultiPoint'
	  };
	  MultiPoint.prototype.copy = function copy () {
	    var this$1$1 = this;

	    var points = new Array(this._geometries.length).fill(null);
	    for (var i = 0; i < points.length; i++) {
	      points[i] = this$1$1._geometries[i].copy();
	    }
	    return new MultiPoint(points, this._factory)
	  };
	  MultiPoint.prototype.interfaces_ = function interfaces_ () {
	    return [Puntal]
	  };
	  MultiPoint.prototype.getClass = function getClass () {
	    return MultiPoint
	  };
	  staticAccessors.serialVersionUID.get = function () { return -8048474874175355449 };

	  Object.defineProperties( MultiPoint, staticAccessors );

	  return MultiPoint;
	}(GeometryCollection));

	var LinearRing = (function (LineString$$1) {
	  function LinearRing (points, factory) {
	    if (points instanceof Coordinate && factory instanceof GeometryFactory) {
	      points = factory.getCoordinateSequenceFactory().create(points);
	    }
	    LineString$$1.call(this, points, factory);
	    this.validateConstruction();
	  }

	  if ( LineString$$1 ) LinearRing.__proto__ = LineString$$1;
	  LinearRing.prototype = Object.create( LineString$$1 && LineString$$1.prototype );
	  LinearRing.prototype.constructor = LinearRing;

	  var staticAccessors = { MINIMUM_VALID_SIZE: { configurable: true },serialVersionUID: { configurable: true } };
	  LinearRing.prototype.getSortIndex = function getSortIndex () {
	    return Geometry.SORTINDEX_LINEARRING
	  };
	  LinearRing.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    return Dimension.FALSE
	  };
	  LinearRing.prototype.isClosed = function isClosed () {
	    if (this.isEmpty()) {
	      return true
	    }
	    return LineString$$1.prototype.isClosed.call(this)
	  };
	  LinearRing.prototype.reverse = function reverse () {
	    var seq = this._points.copy();
	    CoordinateSequences.reverse(seq);
	    var rev = this.getFactory().createLinearRing(seq);
	    return rev
	  };
	  LinearRing.prototype.validateConstruction = function validateConstruction () {
	    if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {
	      throw new IllegalArgumentException()
	    }
	    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
	      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')
	    }
	  };
	  LinearRing.prototype.getGeometryType = function getGeometryType () {
	    return 'LinearRing'
	  };
	  LinearRing.prototype.copy = function copy () {
	    return new LinearRing(this._points.copy(), this._factory)
	  };
	  LinearRing.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  LinearRing.prototype.getClass = function getClass () {
	    return LinearRing
	  };
	  staticAccessors.MINIMUM_VALID_SIZE.get = function () { return 4 };
	  staticAccessors.serialVersionUID.get = function () { return -4261142084085851829 };

	  Object.defineProperties( LinearRing, staticAccessors );

	  return LinearRing;
	}(LineString$1));

	var MultiPolygon = (function (GeometryCollection$$1) {
	  function MultiPolygon () {
	    GeometryCollection$$1.apply(this, arguments);
	  }

	  if ( GeometryCollection$$1 ) MultiPolygon.__proto__ = GeometryCollection$$1;
	  MultiPolygon.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );
	  MultiPolygon.prototype.constructor = MultiPolygon;

	  var staticAccessors = { serialVersionUID: { configurable: true } };

	  MultiPolygon.prototype.getSortIndex = function getSortIndex () {
	    return Geometry.SORTINDEX_MULTIPOLYGON
	  };
	  MultiPolygon.prototype.equalsExact = function equalsExact () {
	    if (arguments.length === 2) {
	      var other = arguments[0];
	      var tolerance = arguments[1];
	      if (!this.isEquivalentClass(other)) {
	        return false
	      }
	      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)
	    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }
	  };
	  MultiPolygon.prototype.getBoundaryDimension = function getBoundaryDimension () {
	    return 1
	  };
	  MultiPolygon.prototype.getDimension = function getDimension () {
	    return 2
	  };
	  MultiPolygon.prototype.reverse = function reverse () {
	    var this$1$1 = this;

	    var n = this._geometries.length;
	    var revGeoms = new Array(n).fill(null);
	    for (var i = 0; i < this._geometries.length; i++) {
	      revGeoms[i] = this$1$1._geometries[i].reverse();
	    }
	    return this.getFactory().createMultiPolygon(revGeoms)
	  };
	  MultiPolygon.prototype.getBoundary = function getBoundary () {
	    var this$1$1 = this;

	    if (this.isEmpty()) {
	      return this.getFactory().createMultiLineString()
	    }
	    var allRings = new ArrayList();
	    for (var i = 0; i < this._geometries.length; i++) {
	      var polygon = this$1$1._geometries[i];
	      var rings = polygon.getBoundary();
	      for (var j = 0; j < rings.getNumGeometries(); j++) {
	        allRings.add(rings.getGeometryN(j));
	      }
	    }
	    var allRingsArray = new Array(allRings.size()).fill(null);
	    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))
	  };
	  MultiPolygon.prototype.getGeometryType = function getGeometryType () {
	    return 'MultiPolygon'
	  };
	  MultiPolygon.prototype.copy = function copy () {
	    var this$1$1 = this;

	    var polygons = new Array(this._geometries.length).fill(null);
	    for (var i = 0; i < polygons.length; i++) {
	      polygons[i] = this$1$1._geometries[i].copy();
	    }
	    return new MultiPolygon(polygons, this._factory)
	  };
	  MultiPolygon.prototype.interfaces_ = function interfaces_ () {
	    return [Polygonal]
	  };
	  MultiPolygon.prototype.getClass = function getClass () {
	    return MultiPolygon
	  };
	  staticAccessors.serialVersionUID.get = function () { return -551033529766975875 };

	  Object.defineProperties( MultiPolygon, staticAccessors );

	  return MultiPolygon;
	}(GeometryCollection));

	var GeometryEditor = function GeometryEditor (factory) {
	  this._factory = factory || null;
	  this._isUserDataCopied = false;
	};

	var staticAccessors$16 = { NoOpGeometryOperation: { configurable: true },CoordinateOperation: { configurable: true },CoordinateSequenceOperation: { configurable: true } };
	GeometryEditor.prototype.setCopyUserData = function setCopyUserData (isUserDataCopied) {
	  this._isUserDataCopied = isUserDataCopied;
	};
	GeometryEditor.prototype.edit = function edit (geometry, operation) {
	  if (geometry === null) { return null }
	  var result = this.editInternal(geometry, operation);
	  if (this._isUserDataCopied) {
	    result.setUserData(geometry.getUserData());
	  }
	  return result
	};
	GeometryEditor.prototype.editInternal = function editInternal (geometry, operation) {
	  if (this._factory === null) { this._factory = geometry.getFactory(); }
	  if (geometry instanceof GeometryCollection) {
	    return this.editGeometryCollection(geometry, operation)
	  }
	  if (geometry instanceof Polygon) {
	    return this.editPolygon(geometry, operation)
	  }
	  if (geometry instanceof Point) {
	    return operation.edit(geometry, this._factory)
	  }
	  if (geometry instanceof LineString$1) {
	    return operation.edit(geometry, this._factory)
	  }
	  Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());
	  return null
	};
	GeometryEditor.prototype.editGeometryCollection = function editGeometryCollection (collection, operation) {
	    var this$1$1 = this;

	  var collectionForType = operation.edit(collection, this._factory);
	  var geometries = new ArrayList();
	  for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
	    var geometry = this$1$1.edit(collectionForType.getGeometryN(i), operation);
	    if (geometry === null || geometry.isEmpty()) {
	      continue
	    }
	    geometries.add(geometry);
	  }
	  if (collectionForType.getClass() === MultiPoint) {
	    return this._factory.createMultiPoint(geometries.toArray([]))
	  }
	  if (collectionForType.getClass() === MultiLineString) {
	    return this._factory.createMultiLineString(geometries.toArray([]))
	  }
	  if (collectionForType.getClass() === MultiPolygon) {
	    return this._factory.createMultiPolygon(geometries.toArray([]))
	  }
	  return this._factory.createGeometryCollection(geometries.toArray([]))
	};
	GeometryEditor.prototype.editPolygon = function editPolygon (polygon, operation) {
	    var this$1$1 = this;

	  var newPolygon = operation.edit(polygon, this._factory);
	  if (newPolygon === null) { newPolygon = this._factory.createPolygon(null); }
	  if (newPolygon.isEmpty()) {
	    return newPolygon
	  }
	  var shell = this.edit(newPolygon.getExteriorRing(), operation);
	  if (shell === null || shell.isEmpty()) {
	    return this._factory.createPolygon()
	  }
	  var holes = new ArrayList();
	  for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
	    var hole = this$1$1.edit(newPolygon.getInteriorRingN(i), operation);
	    if (hole === null || hole.isEmpty()) {
	      continue
	    }
	    holes.add(hole);
	  }
	  return this._factory.createPolygon(shell, holes.toArray([]))
	};
	GeometryEditor.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryEditor.prototype.getClass = function getClass () {
	  return GeometryEditor
	};
	GeometryEditor.GeometryEditorOperation = function GeometryEditorOperation () {};
	staticAccessors$16.NoOpGeometryOperation.get = function () { return NoOpGeometryOperation };
	staticAccessors$16.CoordinateOperation.get = function () { return CoordinateOperation };
	staticAccessors$16.CoordinateSequenceOperation.get = function () { return CoordinateSequenceOperation };

	Object.defineProperties( GeometryEditor, staticAccessors$16 );

	var NoOpGeometryOperation = function NoOpGeometryOperation () {};

	NoOpGeometryOperation.prototype.edit = function edit (geometry, factory) {
	  return geometry
	};
	NoOpGeometryOperation.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryEditor.GeometryEditorOperation]
	};
	NoOpGeometryOperation.prototype.getClass = function getClass () {
	  return NoOpGeometryOperation
	};

	var CoordinateOperation = function CoordinateOperation () {};

	CoordinateOperation.prototype.edit = function edit (geometry, factory) {
	  var coords = this.editCoordinates(geometry.getCoordinates(), geometry);
	  if (coords === null) { return geometry }
	  if (geometry instanceof LinearRing) {
	    return factory.createLinearRing(coords)
	  }
	  if (geometry instanceof LineString$1) {
	    return factory.createLineString(coords)
	  }
	  if (geometry instanceof Point) {
	    if (coords.length > 0) {
	      return factory.createPoint(coords[0])
	    } else {
	      return factory.createPoint()
	    }
	  }
	  return geometry
	};
	CoordinateOperation.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryEditor.GeometryEditorOperation]
	};
	CoordinateOperation.prototype.getClass = function getClass () {
	  return CoordinateOperation
	};

	var CoordinateSequenceOperation = function CoordinateSequenceOperation () {};

	CoordinateSequenceOperation.prototype.edit = function edit (geometry, factory) {
	  if (geometry instanceof LinearRing) {
	    return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))
	  }
	  if (geometry instanceof LineString$1) {
	    return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))
	  }
	  if (geometry instanceof Point) {
	    return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))
	  }
	  return geometry
	};
	CoordinateSequenceOperation.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryEditor.GeometryEditorOperation]
	};
	CoordinateSequenceOperation.prototype.getClass = function getClass () {
	  return CoordinateSequenceOperation
	};

	var CoordinateArraySequence = function CoordinateArraySequence () {
	  var this$1$1 = this;

	  this._dimension = 3;
	  this._coordinates = null;
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Array) {
	      this._coordinates = arguments[0];
	      this._dimension = 3;
	    } else if (Number.isInteger(arguments[0])) {
	      var size = arguments[0];
	      this._coordinates = new Array(size).fill(null);
	      for (var i = 0; i < size; i++) {
	        this$1$1._coordinates[i] = new Coordinate();
	      }
	    } else if (hasInterface(arguments[0], CoordinateSequence)) {
	      var coordSeq = arguments[0];
	      if (coordSeq === null) {
	        this._coordinates = new Array(0).fill(null);
	        return null
	      }
	      this._dimension = coordSeq.getDimension();
	      this._coordinates = new Array(coordSeq.size()).fill(null);
	      for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {
	        this$1$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);
	      }
	    }
	  } else if (arguments.length === 2) {
	    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
	      var coordinates = arguments[0];
	      var dimension = arguments[1];
	      this._coordinates = coordinates;
	      this._dimension = dimension;
	      if (coordinates === null) { this._coordinates = new Array(0).fill(null); }
	    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
	      var size$1 = arguments[0];
	      var dimension$1 = arguments[1];
	      this._coordinates = new Array(size$1).fill(null);
	      this._dimension = dimension$1;
	      for (var i$2 = 0; i$2 < size$1; i$2++) {
	        this$1$1._coordinates[i$2] = new Coordinate();
	      }
	    }
	  }
	};

	var staticAccessors$18 = { serialVersionUID: { configurable: true } };
	CoordinateArraySequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {
	  switch (ordinateIndex) {
	    case CoordinateSequence.X:
	      this._coordinates[index].x = value;
	      break
	    case CoordinateSequence.Y:
	      this._coordinates[index].y = value;
	      break
	    case CoordinateSequence.Z:
	      this._coordinates[index].z = value;
	      break
	    default:
	      throw new IllegalArgumentException()
	  }
	};
	CoordinateArraySequence.prototype.size = function size () {
	  return this._coordinates.length
	};
	CoordinateArraySequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {
	  switch (ordinateIndex) {
	    case CoordinateSequence.X:
	      return this._coordinates[index].x
	    case CoordinateSequence.Y:
	      return this._coordinates[index].y
	    case CoordinateSequence.Z:
	      return this._coordinates[index].z
	  }
	  return Double.NaN
	};
	CoordinateArraySequence.prototype.getCoordinate = function getCoordinate () {
	  if (arguments.length === 1) {
	    var i = arguments[0];
	    return this._coordinates[i]
	  } else if (arguments.length === 2) {
	    var index = arguments[0];
	    var coord = arguments[1];
	    coord.x = this._coordinates[index].x;
	    coord.y = this._coordinates[index].y;
	    coord.z = this._coordinates[index].z;
	  }
	};
	CoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {
	  return new Coordinate(this._coordinates[i])
	};
	CoordinateArraySequence.prototype.getDimension = function getDimension () {
	  return this._dimension
	};
	CoordinateArraySequence.prototype.getX = function getX (index) {
	  return this._coordinates[index].x
	};
	CoordinateArraySequence.prototype.clone = function clone () {
	    var this$1$1 = this;

	  var cloneCoordinates = new Array(this.size()).fill(null);
	  for (var i = 0; i < this._coordinates.length; i++) {
	    cloneCoordinates[i] = this$1$1._coordinates[i].clone();
	  }
	  return new CoordinateArraySequence(cloneCoordinates, this._dimension)
	};
	CoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope (env) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._coordinates.length; i++) {
	    env.expandToInclude(this$1$1._coordinates[i]);
	  }
	  return env
	};
	CoordinateArraySequence.prototype.copy = function copy () {
	    var this$1$1 = this;

	  var cloneCoordinates = new Array(this.size()).fill(null);
	  for (var i = 0; i < this._coordinates.length; i++) {
	    cloneCoordinates[i] = this$1$1._coordinates[i].copy();
	  }
	  return new CoordinateArraySequence(cloneCoordinates, this._dimension)
	};
	CoordinateArraySequence.prototype.toString = function toString () {
	    var this$1$1 = this;

	  if (this._coordinates.length > 0) {
	    var strBuf = new StringBuffer(17 * this._coordinates.length);
	    strBuf.append('(');
	    strBuf.append(this._coordinates[0]);
	    for (var i = 1; i < this._coordinates.length; i++) {
	      strBuf.append(', ');
	      strBuf.append(this$1$1._coordinates[i]);
	    }
	    strBuf.append(')');
	    return strBuf.toString()
	  } else {
	    return '()'
	  }
	};
	CoordinateArraySequence.prototype.getY = function getY (index) {
	  return this._coordinates[index].y
	};
	CoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray () {
	  return this._coordinates
	};
	CoordinateArraySequence.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateSequence, Serializable]
	};
	CoordinateArraySequence.prototype.getClass = function getClass () {
	  return CoordinateArraySequence
	};
	staticAccessors$18.serialVersionUID.get = function () { return -915438501601840650 };

	Object.defineProperties( CoordinateArraySequence, staticAccessors$18 );

	var CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory () {};

	var staticAccessors$17 = { serialVersionUID: { configurable: true },instanceObject: { configurable: true } };

	CoordinateArraySequenceFactory.prototype.readResolve = function readResolve () {
	  return CoordinateArraySequenceFactory.instance()
	};
	CoordinateArraySequenceFactory.prototype.create = function create () {
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Array) {
	      var coordinates = arguments[0];
	      return new CoordinateArraySequence(coordinates)
	    } else if (hasInterface(arguments[0], CoordinateSequence)) {
	      var coordSeq = arguments[0];
	      return new CoordinateArraySequence(coordSeq)
	    }
	  } else if (arguments.length === 2) {
	    var size = arguments[0];
	    var dimension = arguments[1];
	    if (dimension > 3) { dimension = 3; }
	    if (dimension < 2) { return new CoordinateArraySequence(size) }
	    return new CoordinateArraySequence(size, dimension)
	  }
	};
	CoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateSequenceFactory, Serializable]
	};
	CoordinateArraySequenceFactory.prototype.getClass = function getClass () {
	  return CoordinateArraySequenceFactory
	};
	CoordinateArraySequenceFactory.instance = function instance () {
	  return CoordinateArraySequenceFactory.instanceObject
	};

	staticAccessors$17.serialVersionUID.get = function () { return -4099577099607551657 };
	staticAccessors$17.instanceObject.get = function () { return new CoordinateArraySequenceFactory() };

	Object.defineProperties( CoordinateArraySequenceFactory, staticAccessors$17 );

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
	 *
	 * @extends {javascript.util.Map}
	 * @constructor
	 * @private
	 */
	var HashMap = (function (MapInterface) {
	  function HashMap () {
	    MapInterface.call(this);
	    this.map_ = new Map();
	  }

	  if ( MapInterface ) HashMap.__proto__ = MapInterface;
	  HashMap.prototype = Object.create( MapInterface && MapInterface.prototype );
	  HashMap.prototype.constructor = HashMap;
	  /**
	   * @override
	   */
	  HashMap.prototype.get = function get (key) {
	    return this.map_.get(key) || null
	  };

	  /**
	   * @override
	   */
	  HashMap.prototype.put = function put (key, value) {
	    this.map_.set(key, value);
	    return value
	  };

	  /**
	   * @override
	   */
	  HashMap.prototype.values = function values () {
	    var arrayList = new ArrayList();
	    var it = this.map_.values();
	    var o = it.next();
	    while (!o.done) {
	      arrayList.add(o.value);
	      o = it.next();
	    }
	    return arrayList
	  };

	  /**
	   * @override
	   */
	  HashMap.prototype.entrySet = function entrySet () {
	    var hashSet = new HashSet();
	    this.map_.entries().forEach(function (entry) { return hashSet.add(entry); });
	    return hashSet
	  };

	  /**
	   * @override
	   */
	  HashMap.prototype.size = function size () {
	    return this.map_.size()
	  };

	  return HashMap;
	}(Map$1));

	var PrecisionModel = function PrecisionModel () {
	  this._modelType = null;
	  this._scale = null;
	  if (arguments.length === 0) {
	    this._modelType = PrecisionModel.FLOATING;
	  } else if (arguments.length === 1) {
	    if (arguments[0] instanceof Type) {
	      var modelType = arguments[0];
	      this._modelType = modelType;
	      if (modelType === PrecisionModel.FIXED) {
	        this.setScale(1.0);
	      }
	    } else if (typeof arguments[0] === 'number') {
	      var scale = arguments[0];
	      this._modelType = PrecisionModel.FIXED;
	      this.setScale(scale);
	    } else if (arguments[0] instanceof PrecisionModel) {
	      var pm = arguments[0];
	      this._modelType = pm._modelType;
	      this._scale = pm._scale;
	    }
	  }
	};

	var staticAccessors$19 = { serialVersionUID: { configurable: true },maximumPreciseValue: { configurable: true } };
	PrecisionModel.prototype.equals = function equals (other) {
	  if (!(other instanceof PrecisionModel)) {
	    return false
	  }
	  var otherPrecisionModel = other;
	  return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale
	};
	PrecisionModel.prototype.compareTo = function compareTo (o) {
	  var other = o;
	  var sigDigits = this.getMaximumSignificantDigits();
	  var otherSigDigits = other.getMaximumSignificantDigits();
	  return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))
	};
	PrecisionModel.prototype.getScale = function getScale () {
	  return this._scale
	};
	PrecisionModel.prototype.isFloating = function isFloating () {
	  return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE
	};
	PrecisionModel.prototype.getType = function getType () {
	  return this._modelType
	};
	PrecisionModel.prototype.toString = function toString () {
	  var description = 'UNKNOWN';
	  if (this._modelType === PrecisionModel.FLOATING) {
	    description = 'Floating';
	  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
	    description = 'Floating-Single';
	  } else if (this._modelType === PrecisionModel.FIXED) {
	    description = 'Fixed (Scale=' + this.getScale() + ')';
	  }
	  return description
	};
	PrecisionModel.prototype.makePrecise = function makePrecise () {
	  if (typeof arguments[0] === 'number') {
	    var val = arguments[0];
	    if (Double.isNaN(val)) { return val }
	    if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
	      var floatSingleVal = val;
	      return floatSingleVal
	    }
	    if (this._modelType === PrecisionModel.FIXED) {
	      return Math.round(val * this._scale) / this._scale
	    }
	    return val
	  } else if (arguments[0] instanceof Coordinate) {
	    var coord = arguments[0];
	    if (this._modelType === PrecisionModel.FLOATING) { return null }
	    coord.x = this.makePrecise(coord.x);
	    coord.y = this.makePrecise(coord.y);
	  }
	};
	PrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits () {
	  var maxSigDigits = 16;
	  if (this._modelType === PrecisionModel.FLOATING) {
	    maxSigDigits = 16;
	  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
	    maxSigDigits = 6;
	  } else if (this._modelType === PrecisionModel.FIXED) {
	    maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
	  }
	  return maxSigDigits
	};
	PrecisionModel.prototype.setScale = function setScale (scale) {
	  this._scale = Math.abs(scale);
	};
	PrecisionModel.prototype.interfaces_ = function interfaces_ () {
	  return [Serializable, Comparable]
	};
	PrecisionModel.prototype.getClass = function getClass () {
	  return PrecisionModel
	};
	PrecisionModel.mostPrecise = function mostPrecise (pm1, pm2) {
	  if (pm1.compareTo(pm2) >= 0) { return pm1 }
	  return pm2
	};
	staticAccessors$19.serialVersionUID.get = function () { return 7777263578777803835 };
	staticAccessors$19.maximumPreciseValue.get = function () { return 9007199254740992.0 };

	Object.defineProperties( PrecisionModel, staticAccessors$19 );

	var Type = function Type (name) {
	  this._name = name || null;
	  Type.nameToTypeMap.put(name, this);
	};

	var staticAccessors$1$1 = { serialVersionUID: { configurable: true },nameToTypeMap: { configurable: true } };
	Type.prototype.readResolve = function readResolve () {
	  return Type.nameToTypeMap.get(this._name)
	};
	Type.prototype.toString = function toString () {
	  return this._name
	};
	Type.prototype.interfaces_ = function interfaces_ () {
	  return [Serializable]
	};
	Type.prototype.getClass = function getClass () {
	  return Type
	};
	staticAccessors$1$1.serialVersionUID.get = function () { return -5528602631731589822 };
	staticAccessors$1$1.nameToTypeMap.get = function () { return new HashMap() };

	Object.defineProperties( Type, staticAccessors$1$1 );

	PrecisionModel.Type = Type;
	PrecisionModel.FIXED = new Type('FIXED');
	PrecisionModel.FLOATING = new Type('FLOATING');
	PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');

	var GeometryFactory = function GeometryFactory () {
	  this._precisionModel = new PrecisionModel();
	  this._SRID = 0;
	  this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();

	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
	      this._coordinateSequenceFactory = arguments[0];
	    } else if (arguments[0] instanceof PrecisionModel) {
	      this._precisionModel = arguments[0];
	    }
	  } else if (arguments.length === 2) {
	    this._precisionModel = arguments[0];
	    this._SRID = arguments[1];
	  } else if (arguments.length === 3) {
	    this._precisionModel = arguments[0];
	    this._SRID = arguments[1];
	    this._coordinateSequenceFactory = arguments[2];
	  }
	};

	var staticAccessors$2 = { serialVersionUID: { configurable: true } };
	GeometryFactory.prototype.toGeometry = function toGeometry (envelope) {
	  if (envelope.isNull()) {
	    return this.createPoint(null)
	  }
	  if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
	    return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))
	  }
	  if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
	    return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])
	  }
	  return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)
	};
	GeometryFactory.prototype.createLineString = function createLineString (coordinates) {
	  if (!coordinates) { return new LineString$1(this.getCoordinateSequenceFactory().create([]), this) }
	  else if (coordinates instanceof Array) { return new LineString$1(this.getCoordinateSequenceFactory().create(coordinates), this) }
	  else if (hasInterface(coordinates, CoordinateSequence)) { return new LineString$1(coordinates, this) }
	};
	GeometryFactory.prototype.createMultiLineString = function createMultiLineString () {
	  if (arguments.length === 0) {
	    return new MultiLineString(null, this)
	  } else if (arguments.length === 1) {
	    var lineStrings = arguments[0];
	    return new MultiLineString(lineStrings, this)
	  }
	};
	GeometryFactory.prototype.buildGeometry = function buildGeometry (geomList) {
	  var geomClass = null;
	  var isHeterogeneous = false;
	  var hasGeometryCollection = false;
	  for (var i = geomList.iterator(); i.hasNext();) {
	    var geom = i.next();
	    var partClass = geom.getClass();
	    if (geomClass === null) {
	      geomClass = partClass;
	    }
	    if (partClass !== geomClass) {
	      isHeterogeneous = true;
	    }
	    if (geom.isGeometryCollectionOrDerived()) { hasGeometryCollection = true; }
	  }
	  if (geomClass === null) {
	    return this.createGeometryCollection()
	  }
	  if (isHeterogeneous || hasGeometryCollection) {
	    return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))
	  }
	  var geom0 = geomList.iterator().next();
	  var isCollection = geomList.size() > 1;
	  if (isCollection) {
	    if (geom0 instanceof Polygon) {
	      return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))
	    } else if (geom0 instanceof LineString$1) {
	      return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))
	    } else if (geom0 instanceof Point) {
	      return this.createMultiPoint(GeometryFactory.toPointArray(geomList))
	    }
	    Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());
	  }
	  return geom0
	};
	GeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords (coordinates) {
	  return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
	};
	GeometryFactory.prototype.createPoint = function createPoint () {
	  if (arguments.length === 0) {
	    return this.createPoint(this.getCoordinateSequenceFactory().create([]))
	  } else if (arguments.length === 1) {
	    if (arguments[0] instanceof Coordinate) {
	      var coordinate = arguments[0];
	      return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)
	    } else if (hasInterface(arguments[0], CoordinateSequence)) {
	      var coordinates = arguments[0];
	      return new Point(coordinates, this)
	    }
	  }
	};
	GeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory () {
	  return this._coordinateSequenceFactory
	};
	GeometryFactory.prototype.createPolygon = function createPolygon () {
	  if (arguments.length === 0) {
	    return new Polygon(null, null, this)
	  } else if (arguments.length === 1) {
	    if (hasInterface(arguments[0], CoordinateSequence)) {
	      var coordinates = arguments[0];
	      return this.createPolygon(this.createLinearRing(coordinates))
	    } else if (arguments[0] instanceof Array) {
	      var coordinates$1 = arguments[0];
	      return this.createPolygon(this.createLinearRing(coordinates$1))
	    } else if (arguments[0] instanceof LinearRing) {
	      var shell = arguments[0];
	      return this.createPolygon(shell, null)
	    }
	  } else if (arguments.length === 2) {
	    var shell$1 = arguments[0];
	    var holes = arguments[1];
	    return new Polygon(shell$1, holes, this)
	  }
	};
	GeometryFactory.prototype.getSRID = function getSRID () {
	  return this._SRID
	};
	GeometryFactory.prototype.createGeometryCollection = function createGeometryCollection () {
	  if (arguments.length === 0) {
	    return new GeometryCollection(null, this)
	  } else if (arguments.length === 1) {
	    var geometries = arguments[0];
	    return new GeometryCollection(geometries, this)
	  }
	};
	GeometryFactory.prototype.createGeometry = function createGeometry (g) {
	  var editor = new GeometryEditor(this);
	  return editor.edit(g, {
	    edit: function () {
	      if (arguments.length === 2) {
	        var coordSeq = arguments[0];
	        // const geometry = arguments[1]
	        return this._coordinateSequenceFactory.create(coordSeq)
	      }
	    }
	  })
	};
	GeometryFactory.prototype.getPrecisionModel = function getPrecisionModel () {
	  return this._precisionModel
	};
	GeometryFactory.prototype.createLinearRing = function createLinearRing () {
	  if (arguments.length === 0) {
	    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))
	  } else if (arguments.length === 1) {
	    if (arguments[0] instanceof Array) {
	      var coordinates = arguments[0];
	      return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
	    } else if (hasInterface(arguments[0], CoordinateSequence)) {
	      var coordinates$1 = arguments[0];
	      return new LinearRing(coordinates$1, this)
	    }
	  }
	};
	GeometryFactory.prototype.createMultiPolygon = function createMultiPolygon () {
	  if (arguments.length === 0) {
	    return new MultiPolygon(null, this)
	  } else if (arguments.length === 1) {
	    var polygons = arguments[0];
	    return new MultiPolygon(polygons, this)
	  }
	};
	GeometryFactory.prototype.createMultiPoint = function createMultiPoint () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    return new MultiPoint(null, this)
	  } else if (arguments.length === 1) {
	    if (arguments[0] instanceof Array) {
	      var point = arguments[0];
	      return new MultiPoint(point, this)
	    } else if (arguments[0] instanceof Array) {
	      var coordinates = arguments[0];
	      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
	    } else if (hasInterface(arguments[0], CoordinateSequence)) {
	      var coordinates$1 = arguments[0];
	      if (coordinates$1 === null) {
	        return this.createMultiPoint(new Array(0).fill(null))
	      }
	      var points = new Array(coordinates$1.size()).fill(null);
	      for (var i = 0; i < coordinates$1.size(); i++) {
	        var ptSeq = this$1$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());
	        CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);
	        points[i] = this$1$1.createPoint(ptSeq);
	      }
	      return this.createMultiPoint(points)
	    }
	  }
	};
	GeometryFactory.prototype.interfaces_ = function interfaces_ () {
	  return [Serializable]
	};
	GeometryFactory.prototype.getClass = function getClass () {
	  return GeometryFactory
	};
	GeometryFactory.toMultiPolygonArray = function toMultiPolygonArray (multiPolygons) {
	  var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
	  return multiPolygons.toArray(multiPolygonArray)
	};
	GeometryFactory.toGeometryArray = function toGeometryArray (geometries) {
	  if (geometries === null) { return null }
	  var geometryArray = new Array(geometries.size()).fill(null);
	  return geometries.toArray(geometryArray)
	};
	GeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory () {
	  return CoordinateArraySequenceFactory.instance()
	};
	GeometryFactory.toMultiLineStringArray = function toMultiLineStringArray (multiLineStrings) {
	  var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
	  return multiLineStrings.toArray(multiLineStringArray)
	};
	GeometryFactory.toLineStringArray = function toLineStringArray (lineStrings) {
	  var lineStringArray = new Array(lineStrings.size()).fill(null);
	  return lineStrings.toArray(lineStringArray)
	};
	GeometryFactory.toMultiPointArray = function toMultiPointArray (multiPoints) {
	  var multiPointArray = new Array(multiPoints.size()).fill(null);
	  return multiPoints.toArray(multiPointArray)
	};
	GeometryFactory.toLinearRingArray = function toLinearRingArray (linearRings) {
	  var linearRingArray = new Array(linearRings.size()).fill(null);
	  return linearRings.toArray(linearRingArray)
	};
	GeometryFactory.toPointArray = function toPointArray (points) {
	  var pointArray = new Array(points.size()).fill(null);
	  return points.toArray(pointArray)
	};
	GeometryFactory.toPolygonArray = function toPolygonArray (polygons) {
	  var polygonArray = new Array(polygons.size()).fill(null);
	  return polygons.toArray(polygonArray)
	};
	GeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord (coord, exemplar) {
	  exemplar.getPrecisionModel().makePrecise(coord);
	  return exemplar.getFactory().createPoint(coord)
	};
	staticAccessors$2.serialVersionUID.get = function () { return -6820524753094095635 };

	Object.defineProperties( GeometryFactory, staticAccessors$2 );

	var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

	/**
	 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
	 * NOTE: Adapted from OpenLayers 2.11 implementation.
	 */

	/**
	 * Create a new parser for GeoJSON
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @return An instance of GeoJsonParser.
	 * @constructor
	 * @private
	 */
	var GeoJSONParser = function GeoJSONParser (geometryFactory) {
	  this.geometryFactory = geometryFactory || new GeometryFactory();
	};
	/**
	 * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
	 *
	 * @param {}
	 *        A GeoJSON object.
	 * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
	 * @private
	 */
	GeoJSONParser.prototype.read = function read (json) {
	  var obj;
	  if (typeof json === 'string') {
	    obj = JSON.parse(json);
	  } else {
	    obj = json;
	  }

	  var type = obj.type;

	  if (!parse$5[type]) {
	    throw new Error('Unknown GeoJSON type: ' + obj.type)
	  }

	  if (geometryTypes.indexOf(type) !== -1) {
	    return parse$5[type].apply(this, [obj.coordinates])
	  } else if (type === 'GeometryCollection') {
	    return parse$5[type].apply(this, [obj.geometries])
	  }

	  // feature or feature collection
	  return parse$5[type].apply(this, [obj])
	};

	/**
	 * Serialize a Geometry object into GeoJSON
	 *
	 * @param {Geometry}
	 *        geometry A Geometry or array of Geometries.
	 * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
	 * @private
	 */
	GeoJSONParser.prototype.write = function write (geometry) {
	  var type = geometry.getGeometryType();

	  if (!extract$1$1[type]) {
	    throw new Error('Geometry is not supported')
	  }

	  return extract$1$1[type].apply(this, [geometry])
	};

	var parse$5 = {
	  /**
	   * Parse a GeoJSON Feature object
	   *
	   * @param {Object}
	   *          obj Object to parse.
	   *
	   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
	   */
	  Feature: function (obj) {
	    var feature = {};

	    // copy features
	    for (var key in obj) {
	      feature[key] = obj[key];
	    }

	    // parse geometry
	    if (obj.geometry) {
	      var type = obj.geometry.type;
	      if (!parse$5[type]) {
	        throw new Error('Unknown GeoJSON type: ' + obj.type)
	      }
	      feature.geometry = this.read(obj.geometry);
	    }

	    // bbox
	    if (obj.bbox) {
	      feature.bbox = parse$5.bbox.apply(this, [obj.bbox]);
	    }

	    return feature
	  },

	  /**
	   * Parse a GeoJSON FeatureCollection object
	   *
	   * @param {Object}
	   *          obj Object to parse.
	   *
	   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
	   */
	  FeatureCollection: function (obj) {
	    var this$1$1 = this;

	    var featureCollection = {};

	    if (obj.features) {
	      featureCollection.features = [];

	      for (var i = 0; i < obj.features.length; ++i) {
	        featureCollection.features.push(this$1$1.read(obj.features[i]));
	      }
	    }

	    if (obj.bbox) {
	      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);
	    }

	    return featureCollection
	  },

	  /**
	   * Convert the ordinates in an array to an array of Coordinates
	   *
	   * @param {Array}
	   *          array Array with {Number}s.
	   *
	   * @return {Array} Array with Coordinates.
	   */
	  coordinates: function (array) {
	    var coordinates = [];
	    for (var i = 0; i < array.length; ++i) {
	      var sub = array[i];
	      coordinates.push(new Coordinate(sub[0], sub[1]));
	    }
	    return coordinates
	  },

	  /**
	   * Convert the bbox to a LinearRing
	   *
	   * @param {Array}
	   *          array Array with [xMin, yMin, xMax, yMax].
	   *
	   * @return {Array} Array with Coordinates.
	   */
	  bbox: function (array) {
	    return this.geometryFactory.createLinearRing([
	      new Coordinate(array[0], array[1]),
	      new Coordinate(array[2], array[1]),
	      new Coordinate(array[2], array[3]),
	      new Coordinate(array[0], array[3]),
	      new Coordinate(array[0], array[1])
	    ])
	  },

	  /**
	   * Convert an Array with ordinates to a Point
	   *
	   * @param {Array}
	   *          array Array with ordinates.
	   *
	   * @return {Point} Point.
	   */
	  Point: function (array) {
	    var coordinate = new Coordinate(array[0], array[1]);
	    return this.geometryFactory.createPoint(coordinate)
	  },

	  /**
	   * Convert an Array with coordinates to a MultiPoint
	   *
	   * @param {Array}
	   *          array Array with coordinates.
	   *
	   * @return {MultiPoint} MultiPoint.
	   */
	  MultiPoint: function (array) {
	    var this$1$1 = this;

	    var points = [];
	    for (var i = 0; i < array.length; ++i) {
	      points.push(parse$5.Point.apply(this$1$1, [array[i]]));
	    }
	    return this.geometryFactory.createMultiPoint(points)
	  },

	  /**
	   * Convert an Array with coordinates to a LineString
	   *
	   * @param {Array}
	   *          array Array with coordinates.
	   *
	   * @return {LineString} LineString.
	   */
	  LineString: function (array) {
	    var coordinates = parse$5.coordinates.apply(this, [array]);
	    return this.geometryFactory.createLineString(coordinates)
	  },

	  /**
	   * Convert an Array with coordinates to a MultiLineString
	   *
	   * @param {Array}
	   *          array Array with coordinates.
	   *
	   * @return {MultiLineString} MultiLineString.
	   */
	  MultiLineString: function (array) {
	    var this$1$1 = this;

	    var lineStrings = [];
	    for (var i = 0; i < array.length; ++i) {
	      lineStrings.push(parse$5.LineString.apply(this$1$1, [array[i]]));
	    }
	    return this.geometryFactory.createMultiLineString(lineStrings)
	  },

	  /**
	   * Convert an Array to a Polygon
	   *
	   * @param {Array}
	   *          array Array with shell and holes.
	   *
	   * @return {Polygon} Polygon.
	   */
	  Polygon: function (array) {
	    var this$1$1 = this;

	    var shellCoordinates = parse$5.coordinates.apply(this, [array[0]]);
	    var shell = this.geometryFactory.createLinearRing(shellCoordinates);
	    var holes = [];
	    for (var i = 1; i < array.length; ++i) {
	      var hole = array[i];
	      var coordinates = parse$5.coordinates.apply(this$1$1, [hole]);
	      var linearRing = this$1$1.geometryFactory.createLinearRing(coordinates);
	      holes.push(linearRing);
	    }
	    return this.geometryFactory.createPolygon(shell, holes)
	  },

	  /**
	   * Convert an Array to a MultiPolygon
	   *
	   * @param {Array}
	   *          array Array of arrays with shell and rings.
	   *
	   * @return {MultiPolygon} MultiPolygon.
	   */
	  MultiPolygon: function (array) {
	    var this$1$1 = this;

	    var polygons = [];
	    for (var i = 0; i < array.length; ++i) {
	      var polygon = array[i];
	      polygons.push(parse$5.Polygon.apply(this$1$1, [polygon]));
	    }
	    return this.geometryFactory.createMultiPolygon(polygons)
	  },

	  /**
	   * Convert an Array to a GeometryCollection
	   *
	   * @param {Array}
	   *          array Array of GeoJSON geometries.
	   *
	   * @return {GeometryCollection} GeometryCollection.
	   */
	  GeometryCollection: function (array) {
	    var this$1$1 = this;

	    var geometries = [];
	    for (var i = 0; i < array.length; ++i) {
	      var geometry = array[i];
	      geometries.push(this$1$1.read(geometry));
	    }
	    return this.geometryFactory.createGeometryCollection(geometries)
	  }
	};

	var extract$1$1 = {
	  /**
	   * Convert a Coordinate to an Array
	   *
	   * @param {Coordinate}
	   *          coordinate Coordinate to convert.
	   *
	   * @return {Array} Array of ordinates.
	   */
	  coordinate: function (coordinate) {
	    return [coordinate.x, coordinate.y]
	  },

	  /**
	   * Convert a Point to a GeoJSON object
	   *
	   * @param {Point}
	   *          point Point to convert.
	   *
	   * @return {Array} Array of 2 ordinates (paired to a coordinate).
	   */
	  Point: function (point) {
	    var array = extract$1$1.coordinate.apply(this, [point.getCoordinate()]);
	    return {
	      type: 'Point',
	      coordinates: array
	    }
	  },

	  /**
	   * Convert a MultiPoint to a GeoJSON object
	   *
	   * @param {MultiPoint}
	   *          multipoint MultiPoint to convert.
	   *
	   * @return {Array} Array of coordinates.
	   */
	  MultiPoint: function (multipoint) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0; i < multipoint._geometries.length; ++i) {
	      var point = multipoint._geometries[i];
	      var geoJson = extract$1$1.Point.apply(this$1$1, [point]);
	      array.push(geoJson.coordinates);
	    }
	    return {
	      type: 'MultiPoint',
	      coordinates: array
	    }
	  },

	  /**
	   * Convert a LineString to a GeoJSON object
	   *
	   * @param {LineString}
	   *          linestring LineString to convert.
	   *
	   * @return {Array} Array of coordinates.
	   */
	  LineString: function (linestring) {
	    var this$1$1 = this;

	    var array = [];
	    var coordinates = linestring.getCoordinates();
	    for (var i = 0; i < coordinates.length; ++i) {
	      var coordinate = coordinates[i];
	      array.push(extract$1$1.coordinate.apply(this$1$1, [coordinate]));
	    }
	    return {
	      type: 'LineString',
	      coordinates: array
	    }
	  },

	  /**
	   * Convert a MultiLineString to a GeoJSON object
	   *
	   * @param {MultiLineString}
	   *          multilinestring MultiLineString to convert.
	   *
	   * @return {Array} Array of Array of coordinates.
	   */
	  MultiLineString: function (multilinestring) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0; i < multilinestring._geometries.length; ++i) {
	      var linestring = multilinestring._geometries[i];
	      var geoJson = extract$1$1.LineString.apply(this$1$1, [linestring]);
	      array.push(geoJson.coordinates);
	    }
	    return {
	      type: 'MultiLineString',
	      coordinates: array
	    }
	  },

	  /**
	   * Convert a Polygon to a GeoJSON object
	   *
	   * @param {Polygon}
	   *          polygon Polygon to convert.
	   *
	   * @return {Array} Array with shell, holes.
	   */
	  Polygon: function (polygon) {
	    var this$1$1 = this;

	    var array = [];
	    var shellGeoJson = extract$1$1.LineString.apply(this, [polygon._shell]);
	    array.push(shellGeoJson.coordinates);
	    for (var i = 0; i < polygon._holes.length; ++i) {
	      var hole = polygon._holes[i];
	      var holeGeoJson = extract$1$1.LineString.apply(this$1$1, [hole]);
	      array.push(holeGeoJson.coordinates);
	    }
	    return {
	      type: 'Polygon',
	      coordinates: array
	    }
	  },

	  /**
	   * Convert a MultiPolygon to a GeoJSON object
	   *
	   * @param {MultiPolygon}
	   *          multipolygon MultiPolygon to convert.
	   *
	   * @return {Array} Array of polygons.
	   */
	  MultiPolygon: function (multipolygon) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0; i < multipolygon._geometries.length; ++i) {
	      var polygon = multipolygon._geometries[i];
	      var geoJson = extract$1$1.Polygon.apply(this$1$1, [polygon]);
	      array.push(geoJson.coordinates);
	    }
	    return {
	      type: 'MultiPolygon',
	      coordinates: array
	    }
	  },

	  /**
	   * Convert a GeometryCollection to a GeoJSON object
	   *
	   * @param {GeometryCollection}
	   *          collection GeometryCollection to convert.
	   *
	   * @return {Array} Array of geometries.
	   */
	  GeometryCollection: function (collection) {
	    var this$1$1 = this;

	    var array = [];
	    for (var i = 0; i < collection._geometries.length; ++i) {
	      var geometry = collection._geometries[i];
	      var type = geometry.getGeometryType();
	      array.push(extract$1$1[type].apply(this$1$1, [geometry]));
	    }
	    return {
	      type: 'GeometryCollection',
	      geometries: array
	    }
	  }
	};

	/**
	 * Converts a geometry in GeoJSON to a {@link Geometry}.
	 */

	/**
	 * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
	 * to allow it to create <code>Geometry</code> objects of the appropriate
	 * implementation. In particular, the <code>GeometryFactory</code> determines
	 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @constructor
	 */
	var GeoJSONReader = function GeoJSONReader (geometryFactory) {
	  this.geometryFactory = geometryFactory || new GeometryFactory();
	  this.precisionModel = this.geometryFactory.getPrecisionModel();
	  this.parser = new GeoJSONParser(this.geometryFactory);
	};
	/**
	 * Reads a GeoJSON representation of a {@link Geometry}
	 *
	 * Will also parse GeoJSON Features/FeatureCollections as custom objects.
	 *
	 * @param {Object|String} geoJson a GeoJSON Object or String.
	 * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
	 * @memberof GeoJSONReader
	 */
	GeoJSONReader.prototype.read = function read (geoJson) {
	  var geometry = this.parser.read(geoJson);

	  if (this.precisionModel.getType() === PrecisionModel.FIXED) {
	    this.reducePrecision(geometry);
	  }

	  return geometry
	};

	// NOTE: this is a hack
	GeoJSONReader.prototype.reducePrecision = function reducePrecision (geometry) {
	    var this$1$1 = this;

	  var i, len;

	  if (geometry.coordinate) {
	    this.precisionModel.makePrecise(geometry.coordinate);
	  } else if (geometry.points) {
	    for (i = 0, len = geometry.points.length; i < len; i++) {
	      this$1$1.precisionModel.makePrecise(geometry.points[i]);
	    }
	  } else if (geometry.geometries) {
	    for (i = 0, len = geometry.geometries.length; i < len; i++) {
	      this$1$1.reducePrecision(geometry.geometries[i]);
	    }
	  }
	};

	/**
	 * @module GeoJSONWriter
	 */

	/**
	 * Writes the GeoJSON representation of a {@link Geometry}. The
	 * The GeoJSON format is defined <A
	 * HREF="http://geojson.org/geojson-spec.html">here</A>.
	 */

	/**
	 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
	 * model. Only the maximum number of decimal places necessary to represent the
	 * ordinates to the required precision will be output.
	 *
	 * @param {GeometryFactory} geometryFactory
	 * @constructor
	 */
	var GeoJSONWriter = function GeoJSONWriter () {
	  this.parser = new GeoJSONParser(this.geometryFactory);
	};
	/**
	 * Converts a <code>Geometry</code> to its GeoJSON representation.
	 *
	 * @param {Geometry}
	 *        geometry a <code>Geometry</code> to process.
	 * @return {Object} The GeoJSON representation of the Geometry.
	 * @memberof GeoJSONWriter
	 */
	GeoJSONWriter.prototype.write = function write (geometry) {
	  return this.parser.write(geometry)
	};

	/* eslint-disable no-undef */

	// io

	var Position$1 = function Position () {};

	var staticAccessors$20 = { ON: { configurable: true },LEFT: { configurable: true },RIGHT: { configurable: true } };

	Position$1.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Position$1.prototype.getClass = function getClass () {
	  return Position$1
	};
	Position$1.opposite = function opposite (position) {
	  if (position === Position$1.LEFT) { return Position$1.RIGHT }
	  if (position === Position$1.RIGHT) { return Position$1.LEFT }
	  return position
	};
	staticAccessors$20.ON.get = function () { return 0 };
	staticAccessors$20.LEFT.get = function () { return 1 };
	staticAccessors$20.RIGHT.get = function () { return 2 };

	Object.defineProperties( Position$1, staticAccessors$20 );

	/**
	 * @param {string=} message Optional message
	 * @extends {Error}
	 * @constructor
	 * @private
	 */
	function EmptyStackException (message) {
	  this.message = message || '';
	}
	EmptyStackException.prototype = new Error();

	/**
	 * @type {string}
	 */
	EmptyStackException.prototype.name = 'EmptyStackException';

	/**
	 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
	 *
	 * @extends {List}
	 * @constructor
	 * @private
	 */
	function Stack () {
	  /**
	   * @type {Array}
	   * @private
	   */
	  this.array_ = [];
	}
	Stack.prototype = new List();

	/**
	 * @override
	 */
	Stack.prototype.add = function (e) {
	  this.array_.push(e);
	  return true
	};

	/**
	 * @override
	 */
	Stack.prototype.get = function (index) {
	  if (index < 0 || index >= this.size()) {
	    throw new Error()
	  }

	  return this.array_[index]
	};

	/**
	 * Pushes an item onto the top of this stack.
	 * @param {Object} e
	 * @return {Object}
	 */
	Stack.prototype.push = function (e) {
	  this.array_.push(e);
	  return e
	};

	/**
	 * Pushes an item onto the top of this stack.
	 * @param {Object} e
	 * @return {Object}
	 */
	Stack.prototype.pop = function (e) {
	  if (this.array_.length === 0) {
	    throw new EmptyStackException()
	  }

	  return this.array_.pop()
	};

	/**
	 * Looks at the object at the top of this stack without removing it from the
	 * stack.
	 * @return {Object}
	 */
	Stack.prototype.peek = function () {
	  if (this.array_.length === 0) {
	    throw new EmptyStackException()
	  }

	  return this.array_[this.array_.length - 1]
	};

	/**
	 * Tests if this stack is empty.
	 * @return {boolean} true if and only if this stack contains no items; false
	 *         otherwise.
	 */
	Stack.prototype.empty = function () {
	  if (this.array_.length === 0) {
	    return true
	  } else {
	    return false
	  }
	};

	/**
	 * @return {boolean}
	 */
	Stack.prototype.isEmpty = function () {
	  return this.empty()
	};

	/**
	 * Returns the 1-based position where an object is on this stack. If the object
	 * o occurs as an item in this stack, this method returns the distance from the
	 * top of the stack of the occurrence nearest the top of the stack; the topmost
	 * item on the stack is considered to be at distance 1. The equals method is
	 * used to compare o to the items in this stack.
	 *
	 * NOTE: does not currently actually use equals. (=== is used)
	 *
	 * @param {Object} o
	 * @return {number} the 1-based position from the top of the stack where the
	 *         object is located; the return value -1 indicates that the object is
	 *         not on the stack.
	 */
	Stack.prototype.search = function (o) {
	  return this.array_.indexOf(o)
	};

	/**
	 * @return {number}
	 * @export
	 */
	Stack.prototype.size = function () {
	  return this.array_.length
	};

	/**
	 * @return {Array}
	 */
	Stack.prototype.toArray = function () {
	  var this$1$1 = this;

	  var array = [];

	  for (var i = 0, len = this.array_.length; i < len; i++) {
	    array.push(this$1$1.array_[i]);
	  }

	  return array
	};

	var RightmostEdgeFinder = function RightmostEdgeFinder () {
	  this._minIndex = -1;
	  this._minCoord = null;
	  this._minDe = null;
	  this._orientedDe = null;
	};
	RightmostEdgeFinder.prototype.getCoordinate = function getCoordinate () {
	  return this._minCoord
	};
	RightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide (de, index) {
	  var side = this.getRightmostSideOfSegment(de, index);
	  if (side < 0) { side = this.getRightmostSideOfSegment(de, index - 1); }
	  if (side < 0) {
	    this._minCoord = null;
	    this.checkForRightmostCoordinate(de);
	  }
	  return side
	};
	RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex () {
	  var pts = this._minDe.getEdge().getCoordinates();
	  Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
	  var pPrev = pts[this._minIndex - 1];
	  var pNext = pts[this._minIndex + 1];
	  var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
	  var usePrev = false;
	  if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {
	    usePrev = true;
	  } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {
	    usePrev = true;
	  }
	  if (usePrev) {
	    this._minIndex = this._minIndex - 1;
	  }
	};
	RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment (de, i) {
	  var e = de.getEdge();
	  var coord = e.getCoordinates();
	  if (i < 0 || i + 1 >= coord.length) { return -1 }
	  if (coord[i].y === coord[i + 1].y) { return -1 }
	  var pos = Position$1.LEFT;
	  if (coord[i].y < coord[i + 1].y) { pos = Position$1.RIGHT; }
	  return pos
	};
	RightmostEdgeFinder.prototype.getEdge = function getEdge () {
	  return this._orientedDe
	};
	RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate (de) {
	    var this$1$1 = this;

	  var coord = de.getEdge().getCoordinates();
	  for (var i = 0; i < coord.length - 1; i++) {
	    if (this$1$1._minCoord === null || coord[i].x > this$1$1._minCoord.x) {
	      this$1$1._minDe = de;
	      this$1$1._minIndex = i;
	      this$1$1._minCoord = coord[i];
	    }
	  }
	};
	RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode () {
	  var node = this._minDe.getNode();
	  var star = node.getEdges();
	  this._minDe = star.getRightmostEdge();
	  if (!this._minDe.isForward()) {
	    this._minDe = this._minDe.getSym();
	    this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
	  }
	};
	RightmostEdgeFinder.prototype.findEdge = function findEdge (dirEdgeList) {
	    var this$1$1 = this;

	  for (var i = dirEdgeList.iterator(); i.hasNext();) {
	    var de = i.next();
	    if (!de.isForward()) { continue }
	    this$1$1.checkForRightmostCoordinate(de);
	  }
	  Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
	  if (this._minIndex === 0) {
	    this.findRightmostEdgeAtNode();
	  } else {
	    this.findRightmostEdgeAtVertex();
	  }
	  this._orientedDe = this._minDe;
	  var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
	  if (rightmostSide === Position$1.LEFT) {
	    this._orientedDe = this._minDe.getSym();
	  }
	};
	RightmostEdgeFinder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	RightmostEdgeFinder.prototype.getClass = function getClass () {
	  return RightmostEdgeFinder
	};

	var TopologyException = (function (RuntimeException$$1) {
	  function TopologyException (msg, pt) {
	    RuntimeException$$1.call(this, TopologyException.msgWithCoord(msg, pt));
	    this.pt = pt ? new Coordinate(pt) : null;
	    this.name = 'TopologyException';
	  }

	  if ( RuntimeException$$1 ) TopologyException.__proto__ = RuntimeException$$1;
	  TopologyException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );
	  TopologyException.prototype.constructor = TopologyException;
	  TopologyException.prototype.getCoordinate = function getCoordinate () {
	    return this.pt
	  };
	  TopologyException.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  TopologyException.prototype.getClass = function getClass () {
	    return TopologyException
	  };
	  TopologyException.msgWithCoord = function msgWithCoord (msg, pt) {
	    if (!pt) { return msg + ' [ ' + pt + ' ]' }
	    return msg
	  };

	  return TopologyException;
	}(RuntimeException));

	var LinkedList = function LinkedList () {
	  this.array_ = [];
	};
	LinkedList.prototype.addLast = function addLast (e) {
	  this.array_.push(e);
	};
	LinkedList.prototype.removeFirst = function removeFirst () {
	  return this.array_.shift()
	};
	LinkedList.prototype.isEmpty = function isEmpty () {
	  return this.array_.length === 0
	};

	var BufferSubgraph = function BufferSubgraph () {
	  this._finder = null;
	  this._dirEdgeList = new ArrayList();
	  this._nodes = new ArrayList();
	  this._rightMostCoord = null;
	  this._env = null;
	  this._finder = new RightmostEdgeFinder();
	};
	BufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges () {
	  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
	    var de = it.next();
	    de.setVisited(false);
	  }
	};
	BufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate () {
	  return this._rightMostCoord
	};
	BufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth (n) {
	    var this$1$1 = this;

	  var startEdge = null;
	  for (var i = n.getEdges().iterator(); i.hasNext();) {
	    var de = i.next();
	    if (de.isVisited() || de.getSym().isVisited()) {
	      startEdge = de;
	      break
	    }
	  }
	  if (startEdge === null) { throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate()) }
	  n.getEdges().computeDepths(startEdge);
	  for (var i$1 = n.getEdges().iterator(); i$1.hasNext();) {
	    var de$1 = i$1.next();
	    de$1.setVisited(true);
	    this$1$1.copySymDepths(de$1);
	  }
	};
	BufferSubgraph.prototype.computeDepth = function computeDepth (outsideDepth) {
	  this.clearVisitedEdges();
	  var de = this._finder.getEdge();
	  // const n = de.getNode()
	  // const label = de.getLabel()
	  de.setEdgeDepths(Position$1.RIGHT, outsideDepth);
	  this.copySymDepths(de);
	  this.computeDepths(de);
	};
	BufferSubgraph.prototype.create = function create (node) {
	  this.addReachable(node);
	  this._finder.findEdge(this._dirEdgeList);
	  this._rightMostCoord = this._finder.getCoordinate();
	};
	BufferSubgraph.prototype.findResultEdges = function findResultEdges () {
	  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
	    var de = it.next();
	    if (de.getDepth(Position$1.RIGHT) >= 1 && de.getDepth(Position$1.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
	      de.setInResult(true);
	    }
	  }
	};
	BufferSubgraph.prototype.computeDepths = function computeDepths (startEdge) {
	    var this$1$1 = this;

	  var nodesVisited = new HashSet();
	  var nodeQueue = new LinkedList();
	  var startNode = startEdge.getNode();
	  nodeQueue.addLast(startNode);
	  nodesVisited.add(startNode);
	  startEdge.setVisited(true);
	  while (!nodeQueue.isEmpty()) {
	    var n = nodeQueue.removeFirst();
	    nodesVisited.add(n);
	    this$1$1.computeNodeDepth(n);
	    for (var i = n.getEdges().iterator(); i.hasNext();) {
	      var de = i.next();
	      var sym = de.getSym();
	      if (sym.isVisited()) { continue }
	      var adjNode = sym.getNode();
	      if (!nodesVisited.contains(adjNode)) {
	        nodeQueue.addLast(adjNode);
	        nodesVisited.add(adjNode);
	      }
	    }
	  }
	};
	BufferSubgraph.prototype.compareTo = function compareTo (o) {
	  var graph = o;
	  if (this._rightMostCoord.x < graph._rightMostCoord.x) {
	    return -1
	  }
	  if (this._rightMostCoord.x > graph._rightMostCoord.x) {
	    return 1
	  }
	  return 0
	};
	BufferSubgraph.prototype.getEnvelope = function getEnvelope () {
	  if (this._env === null) {
	    var edgeEnv = new Envelope();
	    for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
	      var dirEdge = it.next();
	      var pts = dirEdge.getEdge().getCoordinates();
	      for (var i = 0; i < pts.length - 1; i++) {
	        edgeEnv.expandToInclude(pts[i]);
	      }
	    }
	    this._env = edgeEnv;
	  }
	  return this._env
	};
	BufferSubgraph.prototype.addReachable = function addReachable (startNode) {
	    var this$1$1 = this;

	  var nodeStack = new Stack();
	  nodeStack.add(startNode);
	  while (!nodeStack.empty()) {
	    var node = nodeStack.pop();
	    this$1$1.add(node, nodeStack);
	  }
	};
	BufferSubgraph.prototype.copySymDepths = function copySymDepths (de) {
	  var sym = de.getSym();
	  sym.setDepth(Position$1.LEFT, de.getDepth(Position$1.RIGHT));
	  sym.setDepth(Position$1.RIGHT, de.getDepth(Position$1.LEFT));
	};
	BufferSubgraph.prototype.add = function add (node, nodeStack) {
	    var this$1$1 = this;

	  node.setVisited(true);
	  this._nodes.add(node);
	  for (var i = node.getEdges().iterator(); i.hasNext();) {
	    var de = i.next();
	    this$1$1._dirEdgeList.add(de);
	    var sym = de.getSym();
	    var symNode = sym.getNode();
	    if (!symNode.isVisited()) { nodeStack.push(symNode); }
	  }
	};
	BufferSubgraph.prototype.getNodes = function getNodes () {
	  return this._nodes
	};
	BufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges () {
	  return this._dirEdgeList
	};
	BufferSubgraph.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	BufferSubgraph.prototype.getClass = function getClass () {
	  return BufferSubgraph
	};

	var TopologyLocation = function TopologyLocation () {
	  var this$1$1 = this;

	  this.location = null;
	  if (arguments.length === 1) {
	    if (arguments[0] instanceof Array) {
	      var location = arguments[0];
	      this.init(location.length);
	    } else if (Number.isInteger(arguments[0])) {
	      var on = arguments[0];
	      this.init(1);
	      this.location[Position$1.ON] = on;
	    } else if (arguments[0] instanceof TopologyLocation) {
	      var gl = arguments[0];
	      this.init(gl.location.length);
	      if (gl !== null) {
	        for (var i = 0; i < this.location.length; i++) {
	          this$1$1.location[i] = gl.location[i];
	        }
	      }
	    }
	  } else if (arguments.length === 3) {
	    var on$1 = arguments[0];
	    var left = arguments[1];
	    var right = arguments[2];
	    this.init(3);
	    this.location[Position$1.ON] = on$1;
	    this.location[Position$1.LEFT] = left;
	    this.location[Position$1.RIGHT] = right;
	  }
	};
	TopologyLocation.prototype.setAllLocations = function setAllLocations (locValue) {
	    var this$1$1 = this;

	  for (var i = 0; i < this.location.length; i++) {
	    this$1$1.location[i] = locValue;
	  }
	};
	TopologyLocation.prototype.isNull = function isNull () {
	    var this$1$1 = this;

	  for (var i = 0; i < this.location.length; i++) {
	    if (this$1$1.location[i] !== Location.NONE) { return false }
	  }
	  return true
	};
	TopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull (locValue) {
	    var this$1$1 = this;

	  for (var i = 0; i < this.location.length; i++) {
	    if (this$1$1.location[i] === Location.NONE) { this$1$1.location[i] = locValue; }
	  }
	};
	TopologyLocation.prototype.isLine = function isLine () {
	  return this.location.length === 1
	};
	TopologyLocation.prototype.merge = function merge (gl) {
	    var this$1$1 = this;

	  if (gl.location.length > this.location.length) {
	    var newLoc = new Array(3).fill(null);
	    newLoc[Position$1.ON] = this.location[Position$1.ON];
	    newLoc[Position$1.LEFT] = Location.NONE;
	    newLoc[Position$1.RIGHT] = Location.NONE;
	    this.location = newLoc;
	  }
	  for (var i = 0; i < this.location.length; i++) {
	    if (this$1$1.location[i] === Location.NONE && i < gl.location.length) { this$1$1.location[i] = gl.location[i]; }
	  }
	};
	TopologyLocation.prototype.getLocations = function getLocations () {
	  return this.location
	};
	TopologyLocation.prototype.flip = function flip () {
	  if (this.location.length <= 1) { return null }
	  var temp = this.location[Position$1.LEFT];
	  this.location[Position$1.LEFT] = this.location[Position$1.RIGHT];
	  this.location[Position$1.RIGHT] = temp;
	};
	TopologyLocation.prototype.toString = function toString () {
	  var buf = new StringBuffer();
	  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position$1.LEFT])); }
	  buf.append(Location.toLocationSymbol(this.location[Position$1.ON]));
	  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position$1.RIGHT])); }
	  return buf.toString()
	};
	TopologyLocation.prototype.setLocations = function setLocations (on, left, right) {
	  this.location[Position$1.ON] = on;
	  this.location[Position$1.LEFT] = left;
	  this.location[Position$1.RIGHT] = right;
	};
	TopologyLocation.prototype.get = function get (posIndex) {
	  if (posIndex < this.location.length) { return this.location[posIndex] }
	  return Location.NONE
	};
	TopologyLocation.prototype.isArea = function isArea () {
	  return this.location.length > 1
	};
	TopologyLocation.prototype.isAnyNull = function isAnyNull () {
	    var this$1$1 = this;

	  for (var i = 0; i < this.location.length; i++) {
	    if (this$1$1.location[i] === Location.NONE) { return true }
	  }
	  return false
	};
	TopologyLocation.prototype.setLocation = function setLocation () {
	  if (arguments.length === 1) {
	    var locValue = arguments[0];
	    this.setLocation(Position$1.ON, locValue);
	  } else if (arguments.length === 2) {
	    var locIndex = arguments[0];
	    var locValue$1 = arguments[1];
	    this.location[locIndex] = locValue$1;
	  }
	};
	TopologyLocation.prototype.init = function init (size) {
	  this.location = new Array(size).fill(null);
	  this.setAllLocations(Location.NONE);
	};
	TopologyLocation.prototype.isEqualOnSide = function isEqualOnSide (le, locIndex) {
	  return this.location[locIndex] === le.location[locIndex]
	};
	TopologyLocation.prototype.allPositionsEqual = function allPositionsEqual (loc) {
	    var this$1$1 = this;

	  for (var i = 0; i < this.location.length; i++) {
	    if (this$1$1.location[i] !== loc) { return false }
	  }
	  return true
	};
	TopologyLocation.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	TopologyLocation.prototype.getClass = function getClass () {
	  return TopologyLocation
	};

	var Label = function Label () {
	  this.elt = new Array(2).fill(null);
	  if (arguments.length === 1) {
	    if (Number.isInteger(arguments[0])) {
	      var onLoc = arguments[0];
	      this.elt[0] = new TopologyLocation(onLoc);
	      this.elt[1] = new TopologyLocation(onLoc);
	    } else if (arguments[0] instanceof Label) {
	      var lbl = arguments[0];
	      this.elt[0] = new TopologyLocation(lbl.elt[0]);
	      this.elt[1] = new TopologyLocation(lbl.elt[1]);
	    }
	  } else if (arguments.length === 2) {
	    var geomIndex = arguments[0];
	    var onLoc$1 = arguments[1];
	    this.elt[0] = new TopologyLocation(Location.NONE);
	    this.elt[1] = new TopologyLocation(Location.NONE);
	    this.elt[geomIndex].setLocation(onLoc$1);
	  } else if (arguments.length === 3) {
	    var onLoc$2 = arguments[0];
	    var leftLoc = arguments[1];
	    var rightLoc = arguments[2];
	    this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
	    this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
	  } else if (arguments.length === 4) {
	    var geomIndex$1 = arguments[0];
	    var onLoc$3 = arguments[1];
	    var leftLoc$1 = arguments[2];
	    var rightLoc$1 = arguments[3];
	    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
	    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
	    this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);
	  }
	};
	Label.prototype.getGeometryCount = function getGeometryCount () {
	  var count = 0;
	  if (!this.elt[0].isNull()) { count++; }
	  if (!this.elt[1].isNull()) { count++; }
	  return count
	};
	Label.prototype.setAllLocations = function setAllLocations (geomIndex, location) {
	  this.elt[geomIndex].setAllLocations(location);
	};
	Label.prototype.isNull = function isNull (geomIndex) {
	  return this.elt[geomIndex].isNull()
	};
	Label.prototype.setAllLocationsIfNull = function setAllLocationsIfNull () {
	  if (arguments.length === 1) {
	    var location = arguments[0];
	    this.setAllLocationsIfNull(0, location);
	    this.setAllLocationsIfNull(1, location);
	  } else if (arguments.length === 2) {
	    var geomIndex = arguments[0];
	    var location$1 = arguments[1];
	    this.elt[geomIndex].setAllLocationsIfNull(location$1);
	  }
	};
	Label.prototype.isLine = function isLine (geomIndex) {
	  return this.elt[geomIndex].isLine()
	};
	Label.prototype.merge = function merge (lbl) {
	    var this$1$1 = this;

	  for (var i = 0; i < 2; i++) {
	    if (this$1$1.elt[i] === null && lbl.elt[i] !== null) {
	      this$1$1.elt[i] = new TopologyLocation(lbl.elt[i]);
	    } else {
	      this$1$1.elt[i].merge(lbl.elt[i]);
	    }
	  }
	};
	Label.prototype.flip = function flip () {
	  this.elt[0].flip();
	  this.elt[1].flip();
	};
	Label.prototype.getLocation = function getLocation () {
	  if (arguments.length === 1) {
	    var geomIndex = arguments[0];
	    return this.elt[geomIndex].get(Position$1.ON)
	  } else if (arguments.length === 2) {
	    var geomIndex$1 = arguments[0];
	    var posIndex = arguments[1];
	    return this.elt[geomIndex$1].get(posIndex)
	  }
	};
	Label.prototype.toString = function toString () {
	  var buf = new StringBuffer();
	  if (this.elt[0] !== null) {
	    buf.append('A:');
	    buf.append(this.elt[0].toString());
	  }
	  if (this.elt[1] !== null) {
	    buf.append(' B:');
	    buf.append(this.elt[1].toString());
	  }
	  return buf.toString()
	};
	Label.prototype.isArea = function isArea () {
	  if (arguments.length === 0) {
	    return this.elt[0].isArea() || this.elt[1].isArea()
	  } else if (arguments.length === 1) {
	    var geomIndex = arguments[0];
	    return this.elt[geomIndex].isArea()
	  }
	};
	Label.prototype.isAnyNull = function isAnyNull (geomIndex) {
	  return this.elt[geomIndex].isAnyNull()
	};
	Label.prototype.setLocation = function setLocation () {
	  if (arguments.length === 2) {
	    var geomIndex = arguments[0];
	    var location = arguments[1];
	    this.elt[geomIndex].setLocation(Position$1.ON, location);
	  } else if (arguments.length === 3) {
	    var geomIndex$1 = arguments[0];
	    var posIndex = arguments[1];
	    var location$1 = arguments[2];
	    this.elt[geomIndex$1].setLocation(posIndex, location$1);
	  }
	};
	Label.prototype.isEqualOnSide = function isEqualOnSide (lbl, side) {
	  return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)
	};
	Label.prototype.allPositionsEqual = function allPositionsEqual (geomIndex, loc) {
	  return this.elt[geomIndex].allPositionsEqual(loc)
	};
	Label.prototype.toLine = function toLine (geomIndex) {
	  if (this.elt[geomIndex].isArea()) { this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]); }
	};
	Label.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Label.prototype.getClass = function getClass () {
	  return Label
	};
	Label.toLineLabel = function toLineLabel (label) {
	  var lineLabel = new Label(Location.NONE);
	  for (var i = 0; i < 2; i++) {
	    lineLabel.setLocation(i, label.getLocation(i));
	  }
	  return lineLabel
	};

	var EdgeRing$1 = function EdgeRing () {
	  this._startDe = null;
	  this._maxNodeDegree = -1;
	  this._edges = new ArrayList();
	  this._pts = new ArrayList();
	  this._label = new Label(Location.NONE);
	  this._ring = null;
	  this._isHole = null;
	  this._shell = null;
	  this._holes = new ArrayList();
	  this._geometryFactory = null;
	  var start = arguments[0];
	  var geometryFactory = arguments[1];
	  this._geometryFactory = geometryFactory;
	  this.computePoints(start);
	  this.computeRing();
	};
	EdgeRing$1.prototype.computeRing = function computeRing () {
	    var this$1$1 = this;

	  if (this._ring !== null) { return null }
	  var coord = new Array(this._pts.size()).fill(null);
	  for (var i = 0; i < this._pts.size(); i++) {
	    coord[i] = this$1$1._pts.get(i);
	  }
	  this._ring = this._geometryFactory.createLinearRing(coord);
	  this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
	};
	EdgeRing$1.prototype.isIsolated = function isIsolated () {
	  return this._label.getGeometryCount() === 1
	};
	EdgeRing$1.prototype.computePoints = function computePoints (start) {
	    var this$1$1 = this;

	  this._startDe = start;
	  var de = start;
	  var isFirstEdge = true;
	  do {
	    if (de === null) { throw new TopologyException('Found null DirectedEdge') }
	    if (de.getEdgeRing() === this$1$1) { throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate()) }
	    this$1$1._edges.add(de);
	    var label = de.getLabel();
	    Assert.isTrue(label.isArea());
	    this$1$1.mergeLabel(label);
	    this$1$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
	    isFirstEdge = false;
	    this$1$1.setEdgeRing(de, this$1$1);
	    de = this$1$1.getNext(de);
	  } while (de !== this._startDe)
	};
	EdgeRing$1.prototype.getLinearRing = function getLinearRing () {
	  return this._ring
	};
	EdgeRing$1.prototype.getCoordinate = function getCoordinate (i) {
	  return this._pts.get(i)
	};
	EdgeRing$1.prototype.computeMaxNodeDegree = function computeMaxNodeDegree () {
	    var this$1$1 = this;

	  this._maxNodeDegree = 0;
	  var de = this._startDe;
	  do {
	    var node = de.getNode();
	    var degree = node.getEdges().getOutgoingDegree(this$1$1);
	    if (degree > this$1$1._maxNodeDegree) { this$1$1._maxNodeDegree = degree; }
	    de = this$1$1.getNext(de);
	  } while (de !== this._startDe)
	  this._maxNodeDegree *= 2;
	};
	EdgeRing$1.prototype.addPoints = function addPoints (edge, isForward, isFirstEdge) {
	    var this$1$1 = this;

	  var edgePts = edge.getCoordinates();
	  if (isForward) {
	    var startIndex = 1;
	    if (isFirstEdge) { startIndex = 0; }
	    for (var i = startIndex; i < edgePts.length; i++) {
	      this$1$1._pts.add(edgePts[i]);
	    }
	  } else {
	    var startIndex$1 = edgePts.length - 2;
	    if (isFirstEdge) { startIndex$1 = edgePts.length - 1; }
	    for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {
	      this$1$1._pts.add(edgePts[i$1]);
	    }
	  }
	};
	EdgeRing$1.prototype.isHole = function isHole () {
	  return this._isHole
	};
	EdgeRing$1.prototype.setInResult = function setInResult () {
	  var de = this._startDe;
	  do {
	    de.getEdge().setInResult(true);
	    de = de.getNext();
	  } while (de !== this._startDe)
	};
	EdgeRing$1.prototype.containsPoint = function containsPoint (p) {
	  var shell = this.getLinearRing();
	  var env = shell.getEnvelopeInternal();
	  if (!env.contains(p)) { return false }
	  if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) { return false }
	  for (var i = this._holes.iterator(); i.hasNext();) {
	    var hole = i.next();
	    if (hole.containsPoint(p)) { return false }
	  }
	  return true
	};
	EdgeRing$1.prototype.addHole = function addHole (ring) {
	  this._holes.add(ring);
	};
	EdgeRing$1.prototype.isShell = function isShell () {
	  return this._shell === null
	};
	EdgeRing$1.prototype.getLabel = function getLabel () {
	  return this._label
	};
	EdgeRing$1.prototype.getEdges = function getEdges () {
	  return this._edges
	};
	EdgeRing$1.prototype.getMaxNodeDegree = function getMaxNodeDegree () {
	  if (this._maxNodeDegree < 0) { this.computeMaxNodeDegree(); }
	  return this._maxNodeDegree
	};
	EdgeRing$1.prototype.getShell = function getShell () {
	  return this._shell
	};
	EdgeRing$1.prototype.mergeLabel = function mergeLabel () {
	  if (arguments.length === 1) {
	    var deLabel = arguments[0];
	    this.mergeLabel(deLabel, 0);
	    this.mergeLabel(deLabel, 1);
	  } else if (arguments.length === 2) {
	    var deLabel$1 = arguments[0];
	    var geomIndex = arguments[1];
	    var loc = deLabel$1.getLocation(geomIndex, Position$1.RIGHT);
	    if (loc === Location.NONE) { return null }
	    if (this._label.getLocation(geomIndex) === Location.NONE) {
	      this._label.setLocation(geomIndex, loc);
	      return null
	    }
	  }
	};
	EdgeRing$1.prototype.setShell = function setShell (shell) {
	  this._shell = shell;
	  if (shell !== null) { shell.addHole(this); }
	};
	EdgeRing$1.prototype.toPolygon = function toPolygon (geometryFactory) {
	    var this$1$1 = this;

	  var holeLR = new Array(this._holes.size()).fill(null);
	  for (var i = 0; i < this._holes.size(); i++) {
	    holeLR[i] = this$1$1._holes.get(i).getLinearRing();
	  }
	  var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
	  return poly
	};
	EdgeRing$1.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	EdgeRing$1.prototype.getClass = function getClass () {
	  return EdgeRing$1
	};

	var MinimalEdgeRing = (function (EdgeRing$$1) {
	  function MinimalEdgeRing () {
	    var start = arguments[0];
	    var geometryFactory = arguments[1];
	    EdgeRing$$1.call(this, start, geometryFactory);
	  }

	  if ( EdgeRing$$1 ) MinimalEdgeRing.__proto__ = EdgeRing$$1;
	  MinimalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );
	  MinimalEdgeRing.prototype.constructor = MinimalEdgeRing;
	  MinimalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {
	    de.setMinEdgeRing(er);
	  };
	  MinimalEdgeRing.prototype.getNext = function getNext (de) {
	    return de.getNextMin()
	  };
	  MinimalEdgeRing.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  MinimalEdgeRing.prototype.getClass = function getClass () {
	    return MinimalEdgeRing
	  };

	  return MinimalEdgeRing;
	}(EdgeRing$1));

	var MaximalEdgeRing = (function (EdgeRing$$1) {
	  function MaximalEdgeRing () {
	    var start = arguments[0];
	    var geometryFactory = arguments[1];
	    EdgeRing$$1.call(this, start, geometryFactory);
	  }

	  if ( EdgeRing$$1 ) MaximalEdgeRing.__proto__ = EdgeRing$$1;
	  MaximalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );
	  MaximalEdgeRing.prototype.constructor = MaximalEdgeRing;
	  MaximalEdgeRing.prototype.buildMinimalRings = function buildMinimalRings () {
	    var this$1$1 = this;

	    var minEdgeRings = new ArrayList();
	    var de = this._startDe;
	    do {
	      if (de.getMinEdgeRing() === null) {
	        var minEr = new MinimalEdgeRing(de, this$1$1._geometryFactory);
	        minEdgeRings.add(minEr);
	      }
	      de = de.getNext();
	    } while (de !== this._startDe)
	    return minEdgeRings
	  };
	  MaximalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {
	    de.setEdgeRing(er);
	  };
	  MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings () {
	    var this$1$1 = this;

	    var de = this._startDe;
	    do {
	      var node = de.getNode();
	      node.getEdges().linkMinimalDirectedEdges(this$1$1);
	      de = de.getNext();
	    } while (de !== this._startDe)
	  };
	  MaximalEdgeRing.prototype.getNext = function getNext (de) {
	    return de.getNext()
	  };
	  MaximalEdgeRing.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  MaximalEdgeRing.prototype.getClass = function getClass () {
	    return MaximalEdgeRing
	  };

	  return MaximalEdgeRing;
	}(EdgeRing$1));

	var GraphComponent = function GraphComponent () {
	  this._label = null;
	  this._isInResult = false;
	  this._isCovered = false;
	  this._isCoveredSet = false;
	  this._isVisited = false;
	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    var label = arguments[0];
	    this._label = label;
	  }
	};
	GraphComponent.prototype.setVisited = function setVisited (isVisited) {
	  this._isVisited = isVisited;
	};
	GraphComponent.prototype.setInResult = function setInResult (isInResult) {
	  this._isInResult = isInResult;
	};
	GraphComponent.prototype.isCovered = function isCovered () {
	  return this._isCovered
	};
	GraphComponent.prototype.isCoveredSet = function isCoveredSet () {
	  return this._isCoveredSet
	};
	GraphComponent.prototype.setLabel = function setLabel (label) {
	  this._label = label;
	};
	GraphComponent.prototype.getLabel = function getLabel () {
	  return this._label
	};
	GraphComponent.prototype.setCovered = function setCovered (isCovered) {
	  this._isCovered = isCovered;
	  this._isCoveredSet = true;
	};
	GraphComponent.prototype.updateIM = function updateIM (im) {
	  Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
	  this.computeIM(im);
	};
	GraphComponent.prototype.isInResult = function isInResult () {
	  return this._isInResult
	};
	GraphComponent.prototype.isVisited = function isVisited () {
	  return this._isVisited
	};
	GraphComponent.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GraphComponent.prototype.getClass = function getClass () {
	  return GraphComponent
	};

	var Node$2 = (function (GraphComponent$$1) {
	  function Node () {
	    GraphComponent$$1.call(this);
	    this._coord = null;
	    this._edges = null;
	    var coord = arguments[0];
	    var edges = arguments[1];
	    this._coord = coord;
	    this._edges = edges;
	    this._label = new Label(0, Location.NONE);
	  }

	  if ( GraphComponent$$1 ) Node.__proto__ = GraphComponent$$1;
	  Node.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );
	  Node.prototype.constructor = Node;
	  Node.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult () {
	    for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {
	      var de = it.next();
	      if (de.getEdge().isInResult()) { return true }
	    }
	    return false
	  };
	  Node.prototype.isIsolated = function isIsolated () {
	    return this._label.getGeometryCount() === 1
	  };
	  Node.prototype.getCoordinate = function getCoordinate () {
	    return this._coord
	  };
	  Node.prototype.print = function print (out) {
	    out.println('node ' + this._coord + ' lbl: ' + this._label);
	  };
	  Node.prototype.computeIM = function computeIM (im) {};
	  Node.prototype.computeMergedLocation = function computeMergedLocation (label2, eltIndex) {
	    var loc = Location.NONE;
	    loc = this._label.getLocation(eltIndex);
	    if (!label2.isNull(eltIndex)) {
	      var nLoc = label2.getLocation(eltIndex);
	      if (loc !== Location.BOUNDARY) { loc = nLoc; }
	    }
	    return loc
	  };
	  Node.prototype.setLabel = function setLabel () {
	    if (arguments.length === 2) {
	      var argIndex = arguments[0];
	      var onLocation = arguments[1];
	      if (this._label === null) {
	        this._label = new Label(argIndex, onLocation);
	      } else { this._label.setLocation(argIndex, onLocation); }
	    } else { return GraphComponent$$1.prototype.setLabel.apply(this, arguments) }
	  };
	  Node.prototype.getEdges = function getEdges () {
	    return this._edges
	  };
	  Node.prototype.mergeLabel = function mergeLabel () {
	    var this$1$1 = this;

	    if (arguments[0] instanceof Node) {
	      var n = arguments[0];
	      this.mergeLabel(n._label);
	    } else if (arguments[0] instanceof Label) {
	      var label2 = arguments[0];
	      for (var i = 0; i < 2; i++) {
	        var loc = this$1$1.computeMergedLocation(label2, i);
	        var thisLoc = this$1$1._label.getLocation(i);
	        if (thisLoc === Location.NONE) { this$1$1._label.setLocation(i, loc); }
	      }
	    }
	  };
	  Node.prototype.add = function add (e) {
	    this._edges.insert(e);
	    e.setNode(this);
	  };
	  Node.prototype.setLabelBoundary = function setLabelBoundary (argIndex) {
	    if (this._label === null) { return null }
	    var loc = Location.NONE;
	    if (this._label !== null) { loc = this._label.getLocation(argIndex); }
	    var newLoc = null;
	    switch (loc) {
	      case Location.BOUNDARY:
	        newLoc = Location.INTERIOR;
	        break
	      case Location.INTERIOR:
	        newLoc = Location.BOUNDARY;
	        break
	      default:
	        newLoc = Location.BOUNDARY;
	        break
	    }
	    this._label.setLocation(argIndex, newLoc);
	  };
	  Node.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  Node.prototype.getClass = function getClass () {
	    return Node
	  };

	  return Node;
	}(GraphComponent));

	var NodeMap = function NodeMap () {
	  this.nodeMap = new TreeMap();
	  this.nodeFact = null;
	  var nodeFact = arguments[0];
	  this.nodeFact = nodeFact;
	};
	NodeMap.prototype.find = function find (coord) {
	  return this.nodeMap.get(coord)
	};
	NodeMap.prototype.addNode = function addNode () {
	  if (arguments[0] instanceof Coordinate) {
	    var coord = arguments[0];
	    var node = this.nodeMap.get(coord);
	    if (node === null) {
	      node = this.nodeFact.createNode(coord);
	      this.nodeMap.put(coord, node);
	    }
	    return node
	  } else if (arguments[0] instanceof Node$2) {
	    var n = arguments[0];
	    var node$1 = this.nodeMap.get(n.getCoordinate());
	    if (node$1 === null) {
	      this.nodeMap.put(n.getCoordinate(), n);
	      return n
	    }
	    node$1.mergeLabel(n);
	    return node$1
	  }
	};
	NodeMap.prototype.print = function print (out) {
	  for (var it = this.iterator(); it.hasNext();) {
	    var n = it.next();
	    n.print(out);
	  }
	};
	NodeMap.prototype.iterator = function iterator () {
	  return this.nodeMap.values().iterator()
	};
	NodeMap.prototype.values = function values () {
	  return this.nodeMap.values()
	};
	NodeMap.prototype.getBoundaryNodes = function getBoundaryNodes (geomIndex) {
	  var bdyNodes = new ArrayList();
	  for (var i = this.iterator(); i.hasNext();) {
	    var node = i.next();
	    if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) { bdyNodes.add(node); }
	  }
	  return bdyNodes
	};
	NodeMap.prototype.add = function add (e) {
	  var p = e.getCoordinate();
	  var n = this.addNode(p);
	  n.add(e);
	};
	NodeMap.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	NodeMap.prototype.getClass = function getClass () {
	  return NodeMap
	};

	var Quadrant = function Quadrant () {};

	var staticAccessors$21 = { NE: { configurable: true },NW: { configurable: true },SW: { configurable: true },SE: { configurable: true } };

	Quadrant.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Quadrant.prototype.getClass = function getClass () {
	  return Quadrant
	};
	Quadrant.isNorthern = function isNorthern (quad) {
	  return quad === Quadrant.NE || quad === Quadrant.NW
	};
	Quadrant.isOpposite = function isOpposite (quad1, quad2) {
	  if (quad1 === quad2) { return false }
	  var diff = (quad1 - quad2 + 4) % 4;
	  if (diff === 2) { return true }
	  return false
	};
	Quadrant.commonHalfPlane = function commonHalfPlane (quad1, quad2) {
	  if (quad1 === quad2) { return quad1 }
	  var diff = (quad1 - quad2 + 4) % 4;
	  if (diff === 2) { return -1 }
	  var min = quad1 < quad2 ? quad1 : quad2;
	  var max = quad1 > quad2 ? quad1 : quad2;
	  if (min === 0 && max === 3) { return 3 }
	  return min
	};
	Quadrant.isInHalfPlane = function isInHalfPlane (quad, halfPlane) {
	  if (halfPlane === Quadrant.SE) {
	    return quad === Quadrant.SE || quad === Quadrant.SW
	  }
	  return quad === halfPlane || quad === halfPlane + 1
	};
	Quadrant.quadrant = function quadrant () {
	  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
	    var dx = arguments[0];
	    var dy = arguments[1];
	    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException() }
	    if (dx >= 0.0) {
	      if (dy >= 0.0) { return Quadrant.NE; } else { return Quadrant.SE }
	    } else {
	      if (dy >= 0.0) { return Quadrant.NW; } else { return Quadrant.SW }
	    }
	  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    if (p1.x === p0.x && p1.y === p0.y) { throw new IllegalArgumentException() }
	    if (p1.x >= p0.x) {
	      if (p1.y >= p0.y) { return Quadrant.NE; } else { return Quadrant.SE }
	    } else {
	      if (p1.y >= p0.y) { return Quadrant.NW; } else { return Quadrant.SW }
	    }
	  }
	};
	staticAccessors$21.NE.get = function () { return 0 };
	staticAccessors$21.NW.get = function () { return 1 };
	staticAccessors$21.SW.get = function () { return 2 };
	staticAccessors$21.SE.get = function () { return 3 };

	Object.defineProperties( Quadrant, staticAccessors$21 );

	var EdgeEnd = function EdgeEnd () {
	  this._edge = null;
	  this._label = null;
	  this._node = null;
	  this._p0 = null;
	  this._p1 = null;
	  this._dx = null;
	  this._dy = null;
	  this._quadrant = null;
	  if (arguments.length === 1) {
	    var edge = arguments[0];
	    this._edge = edge;
	  } else if (arguments.length === 3) {
	    var edge$1 = arguments[0];
	    var p0 = arguments[1];
	    var p1 = arguments[2];
	    var label = null;
	    this._edge = edge$1;
	    this.init(p0, p1);
	    this._label = label;
	  } else if (arguments.length === 4) {
	    var edge$2 = arguments[0];
	    var p0$1 = arguments[1];
	    var p1$1 = arguments[2];
	    var label$1 = arguments[3];
	    this._edge = edge$2;
	    this.init(p0$1, p1$1);
	    this._label = label$1;
	  }
	};
	EdgeEnd.prototype.compareDirection = function compareDirection (e) {
	  if (this._dx === e._dx && this._dy === e._dy) { return 0 }
	  if (this._quadrant > e._quadrant) { return 1 }
	  if (this._quadrant < e._quadrant) { return -1 }
	  return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1)
	};
	EdgeEnd.prototype.getDy = function getDy () {
	  return this._dy
	};
	EdgeEnd.prototype.getCoordinate = function getCoordinate () {
	  return this._p0
	};
	EdgeEnd.prototype.setNode = function setNode (node) {
	  this._node = node;
	};
	EdgeEnd.prototype.print = function print (out) {
	  var angle = Math.atan2(this._dy, this._dx);
	  var className = this.getClass().getName();
	  var lastDotPos = className.lastIndexOf('.');
	  var name = className.substring(lastDotPos + 1);
	  out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
	};
	EdgeEnd.prototype.compareTo = function compareTo (obj) {
	  var e = obj;
	  return this.compareDirection(e)
	};
	EdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate () {
	  return this._p1
	};
	EdgeEnd.prototype.getDx = function getDx () {
	  return this._dx
	};
	EdgeEnd.prototype.getLabel = function getLabel () {
	  return this._label
	};
	EdgeEnd.prototype.getEdge = function getEdge () {
	  return this._edge
	};
	EdgeEnd.prototype.getQuadrant = function getQuadrant () {
	  return this._quadrant
	};
	EdgeEnd.prototype.getNode = function getNode () {
	  return this._node
	};
	EdgeEnd.prototype.toString = function toString () {
	  var angle = Math.atan2(this._dy, this._dx);
	  var className = this.getClass().getName();
	  var lastDotPos = className.lastIndexOf('.');
	  var name = className.substring(lastDotPos + 1);
	  return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label
	};
	EdgeEnd.prototype.computeLabel = function computeLabel (boundaryNodeRule) {};
	EdgeEnd.prototype.init = function init (p0, p1) {
	  this._p0 = p0;
	  this._p1 = p1;
	  this._dx = p1.x - p0.x;
	  this._dy = p1.y - p0.y;
	  this._quadrant = Quadrant.quadrant(this._dx, this._dy);
	  Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
	};
	EdgeEnd.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	EdgeEnd.prototype.getClass = function getClass () {
	  return EdgeEnd
	};

	var DirectedEdge = (function (EdgeEnd$$1) {
	  function DirectedEdge () {
	    var edge = arguments[0];
	    var isForward = arguments[1];
	    EdgeEnd$$1.call(this, edge);
	    this._isForward = null;
	    this._isInResult = false;
	    this._isVisited = false;
	    this._sym = null;
	    this._next = null;
	    this._nextMin = null;
	    this._edgeRing = null;
	    this._minEdgeRing = null;
	    this._depth = [0, -999, -999];
	    this._isForward = isForward;
	    if (isForward) {
	      this.init(edge.getCoordinate(0), edge.getCoordinate(1));
	    } else {
	      var n = edge.getNumPoints() - 1;
	      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
	    }
	    this.computeDirectedLabel();
	  }

	  if ( EdgeEnd$$1 ) DirectedEdge.__proto__ = EdgeEnd$$1;
	  DirectedEdge.prototype = Object.create( EdgeEnd$$1 && EdgeEnd$$1.prototype );
	  DirectedEdge.prototype.constructor = DirectedEdge;
	  DirectedEdge.prototype.getNextMin = function getNextMin () {
	    return this._nextMin
	  };
	  DirectedEdge.prototype.getDepth = function getDepth (position) {
	    return this._depth[position]
	  };
	  DirectedEdge.prototype.setVisited = function setVisited (isVisited) {
	    this._isVisited = isVisited;
	  };
	  DirectedEdge.prototype.computeDirectedLabel = function computeDirectedLabel () {
	    this._label = new Label(this._edge.getLabel());
	    if (!this._isForward) { this._label.flip(); }
	  };
	  DirectedEdge.prototype.getNext = function getNext () {
	    return this._next
	  };
	  DirectedEdge.prototype.setDepth = function setDepth (position, depthVal) {
	    if (this._depth[position] !== -999) {
	      if (this._depth[position] !== depthVal) { throw new TopologyException('assigned depths do not match', this.getCoordinate()) }
	    }
	    this._depth[position] = depthVal;
	  };
	  DirectedEdge.prototype.isInteriorAreaEdge = function isInteriorAreaEdge () {
	    var this$1$1 = this;

	    var isInteriorAreaEdge = true;
	    for (var i = 0; i < 2; i++) {
	      if (!(this$1$1._label.isArea(i) && this$1$1._label.getLocation(i, Position$1.LEFT) === Location.INTERIOR && this$1$1._label.getLocation(i, Position$1.RIGHT) === Location.INTERIOR)) {
	        isInteriorAreaEdge = false;
	      }
	    }
	    return isInteriorAreaEdge
	  };
	  DirectedEdge.prototype.setNextMin = function setNextMin (nextMin) {
	    this._nextMin = nextMin;
	  };
	  DirectedEdge.prototype.print = function print (out) {
	    EdgeEnd$$1.prototype.print.call(this, out);
	    out.print(' ' + this._depth[Position$1.LEFT] + '/' + this._depth[Position$1.RIGHT]);
	    out.print(' (' + this.getDepthDelta() + ')');
	    if (this._isInResult) { out.print(' inResult'); }
	  };
	  DirectedEdge.prototype.setMinEdgeRing = function setMinEdgeRing (minEdgeRing) {
	    this._minEdgeRing = minEdgeRing;
	  };
	  DirectedEdge.prototype.isLineEdge = function isLineEdge () {
	    var isLine = this._label.isLine(0) || this._label.isLine(1);
	    var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
	    var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
	    return isLine && isExteriorIfArea0 && isExteriorIfArea1
	  };
	  DirectedEdge.prototype.setEdgeRing = function setEdgeRing (edgeRing) {
	    this._edgeRing = edgeRing;
	  };
	  DirectedEdge.prototype.getMinEdgeRing = function getMinEdgeRing () {
	    return this._minEdgeRing
	  };
	  DirectedEdge.prototype.getDepthDelta = function getDepthDelta () {
	    var depthDelta = this._edge.getDepthDelta();
	    if (!this._isForward) { depthDelta = -depthDelta; }
	    return depthDelta
	  };
	  DirectedEdge.prototype.setInResult = function setInResult (isInResult) {
	    this._isInResult = isInResult;
	  };
	  DirectedEdge.prototype.getSym = function getSym () {
	    return this._sym
	  };
	  DirectedEdge.prototype.isForward = function isForward () {
	    return this._isForward
	  };
	  DirectedEdge.prototype.getEdge = function getEdge () {
	    return this._edge
	  };
	  DirectedEdge.prototype.printEdge = function printEdge (out) {
	    this.print(out);
	    out.print(' ');
	    if (this._isForward) { this._edge.print(out); } else { this._edge.printReverse(out); }
	  };
	  DirectedEdge.prototype.setSym = function setSym (de) {
	    this._sym = de;
	  };
	  DirectedEdge.prototype.setVisitedEdge = function setVisitedEdge (isVisited) {
	    this.setVisited(isVisited);
	    this._sym.setVisited(isVisited);
	  };
	  DirectedEdge.prototype.setEdgeDepths = function setEdgeDepths (position, depth) {
	    var depthDelta = this.getEdge().getDepthDelta();
	    if (!this._isForward) { depthDelta = -depthDelta; }
	    var directionFactor = 1;
	    if (position === Position$1.LEFT) { directionFactor = -1; }
	    var oppositePos = Position$1.opposite(position);
	    var delta = depthDelta * directionFactor;
	    var oppositeDepth = depth + delta;
	    this.setDepth(position, depth);
	    this.setDepth(oppositePos, oppositeDepth);
	  };
	  DirectedEdge.prototype.getEdgeRing = function getEdgeRing () {
	    return this._edgeRing
	  };
	  DirectedEdge.prototype.isInResult = function isInResult () {
	    return this._isInResult
	  };
	  DirectedEdge.prototype.setNext = function setNext (next) {
	    this._next = next;
	  };
	  DirectedEdge.prototype.isVisited = function isVisited () {
	    return this._isVisited
	  };
	  DirectedEdge.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  DirectedEdge.prototype.getClass = function getClass () {
	    return DirectedEdge
	  };
	  DirectedEdge.depthFactor = function depthFactor (currLocation, nextLocation) {
	    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) { return 1; } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) { return -1 }
	    return 0
	  };

	  return DirectedEdge;
	}(EdgeEnd));

	var NodeFactory = function NodeFactory () {};

	NodeFactory.prototype.createNode = function createNode (coord) {
	  return new Node$2(coord, null)
	};
	NodeFactory.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	NodeFactory.prototype.getClass = function getClass () {
	  return NodeFactory
	};

	var PlanarGraph = function PlanarGraph () {
	  this._edges = new ArrayList();
	  this._nodes = null;
	  this._edgeEndList = new ArrayList();
	  if (arguments.length === 0) {
	    this._nodes = new NodeMap(new NodeFactory());
	  } else if (arguments.length === 1) {
	    var nodeFact = arguments[0];
	    this._nodes = new NodeMap(nodeFact);
	  }
	};
	PlanarGraph.prototype.printEdges = function printEdges (out) {
	    var this$1$1 = this;

	  out.println('Edges:');
	  for (var i = 0; i < this._edges.size(); i++) {
	    out.println('edge ' + i + ':');
	    var e = this$1$1._edges.get(i);
	    e.print(out);
	    e.eiList.print(out);
	  }
	};
	PlanarGraph.prototype.find = function find (coord) {
	  return this._nodes.find(coord)
	};
	PlanarGraph.prototype.addNode = function addNode () {
	  if (arguments[0] instanceof Node$2) {
	    var node = arguments[0];
	    return this._nodes.addNode(node)
	  } else if (arguments[0] instanceof Coordinate) {
	    var coord = arguments[0];
	    return this._nodes.addNode(coord)
	  }
	};
	PlanarGraph.prototype.getNodeIterator = function getNodeIterator () {
	  return this._nodes.iterator()
	};
	PlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {
	  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
	    var node = nodeit.next();
	    node.getEdges().linkResultDirectedEdges();
	  }
	};
	PlanarGraph.prototype.debugPrintln = function debugPrintln (o) {
	  System.out.println(o);
	};
	PlanarGraph.prototype.isBoundaryNode = function isBoundaryNode (geomIndex, coord) {
	  var node = this._nodes.find(coord);
	  if (node === null) { return false }
	  var label = node.getLabel();
	  if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) { return true }
	  return false
	};
	PlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {
	  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
	    var node = nodeit.next();
	    node.getEdges().linkAllDirectedEdges();
	  }
	};
	PlanarGraph.prototype.matchInSameDirection = function matchInSameDirection (p0, p1, ep0, ep1) {
	  if (!p0.equals(ep0)) { return false }
	  if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) { return true }
	  return false
	};
	PlanarGraph.prototype.getEdgeEnds = function getEdgeEnds () {
	  return this._edgeEndList
	};
	PlanarGraph.prototype.debugPrint = function debugPrint (o) {
	  System.out.print(o);
	};
	PlanarGraph.prototype.getEdgeIterator = function getEdgeIterator () {
	  return this._edges.iterator()
	};
	PlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection (p0, p1) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._edges.size(); i++) {
	    var e = this$1$1._edges.get(i);
	    var eCoord = e.getCoordinates();
	    if (this$1$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) { return e }
	    if (this$1$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) { return e }
	  }
	  return null
	};
	PlanarGraph.prototype.insertEdge = function insertEdge (e) {
	  this._edges.add(e);
	};
	PlanarGraph.prototype.findEdgeEnd = function findEdgeEnd (e) {
	  for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {
	    var ee = i.next();
	    if (ee.getEdge() === e) { return ee }
	  }
	  return null
	};
	PlanarGraph.prototype.addEdges = function addEdges (edgesToAdd) {
	    var this$1$1 = this;

	  for (var it = edgesToAdd.iterator(); it.hasNext();) {
	    var e = it.next();
	    this$1$1._edges.add(e);
	    var de1 = new DirectedEdge(e, true);
	    var de2 = new DirectedEdge(e, false);
	    de1.setSym(de2);
	    de2.setSym(de1);
	    this$1$1.add(de1);
	    this$1$1.add(de2);
	  }
	};
	PlanarGraph.prototype.add = function add (e) {
	  this._nodes.add(e);
	  this._edgeEndList.add(e);
	};
	PlanarGraph.prototype.getNodes = function getNodes () {
	  return this._nodes.values()
	};
	PlanarGraph.prototype.findEdge = function findEdge (p0, p1) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._edges.size(); i++) {
	    var e = this$1$1._edges.get(i);
	    var eCoord = e.getCoordinates();
	    if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) { return e }
	  }
	  return null
	};
	PlanarGraph.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PlanarGraph.prototype.getClass = function getClass () {
	  return PlanarGraph
	};
	PlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges (nodes) {
	  for (var nodeit = nodes.iterator(); nodeit.hasNext();) {
	    var node = nodeit.next();
	    node.getEdges().linkResultDirectedEdges();
	  }
	};

	var PolygonBuilder = function PolygonBuilder () {
	  this._geometryFactory = null;
	  this._shellList = new ArrayList();
	  var geometryFactory = arguments[0];
	  this._geometryFactory = geometryFactory;
	};
	PolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles (edgeRings, shellList, freeHoleList) {
	  for (var it = edgeRings.iterator(); it.hasNext();) {
	    var er = it.next();
	    if (er.isHole()) {
	      freeHoleList.add(er);
	    } else {
	      shellList.add(er);
	    }
	  }
	};
	PolygonBuilder.prototype.computePolygons = function computePolygons (shellList) {
	    var this$1$1 = this;

	  var resultPolyList = new ArrayList();
	  for (var it = shellList.iterator(); it.hasNext();) {
	    var er = it.next();
	    var poly = er.toPolygon(this$1$1._geometryFactory);
	    resultPolyList.add(poly);
	  }
	  return resultPolyList
	};
	PolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles (shellList, freeHoleList) {
	    var this$1$1 = this;

	  for (var it = freeHoleList.iterator(); it.hasNext();) {
	    var hole = it.next();
	    if (hole.getShell() === null) {
	      var shell = this$1$1.findEdgeRingContaining(hole, shellList);
	      if (shell === null) { throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0)) }
	      hole.setShell(shell);
	    }
	  }
	};
	PolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings (maxEdgeRings, shellList, freeHoleList) {
	    var this$1$1 = this;

	  var edgeRings = new ArrayList();
	  for (var it = maxEdgeRings.iterator(); it.hasNext();) {
	    var er = it.next();
	    if (er.getMaxNodeDegree() > 2) {
	      er.linkDirectedEdgesForMinimalEdgeRings();
	      var minEdgeRings = er.buildMinimalRings();
	      var shell = this$1$1.findShell(minEdgeRings);
	      if (shell !== null) {
	        this$1$1.placePolygonHoles(shell, minEdgeRings);
	        shellList.add(shell);
	      } else {
	        freeHoleList.addAll(minEdgeRings);
	      }
	    } else {
	      edgeRings.add(er);
	    }
	  }
	  return edgeRings
	};
	PolygonBuilder.prototype.containsPoint = function containsPoint (p) {
	  for (var it = this._shellList.iterator(); it.hasNext();) {
	    var er = it.next();
	    if (er.containsPoint(p)) { return true }
	  }
	  return false
	};
	PolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings (dirEdges) {
	    var this$1$1 = this;

	  var maxEdgeRings = new ArrayList();
	  for (var it = dirEdges.iterator(); it.hasNext();) {
	    var de = it.next();
	    if (de.isInResult() && de.getLabel().isArea()) {
	      if (de.getEdgeRing() === null) {
	        var er = new MaximalEdgeRing(de, this$1$1._geometryFactory);
	        maxEdgeRings.add(er);
	        er.setInResult();
	      }
	    }
	  }
	  return maxEdgeRings
	};
	PolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles (shell, minEdgeRings) {
	  for (var it = minEdgeRings.iterator(); it.hasNext();) {
	    var er = it.next();
	    if (er.isHole()) {
	      er.setShell(shell);
	    }
	  }
	};
	PolygonBuilder.prototype.getPolygons = function getPolygons () {
	  var resultPolyList = this.computePolygons(this._shellList);
	  return resultPolyList
	};
	PolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining (testEr, shellList) {
	  var testRing = testEr.getLinearRing();
	  var testEnv = testRing.getEnvelopeInternal();
	  var testPt = testRing.getCoordinateN(0);
	  var minShell = null;
	  var minEnv = null;
	  for (var it = shellList.iterator(); it.hasNext();) {
	    var tryShell = it.next();
	    var tryRing = tryShell.getLinearRing();
	    var tryEnv = tryRing.getEnvelopeInternal();
	    if (minShell !== null) { minEnv = minShell.getLinearRing().getEnvelopeInternal(); }
	    var isContained = false;
	    if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) { isContained = true; }
	    if (isContained) {
	      if (minShell === null || minEnv.contains(tryEnv)) {
	        minShell = tryShell;
	      }
	    }
	  }
	  return minShell
	};
	PolygonBuilder.prototype.findShell = function findShell (minEdgeRings) {
	  var shellCount = 0;
	  var shell = null;
	  for (var it = minEdgeRings.iterator(); it.hasNext();) {
	    var er = it.next();
	    if (!er.isHole()) {
	      shell = er;
	      shellCount++;
	    }
	  }
	  Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
	  return shell
	};
	PolygonBuilder.prototype.add = function add () {
	  if (arguments.length === 1) {
	    var graph = arguments[0];
	    this.add(graph.getEdgeEnds(), graph.getNodes());
	  } else if (arguments.length === 2) {
	    var dirEdges = arguments[0];
	    var nodes = arguments[1];
	    PlanarGraph.linkResultDirectedEdges(nodes);
	    var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
	    var freeHoleList = new ArrayList();
	    var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
	    this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
	    this.placeFreeHoles(this._shellList, freeHoleList);
	  }
	};
	PolygonBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PolygonBuilder.prototype.getClass = function getClass () {
	  return PolygonBuilder
	};

	var Boundable = function Boundable () {};

	Boundable.prototype.getBounds = function getBounds () {};
	Boundable.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Boundable.prototype.getClass = function getClass () {
	  return Boundable
	};

	var ItemBoundable = function ItemBoundable () {
	  this._bounds = null;
	  this._item = null;
	  var bounds = arguments[0];
	  var item = arguments[1];
	  this._bounds = bounds;
	  this._item = item;
	};
	ItemBoundable.prototype.getItem = function getItem () {
	  return this._item
	};
	ItemBoundable.prototype.getBounds = function getBounds () {
	  return this._bounds
	};
	ItemBoundable.prototype.interfaces_ = function interfaces_ () {
	  return [Boundable, Serializable]
	};
	ItemBoundable.prototype.getClass = function getClass () {
	  return ItemBoundable
	};

	var PriorityQueue = function PriorityQueue () {
	  this._size = null;
	  this._items = null;
	  this._size = 0;
	  this._items = new ArrayList();
	  this._items.add(null);
	};
	PriorityQueue.prototype.poll = function poll () {
	  if (this.isEmpty()) { return null }
	  var minItem = this._items.get(1);
	  this._items.set(1, this._items.get(this._size));
	  this._size -= 1;
	  this.reorder(1);
	  return minItem
	};
	PriorityQueue.prototype.size = function size () {
	  return this._size
	};
	PriorityQueue.prototype.reorder = function reorder (hole) {
	    var this$1$1 = this;

	  var child = null;
	  var tmp = this._items.get(hole);
	  for (; hole * 2 <= this._size; hole = child) {
	    child = hole * 2;
	    if (child !== this$1$1._size && this$1$1._items.get(child + 1).compareTo(this$1$1._items.get(child)) < 0) { child++; }
	    if (this$1$1._items.get(child).compareTo(tmp) < 0) { this$1$1._items.set(hole, this$1$1._items.get(child)); } else { break }
	  }
	  this._items.set(hole, tmp);
	};
	PriorityQueue.prototype.clear = function clear () {
	  this._size = 0;
	  this._items.clear();
	};
	PriorityQueue.prototype.isEmpty = function isEmpty () {
	  return this._size === 0
	};
	PriorityQueue.prototype.add = function add (x) {
	    var this$1$1 = this;

	  this._items.add(null);
	  this._size += 1;
	  var hole = this._size;
	  this._items.set(0, x);
	  for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
	    this$1$1._items.set(hole, this$1$1._items.get(Math.trunc(hole / 2)));
	  }
	  this._items.set(hole, x);
	};
	PriorityQueue.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PriorityQueue.prototype.getClass = function getClass () {
	  return PriorityQueue
	};

	var ItemVisitor = function ItemVisitor () {};

	ItemVisitor.prototype.visitItem = function visitItem (item) {};
	ItemVisitor.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	ItemVisitor.prototype.getClass = function getClass () {
	  return ItemVisitor
	};

	var SpatialIndex = function SpatialIndex () {};

	SpatialIndex.prototype.insert = function insert (itemEnv, item) {};
	SpatialIndex.prototype.remove = function remove (itemEnv, item) {};
	SpatialIndex.prototype.query = function query () {
	  // if (arguments.length === 1) {
	  // const searchEnv = arguments[0]
	  // } else if (arguments.length === 2) {
	  // const searchEnv = arguments[0]
	  // const visitor = arguments[1]
	  // }
	};
	SpatialIndex.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SpatialIndex.prototype.getClass = function getClass () {
	  return SpatialIndex
	};

	var AbstractNode = function AbstractNode () {
	  this._childBoundables = new ArrayList();
	  this._bounds = null;
	  this._level = null;
	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    var level = arguments[0];
	    this._level = level;
	  }
	};

	var staticAccessors$22 = { serialVersionUID: { configurable: true } };
	AbstractNode.prototype.getLevel = function getLevel () {
	  return this._level
	};
	AbstractNode.prototype.size = function size () {
	  return this._childBoundables.size()
	};
	AbstractNode.prototype.getChildBoundables = function getChildBoundables () {
	  return this._childBoundables
	};
	AbstractNode.prototype.addChildBoundable = function addChildBoundable (childBoundable) {
	  Assert.isTrue(this._bounds === null);
	  this._childBoundables.add(childBoundable);
	};
	AbstractNode.prototype.isEmpty = function isEmpty () {
	  return this._childBoundables.isEmpty()
	};
	AbstractNode.prototype.getBounds = function getBounds () {
	  if (this._bounds === null) {
	    this._bounds = this.computeBounds();
	  }
	  return this._bounds
	};
	AbstractNode.prototype.interfaces_ = function interfaces_ () {
	  return [Boundable, Serializable]
	};
	AbstractNode.prototype.getClass = function getClass () {
	  return AbstractNode
	};
	staticAccessors$22.serialVersionUID.get = function () { return 6493722185909573708 };

	Object.defineProperties( AbstractNode, staticAccessors$22 );

	var Collections = function Collections () {};

	Collections.reverseOrder = function reverseOrder () {
	  return {
	    compare: function compare (a, b) {
	      return b.compareTo(a)
	    }
	  }
	};
	Collections.min = function min (l) {
	  Collections.sort(l);
	  return l.get(0)
	};
	Collections.sort = function sort (l, c) {
	  var a = l.toArray();
	  if (c) {
	    Arrays.sort(a, c);
	  } else {
	    Arrays.sort(a);
	  }
	  var i = l.iterator();
	  for (var pos = 0, alen = a.length; pos < alen; pos++) {
	    i.next();
	    i.set(a[pos]);
	  }
	};
	Collections.singletonList = function singletonList (o) {
	  var arrayList = new ArrayList();
	  arrayList.add(o);
	  return arrayList
	};

	var BoundablePair = function BoundablePair () {
	  this._boundable1 = null;
	  this._boundable2 = null;
	  this._distance = null;
	  this._itemDistance = null;
	  var boundable1 = arguments[0];
	  var boundable2 = arguments[1];
	  var itemDistance = arguments[2];
	  this._boundable1 = boundable1;
	  this._boundable2 = boundable2;
	  this._itemDistance = itemDistance;
	  this._distance = this.distance();
	};
	BoundablePair.prototype.expandToQueue = function expandToQueue (priQ, minDistance) {
	  var isComp1 = BoundablePair.isComposite(this._boundable1);
	  var isComp2 = BoundablePair.isComposite(this._boundable2);
	  if (isComp1 && isComp2) {
	    if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
	      this.expand(this._boundable1, this._boundable2, priQ, minDistance);
	      return null
	    } else {
	      this.expand(this._boundable2, this._boundable1, priQ, minDistance);
	      return null
	    }
	  } else if (isComp1) {
	    this.expand(this._boundable1, this._boundable2, priQ, minDistance);
	    return null
	  } else if (isComp2) {
	    this.expand(this._boundable2, this._boundable1, priQ, minDistance);
	    return null
	  }
	  throw new IllegalArgumentException()
	};
	BoundablePair.prototype.isLeaves = function isLeaves () {
	  return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))
	};
	BoundablePair.prototype.compareTo = function compareTo (o) {
	  var nd = o;
	  if (this._distance < nd._distance) { return -1 }
	  if (this._distance > nd._distance) { return 1 }
	  return 0
	};
	BoundablePair.prototype.expand = function expand (bndComposite, bndOther, priQ, minDistance) {
	    var this$1$1 = this;

	  var children = bndComposite.getChildBoundables();
	  for (var i = children.iterator(); i.hasNext();) {
	    var child = i.next();
	    var bp = new BoundablePair(child, bndOther, this$1$1._itemDistance);
	    if (bp.getDistance() < minDistance) {
	      priQ.add(bp);
	    }
	  }
	};
	BoundablePair.prototype.getBoundable = function getBoundable (i) {
	  if (i === 0) { return this._boundable1 }
	  return this._boundable2
	};
	BoundablePair.prototype.getDistance = function getDistance () {
	  return this._distance
	};
	BoundablePair.prototype.distance = function distance () {
	  if (this.isLeaves()) {
	    return this._itemDistance.distance(this._boundable1, this._boundable2)
	  }
	  return this._boundable1.getBounds().distance(this._boundable2.getBounds())
	};
	BoundablePair.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	BoundablePair.prototype.getClass = function getClass () {
	  return BoundablePair
	};
	BoundablePair.area = function area (b) {
	  return b.getBounds().getArea()
	};
	BoundablePair.isComposite = function isComposite (item) {
	  return item instanceof AbstractNode
	};

	var AbstractSTRtree = function AbstractSTRtree () {
	  this._root = null;
	  this._built = false;
	  this._itemBoundables = new ArrayList();
	  this._nodeCapacity = null;
	  if (arguments.length === 0) {
	    var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;
	    this._nodeCapacity = nodeCapacity;
	  } else if (arguments.length === 1) {
	    var nodeCapacity$1 = arguments[0];
	    Assert.isTrue(nodeCapacity$1 > 1, 'Node capacity must be greater than 1');
	    this._nodeCapacity = nodeCapacity$1;
	  }
	};

	var staticAccessors$23 = { IntersectsOp: { configurable: true },serialVersionUID: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };
	AbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity () {
	  return this._nodeCapacity
	};
	AbstractSTRtree.prototype.lastNode = function lastNode (nodes) {
	  return nodes.get(nodes.size() - 1)
	};
	AbstractSTRtree.prototype.size = function size () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    if (this.isEmpty()) {
	      return 0
	    }
	    this.build();
	    return this.size(this._root)
	  } else if (arguments.length === 1) {
	    var node = arguments[0];
	    var size = 0;
	    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
	      var childBoundable = i.next();
	      if (childBoundable instanceof AbstractNode) {
	        size += this$1$1.size(childBoundable);
	      } else if (childBoundable instanceof ItemBoundable) {
	        size += 1;
	      }
	    }
	    return size
	  }
	};
	AbstractSTRtree.prototype.removeItem = function removeItem (node, item) {
	  var childToRemove = null;
	  for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
	    var childBoundable = i.next();
	    if (childBoundable instanceof ItemBoundable) {
	      if (childBoundable.getItem() === item) { childToRemove = childBoundable; }
	    }
	  }
	  if (childToRemove !== null) {
	    node.getChildBoundables().remove(childToRemove);
	    return true
	  }
	  return false
	};
	AbstractSTRtree.prototype.itemsTree = function itemsTree () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    this.build();
	    var valuesTree = this.itemsTree(this._root);
	    if (valuesTree === null) { return new ArrayList() }
	    return valuesTree
	  } else if (arguments.length === 1) {
	    var node = arguments[0];
	    var valuesTreeForNode = new ArrayList();
	    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
	      var childBoundable = i.next();
	      if (childBoundable instanceof AbstractNode) {
	        var valuesTreeForChild = this$1$1.itemsTree(childBoundable);
	        if (valuesTreeForChild !== null) { valuesTreeForNode.add(valuesTreeForChild); }
	      } else if (childBoundable instanceof ItemBoundable) {
	        valuesTreeForNode.add(childBoundable.getItem());
	      } else {
	        Assert.shouldNeverReachHere();
	      }
	    }
	    if (valuesTreeForNode.size() <= 0) { return null }
	    return valuesTreeForNode
	  }
	};
	AbstractSTRtree.prototype.insert = function insert (bounds, item) {
	  Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
	  this._itemBoundables.add(new ItemBoundable(bounds, item));
	};
	AbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel () {
	    var this$1$1 = this;

	  if (arguments.length === 1) {
	    var level = arguments[0];
	    var boundables = new ArrayList();
	    this.boundablesAtLevel(level, this._root, boundables);
	    return boundables
	  } else if (arguments.length === 3) {
	    var level$1 = arguments[0];
	    var top = arguments[1];
	    var boundables$1 = arguments[2];
	    Assert.isTrue(level$1 > -2);
	    if (top.getLevel() === level$1) {
	      boundables$1.add(top);
	      return null
	    }
	    for (var i = top.getChildBoundables().iterator(); i.hasNext();) {
	      var boundable = i.next();
	      if (boundable instanceof AbstractNode) {
	        this$1$1.boundablesAtLevel(level$1, boundable, boundables$1);
	      } else {
	        Assert.isTrue(boundable instanceof ItemBoundable);
	        if (level$1 === -1) {
	          boundables$1.add(boundable);
	        }
	      }
	    }
	    return null
	  }
	};
	AbstractSTRtree.prototype.query = function query () {
	    var this$1$1 = this;

	  if (arguments.length === 1) {
	    var searchBounds = arguments[0];
	    this.build();
	    var matches = new ArrayList();
	    if (this.isEmpty()) {
	      return matches
	    }
	    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
	      this.query(searchBounds, this._root, matches);
	    }
	    return matches
	  } else if (arguments.length === 2) {
	    var searchBounds$1 = arguments[0];
	    var visitor = arguments[1];
	    this.build();
	    if (this.isEmpty()) {
	      return null
	    }
	    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {
	      this.query(searchBounds$1, this._root, visitor);
	    }
	  } else if (arguments.length === 3) {
	    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
	      var searchBounds$2 = arguments[0];
	      var node = arguments[1];
	      var visitor$1 = arguments[2];
	      var childBoundables = node.getChildBoundables();
	      for (var i = 0; i < childBoundables.size(); i++) {
	        var childBoundable = childBoundables.get(i);
	        if (!this$1$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {
	          continue
	        }
	        if (childBoundable instanceof AbstractNode) {
	          this$1$1.query(searchBounds$2, childBoundable, visitor$1);
	        } else if (childBoundable instanceof ItemBoundable) {
	          visitor$1.visitItem(childBoundable.getItem());
	        } else {
	          Assert.shouldNeverReachHere();
	        }
	      }
	    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
	      var searchBounds$3 = arguments[0];
	      var node$1 = arguments[1];
	      var matches$1 = arguments[2];
	      var childBoundables$1 = node$1.getChildBoundables();
	      for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {
	        var childBoundable$1 = childBoundables$1.get(i$1);
	        if (!this$1$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {
	          continue
	        }
	        if (childBoundable$1 instanceof AbstractNode) {
	          this$1$1.query(searchBounds$3, childBoundable$1, matches$1);
	        } else if (childBoundable$1 instanceof ItemBoundable) {
	          matches$1.add(childBoundable$1.getItem());
	        } else {
	          Assert.shouldNeverReachHere();
	        }
	      }
	    }
	  }
	};
	AbstractSTRtree.prototype.build = function build () {
	  if (this._built) { return null }
	  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
	  this._itemBoundables = null;
	  this._built = true;
	};
	AbstractSTRtree.prototype.getRoot = function getRoot () {
	  this.build();
	  return this._root
	};
	AbstractSTRtree.prototype.remove = function remove () {
	    var this$1$1 = this;

	  if (arguments.length === 2) {
	    var searchBounds = arguments[0];
	    var item = arguments[1];
	    this.build();
	    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
	      return this.remove(searchBounds, this._root, item)
	    }
	    return false
	  } else if (arguments.length === 3) {
	    var searchBounds$1 = arguments[0];
	    var node = arguments[1];
	    var item$1 = arguments[2];
	    var found = this.removeItem(node, item$1);
	    if (found) { return true }
	    var childToPrune = null;
	    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
	      var childBoundable = i.next();
	      if (!this$1$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {
	        continue
	      }
	      if (childBoundable instanceof AbstractNode) {
	        found = this$1$1.remove(searchBounds$1, childBoundable, item$1);
	        if (found) {
	          childToPrune = childBoundable;
	          break
	        }
	      }
	    }
	    if (childToPrune !== null) {
	      if (childToPrune.getChildBoundables().isEmpty()) {
	        node.getChildBoundables().remove(childToPrune);
	      }
	    }
	    return found
	  }
	};
	AbstractSTRtree.prototype.createHigherLevels = function createHigherLevels (boundablesOfALevel, level) {
	  Assert.isTrue(!boundablesOfALevel.isEmpty());
	  var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
	  if (parentBoundables.size() === 1) {
	    return parentBoundables.get(0)
	  }
	  return this.createHigherLevels(parentBoundables, level + 1)
	};
	AbstractSTRtree.prototype.depth = function depth () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    if (this.isEmpty()) {
	      return 0
	    }
	    this.build();
	    return this.depth(this._root)
	  } else if (arguments.length === 1) {
	    var node = arguments[0];
	    var maxChildDepth = 0;
	    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
	      var childBoundable = i.next();
	      if (childBoundable instanceof AbstractNode) {
	        var childDepth = this$1$1.depth(childBoundable);
	        if (childDepth > maxChildDepth) { maxChildDepth = childDepth; }
	      }
	    }
	    return maxChildDepth + 1
	  }
	};
	AbstractSTRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {
	    var this$1$1 = this;

	  Assert.isTrue(!childBoundables.isEmpty());
	  var parentBoundables = new ArrayList();
	  parentBoundables.add(this.createNode(newLevel));
	  var sortedChildBoundables = new ArrayList(childBoundables);
	  Collections.sort(sortedChildBoundables, this.getComparator());
	  for (var i = sortedChildBoundables.iterator(); i.hasNext();) {
	    var childBoundable = i.next();
	    if (this$1$1.lastNode(parentBoundables).getChildBoundables().size() === this$1$1.getNodeCapacity()) {
	      parentBoundables.add(this$1$1.createNode(newLevel));
	    }
	    this$1$1.lastNode(parentBoundables).addChildBoundable(childBoundable);
	  }
	  return parentBoundables
	};
	AbstractSTRtree.prototype.isEmpty = function isEmpty () {
	  if (!this._built) { return this._itemBoundables.isEmpty() }
	  return this._root.isEmpty()
	};
	AbstractSTRtree.prototype.interfaces_ = function interfaces_ () {
	  return [Serializable]
	};
	AbstractSTRtree.prototype.getClass = function getClass () {
	  return AbstractSTRtree
	};
	AbstractSTRtree.compareDoubles = function compareDoubles (a, b) {
	  return a > b ? 1 : a < b ? -1 : 0
	};
	staticAccessors$23.IntersectsOp.get = function () { return IntersectsOp };
	staticAccessors$23.serialVersionUID.get = function () { return -3886435814360241337 };
	staticAccessors$23.DEFAULT_NODE_CAPACITY.get = function () { return 10 };

	Object.defineProperties( AbstractSTRtree, staticAccessors$23 );

	var IntersectsOp = function IntersectsOp () {};

	var ItemDistance = function ItemDistance () {};

	ItemDistance.prototype.distance = function distance (item1, item2) {};
	ItemDistance.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	ItemDistance.prototype.getClass = function getClass () {
	  return ItemDistance
	};

	var STRtree = (function (AbstractSTRtree$$1) {
	  function STRtree (nodeCapacity) {
	    nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;
	    AbstractSTRtree$$1.call(this, nodeCapacity);
	  }

	  if ( AbstractSTRtree$$1 ) STRtree.__proto__ = AbstractSTRtree$$1;
	  STRtree.prototype = Object.create( AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype );
	  STRtree.prototype.constructor = STRtree;

	  var staticAccessors = { STRtreeNode: { configurable: true },serialVersionUID: { configurable: true },xComparator: { configurable: true },yComparator: { configurable: true },intersectsOp: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };
	  STRtree.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices (verticalSlices, newLevel) {
	    var this$1$1 = this;

	    Assert.isTrue(verticalSlices.length > 0);
	    var parentBoundables = new ArrayList();
	    for (var i = 0; i < verticalSlices.length; i++) {
	      parentBoundables.addAll(this$1$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
	    }
	    return parentBoundables
	  };
	  STRtree.prototype.createNode = function createNode (level) {
	    return new STRtreeNode(level)
	  };
	  STRtree.prototype.size = function size () {
	    if (arguments.length === 0) {
	      return AbstractSTRtree$$1.prototype.size.call(this)
	    } else { return AbstractSTRtree$$1.prototype.size.apply(this, arguments) }
	  };
	  STRtree.prototype.insert = function insert () {
	    if (arguments.length === 2) {
	      var itemEnv = arguments[0];
	      var item = arguments[1];
	      if (itemEnv.isNull()) {
	        return null
	      }
	      AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);
	    } else { return AbstractSTRtree$$1.prototype.insert.apply(this, arguments) }
	  };
	  STRtree.prototype.getIntersectsOp = function getIntersectsOp () {
	    return STRtree.intersectsOp
	  };
	  STRtree.prototype.verticalSlices = function verticalSlices (childBoundables, sliceCount) {
	    var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
	    var slices = new Array(sliceCount).fill(null);
	    var i = childBoundables.iterator();
	    for (var j = 0; j < sliceCount; j++) {
	      slices[j] = new ArrayList();
	      var boundablesAddedToSlice = 0;
	      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
	        var childBoundable = i.next();
	        slices[j].add(childBoundable);
	        boundablesAddedToSlice++;
	      }
	    }
	    return slices
	  };
	  STRtree.prototype.query = function query () {
	    if (arguments.length === 1) {
	      var searchEnv = arguments[0];
	      return AbstractSTRtree$$1.prototype.query.call(this, searchEnv)
	    } else if (arguments.length === 2) {
	      var searchEnv$1 = arguments[0];
	      var visitor = arguments[1];
	      AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);
	    } else if (arguments.length === 3) {
	      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
	        var searchBounds = arguments[0];
	        var node = arguments[1];
	        var visitor$1 = arguments[2];
	        AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);
	      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
	        var searchBounds$1 = arguments[0];
	        var node$1 = arguments[1];
	        var matches = arguments[2];
	        AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);
	      }
	    }
	  };
	  STRtree.prototype.getComparator = function getComparator () {
	    return STRtree.yComparator
	  };
	  STRtree.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice (childBoundables, newLevel) {
	    return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel)
	  };
	  STRtree.prototype.remove = function remove () {
	    if (arguments.length === 2) {
	      var itemEnv = arguments[0];
	      var item = arguments[1];
	      return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item)
	    } else { return AbstractSTRtree$$1.prototype.remove.apply(this, arguments) }
	  };
	  STRtree.prototype.depth = function depth () {
	    if (arguments.length === 0) {
	      return AbstractSTRtree$$1.prototype.depth.call(this)
	    } else { return AbstractSTRtree$$1.prototype.depth.apply(this, arguments) }
	  };
	  STRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {
	    Assert.isTrue(!childBoundables.isEmpty());
	    var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
	    var sortedChildBoundables = new ArrayList(childBoundables);
	    Collections.sort(sortedChildBoundables, STRtree.xComparator);
	    var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
	    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)
	  };
	  STRtree.prototype.nearestNeighbour = function nearestNeighbour () {
	    if (arguments.length === 1) {
	      if (hasInterface(arguments[0], ItemDistance)) {
	        var itemDist = arguments[0];
	        var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
	        return this.nearestNeighbour(bp)
	      } else if (arguments[0] instanceof BoundablePair) {
	        var initBndPair = arguments[0];
	        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)
	      }
	    } else if (arguments.length === 2) {
	      if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {
	        var tree = arguments[0];
	        var itemDist$1 = arguments[1];
	        var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);
	        return this.nearestNeighbour(bp$1)
	      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {
	        var initBndPair$1 = arguments[0];
	        var maxDistance = arguments[1];
	        var distanceLowerBound = maxDistance;
	        var minPair = null;
	        var priQ = new PriorityQueue();
	        priQ.add(initBndPair$1);
	        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
	          var bndPair = priQ.poll();
	          var currentDistance = bndPair.getDistance();
	          if (currentDistance >= distanceLowerBound) { break }
	          if (bndPair.isLeaves()) {
	            distanceLowerBound = currentDistance;
	            minPair = bndPair;
	          } else {
	            bndPair.expandToQueue(priQ, distanceLowerBound);
	          }
	        }
	        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]
	      }
	    } else if (arguments.length === 3) {
	      var env = arguments[0];
	      var item = arguments[1];
	      var itemDist$2 = arguments[2];
	      var bnd = new ItemBoundable(env, item);
	      var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);
	      return this.nearestNeighbour(bp$2)[0]
	    }
	  };
	  STRtree.prototype.interfaces_ = function interfaces_ () {
	    return [SpatialIndex, Serializable]
	  };
	  STRtree.prototype.getClass = function getClass () {
	    return STRtree
	  };
	  STRtree.centreX = function centreX (e) {
	    return STRtree.avg(e.getMinX(), e.getMaxX())
	  };
	  STRtree.avg = function avg (a, b) {
	    return (a + b) / 2
	  };
	  STRtree.centreY = function centreY (e) {
	    return STRtree.avg(e.getMinY(), e.getMaxY())
	  };
	  staticAccessors.STRtreeNode.get = function () { return STRtreeNode };
	  staticAccessors.serialVersionUID.get = function () { return 259274702368956900 };
	  staticAccessors.xComparator.get = function () {
	    return {
	      interfaces_: function () {
	        return [Comparator]
	      },
	      compare: function (o1, o2) {
	        return AbstractSTRtree$$1.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))
	      }
	    }
	  };
	  staticAccessors.yComparator.get = function () {
	    return {
	      interfaces_: function () {
	        return [Comparator]
	      },
	      compare: function (o1, o2) {
	        return AbstractSTRtree$$1.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))
	      }
	    }
	  };
	  staticAccessors.intersectsOp.get = function () {
	    return {
	      interfaces_: function () {
	        return [AbstractSTRtree$$1.IntersectsOp]
	      },
	      intersects: function (aBounds, bBounds) {
	        return aBounds.intersects(bBounds)
	      }
	    }
	  };
	  staticAccessors.DEFAULT_NODE_CAPACITY.get = function () { return 10 };

	  Object.defineProperties( STRtree, staticAccessors );

	  return STRtree;
	}(AbstractSTRtree));

	var STRtreeNode = (function (AbstractNode$$1) {
	  function STRtreeNode () {
	    var level = arguments[0];
	    AbstractNode$$1.call(this, level);
	  }

	  if ( AbstractNode$$1 ) STRtreeNode.__proto__ = AbstractNode$$1;
	  STRtreeNode.prototype = Object.create( AbstractNode$$1 && AbstractNode$$1.prototype );
	  STRtreeNode.prototype.constructor = STRtreeNode;
	  STRtreeNode.prototype.computeBounds = function computeBounds () {
	    var bounds = null;
	    for (var i = this.getChildBoundables().iterator(); i.hasNext();) {
	      var childBoundable = i.next();
	      if (bounds === null) {
	        bounds = new Envelope(childBoundable.getBounds());
	      } else {
	        bounds.expandToInclude(childBoundable.getBounds());
	      }
	    }
	    return bounds
	  };
	  STRtreeNode.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  STRtreeNode.prototype.getClass = function getClass () {
	    return STRtreeNode
	  };

	  return STRtreeNode;
	}(AbstractNode));

	var SegmentPointComparator = function SegmentPointComparator () {};

	SegmentPointComparator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SegmentPointComparator.prototype.getClass = function getClass () {
	  return SegmentPointComparator
	};
	SegmentPointComparator.relativeSign = function relativeSign (x0, x1) {
	  if (x0 < x1) { return -1 }
	  if (x0 > x1) { return 1 }
	  return 0
	};
	SegmentPointComparator.compare = function compare (octant, p0, p1) {
	  if (p0.equals2D(p1)) { return 0 }
	  var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
	  var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
	  switch (octant) {
	    case 0:
	      return SegmentPointComparator.compareValue(xSign, ySign)
	    case 1:
	      return SegmentPointComparator.compareValue(ySign, xSign)
	    case 2:
	      return SegmentPointComparator.compareValue(ySign, -xSign)
	    case 3:
	      return SegmentPointComparator.compareValue(-xSign, ySign)
	    case 4:
	      return SegmentPointComparator.compareValue(-xSign, -ySign)
	    case 5:
	      return SegmentPointComparator.compareValue(-ySign, -xSign)
	    case 6:
	      return SegmentPointComparator.compareValue(-ySign, xSign)
	    case 7:
	      return SegmentPointComparator.compareValue(xSign, -ySign)
	  }
	  Assert.shouldNeverReachHere('invalid octant value');
	  return 0
	};
	SegmentPointComparator.compareValue = function compareValue (compareSign0, compareSign1) {
	  if (compareSign0 < 0) { return -1 }
	  if (compareSign0 > 0) { return 1 }
	  if (compareSign1 < 0) { return -1 }
	  if (compareSign1 > 0) { return 1 }
	  return 0
	};

	var SegmentNode = function SegmentNode () {
	  this._segString = null;
	  this.coord = null;
	  this.segmentIndex = null;
	  this._segmentOctant = null;
	  this._isInterior = null;
	  var segString = arguments[0];
	  var coord = arguments[1];
	  var segmentIndex = arguments[2];
	  var segmentOctant = arguments[3];
	  this._segString = segString;
	  this.coord = new Coordinate(coord);
	  this.segmentIndex = segmentIndex;
	  this._segmentOctant = segmentOctant;
	  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
	};
	SegmentNode.prototype.getCoordinate = function getCoordinate () {
	  return this.coord
	};
	SegmentNode.prototype.print = function print (out) {
	  out.print(this.coord);
	  out.print(' seg # = ' + this.segmentIndex);
	};
	SegmentNode.prototype.compareTo = function compareTo (obj) {
	  var other = obj;
	  if (this.segmentIndex < other.segmentIndex) { return -1 }
	  if (this.segmentIndex > other.segmentIndex) { return 1 }
	  if (this.coord.equals2D(other.coord)) { return 0 }
	  return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)
	};
	SegmentNode.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {
	  if (this.segmentIndex === 0 && !this._isInterior) { return true }
	  if (this.segmentIndex === maxSegmentIndex) { return true }
	  return false
	};
	SegmentNode.prototype.isInterior = function isInterior () {
	  return this._isInterior
	};
	SegmentNode.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	SegmentNode.prototype.getClass = function getClass () {
	  return SegmentNode
	};

	// import Iterator from '../../../../java/util/Iterator'
	var SegmentNodeList = function SegmentNodeList () {
	  this._nodeMap = new TreeMap();
	  this._edge = null;
	  var edge = arguments[0];
	  this._edge = edge;
	};
	SegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates () {
	    var this$1$1 = this;

	  var coordList = new CoordinateList();
	  this.addEndpoints();
	  var it = this.iterator();
	  var eiPrev = it.next();
	  while (it.hasNext()) {
	    var ei = it.next();
	    this$1$1.addEdgeCoordinates(eiPrev, ei, coordList);
	    eiPrev = ei;
	  }
	  return coordList.toCoordinateArray()
	};
	SegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes () {
	    var this$1$1 = this;

	  var collapsedVertexIndexes = new ArrayList();
	  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
	  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
	  for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {
	    var vertexIndex = it.next().intValue();
	    this$1$1.add(this$1$1._edge.getCoordinate(vertexIndex), vertexIndex);
	  }
	};
	SegmentNodeList.prototype.print = function print (out) {
	  out.println('Intersections:');
	  for (var it = this.iterator(); it.hasNext();) {
	    var ei = it.next();
	    ei.print(out);
	  }
	};
	SegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices (collapsedVertexIndexes) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._edge.size() - 2; i++) {
	    var p0 = this$1$1._edge.getCoordinate(i);
	    // const p1 = this._edge.getCoordinate(i + 1)
	    var p2 = this$1$1._edge.getCoordinate(i + 2);
	    if (p0.equals2D(p2)) {
	      collapsedVertexIndexes.add(new Integer(i + 1));
	    }
	  }
	};
	SegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates (ei0, ei1, coordList) {
	    var this$1$1 = this;

	  // let npts = ei1.segmentIndex - ei0.segmentIndex + 2
	  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
	  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
	  // if (!useIntPt1) {
	  // npts--
	  // }
	  // const ipt = 0
	  coordList.add(new Coordinate(ei0.coord), false);
	  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
	    coordList.add(this$1$1._edge.getCoordinate(i));
	  }
	  if (useIntPt1) {
	    coordList.add(new Coordinate(ei1.coord));
	  }
	};
	SegmentNodeList.prototype.iterator = function iterator () {
	  return this._nodeMap.values().iterator()
	};
	SegmentNodeList.prototype.addSplitEdges = function addSplitEdges (edgeList) {
	    var this$1$1 = this;

	  this.addEndpoints();
	  this.addCollapsedNodes();
	  var it = this.iterator();
	  var eiPrev = it.next();
	  while (it.hasNext()) {
	    var ei = it.next();
	    var newEdge = this$1$1.createSplitEdge(eiPrev, ei);
	    edgeList.add(newEdge);
	    eiPrev = ei;
	  }
	};
	SegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex (ei0, ei1, collapsedVertexIndex) {
	  if (!ei0.coord.equals2D(ei1.coord)) { return false }
	  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
	  if (!ei1.isInterior()) {
	    numVerticesBetween--;
	  }
	  if (numVerticesBetween === 1) {
	    collapsedVertexIndex[0] = ei0.segmentIndex + 1;
	    return true
	  }
	  return false
	};
	SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes (collapsedVertexIndexes) {
	    var this$1$1 = this;

	  var collapsedVertexIndex = new Array(1).fill(null);
	  var it = this.iterator();
	  var eiPrev = it.next();
	  while (it.hasNext()) {
	    var ei = it.next();
	    var isCollapsed = this$1$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
	    if (isCollapsed) { collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0])); }
	    eiPrev = ei;
	  }
	};
	SegmentNodeList.prototype.getEdge = function getEdge () {
	  return this._edge
	};
	SegmentNodeList.prototype.addEndpoints = function addEndpoints () {
	  var maxSegIndex = this._edge.size() - 1;
	  this.add(this._edge.getCoordinate(0), 0);
	  this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
	};
	SegmentNodeList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {
	    var this$1$1 = this;

	  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
	  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
	  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
	  if (!useIntPt1) {
	    npts--;
	  }
	  var pts = new Array(npts).fill(null);
	  var ipt = 0;
	  pts[ipt++] = new Coordinate(ei0.coord);
	  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
	    pts[ipt++] = this$1$1._edge.getCoordinate(i);
	  }
	  if (useIntPt1) { pts[ipt] = new Coordinate(ei1.coord); }
	  return new NodedSegmentString(pts, this._edge.getData())
	};
	SegmentNodeList.prototype.add = function add (intPt, segmentIndex) {
	  var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
	  var ei = this._nodeMap.get(eiNew);
	  if (ei !== null) {
	    Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
	    return ei
	  }
	  this._nodeMap.put(eiNew, eiNew);
	  return eiNew
	};
	SegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness (splitEdges) {
	  var edgePts = this._edge.getCoordinates();
	  var split0 = splitEdges.get(0);
	  var pt0 = split0.getCoordinate(0);
	  if (!pt0.equals2D(edgePts[0])) { throw new RuntimeException('bad split edge start point at ' + pt0) }
	  var splitn = splitEdges.get(splitEdges.size() - 1);
	  var splitnPts = splitn.getCoordinates();
	  var ptn = splitnPts[splitnPts.length - 1];
	  if (!ptn.equals2D(edgePts[edgePts.length - 1])) { throw new RuntimeException('bad split edge end point at ' + ptn) }
	};
	SegmentNodeList.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SegmentNodeList.prototype.getClass = function getClass () {
	  return SegmentNodeList
	};



	// class NodeVertexIterator {
	//   constructor () {
	//     this._nodeList = null
	//     this._edge = null
	//     this._nodeIt = null
	//     this._currNode = null
	//     this._nextNode = null
	//     this._currSegIndex = 0
	//     let nodeList = arguments[0]
	//     this._nodeList = nodeList
	//     this._edge = nodeList.getEdge()
	//     this._nodeIt = nodeList.iterator()
	//     this.readNextNode()
	//   }
	//   next () {
	//     if (this._currNode === null) {
	//       this._currNode = this._nextNode
	//       this._currSegIndex = this._currNode.segmentIndex
	//       this.readNextNode()
	//       return this._currNode
	//     }
	//     if (this._nextNode === null) return null
	//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
	//       this._currNode = this._nextNode
	//       this._currSegIndex = this._currNode.segmentIndex
	//       this.readNextNode()
	//       return this._currNode
	//     }
	//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}
	//     return null
	//   }
	//   remove () {
	//     // throw new UnsupportedOperationException(this.getClass().getName())
	//   }
	//   hasNext () {
	//     if (this._nextNode === null) return false
	//     return true
	//   }
	//   readNextNode () {
	//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null
	//   }
	//   interfaces_ () {
	//     return [Iterator]
	//   }
	//   getClass () {
	//     return NodeVertexIterator
	//   }
	// }

	var Octant = function Octant () {};

	Octant.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Octant.prototype.getClass = function getClass () {
	  return Octant
	};
	Octant.octant = function octant () {
	  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
	    var dx = arguments[0];
	    var dy = arguments[1];
	    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException() }
	    var adx = Math.abs(dx);
	    var ady = Math.abs(dy);
	    if (dx >= 0) {
	      if (dy >= 0) {
	        if (adx >= ady) { return 0; } else { return 1 }
	      } else {
	        if (adx >= ady) { return 7; } else { return 6 }
	      }
	    } else {
	      if (dy >= 0) {
	        if (adx >= ady) { return 3; } else { return 2 }
	      } else {
	        if (adx >= ady) { return 4; } else { return 5 }
	      }
	    }
	  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    var dx$1 = p1.x - p0.x;
	    var dy$1 = p1.y - p0.y;
	    if (dx$1 === 0.0 && dy$1 === 0.0) { throw new IllegalArgumentException() }
	    return Octant.octant(dx$1, dy$1)
	  }
	};

	var SegmentString = function SegmentString () {};

	SegmentString.prototype.getCoordinates = function getCoordinates () {};
	SegmentString.prototype.size = function size () {};
	SegmentString.prototype.getCoordinate = function getCoordinate (i) {};
	SegmentString.prototype.isClosed = function isClosed () {};
	SegmentString.prototype.setData = function setData (data) {};
	SegmentString.prototype.getData = function getData () {};
	SegmentString.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SegmentString.prototype.getClass = function getClass () {
	  return SegmentString
	};

	var NodableSegmentString = function NodableSegmentString () {};

	NodableSegmentString.prototype.addIntersection = function addIntersection (intPt, segmentIndex) {};
	NodableSegmentString.prototype.interfaces_ = function interfaces_ () {
	  return [SegmentString]
	};
	NodableSegmentString.prototype.getClass = function getClass () {
	  return NodableSegmentString
	};

	var NodedSegmentString = function NodedSegmentString () {
	  this._nodeList = new SegmentNodeList(this);
	  this._pts = null;
	  this._data = null;
	  var pts = arguments[0];
	  var data = arguments[1];
	  this._pts = pts;
	  this._data = data;
	};
	NodedSegmentString.prototype.getCoordinates = function getCoordinates () {
	  return this._pts
	};
	NodedSegmentString.prototype.size = function size () {
	  return this._pts.length
	};
	NodedSegmentString.prototype.getCoordinate = function getCoordinate (i) {
	  return this._pts[i]
	};
	NodedSegmentString.prototype.isClosed = function isClosed () {
	  return this._pts[0].equals(this._pts[this._pts.length - 1])
	};
	NodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {
	  if (index === this._pts.length - 1) { return -1 }
	  return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))
	};
	NodedSegmentString.prototype.setData = function setData (data) {
	  this._data = data;
	};
	NodedSegmentString.prototype.safeOctant = function safeOctant (p0, p1) {
	  if (p0.equals2D(p1)) { return 0 }
	  return Octant.octant(p0, p1)
	};
	NodedSegmentString.prototype.getData = function getData () {
	  return this._data
	};
	NodedSegmentString.prototype.addIntersection = function addIntersection () {
	  if (arguments.length === 2) {
	    var intPt$1 = arguments[0];
	    var segmentIndex = arguments[1];
	    this.addIntersectionNode(intPt$1, segmentIndex);
	  } else if (arguments.length === 4) {
	    var li = arguments[0];
	    var segmentIndex$1 = arguments[1];
	    // const geomIndex = arguments[2]
	    var intIndex = arguments[3];
	    var intPt = new Coordinate(li.getIntersection(intIndex));
	    this.addIntersection(intPt, segmentIndex$1);
	  }
	};
	NodedSegmentString.prototype.toString = function toString () {
	  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
	};
	NodedSegmentString.prototype.getNodeList = function getNodeList () {
	  return this._nodeList
	};
	NodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode (intPt, segmentIndex) {
	  var normalizedSegmentIndex = segmentIndex;
	  var nextSegIndex = normalizedSegmentIndex + 1;
	  if (nextSegIndex < this._pts.length) {
	    var nextPt = this._pts[nextSegIndex];
	    if (intPt.equals2D(nextPt)) {
	      normalizedSegmentIndex = nextSegIndex;
	    }
	  }
	  var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
	  return ei
	};
	NodedSegmentString.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {
	    var this$1$1 = this;

	  for (var i = 0; i < li.getIntersectionNum(); i++) {
	    this$1$1.addIntersection(li, segmentIndex, geomIndex, i);
	  }
	};
	NodedSegmentString.prototype.interfaces_ = function interfaces_ () {
	  return [NodableSegmentString]
	};
	NodedSegmentString.prototype.getClass = function getClass () {
	  return NodedSegmentString
	};
	NodedSegmentString.getNodedSubstrings = function getNodedSubstrings () {
	  if (arguments.length === 1) {
	    var segStrings = arguments[0];
	    var resultEdgelist = new ArrayList();
	    NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
	    return resultEdgelist
	  } else if (arguments.length === 2) {
	    var segStrings$1 = arguments[0];
	    var resultEdgelist$1 = arguments[1];
	    for (var i = segStrings$1.iterator(); i.hasNext();) {
	      var ss = i.next();
	      ss.getNodeList().addSplitEdges(resultEdgelist$1);
	    }
	  }
	};

	var LineSegment = function LineSegment () {
	  this.p0 = null;
	  this.p1 = null;
	  if (arguments.length === 0) {
	    this.p0 = new Coordinate();
	    this.p1 = new Coordinate();
	  } else if (arguments.length === 1) {
	    var ls = arguments[0];
	    this.p0 = new Coordinate(ls.p0);
	    this.p1 = new Coordinate(ls.p1);
	  } else if (arguments.length === 2) {
	    this.p0 = arguments[0];
	    this.p1 = arguments[1];
	  } else if (arguments.length === 4) {
	    var x0 = arguments[0];
	    var y0 = arguments[1];
	    var x1 = arguments[2];
	    var y1 = arguments[3];
	    this.p0 = new Coordinate(x0, y0);
	    this.p1 = new Coordinate(x1, y1);
	  }
	};

	var staticAccessors$24 = { serialVersionUID: { configurable: true } };
	LineSegment.prototype.minX = function minX () {
	  return Math.min(this.p0.x, this.p1.x)
	};
	LineSegment.prototype.orientationIndex = function orientationIndex () {
	  if (arguments[0] instanceof LineSegment) {
	    var seg = arguments[0];
	    var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
	    var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
	    if (orient0 >= 0 && orient1 >= 0) { return Math.max(orient0, orient1) }
	    if (orient0 <= 0 && orient1 <= 0) { return Math.max(orient0, orient1) }
	    return 0
	  } else if (arguments[0] instanceof Coordinate) {
	    var p = arguments[0];
	    return CGAlgorithms.orientationIndex(this.p0, this.p1, p)
	  }
	};
	LineSegment.prototype.toGeometry = function toGeometry (geomFactory) {
	  return geomFactory.createLineString([this.p0, this.p1])
	};
	LineSegment.prototype.isVertical = function isVertical () {
	  return this.p0.x === this.p1.x
	};
	LineSegment.prototype.equals = function equals (o) {
	  if (!(o instanceof LineSegment)) {
	    return false
	  }
	  var other = o;
	  return this.p0.equals(other.p0) && this.p1.equals(other.p1)
	};
	LineSegment.prototype.intersection = function intersection (line) {
	  var li = new RobustLineIntersector();
	  li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
	  if (li.hasIntersection()) { return li.getIntersection(0) }
	  return null
	};
	LineSegment.prototype.project = function project () {
	  if (arguments[0] instanceof Coordinate) {
	    var p = arguments[0];
	    if (p.equals(this.p0) || p.equals(this.p1)) { return new Coordinate(p) }
	    var r = this.projectionFactor(p);
	    var coord = new Coordinate();
	    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
	    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
	    return coord
	  } else if (arguments[0] instanceof LineSegment) {
	    var seg = arguments[0];
	    var pf0 = this.projectionFactor(seg.p0);
	    var pf1 = this.projectionFactor(seg.p1);
	    if (pf0 >= 1.0 && pf1 >= 1.0) { return null }
	    if (pf0 <= 0.0 && pf1 <= 0.0) { return null }
	    var newp0 = this.project(seg.p0);
	    if (pf0 < 0.0) { newp0 = this.p0; }
	    if (pf0 > 1.0) { newp0 = this.p1; }
	    var newp1 = this.project(seg.p1);
	    if (pf1 < 0.0) { newp1 = this.p0; }
	    if (pf1 > 1.0) { newp1 = this.p1; }
	    return new LineSegment(newp0, newp1)
	  }
	};
	LineSegment.prototype.normalize = function normalize () {
	  if (this.p1.compareTo(this.p0) < 0) { this.reverse(); }
	};
	LineSegment.prototype.angle = function angle () {
	  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
	};
	LineSegment.prototype.getCoordinate = function getCoordinate (i) {
	  if (i === 0) { return this.p0 }
	  return this.p1
	};
	LineSegment.prototype.distancePerpendicular = function distancePerpendicular (p) {
	  return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1)
	};
	LineSegment.prototype.minY = function minY () {
	  return Math.min(this.p0.y, this.p1.y)
	};
	LineSegment.prototype.midPoint = function midPoint () {
	  return LineSegment.midPoint(this.p0, this.p1)
	};
	LineSegment.prototype.projectionFactor = function projectionFactor (p) {
	  if (p.equals(this.p0)) { return 0.0 }
	  if (p.equals(this.p1)) { return 1.0 }
	  var dx = this.p1.x - this.p0.x;
	  var dy = this.p1.y - this.p0.y;
	  var len = dx * dx + dy * dy;
	  if (len <= 0.0) { return Double.NaN }
	  var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
	  return r
	};
	LineSegment.prototype.closestPoints = function closestPoints (line) {
	  var intPt = this.intersection(line);
	  if (intPt !== null) {
	    return [intPt, intPt]
	  }
	  var closestPt = new Array(2).fill(null);
	  var minDistance = Double.MAX_VALUE;
	  var dist = null;
	  var close00 = this.closestPoint(line.p0);
	  minDistance = close00.distance(line.p0);
	  closestPt[0] = close00;
	  closestPt[1] = line.p0;
	  var close01 = this.closestPoint(line.p1);
	  dist = close01.distance(line.p1);
	  if (dist < minDistance) {
	    minDistance = dist;
	    closestPt[0] = close01;
	    closestPt[1] = line.p1;
	  }
	  var close10 = line.closestPoint(this.p0);
	  dist = close10.distance(this.p0);
	  if (dist < minDistance) {
	    minDistance = dist;
	    closestPt[0] = this.p0;
	    closestPt[1] = close10;
	  }
	  var close11 = line.closestPoint(this.p1);
	  dist = close11.distance(this.p1);
	  if (dist < minDistance) {
	    minDistance = dist;
	    closestPt[0] = this.p1;
	    closestPt[1] = close11;
	  }
	  return closestPt
	};
	LineSegment.prototype.closestPoint = function closestPoint (p) {
	  var factor = this.projectionFactor(p);
	  if (factor > 0 && factor < 1) {
	    return this.project(p)
	  }
	  var dist0 = this.p0.distance(p);
	  var dist1 = this.p1.distance(p);
	  if (dist0 < dist1) { return this.p0 }
	  return this.p1
	};
	LineSegment.prototype.maxX = function maxX () {
	  return Math.max(this.p0.x, this.p1.x)
	};
	LineSegment.prototype.getLength = function getLength () {
	  return this.p0.distance(this.p1)
	};
	LineSegment.prototype.compareTo = function compareTo (o) {
	  var other = o;
	  var comp0 = this.p0.compareTo(other.p0);
	  if (comp0 !== 0) { return comp0 }
	  return this.p1.compareTo(other.p1)
	};
	LineSegment.prototype.reverse = function reverse () {
	  var temp = this.p0;
	  this.p0 = this.p1;
	  this.p1 = temp;
	};
	LineSegment.prototype.equalsTopo = function equalsTopo (other) {
	  return this.p0.equals(other.p0) &&
	        (this.p1.equals(other.p1) || this.p0.equals(other.p1)) &&
	         this.p1.equals(other.p0)
	};
	LineSegment.prototype.lineIntersection = function lineIntersection (line) {
	  try {
	    var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
	    return intPt
	  } catch (ex) {
	    if (ex instanceof NotRepresentableException) ; else { throw ex }
	  } finally {}
	  return null
	};
	LineSegment.prototype.maxY = function maxY () {
	  return Math.max(this.p0.y, this.p1.y)
	};
	LineSegment.prototype.pointAlongOffset = function pointAlongOffset (segmentLengthFraction, offsetDistance) {
	  var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
	  var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
	  var dx = this.p1.x - this.p0.x;
	  var dy = this.p1.y - this.p0.y;
	  var len = Math.sqrt(dx * dx + dy * dy);
	  var ux = 0.0;
	  var uy = 0.0;
	  if (offsetDistance !== 0.0) {
	    if (len <= 0.0) { throw new Error('Cannot compute offset from zero-length line segment') }
	    ux = offsetDistance * dx / len;
	    uy = offsetDistance * dy / len;
	  }
	  var offsetx = segx - uy;
	  var offsety = segy + ux;
	  var coord = new Coordinate(offsetx, offsety);
	  return coord
	};
	LineSegment.prototype.setCoordinates = function setCoordinates () {
	  if (arguments.length === 1) {
	    var ls = arguments[0];
	    this.setCoordinates(ls.p0, ls.p1);
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    this.p0.x = p0.x;
	    this.p0.y = p0.y;
	    this.p1.x = p1.x;
	    this.p1.y = p1.y;
	  }
	};
	LineSegment.prototype.segmentFraction = function segmentFraction (inputPt) {
	  var segFrac = this.projectionFactor(inputPt);
	  if (segFrac < 0.0) { segFrac = 0.0; } else if (segFrac > 1.0 || Double.isNaN(segFrac)) { segFrac = 1.0; }
	  return segFrac
	};
	LineSegment.prototype.toString = function toString () {
	  return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'
	};
	LineSegment.prototype.isHorizontal = function isHorizontal () {
	  return this.p0.y === this.p1.y
	};
	LineSegment.prototype.distance = function distance () {
	  if (arguments[0] instanceof LineSegment) {
	    var ls = arguments[0];
	    return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1)
	  } else if (arguments[0] instanceof Coordinate) {
	    var p = arguments[0];
	    return CGAlgorithms.distancePointLine(p, this.p0, this.p1)
	  }
	};
	LineSegment.prototype.pointAlong = function pointAlong (segmentLengthFraction) {
	  var coord = new Coordinate();
	  coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
	  coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
	  return coord
	};
	LineSegment.prototype.hashCode = function hashCode () {
	  var bits0 = Double.doubleToLongBits(this.p0.x);
	  bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
	  var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
	  var bits1 = Double.doubleToLongBits(this.p1.x);
	  bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
	  var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
	  return hash0 ^ hash1
	};
	LineSegment.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable, Serializable]
	};
	LineSegment.prototype.getClass = function getClass () {
	  return LineSegment
	};
	LineSegment.midPoint = function midPoint (p0, p1) {
	  return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)
	};
	staticAccessors$24.serialVersionUID.get = function () { return 3252005833466256227 };

	Object.defineProperties( LineSegment, staticAccessors$24 );

	var MonotoneChainOverlapAction = function MonotoneChainOverlapAction () {
	  this.tempEnv1 = new Envelope();
	  this.tempEnv2 = new Envelope();
	  this._overlapSeg1 = new LineSegment();
	  this._overlapSeg2 = new LineSegment();
	};
	MonotoneChainOverlapAction.prototype.overlap = function overlap () {
	  if (arguments.length === 2) ; else if (arguments.length === 4) {
	    var mc1 = arguments[0];
	    var start1 = arguments[1];
	    var mc2 = arguments[2];
	    var start2 = arguments[3];
	    mc1.getLineSegment(start1, this._overlapSeg1);
	    mc2.getLineSegment(start2, this._overlapSeg2);
	    this.overlap(this._overlapSeg1, this._overlapSeg2);
	  }
	};
	MonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChainOverlapAction.prototype.getClass = function getClass () {
	  return MonotoneChainOverlapAction
	};

	var MonotoneChain = function MonotoneChain () {
	  this._pts = null;
	  this._start = null;
	  this._end = null;
	  this._env = null;
	  this._context = null;
	  this._id = null;
	  var pts = arguments[0];
	  var start = arguments[1];
	  var end = arguments[2];
	  var context = arguments[3];
	  this._pts = pts;
	  this._start = start;
	  this._end = end;
	  this._context = context;
	};
	MonotoneChain.prototype.getLineSegment = function getLineSegment (index, ls) {
	  ls.p0 = this._pts[index];
	  ls.p1 = this._pts[index + 1];
	};
	MonotoneChain.prototype.computeSelect = function computeSelect (searchEnv, start0, end0, mcs) {
	  var p0 = this._pts[start0];
	  var p1 = this._pts[end0];
	  mcs.tempEnv1.init(p0, p1);
	  if (end0 - start0 === 1) {
	    mcs.select(this, start0);
	    return null
	  }
	  if (!searchEnv.intersects(mcs.tempEnv1)) { return null }
	  var mid = Math.trunc((start0 + end0) / 2);
	  if (start0 < mid) {
	    this.computeSelect(searchEnv, start0, mid, mcs);
	  }
	  if (mid < end0) {
	    this.computeSelect(searchEnv, mid, end0, mcs);
	  }
	};
	MonotoneChain.prototype.getCoordinates = function getCoordinates () {
	    var this$1$1 = this;

	  var coord = new Array(this._end - this._start + 1).fill(null);
	  var index = 0;
	  for (var i = this._start; i <= this._end; i++) {
	    coord[index++] = this$1$1._pts[i];
	  }
	  return coord
	};
	MonotoneChain.prototype.computeOverlaps = function computeOverlaps (mc, mco) {
	  this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
	};
	MonotoneChain.prototype.setId = function setId (id) {
	  this._id = id;
	};
	MonotoneChain.prototype.select = function select (searchEnv, mcs) {
	  this.computeSelect(searchEnv, this._start, this._end, mcs);
	};
	MonotoneChain.prototype.getEnvelope = function getEnvelope () {
	  if (this._env === null) {
	    var p0 = this._pts[this._start];
	    var p1 = this._pts[this._end];
	    this._env = new Envelope(p0, p1);
	  }
	  return this._env
	};
	MonotoneChain.prototype.getEndIndex = function getEndIndex () {
	  return this._end
	};
	MonotoneChain.prototype.getStartIndex = function getStartIndex () {
	  return this._start
	};
	MonotoneChain.prototype.getContext = function getContext () {
	  return this._context
	};
	MonotoneChain.prototype.getId = function getId () {
	  return this._id
	};
	MonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal (start0, end0, mc, start1, end1, mco) {
	  var p00 = this._pts[start0];
	  var p01 = this._pts[end0];
	  var p10 = mc._pts[start1];
	  var p11 = mc._pts[end1];
	  if (end0 - start0 === 1 && end1 - start1 === 1) {
	    mco.overlap(this, start0, mc, start1);
	    return null
	  }
	  mco.tempEnv1.init(p00, p01);
	  mco.tempEnv2.init(p10, p11);
	  if (!mco.tempEnv1.intersects(mco.tempEnv2)) { return null }
	  var mid0 = Math.trunc((start0 + end0) / 2);
	  var mid1 = Math.trunc((start1 + end1) / 2);
	  if (start0 < mid0) {
	    if (start1 < mid1) { this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco); }
	    if (mid1 < end1) { this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco); }
	  }
	  if (mid0 < end0) {
	    if (start1 < mid1) { this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco); }
	    if (mid1 < end1) { this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco); }
	  }
	};
	MonotoneChain.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChain.prototype.getClass = function getClass () {
	  return MonotoneChain
	};

	var MonotoneChainBuilder = function MonotoneChainBuilder () {};

	MonotoneChainBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChainBuilder.prototype.getClass = function getClass () {
	  return MonotoneChainBuilder
	};
	MonotoneChainBuilder.getChainStartIndices = function getChainStartIndices (pts) {
	  var start = 0;
	  var startIndexList = new ArrayList();
	  startIndexList.add(new Integer(start));
	  do {
	    var last = MonotoneChainBuilder.findChainEnd(pts, start);
	    startIndexList.add(new Integer(last));
	    start = last;
	  } while (start < pts.length - 1)
	  var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
	  return startIndex
	};
	MonotoneChainBuilder.findChainEnd = function findChainEnd (pts, start) {
	  var safeStart = start;
	  while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
	    safeStart++;
	  }
	  if (safeStart >= pts.length - 1) {
	    return pts.length - 1
	  }
	  var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
	  var last = start + 1;
	  while (last < pts.length) {
	    if (!pts[last - 1].equals2D(pts[last])) {
	      var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
	      if (quad !== chainQuad) { break }
	    }
	    last++;
	  }
	  return last - 1
	};
	MonotoneChainBuilder.getChains = function getChains () {
	  if (arguments.length === 1) {
	    var pts = arguments[0];
	    return MonotoneChainBuilder.getChains(pts, null)
	  } else if (arguments.length === 2) {
	    var pts$1 = arguments[0];
	    var context = arguments[1];
	    var mcList = new ArrayList();
	    var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);
	    for (var i = 0; i < startIndex.length - 1; i++) {
	      var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);
	      mcList.add(mc);
	    }
	    return mcList
	  }
	};
	MonotoneChainBuilder.toIntArray = function toIntArray (list) {
	  var array = new Array(list.size()).fill(null);
	  for (var i = 0; i < array.length; i++) {
	    array[i] = list.get(i).intValue();
	  }
	  return array
	};

	var Noder = function Noder () {};

	Noder.prototype.computeNodes = function computeNodes (segStrings) {};
	Noder.prototype.getNodedSubstrings = function getNodedSubstrings () {};
	Noder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Noder.prototype.getClass = function getClass () {
	  return Noder
	};

	var SinglePassNoder = function SinglePassNoder () {
	  this._segInt = null;
	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    var segInt = arguments[0];
	    this.setSegmentIntersector(segInt);
	  }
	};
	SinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector (segInt) {
	  this._segInt = segInt;
	};
	SinglePassNoder.prototype.interfaces_ = function interfaces_ () {
	  return [Noder]
	};
	SinglePassNoder.prototype.getClass = function getClass () {
	  return SinglePassNoder
	};

	var MCIndexNoder = (function (SinglePassNoder$$1) {
	  function MCIndexNoder (si) {
	    if (si) { SinglePassNoder$$1.call(this, si); }
	    else { SinglePassNoder$$1.call(this); }
	    this._monoChains = new ArrayList();
	    this._index = new STRtree();
	    this._idCounter = 0;
	    this._nodedSegStrings = null;
	    this._nOverlaps = 0;
	  }

	  if ( SinglePassNoder$$1 ) MCIndexNoder.__proto__ = SinglePassNoder$$1;
	  MCIndexNoder.prototype = Object.create( SinglePassNoder$$1 && SinglePassNoder$$1.prototype );
	  MCIndexNoder.prototype.constructor = MCIndexNoder;

	  var staticAccessors = { SegmentOverlapAction: { configurable: true } };
	  MCIndexNoder.prototype.getMonotoneChains = function getMonotoneChains () {
	    return this._monoChains
	  };
	  MCIndexNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {
	    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
	  };
	  MCIndexNoder.prototype.getIndex = function getIndex () {
	    return this._index
	  };
	  MCIndexNoder.prototype.add = function add (segStr) {
	    var this$1$1 = this;

	    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
	    for (var i = segChains.iterator(); i.hasNext();) {
	      var mc = i.next();
	      mc.setId(this$1$1._idCounter++);
	      this$1$1._index.insert(mc.getEnvelope(), mc);
	      this$1$1._monoChains.add(mc);
	    }
	  };
	  MCIndexNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {
	    var this$1$1 = this;

	    this._nodedSegStrings = inputSegStrings;
	    for (var i = inputSegStrings.iterator(); i.hasNext();) {
	      this$1$1.add(i.next());
	    }
	    this.intersectChains();
	  };
	  MCIndexNoder.prototype.intersectChains = function intersectChains () {
	    var this$1$1 = this;

	    var overlapAction = new SegmentOverlapAction(this._segInt);
	    for (var i = this._monoChains.iterator(); i.hasNext();) {
	      var queryChain = i.next();
	      var overlapChains = this$1$1._index.query(queryChain.getEnvelope());
	      for (var j = overlapChains.iterator(); j.hasNext();) {
	        var testChain = j.next();
	        if (testChain.getId() > queryChain.getId()) {
	          queryChain.computeOverlaps(testChain, overlapAction);
	          this$1$1._nOverlaps++;
	        }
	        if (this$1$1._segInt.isDone()) { return null }
	      }
	    }
	  };
	  MCIndexNoder.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  MCIndexNoder.prototype.getClass = function getClass () {
	    return MCIndexNoder
	  };
	  staticAccessors.SegmentOverlapAction.get = function () { return SegmentOverlapAction };

	  Object.defineProperties( MCIndexNoder, staticAccessors );

	  return MCIndexNoder;
	}(SinglePassNoder));

	var SegmentOverlapAction = (function (MonotoneChainOverlapAction$$1) {
	  function SegmentOverlapAction () {
	    MonotoneChainOverlapAction$$1.call(this);
	    this._si = null;
	    var si = arguments[0];
	    this._si = si;
	  }

	  if ( MonotoneChainOverlapAction$$1 ) SegmentOverlapAction.__proto__ = MonotoneChainOverlapAction$$1;
	  SegmentOverlapAction.prototype = Object.create( MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype );
	  SegmentOverlapAction.prototype.constructor = SegmentOverlapAction;
	  SegmentOverlapAction.prototype.overlap = function overlap () {
	    if (arguments.length === 4) {
	      var mc1 = arguments[0];
	      var start1 = arguments[1];
	      var mc2 = arguments[2];
	      var start2 = arguments[3];
	      var ss1 = mc1.getContext();
	      var ss2 = mc2.getContext();
	      this._si.processIntersections(ss1, start1, ss2, start2);
	    } else { return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments) }
	  };
	  SegmentOverlapAction.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  SegmentOverlapAction.prototype.getClass = function getClass () {
	    return SegmentOverlapAction
	  };

	  return SegmentOverlapAction;
	}(MonotoneChainOverlapAction));

	var BufferParameters = function BufferParameters () {
	  this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
	  this._endCapStyle = BufferParameters.CAP_ROUND;
	  this._joinStyle = BufferParameters.JOIN_ROUND;
	  this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
	  this._isSingleSided = false;
	  this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;

	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    var quadrantSegments = arguments[0];
	    this.setQuadrantSegments(quadrantSegments);
	  } else if (arguments.length === 2) {
	    var quadrantSegments$1 = arguments[0];
	    var endCapStyle = arguments[1];
	    this.setQuadrantSegments(quadrantSegments$1);
	    this.setEndCapStyle(endCapStyle);
	  } else if (arguments.length === 4) {
	    var quadrantSegments$2 = arguments[0];
	    var endCapStyle$1 = arguments[1];
	    var joinStyle = arguments[2];
	    var mitreLimit = arguments[3];
	    this.setQuadrantSegments(quadrantSegments$2);
	    this.setEndCapStyle(endCapStyle$1);
	    this.setJoinStyle(joinStyle);
	    this.setMitreLimit(mitreLimit);
	  }
	};

	var staticAccessors$25 = { CAP_ROUND: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },JOIN_ROUND: { configurable: true },JOIN_MITRE: { configurable: true },JOIN_BEVEL: { configurable: true },DEFAULT_QUADRANT_SEGMENTS: { configurable: true },DEFAULT_MITRE_LIMIT: { configurable: true },DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
	BufferParameters.prototype.getEndCapStyle = function getEndCapStyle () {
	  return this._endCapStyle
	};
	BufferParameters.prototype.isSingleSided = function isSingleSided () {
	  return this._isSingleSided
	};
	BufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments (quadSegs) {
	  this._quadrantSegments = quadSegs;
	  if (this._quadrantSegments === 0) { this._joinStyle = BufferParameters.JOIN_BEVEL; }
	  if (this._quadrantSegments < 0) {
	    this._joinStyle = BufferParameters.JOIN_MITRE;
	    this._mitreLimit = Math.abs(this._quadrantSegments);
	  }
	  if (quadSegs <= 0) {
	    this._quadrantSegments = 1;
	  }
	  if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
	    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
	  }
	};
	BufferParameters.prototype.getJoinStyle = function getJoinStyle () {
	  return this._joinStyle
	};
	BufferParameters.prototype.setJoinStyle = function setJoinStyle (joinStyle) {
	  this._joinStyle = joinStyle;
	};
	BufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor (simplifyFactor) {
	  this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
	};
	BufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor () {
	  return this._simplifyFactor
	};
	BufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments () {
	  return this._quadrantSegments
	};
	BufferParameters.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {
	  this._endCapStyle = endCapStyle;
	};
	BufferParameters.prototype.getMitreLimit = function getMitreLimit () {
	  return this._mitreLimit
	};
	BufferParameters.prototype.setMitreLimit = function setMitreLimit (mitreLimit) {
	  this._mitreLimit = mitreLimit;
	};
	BufferParameters.prototype.setSingleSided = function setSingleSided (isSingleSided) {
	  this._isSingleSided = isSingleSided;
	};
	BufferParameters.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferParameters.prototype.getClass = function getClass () {
	  return BufferParameters
	};
	BufferParameters.bufferDistanceError = function bufferDistanceError (quadSegs) {
	  var alpha = Math.PI / 2.0 / quadSegs;
	  return 1 - Math.cos(alpha / 2.0)
	};
	staticAccessors$25.CAP_ROUND.get = function () { return 1 };
	staticAccessors$25.CAP_FLAT.get = function () { return 2 };
	staticAccessors$25.CAP_SQUARE.get = function () { return 3 };
	staticAccessors$25.JOIN_ROUND.get = function () { return 1 };
	staticAccessors$25.JOIN_MITRE.get = function () { return 2 };
	staticAccessors$25.JOIN_BEVEL.get = function () { return 3 };
	staticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function () { return 8 };
	staticAccessors$25.DEFAULT_MITRE_LIMIT.get = function () { return 5.0 };
	staticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function () { return 0.01 };

	Object.defineProperties( BufferParameters, staticAccessors$25 );

	var BufferInputLineSimplifier = function BufferInputLineSimplifier (inputLine) {
	  this._distanceTol = null;
	  this._isDeleted = null;
	  this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
	  this._inputLine = inputLine || null;
	};

	var staticAccessors$26 = { INIT: { configurable: true },DELETE: { configurable: true },KEEP: { configurable: true },NUM_PTS_TO_CHECK: { configurable: true } };
	BufferInputLineSimplifier.prototype.isDeletable = function isDeletable (i0, i1, i2, distanceTol) {
	  var p0 = this._inputLine[i0];
	  var p1 = this._inputLine[i1];
	  var p2 = this._inputLine[i2];
	  if (!this.isConcave(p0, p1, p2)) { return false }
	  if (!this.isShallow(p0, p1, p2, distanceTol)) { return false }
	  return this.isShallowSampled(p0, p1, i0, i2, distanceTol)
	};
	BufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities () {
	    var this$1$1 = this;

	  var index = 1;
	  // const maxIndex = this._inputLine.length - 1
	  var midIndex = this.findNextNonDeletedIndex(index);
	  var lastIndex = this.findNextNonDeletedIndex(midIndex);
	  var isChanged = false;
	  while (lastIndex < this._inputLine.length) {
	    var isMiddleVertexDeleted = false;
	    if (this$1$1.isDeletable(index, midIndex, lastIndex, this$1$1._distanceTol)) {
	      this$1$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
	      isMiddleVertexDeleted = true;
	      isChanged = true;
	    }
	    if (isMiddleVertexDeleted) { index = lastIndex; } else { index = midIndex; }
	    midIndex = this$1$1.findNextNonDeletedIndex(index);
	    lastIndex = this$1$1.findNextNonDeletedIndex(midIndex);
	  }
	  return isChanged
	};
	BufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity (p0, p1, p2, distanceTol) {
	  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
	  var isAngleToSimplify = orientation === this._angleOrientation;
	  if (!isAngleToSimplify) { return false }
	  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
	  return dist < distanceTol
	};
	BufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled (p0, p2, i0, i2, distanceTol) {
	    var this$1$1 = this;

	  var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
	  if (inc <= 0) { inc = 1; }
	  for (var i = i0; i < i2; i += inc) {
	    if (!this$1$1.isShallow(p0, p2, this$1$1._inputLine[i], distanceTol)) { return false }
	  }
	  return true
	};
	BufferInputLineSimplifier.prototype.isConcave = function isConcave (p0, p1, p2) {
	  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
	  var isConcave = orientation === this._angleOrientation;
	  return isConcave
	};
	BufferInputLineSimplifier.prototype.simplify = function simplify (distanceTol) {
	    var this$1$1 = this;

	  this._distanceTol = Math.abs(distanceTol);
	  if (distanceTol < 0) { this._angleOrientation = CGAlgorithms.CLOCKWISE; }
	  this._isDeleted = new Array(this._inputLine.length).fill(null);
	  var isChanged = false;
	  do {
	    isChanged = this$1$1.deleteShallowConcavities();
	  } while (isChanged)
	  return this.collapseLine()
	};
	BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex (index) {
	  var next = index + 1;
	  while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) { next++; }
	  return next
	};
	BufferInputLineSimplifier.prototype.isShallow = function isShallow (p0, p1, p2, distanceTol) {
	  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
	  return dist < distanceTol
	};
	BufferInputLineSimplifier.prototype.collapseLine = function collapseLine () {
	    var this$1$1 = this;

	  var coordList = new CoordinateList();
	  for (var i = 0; i < this._inputLine.length; i++) {
	    if (this$1$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) { coordList.add(this$1$1._inputLine[i]); }
	  }
	  return coordList.toCoordinateArray()
	};
	BufferInputLineSimplifier.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferInputLineSimplifier.prototype.getClass = function getClass () {
	  return BufferInputLineSimplifier
	};
	BufferInputLineSimplifier.simplify = function simplify (inputLine, distanceTol) {
	  var simp = new BufferInputLineSimplifier(inputLine);
	  return simp.simplify(distanceTol)
	};
	staticAccessors$26.INIT.get = function () { return 0 };
	staticAccessors$26.DELETE.get = function () { return 1 };
	staticAccessors$26.KEEP.get = function () { return 1 };
	staticAccessors$26.NUM_PTS_TO_CHECK.get = function () { return 10 };

	Object.defineProperties( BufferInputLineSimplifier, staticAccessors$26 );

	var OffsetSegmentString = function OffsetSegmentString () {
	  this._ptList = null;
	  this._precisionModel = null;
	  this._minimimVertexDistance = 0.0;
	  this._ptList = new ArrayList();
	};

	var staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };
	OffsetSegmentString.prototype.getCoordinates = function getCoordinates () {
	  var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
	  return coord
	};
	OffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {
	  this._precisionModel = precisionModel;
	};
	OffsetSegmentString.prototype.addPt = function addPt (pt) {
	  var bufPt = new Coordinate(pt);
	  this._precisionModel.makePrecise(bufPt);
	  if (this.isRedundant(bufPt)) { return null }
	  this._ptList.add(bufPt);
	};
	OffsetSegmentString.prototype.revere = function revere () {};
	OffsetSegmentString.prototype.addPts = function addPts (pt, isForward) {
	    var this$1$1 = this;

	  if (isForward) {
	    for (var i = 0; i < pt.length; i++) {
	      this$1$1.addPt(pt[i]);
	    }
	  } else {
	    for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {
	      this$1$1.addPt(pt[i$1]);
	    }
	  }
	};
	OffsetSegmentString.prototype.isRedundant = function isRedundant (pt) {
	  if (this._ptList.size() < 1) { return false }
	  var lastPt = this._ptList.get(this._ptList.size() - 1);
	  var ptDist = pt.distance(lastPt);
	  if (ptDist < this._minimimVertexDistance) { return true }
	  return false
	};
	OffsetSegmentString.prototype.toString = function toString () {
	  var fact = new GeometryFactory();
	  var line = fact.createLineString(this.getCoordinates());
	  return line.toString()
	};
	OffsetSegmentString.prototype.closeRing = function closeRing () {
	  if (this._ptList.size() < 1) { return null }
	  var startPt = new Coordinate(this._ptList.get(0));
	  var lastPt = this._ptList.get(this._ptList.size() - 1);
	  // const last2Pt = null
	  // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)
	  if (startPt.equals(lastPt)) { return null }
	  this._ptList.add(startPt);
	};
	OffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance (minimimVertexDistance) {
	  this._minimimVertexDistance = minimimVertexDistance;
	};
	OffsetSegmentString.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	OffsetSegmentString.prototype.getClass = function getClass () {
	  return OffsetSegmentString
	};
	staticAccessors$28.COORDINATE_ARRAY_TYPE.get = function () { return new Array(0).fill(null) };

	Object.defineProperties( OffsetSegmentString, staticAccessors$28 );

	var Angle = function Angle () {};

	var staticAccessors$29 = { PI_TIMES_2: { configurable: true },PI_OVER_2: { configurable: true },PI_OVER_4: { configurable: true },COUNTERCLOCKWISE: { configurable: true },CLOCKWISE: { configurable: true },NONE: { configurable: true } };

	Angle.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Angle.prototype.getClass = function getClass () {
	  return Angle
	};
	Angle.toDegrees = function toDegrees (radians) {
	  return radians * 180 / Math.PI
	};
	Angle.normalize = function normalize (angle) {
	  while (angle > Math.PI) { angle -= Angle.PI_TIMES_2; }
	  while (angle <= -Math.PI) { angle += Angle.PI_TIMES_2; }
	  return angle
	};
	Angle.angle = function angle () {
	  if (arguments.length === 1) {
	    var p = arguments[0];
	    return Math.atan2(p.y, p.x)
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    var dx = p1.x - p0.x;
	    var dy = p1.y - p0.y;
	    return Math.atan2(dy, dx)
	  }
	};
	Angle.isAcute = function isAcute (p0, p1, p2) {
	  var dx0 = p0.x - p1.x;
	  var dy0 = p0.y - p1.y;
	  var dx1 = p2.x - p1.x;
	  var dy1 = p2.y - p1.y;
	  var dotprod = dx0 * dx1 + dy0 * dy1;
	  return dotprod > 0
	};
	Angle.isObtuse = function isObtuse (p0, p1, p2) {
	  var dx0 = p0.x - p1.x;
	  var dy0 = p0.y - p1.y;
	  var dx1 = p2.x - p1.x;
	  var dy1 = p2.y - p1.y;
	  var dotprod = dx0 * dx1 + dy0 * dy1;
	  return dotprod < 0
	};
	Angle.interiorAngle = function interiorAngle (p0, p1, p2) {
	  var anglePrev = Angle.angle(p1, p0);
	  var angleNext = Angle.angle(p1, p2);
	  return Math.abs(angleNext - anglePrev)
	};
	Angle.normalizePositive = function normalizePositive (angle) {
	  if (angle < 0.0) {
	    while (angle < 0.0) { angle += Angle.PI_TIMES_2; }
	    if (angle >= Angle.PI_TIMES_2) { angle = 0.0; }
	  } else {
	    while (angle >= Angle.PI_TIMES_2) { angle -= Angle.PI_TIMES_2; }
	    if (angle < 0.0) { angle = 0.0; }
	  }
	  return angle
	};
	Angle.angleBetween = function angleBetween (tip1, tail, tip2) {
	  var a1 = Angle.angle(tail, tip1);
	  var a2 = Angle.angle(tail, tip2);
	  return Angle.diff(a1, a2)
	};
	Angle.diff = function diff (ang1, ang2) {
	  var delAngle = null;
	  if (ang1 < ang2) {
	    delAngle = ang2 - ang1;
	  } else {
	    delAngle = ang1 - ang2;
	  }
	  if (delAngle > Math.PI) {
	    delAngle = 2 * Math.PI - delAngle;
	  }
	  return delAngle
	};
	Angle.toRadians = function toRadians (angleDegrees) {
	  return angleDegrees * Math.PI / 180.0
	};
	Angle.getTurn = function getTurn (ang1, ang2) {
	  var crossproduct = Math.sin(ang2 - ang1);
	  if (crossproduct > 0) {
	    return Angle.COUNTERCLOCKWISE
	  }
	  if (crossproduct < 0) {
	    return Angle.CLOCKWISE
	  }
	  return Angle.NONE
	};
	Angle.angleBetweenOriented = function angleBetweenOriented (tip1, tail, tip2) {
	  var a1 = Angle.angle(tail, tip1);
	  var a2 = Angle.angle(tail, tip2);
	  var angDel = a2 - a1;
	  if (angDel <= -Math.PI) { return angDel + Angle.PI_TIMES_2 }
	  if (angDel > Math.PI) { return angDel - Angle.PI_TIMES_2 }
	  return angDel
	};
	staticAccessors$29.PI_TIMES_2.get = function () { return 2.0 * Math.PI };
	staticAccessors$29.PI_OVER_2.get = function () { return Math.PI / 2.0 };
	staticAccessors$29.PI_OVER_4.get = function () { return Math.PI / 4.0 };
	staticAccessors$29.COUNTERCLOCKWISE.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };
	staticAccessors$29.CLOCKWISE.get = function () { return CGAlgorithms.CLOCKWISE };
	staticAccessors$29.NONE.get = function () { return CGAlgorithms.COLLINEAR };

	Object.defineProperties( Angle, staticAccessors$29 );

	var OffsetSegmentGenerator = function OffsetSegmentGenerator () {
	  this._maxCurveSegmentError = 0.0;
	  this._filletAngleQuantum = null;
	  this._closingSegLengthFactor = 1;
	  this._segList = null;
	  this._distance = 0.0;
	  this._precisionModel = null;
	  this._bufParams = null;
	  this._li = null;
	  this._s0 = null;
	  this._s1 = null;
	  this._s2 = null;
	  this._seg0 = new LineSegment();
	  this._seg1 = new LineSegment();
	  this._offset0 = new LineSegment();
	  this._offset1 = new LineSegment();
	  this._side = 0;
	  this._hasNarrowConcaveAngle = false;
	  var precisionModel = arguments[0];
	  var bufParams = arguments[1];
	  var distance = arguments[2];
	  this._precisionModel = precisionModel;
	  this._bufParams = bufParams;
	  this._li = new RobustLineIntersector();
	  this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
	  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) { this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR; }
	  this.init(distance);
	};

	var staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true },INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
	OffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment (p, addStartPoint) {
	  this._s0 = this._s1;
	  this._s1 = this._s2;
	  this._s2 = p;
	  this._seg0.setCoordinates(this._s0, this._s1);
	  this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
	  this._seg1.setCoordinates(this._s1, this._s2);
	  this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
	  if (this._s1.equals(this._s2)) { return null }
	  var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
	  var outsideTurn = (orientation === CGAlgorithms.CLOCKWISE && this._side === Position$1.LEFT) || (orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position$1.RIGHT);
	  if (orientation === 0) {
	    this.addCollinear(addStartPoint);
	  } else if (outsideTurn) {
	    this.addOutsideTurn(orientation, addStartPoint);
	  } else {
	    this.addInsideTurn(orientation, addStartPoint);
	  }
	};
	OffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap (p0, p1) {
	  var seg = new LineSegment(p0, p1);
	  var offsetL = new LineSegment();
	  this.computeOffsetSegment(seg, Position$1.LEFT, this._distance, offsetL);
	  var offsetR = new LineSegment();
	  this.computeOffsetSegment(seg, Position$1.RIGHT, this._distance, offsetR);
	  var dx = p1.x - p0.x;
	  var dy = p1.y - p0.y;
	  var angle = Math.atan2(dy, dx);
	  switch (this._bufParams.getEndCapStyle()) {
	    case BufferParameters.CAP_ROUND:
	      this._segList.addPt(offsetL.p1);
	      this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
	      this._segList.addPt(offsetR.p1);
	      break
	    case BufferParameters.CAP_FLAT:
	      this._segList.addPt(offsetL.p1);
	      this._segList.addPt(offsetR.p1);
	      break
	    case BufferParameters.CAP_SQUARE:
	      var squareCapSideOffset = new Coordinate();
	      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
	      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
	      var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
	      var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
	      this._segList.addPt(squareCapLOffset);
	      this._segList.addPt(squareCapROffset);
	      break
	  }
	};
	OffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates () {
	  var pts = this._segList.getCoordinates();
	  return pts
	};
	OffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin (p, offset0, offset1, distance) {
	  var isMitreWithinLimit = true;
	  var intPt = null;
	  try {
	    intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
	    var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
	    if (mitreRatio > this._bufParams.getMitreLimit()) { isMitreWithinLimit = false; }
	  } catch (ex) {
	    if (ex instanceof NotRepresentableException) {
	      intPt = new Coordinate(0, 0);
	      isMitreWithinLimit = false;
	    } else { throw ex }
	  } finally {}
	  if (isMitreWithinLimit) {
	    this._segList.addPt(intPt);
	  } else {
	    this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
	  }
	};
	OffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner (p, p0, p1, direction, radius) {
	  var dx0 = p0.x - p.x;
	  var dy0 = p0.y - p.y;
	  var startAngle = Math.atan2(dy0, dx0);
	  var dx1 = p1.x - p.x;
	  var dy1 = p1.y - p.y;
	  var endAngle = Math.atan2(dy1, dx1);
	  if (direction === CGAlgorithms.CLOCKWISE) {
	    if (startAngle <= endAngle) { startAngle += 2.0 * Math.PI; }
	  } else {
	    if (startAngle >= endAngle) { startAngle -= 2.0 * Math.PI; }
	  }
	  this._segList.addPt(p0);
	  this.addFilletArc(p, startAngle, endAngle, direction, radius);
	  this._segList.addPt(p1);
	};
	OffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn (orientation, addStartPoint) {
	  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
	    this._segList.addPt(this._offset0.p1);
	    return null
	  }
	  if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
	    this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
	  } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
	    this.addBevelJoin(this._offset0, this._offset1);
	  } else {
	    if (addStartPoint) { this._segList.addPt(this._offset0.p1); }
	    this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
	    this._segList.addPt(this._offset1.p0);
	  }
	};
	OffsetSegmentGenerator.prototype.createSquare = function createSquare (p) {
	  this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
	  this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
	  this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
	  this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
	  this._segList.closeRing();
	};
	OffsetSegmentGenerator.prototype.addSegments = function addSegments (pt, isForward) {
	  this._segList.addPts(pt, isForward);
	};
	OffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment () {
	  this._segList.addPt(this._offset1.p0);
	};
	OffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment () {
	  this._segList.addPt(this._offset1.p1);
	};
	OffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments (s1, s2, side) {
	  this._s1 = s1;
	  this._s2 = s2;
	  this._side = side;
	  this._seg1.setCoordinates(s1, s2);
	  this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
	};
	OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin (offset0, offset1, distance, mitreLimit) {
	  var basePt = this._seg0.p1;
	  var ang0 = Angle.angle(basePt, this._seg0.p0);
	  // const ang1 = Angle.angle(basePt, this._seg1.p1)
	  var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
	  var angDiffHalf = angDiff / 2;
	  var midAng = Angle.normalize(ang0 + angDiffHalf);
	  var mitreMidAng = Angle.normalize(midAng + Math.PI);
	  var mitreDist = mitreLimit * distance;
	  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
	  var bevelHalfLen = distance - bevelDelta;
	  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
	  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
	  var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
	  var mitreMidLine = new LineSegment(basePt, bevelMidPt);
	  var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
	  var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
	  if (this._side === Position$1.LEFT) {
	    this._segList.addPt(bevelEndLeft);
	    this._segList.addPt(bevelEndRight);
	  } else {
	    this._segList.addPt(bevelEndRight);
	    this._segList.addPt(bevelEndLeft);
	  }
	};
	OffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment (seg, side, distance, offset) {
	  var sideSign = side === Position$1.LEFT ? 1 : -1;
	  var dx = seg.p1.x - seg.p0.x;
	  var dy = seg.p1.y - seg.p0.y;
	  var len = Math.sqrt(dx * dx + dy * dy);
	  var ux = sideSign * distance * dx / len;
	  var uy = sideSign * distance * dy / len;
	  offset.p0.x = seg.p0.x - uy;
	  offset.p0.y = seg.p0.y + ux;
	  offset.p1.x = seg.p1.x - uy;
	  offset.p1.y = seg.p1.y + ux;
	};
	OffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc (p, startAngle, endAngle, direction, radius) {
	    var this$1$1 = this;

	  var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
	  var totalAngle = Math.abs(startAngle - endAngle);
	  var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
	  if (nSegs < 1) { return null }
	  var initAngle = 0.0;
	  var currAngleInc = totalAngle / nSegs;
	  var currAngle = initAngle;
	  var pt = new Coordinate();
	  while (currAngle < totalAngle) {
	    var angle = startAngle + directionFactor * currAngle;
	    pt.x = p.x + radius * Math.cos(angle);
	    pt.y = p.y + radius * Math.sin(angle);
	    this$1$1._segList.addPt(pt);
	    currAngle += currAngleInc;
	  }
	};
	OffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn (orientation, addStartPoint) {
	  this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
	  if (this._li.hasIntersection()) {
	    this._segList.addPt(this._li.getIntersection(0));
	  } else {
	    this._hasNarrowConcaveAngle = true;
	    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
	      this._segList.addPt(this._offset0.p1);
	    } else {
	      this._segList.addPt(this._offset0.p1);
	      if (this._closingSegLengthFactor > 0) {
	        var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
	        this._segList.addPt(mid0);
	        var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
	        this._segList.addPt(mid1);
	      } else {
	        this._segList.addPt(this._s1);
	      }
	      this._segList.addPt(this._offset1.p0);
	    }
	  }
	};
	OffsetSegmentGenerator.prototype.createCircle = function createCircle (p) {
	  var pt = new Coordinate(p.x + this._distance, p.y);
	  this._segList.addPt(pt);
	  this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);
	  this._segList.closeRing();
	};
	OffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin (offset0, offset1) {
	  this._segList.addPt(offset0.p1);
	  this._segList.addPt(offset1.p0);
	};
	OffsetSegmentGenerator.prototype.init = function init (distance) {
	  this._distance = distance;
	  this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
	  this._segList = new OffsetSegmentString();
	  this._segList.setPrecisionModel(this._precisionModel);
	  this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
	};
	OffsetSegmentGenerator.prototype.addCollinear = function addCollinear (addStartPoint) {
	  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
	  var numInt = this._li.getIntersectionNum();
	  if (numInt >= 2) {
	    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
	      if (addStartPoint) { this._segList.addPt(this._offset0.p1); }
	      this._segList.addPt(this._offset1.p0);
	    } else {
	      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
	    }
	  }
	};
	OffsetSegmentGenerator.prototype.closeRing = function closeRing () {
	  this._segList.closeRing();
	};
	OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle () {
	  return this._hasNarrowConcaveAngle
	};
	OffsetSegmentGenerator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	OffsetSegmentGenerator.prototype.getClass = function getClass () {
	  return OffsetSegmentGenerator
	};
	staticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () { return 1.0E-3 };
	staticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-3 };
	staticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-6 };
	staticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function () { return 80 };

	Object.defineProperties( OffsetSegmentGenerator, staticAccessors$27 );

	var OffsetCurveBuilder = function OffsetCurveBuilder () {
	  this._distance = 0.0;
	  this._precisionModel = null;
	  this._bufParams = null;
	  var precisionModel = arguments[0];
	  var bufParams = arguments[1];
	  this._precisionModel = precisionModel;
	  this._bufParams = bufParams;
	};
	OffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve (inputPts, distance) {
	  this._distance = distance;
	  if (distance === 0.0) { return null }
	  var isRightSide = distance < 0.0;
	  var posDistance = Math.abs(distance);
	  var segGen = this.getSegGen(posDistance);
	  if (inputPts.length <= 1) {
	    this.computePointCurve(inputPts[0], segGen);
	  } else {
	    this.computeOffsetCurve(inputPts, isRightSide, segGen);
	  }
	  var curvePts = segGen.getCoordinates();
	  if (isRightSide) { CoordinateArrays.reverse(curvePts); }
	  return curvePts
	};
	OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve (inputPts, isRightSide, segGen) {
	  var distTol = this.simplifyTolerance(this._distance);
	  if (isRightSide) {
	    segGen.addSegments(inputPts, true);
	    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
	    var n2 = simp2.length - 1;
	    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position$1.LEFT);
	    segGen.addFirstSegment();
	    for (var i = n2 - 2; i >= 0; i--) {
	      segGen.addNextSegment(simp2[i], true);
	    }
	  } else {
	    segGen.addSegments(inputPts, false);
	    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
	    var n1 = simp1.length - 1;
	    segGen.initSideSegments(simp1[0], simp1[1], Position$1.LEFT);
	    segGen.addFirstSegment();
	    for (var i$1 = 2; i$1 <= n1; i$1++) {
	      segGen.addNextSegment(simp1[i$1], true);
	    }
	  }
	  segGen.addLastSegment();
	  segGen.closeRing();
	};
	OffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve (inputPts, side, segGen) {
	  var distTol = this.simplifyTolerance(this._distance);
	  if (side === Position$1.RIGHT) { distTol = -distTol; }
	  var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
	  var n = simp.length - 1;
	  segGen.initSideSegments(simp[n - 1], simp[0], side);
	  for (var i = 1; i <= n; i++) {
	    var addStartPoint = i !== 1;
	    segGen.addNextSegment(simp[i], addStartPoint);
	  }
	  segGen.closeRing();
	};
	OffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve (inputPts, segGen) {
	  var distTol = this.simplifyTolerance(this._distance);
	  var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
	  var n1 = simp1.length - 1;
	  segGen.initSideSegments(simp1[0], simp1[1], Position$1.LEFT);
	  for (var i = 2; i <= n1; i++) {
	    segGen.addNextSegment(simp1[i], true);
	  }
	  segGen.addLastSegment();
	  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
	  var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
	  var n2 = simp2.length - 1;
	  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position$1.LEFT);
	  for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {
	    segGen.addNextSegment(simp2[i$1], true);
	  }
	  segGen.addLastSegment();
	  segGen.addLineEndCap(simp2[1], simp2[0]);
	  segGen.closeRing();
	};
	OffsetCurveBuilder.prototype.computePointCurve = function computePointCurve (pt, segGen) {
	  switch (this._bufParams.getEndCapStyle()) {
	    case BufferParameters.CAP_ROUND:
	      segGen.createCircle(pt);
	      break
	    case BufferParameters.CAP_SQUARE:
	      segGen.createSquare(pt);
	      break
	  }
	};
	OffsetCurveBuilder.prototype.getLineCurve = function getLineCurve (inputPts, distance) {
	  this._distance = distance;
	  if (distance < 0.0 && !this._bufParams.isSingleSided()) { return null }
	  if (distance === 0.0) { return null }
	  var posDistance = Math.abs(distance);
	  var segGen = this.getSegGen(posDistance);
	  if (inputPts.length <= 1) {
	    this.computePointCurve(inputPts[0], segGen);
	  } else {
	    if (this._bufParams.isSingleSided()) {
	      var isRightSide = distance < 0.0;
	      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
	    } else { this.computeLineBufferCurve(inputPts, segGen); }
	  }
	  var lineCoord = segGen.getCoordinates();
	  return lineCoord
	};
	OffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters () {
	  return this._bufParams
	};
	OffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance (bufDistance) {
	  return bufDistance * this._bufParams.getSimplifyFactor()
	};
	OffsetCurveBuilder.prototype.getRingCurve = function getRingCurve (inputPts, side, distance) {
	  this._distance = distance;
	  if (inputPts.length <= 2) { return this.getLineCurve(inputPts, distance) }
	  if (distance === 0.0) {
	    return OffsetCurveBuilder.copyCoordinates(inputPts)
	  }
	  var segGen = this.getSegGen(distance);
	  this.computeRingBufferCurve(inputPts, side, segGen);
	  return segGen.getCoordinates()
	};
	OffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve (inputPts, isRightSide, segGen) {
	  var distTol = this.simplifyTolerance(this._distance);
	  if (isRightSide) {
	    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
	    var n2 = simp2.length - 1;
	    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position$1.LEFT);
	    segGen.addFirstSegment();
	    for (var i = n2 - 2; i >= 0; i--) {
	      segGen.addNextSegment(simp2[i], true);
	    }
	  } else {
	    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
	    var n1 = simp1.length - 1;
	    segGen.initSideSegments(simp1[0], simp1[1], Position$1.LEFT);
	    segGen.addFirstSegment();
	    for (var i$1 = 2; i$1 <= n1; i$1++) {
	      segGen.addNextSegment(simp1[i$1], true);
	    }
	  }
	  segGen.addLastSegment();
	};
	OffsetCurveBuilder.prototype.getSegGen = function getSegGen (distance) {
	  return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)
	};
	OffsetCurveBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	OffsetCurveBuilder.prototype.getClass = function getClass () {
	  return OffsetCurveBuilder
	};
	OffsetCurveBuilder.copyCoordinates = function copyCoordinates (pts) {
	  var copy = new Array(pts.length).fill(null);
	  for (var i = 0; i < copy.length; i++) {
	    copy[i] = new Coordinate(pts[i]);
	  }
	  return copy
	};

	var SubgraphDepthLocater = function SubgraphDepthLocater () {
	  this._subgraphs = null;
	  this._seg = new LineSegment();
	  this._cga = new CGAlgorithms();
	  var subgraphs = arguments[0];
	  this._subgraphs = subgraphs;
	};

	var staticAccessors$30 = { DepthSegment: { configurable: true } };
	SubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments () {
	    var this$1$1 = this;

	  if (arguments.length === 1) {
	    var stabbingRayLeftPt = arguments[0];
	    var stabbedSegments = new ArrayList();
	    for (var i = this._subgraphs.iterator(); i.hasNext();) {
	      var bsg = i.next();
	      var env = bsg.getEnvelope();
	      if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) { continue }
	      this$1$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
	    }
	    return stabbedSegments
	  } else if (arguments.length === 3) {
	    if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
	      var stabbingRayLeftPt$1 = arguments[0];
	      var dirEdge = arguments[1];
	      var stabbedSegments$1 = arguments[2];
	      var pts = dirEdge.getEdge().getCoordinates();
	      for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {
	        this$1$1._seg.p0 = pts[i$1];
	        this$1$1._seg.p1 = pts[i$1 + 1];
	        if (this$1$1._seg.p0.y > this$1$1._seg.p1.y) { this$1$1._seg.reverse(); }
	        var maxx = Math.max(this$1$1._seg.p0.x, this$1$1._seg.p1.x);
	        if (maxx < stabbingRayLeftPt$1.x) { continue }
	        if (this$1$1._seg.isHorizontal()) { continue }
	        if (stabbingRayLeftPt$1.y < this$1$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1$1._seg.p1.y) { continue }
	        if (CGAlgorithms.computeOrientation(this$1$1._seg.p0, this$1$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) { continue }
	        var depth = dirEdge.getDepth(Position$1.LEFT);
	        if (!this$1$1._seg.p0.equals(pts[i$1])) { depth = dirEdge.getDepth(Position$1.RIGHT); }
	        var ds = new DepthSegment(this$1$1._seg, depth);
	        stabbedSegments$1.add(ds);
	      }
	    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
	      var stabbingRayLeftPt$2 = arguments[0];
	      var dirEdges = arguments[1];
	      var stabbedSegments$2 = arguments[2];
	      for (var i$2 = dirEdges.iterator(); i$2.hasNext();) {
	        var de = i$2.next();
	        if (!de.isForward()) { continue }
	        this$1$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);
	      }
	    }
	  }
	};
	SubgraphDepthLocater.prototype.getDepth = function getDepth (p) {
	  var stabbedSegments = this.findStabbedSegments(p);
	  if (stabbedSegments.size() === 0) { return 0 }
	  var ds = Collections.min(stabbedSegments);
	  return ds._leftDepth
	};
	SubgraphDepthLocater.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SubgraphDepthLocater.prototype.getClass = function getClass () {
	  return SubgraphDepthLocater
	};
	staticAccessors$30.DepthSegment.get = function () { return DepthSegment };

	Object.defineProperties( SubgraphDepthLocater, staticAccessors$30 );

	var DepthSegment = function DepthSegment () {
	  this._upwardSeg = null;
	  this._leftDepth = null;
	  var seg = arguments[0];
	  var depth = arguments[1];
	  this._upwardSeg = new LineSegment(seg);
	  this._leftDepth = depth;
	};
	DepthSegment.prototype.compareTo = function compareTo (obj) {
	  var other = obj;
	  if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) { return 1 }
	  if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) { return -1 }
	  var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
	  if (orientIndex !== 0) { return orientIndex }
	  orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
	  if (orientIndex !== 0) { return orientIndex }
	  return this._upwardSeg.compareTo(other._upwardSeg)
	};
	DepthSegment.prototype.compareX = function compareX (seg0, seg1) {
	  var compare0 = seg0.p0.compareTo(seg1.p0);
	  if (compare0 !== 0) { return compare0 }
	  return seg0.p1.compareTo(seg1.p1)
	};
	DepthSegment.prototype.toString = function toString () {
	  return this._upwardSeg.toString()
	};
	DepthSegment.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	DepthSegment.prototype.getClass = function getClass () {
	  return DepthSegment
	};

	var Triangle$1 = function Triangle (p0, p1, p2) {
	  this.p0 = p0 || null;
	  this.p1 = p1 || null;
	  this.p2 = p2 || null;
	};
	Triangle$1.prototype.area = function area () {
	  return Triangle$1.area(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.signedArea = function signedArea () {
	  return Triangle$1.signedArea(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.interpolateZ = function interpolateZ (p) {
	  if (p === null) { throw new IllegalArgumentException() }
	  return Triangle$1.interpolateZ(p, this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.longestSideLength = function longestSideLength () {
	  return Triangle$1.longestSideLength(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.isAcute = function isAcute () {
	  return Triangle$1.isAcute(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.circumcentre = function circumcentre () {
	  return Triangle$1.circumcentre(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.area3D = function area3D () {
	  return Triangle$1.area3D(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.centroid = function centroid () {
	  return Triangle$1.centroid(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.inCentre = function inCentre () {
	  return Triangle$1.inCentre(this.p0, this.p1, this.p2)
	};
	Triangle$1.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Triangle$1.prototype.getClass = function getClass () {
	  return Triangle$1
	};
	Triangle$1.area = function area (a, b, c) {
	  return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)
	};
	Triangle$1.signedArea = function signedArea (a, b, c) {
	  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2
	};
	Triangle$1.det = function det (m00, m01, m10, m11) {
	  return m00 * m11 - m01 * m10
	};
	Triangle$1.interpolateZ = function interpolateZ (p, v0, v1, v2) {
	  var x0 = v0.x;
	  var y0 = v0.y;
	  var a = v1.x - x0;
	  var b = v2.x - x0;
	  var c = v1.y - y0;
	  var d = v2.y - y0;
	  var det = a * d - b * c;
	  var dx = p.x - x0;
	  var dy = p.y - y0;
	  var t = (d * dx - b * dy) / det;
	  var u = (-c * dx + a * dy) / det;
	  var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
	  return z
	};
	Triangle$1.longestSideLength = function longestSideLength (a, b, c) {
	  var lenAB = a.distance(b);
	  var lenBC = b.distance(c);
	  var lenCA = c.distance(a);
	  var maxLen = lenAB;
	  if (lenBC > maxLen) { maxLen = lenBC; }
	  if (lenCA > maxLen) { maxLen = lenCA; }
	  return maxLen
	};
	Triangle$1.isAcute = function isAcute (a, b, c) {
	  if (!Angle.isAcute(a, b, c)) { return false }
	  if (!Angle.isAcute(b, c, a)) { return false }
	  if (!Angle.isAcute(c, a, b)) { return false }
	  return true
	};
	Triangle$1.circumcentre = function circumcentre (a, b, c) {
	  var cx = c.x;
	  var cy = c.y;
	  var ax = a.x - cx;
	  var ay = a.y - cy;
	  var bx = b.x - cx;
	  var by = b.y - cy;
	  var denom = 2 * Triangle$1.det(ax, ay, bx, by);
	  var numx = Triangle$1.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
	  var numy = Triangle$1.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
	  var ccx = cx - numx / denom;
	  var ccy = cy + numy / denom;
	  return new Coordinate(ccx, ccy)
	};
	Triangle$1.perpendicularBisector = function perpendicularBisector (a, b) {
	  var dx = b.x - a.x;
	  var dy = b.y - a.y;
	  var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
	  var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
	  return new HCoordinate(l1, l2)
	};
	Triangle$1.angleBisector = function angleBisector (a, b, c) {
	  var len0 = b.distance(a);
	  var len2 = b.distance(c);
	  var frac = len0 / (len0 + len2);
	  var dx = c.x - a.x;
	  var dy = c.y - a.y;
	  var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
	  return splitPt
	};
	Triangle$1.area3D = function area3D (a, b, c) {
	  var ux = b.x - a.x;
	  var uy = b.y - a.y;
	  var uz = b.z - a.z;
	  var vx = c.x - a.x;
	  var vy = c.y - a.y;
	  var vz = c.z - a.z;
	  var crossx = uy * vz - uz * vy;
	  var crossy = uz * vx - ux * vz;
	  var crossz = ux * vy - uy * vx;
	  var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
	  var area3D = Math.sqrt(absSq) / 2;
	  return area3D
	};
	Triangle$1.centroid = function centroid (a, b, c) {
	  var x = (a.x + b.x + c.x) / 3;
	  var y = (a.y + b.y + c.y) / 3;
	  return new Coordinate(x, y)
	};
	Triangle$1.inCentre = function inCentre (a, b, c) {
	  var len0 = b.distance(c);
	  var len1 = a.distance(c);
	  var len2 = a.distance(b);
	  var circum = len0 + len1 + len2;
	  var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
	  var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
	  return new Coordinate(inCentreX, inCentreY)
	};

	var OffsetCurveSetBuilder = function OffsetCurveSetBuilder () {
	  this._inputGeom = null;
	  this._distance = null;
	  this._curveBuilder = null;
	  this._curveList = new ArrayList();
	  var inputGeom = arguments[0];
	  var distance = arguments[1];
	  var curveBuilder = arguments[2];
	  this._inputGeom = inputGeom;
	  this._distance = distance;
	  this._curveBuilder = curveBuilder;
	};
	OffsetCurveSetBuilder.prototype.addPoint = function addPoint (p) {
	  if (this._distance <= 0.0) { return null }
	  var coord = p.getCoordinates();
	  var curve = this._curveBuilder.getLineCurve(coord, this._distance);
	  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
	};
	OffsetCurveSetBuilder.prototype.addPolygon = function addPolygon (p) {
	    var this$1$1 = this;

	  var offsetDistance = this._distance;
	  var offsetSide = Position$1.LEFT;
	  if (this._distance < 0.0) {
	    offsetDistance = -this._distance;
	    offsetSide = Position$1.RIGHT;
	  }
	  var shell = p.getExteriorRing();
	  var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
	  if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) { return null }
	  if (this._distance <= 0.0 && shellCoord.length < 3) { return null }
	  this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
	  for (var i = 0; i < p.getNumInteriorRing(); i++) {
	    var hole = p.getInteriorRingN(i);
	    var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
	    if (this$1$1._distance > 0.0 && this$1$1.isErodedCompletely(hole, -this$1$1._distance)) { continue }
	    this$1$1.addPolygonRing(holeCoord, offsetDistance, Position$1.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
	  }
	};
	OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely (triangleCoord, bufferDistance) {
	  var tri = new Triangle$1(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
	  var inCentre = tri.inCentre();
	  var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);
	  return distToCentre < Math.abs(bufferDistance)
	};
	OffsetCurveSetBuilder.prototype.addLineString = function addLineString (line) {
	  if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) { return null }
	  var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
	  var curve = this._curveBuilder.getLineCurve(coord, this._distance);
	  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
	};
	OffsetCurveSetBuilder.prototype.addCurve = function addCurve (coord, leftLoc, rightLoc) {
	  if (coord === null || coord.length < 2) { return null }
	  var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
	  this._curveList.add(e);
	};
	OffsetCurveSetBuilder.prototype.getCurves = function getCurves () {
	  this.add(this._inputGeom);
	  return this._curveList
	};
	OffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
	  if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) { return null }
	  var leftLoc = cwLeftLoc;
	  var rightLoc = cwRightLoc;
	  if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
	    leftLoc = cwRightLoc;
	    rightLoc = cwLeftLoc;
	    side = Position$1.opposite(side);
	  }
	  var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
	  this.addCurve(curve, leftLoc, rightLoc);
	};
	OffsetCurveSetBuilder.prototype.add = function add (g) {
	  if (g.isEmpty()) { return null }
	  if (g instanceof Polygon) { this.addPolygon(g); }
	  else if (g instanceof LineString$1) { this.addLineString(g); }
	  else if (g instanceof Point) { this.addPoint(g); }
	  else if (g instanceof MultiPoint) { this.addCollection(g); }
	  else if (g instanceof MultiLineString) { this.addCollection(g); }
	  else if (g instanceof MultiPolygon) { this.addCollection(g); }
	  else if (g instanceof GeometryCollection) { this.addCollection(g); }
	  // else throw new UnsupportedOperationException(g.getClass().getName())
	};
	OffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely (ring, bufferDistance) {
	  var ringCoord = ring.getCoordinates();
	  // const minDiam = 0.0
	  if (ringCoord.length < 4) { return bufferDistance < 0 }
	  if (ringCoord.length === 4) { return this.isTriangleErodedCompletely(ringCoord, bufferDistance) }
	  var env = ring.getEnvelopeInternal();
	  var envMinDimension = Math.min(env.getHeight(), env.getWidth());
	  if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) { return true }
	  return false
	};
	OffsetCurveSetBuilder.prototype.addCollection = function addCollection (gc) {
	    var this$1$1 = this;

	  for (var i = 0; i < gc.getNumGeometries(); i++) {
	    var g = gc.getGeometryN(i);
	    this$1$1.add(g);
	  }
	};
	OffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	OffsetCurveSetBuilder.prototype.getClass = function getClass () {
	  return OffsetCurveSetBuilder
	};

	var PointOnGeometryLocator = function PointOnGeometryLocator () {};

	PointOnGeometryLocator.prototype.locate = function locate (p) {};
	PointOnGeometryLocator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PointOnGeometryLocator.prototype.getClass = function getClass () {
	  return PointOnGeometryLocator
	};

	var GeometryCollectionIterator = function GeometryCollectionIterator () {
	  this._parent = null;
	  this._atStart = null;
	  this._max = null;
	  this._index = null;
	  this._subcollectionIterator = null;
	  var parent = arguments[0];
	  this._parent = parent;
	  this._atStart = true;
	  this._index = 0;
	  this._max = parent.getNumGeometries();
	};
	GeometryCollectionIterator.prototype.next = function next () {
	  if (this._atStart) {
	    this._atStart = false;
	    if (GeometryCollectionIterator.isAtomic(this._parent)) { this._index++; }
	    return this._parent
	  }
	  if (this._subcollectionIterator !== null) {
	    if (this._subcollectionIterator.hasNext()) {
	      return this._subcollectionIterator.next()
	    } else {
	      this._subcollectionIterator = null;
	    }
	  }
	  if (this._index >= this._max) {
	    throw new NoSuchElementException()
	  }
	  var obj = this._parent.getGeometryN(this._index++);
	  if (obj instanceof GeometryCollection) {
	    this._subcollectionIterator = new GeometryCollectionIterator(obj);
	    return this._subcollectionIterator.next()
	  }
	  return obj
	};
	GeometryCollectionIterator.prototype.remove = function remove () {
	  throw new Error(this.getClass().getName())
	};
	GeometryCollectionIterator.prototype.hasNext = function hasNext () {
	  if (this._atStart) {
	    return true
	  }
	  if (this._subcollectionIterator !== null) {
	    if (this._subcollectionIterator.hasNext()) {
	      return true
	    }
	    this._subcollectionIterator = null;
	  }
	  if (this._index >= this._max) {
	    return false
	  }
	  return true
	};
	GeometryCollectionIterator.prototype.interfaces_ = function interfaces_ () {
	  return [Iterator]
	};
	GeometryCollectionIterator.prototype.getClass = function getClass () {
	  return GeometryCollectionIterator
	};
	GeometryCollectionIterator.isAtomic = function isAtomic (geom) {
	  return !(geom instanceof GeometryCollection)
	};

	var SimplePointInAreaLocator = function SimplePointInAreaLocator () {
	  this._geom = null;
	  var geom = arguments[0];
	  this._geom = geom;
	};
	SimplePointInAreaLocator.prototype.locate = function locate (p) {
	  return SimplePointInAreaLocator.locate(p, this._geom)
	};
	SimplePointInAreaLocator.prototype.interfaces_ = function interfaces_ () {
	  return [PointOnGeometryLocator]
	};
	SimplePointInAreaLocator.prototype.getClass = function getClass () {
	  return SimplePointInAreaLocator
	};
	SimplePointInAreaLocator.isPointInRing = function isPointInRing (p, ring) {
	  if (!ring.getEnvelopeInternal().intersects(p)) { return false }
	  return CGAlgorithms.isPointInRing(p, ring.getCoordinates())
	};
	SimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon (p, poly) {
	  if (poly.isEmpty()) { return false }
	  var shell = poly.getExteriorRing();
	  if (!SimplePointInAreaLocator.isPointInRing(p, shell)) { return false }
	  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
	    var hole = poly.getInteriorRingN(i);
	    if (SimplePointInAreaLocator.isPointInRing(p, hole)) { return false }
	  }
	  return true
	};
	SimplePointInAreaLocator.containsPoint = function containsPoint (p, geom) {
	  if (geom instanceof Polygon) {
	    return SimplePointInAreaLocator.containsPointInPolygon(p, geom)
	  } else if (geom instanceof GeometryCollection) {
	    var geomi = new GeometryCollectionIterator(geom);
	    while (geomi.hasNext()) {
	      var g2 = geomi.next();
	      if (g2 !== geom) { if (SimplePointInAreaLocator.containsPoint(p, g2)) { return true } }
	    }
	  }
	  return false
	};
	SimplePointInAreaLocator.locate = function locate (p, geom) {
	  if (geom.isEmpty()) { return Location.EXTERIOR }
	  if (SimplePointInAreaLocator.containsPoint(p, geom)) { return Location.INTERIOR }
	  return Location.EXTERIOR
	};

	var EdgeEndStar = function EdgeEndStar () {
	  this._edgeMap = new TreeMap();
	  this._edgeList = null;
	  this._ptInAreaLocation = [Location.NONE, Location.NONE];
	};
	EdgeEndStar.prototype.getNextCW = function getNextCW (ee) {
	  this.getEdges();
	  var i = this._edgeList.indexOf(ee);
	  var iNextCW = i - 1;
	  if (i === 0) { iNextCW = this._edgeList.size() - 1; }
	  return this._edgeList.get(iNextCW)
	};
	EdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels (geomIndex) {
	  var startLoc = Location.NONE;
	  for (var it = this.iterator(); it.hasNext();) {
	    var e = it.next();
	    var label = e.getLabel();
	    if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position$1.LEFT) !== Location.NONE) { startLoc = label.getLocation(geomIndex, Position$1.LEFT); }
	  }
	  if (startLoc === Location.NONE) { return null }
	  var currLoc = startLoc;
	  for (var it$1 = this.iterator(); it$1.hasNext();) {
	    var e$1 = it$1.next();
	    var label$1 = e$1.getLabel();
	    if (label$1.getLocation(geomIndex, Position$1.ON) === Location.NONE) { label$1.setLocation(geomIndex, Position$1.ON, currLoc); }
	    if (label$1.isArea(geomIndex)) {
	      var leftLoc = label$1.getLocation(geomIndex, Position$1.LEFT);
	      var rightLoc = label$1.getLocation(geomIndex, Position$1.RIGHT);
	      if (rightLoc !== Location.NONE) {
	        if (rightLoc !== currLoc) { throw new TopologyException('side location conflict', e$1.getCoordinate()) }
	        if (leftLoc === Location.NONE) {
	          Assert.shouldNeverReachHere('found single null side (at ' + e$1.getCoordinate() + ')');
	        }
	        currLoc = leftLoc;
	      } else {
	        Assert.isTrue(label$1.getLocation(geomIndex, Position$1.LEFT) === Location.NONE, 'found single null side');
	        label$1.setLocation(geomIndex, Position$1.RIGHT, currLoc);
	        label$1.setLocation(geomIndex, Position$1.LEFT, currLoc);
	      }
	    }
	  }
	};
	EdgeEndStar.prototype.getCoordinate = function getCoordinate () {
	  var it = this.iterator();
	  if (!it.hasNext()) { return null }
	  var e = it.next();
	  return e.getCoordinate()
	};
	EdgeEndStar.prototype.print = function print (out) {
	  System.out.println('EdgeEndStar:   ' + this.getCoordinate());
	  for (var it = this.iterator(); it.hasNext();) {
	    var e = it.next();
	    e.print(out);
	  }
	};
	EdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent (geomGraph) {
	  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
	  return this.checkAreaLabelsConsistent(0)
	};
	EdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent (geomIndex) {
	  var edges = this.getEdges();
	  if (edges.size() <= 0) { return true }
	  var lastEdgeIndex = edges.size() - 1;
	  var startLabel = edges.get(lastEdgeIndex).getLabel();
	  var startLoc = startLabel.getLocation(geomIndex, Position$1.LEFT);
	  Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');
	  var currLoc = startLoc;
	  for (var it = this.iterator(); it.hasNext();) {
	    var e = it.next();
	    var label = e.getLabel();
	    Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');
	    var leftLoc = label.getLocation(geomIndex, Position$1.LEFT);
	    var rightLoc = label.getLocation(geomIndex, Position$1.RIGHT);
	    if (leftLoc === rightLoc) {
	      return false
	    }
	    if (rightLoc !== currLoc) {
	      return false
	    }
	    currLoc = leftLoc;
	  }
	  return true
	};
	EdgeEndStar.prototype.findIndex = function findIndex (eSearch) {
	    var this$1$1 = this;

	  this.iterator();
	  for (var i = 0; i < this._edgeList.size(); i++) {
	    var e = this$1$1._edgeList.get(i);
	    if (e === eSearch) { return i }
	  }
	  return -1
	};
	EdgeEndStar.prototype.iterator = function iterator () {
	  return this.getEdges().iterator()
	};
	EdgeEndStar.prototype.getEdges = function getEdges () {
	  if (this._edgeList === null) {
	    this._edgeList = new ArrayList(this._edgeMap.values());
	  }
	  return this._edgeList
	};
	EdgeEndStar.prototype.getLocation = function getLocation (geomIndex, p, geom) {
	  if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
	    this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
	  }
	  return this._ptInAreaLocation[geomIndex]
	};
	EdgeEndStar.prototype.toString = function toString () {
	  var buf = new StringBuffer();
	  buf.append('EdgeEndStar:   ' + this.getCoordinate());
	  buf.append('\n');
	  for (var it = this.iterator(); it.hasNext();) {
	    var e = it.next();
	    buf.append(e);
	    buf.append('\n');
	  }
	  return buf.toString()
	};
	EdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels (boundaryNodeRule) {
	  for (var it = this.iterator(); it.hasNext();) {
	    var ee = it.next();
	    ee.computeLabel(boundaryNodeRule);
	  }
	};
	EdgeEndStar.prototype.computeLabelling = function computeLabelling (geomGraph) {
	    var this$1$1 = this;

	  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
	  this.propagateSideLabels(0);
	  this.propagateSideLabels(1);
	  var hasDimensionalCollapseEdge = [false, false];
	  for (var it = this.iterator(); it.hasNext();) {
	    var e = it.next();
	    var label = e.getLabel();
	    for (var geomi = 0; geomi < 2; geomi++) {
	      if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) { hasDimensionalCollapseEdge[geomi] = true; }
	    }
	  }
	  for (var it$1 = this.iterator(); it$1.hasNext();) {
	    var e$1 = it$1.next();
	    var label$1 = e$1.getLabel();
	    for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {
	      if (label$1.isAnyNull(geomi$1)) {
	        var loc = Location.NONE;
	        if (hasDimensionalCollapseEdge[geomi$1]) {
	          loc = Location.EXTERIOR;
	        } else {
	          var p = e$1.getCoordinate();
	          loc = this$1$1.getLocation(geomi$1, p, geomGraph);
	        }
	        label$1.setAllLocationsIfNull(geomi$1, loc);
	      }
	    }
	  }
	};
	EdgeEndStar.prototype.getDegree = function getDegree () {
	  return this._edgeMap.size()
	};
	EdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd (e, obj) {
	  this._edgeMap.put(e, obj);
	  this._edgeList = null;
	};
	EdgeEndStar.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	EdgeEndStar.prototype.getClass = function getClass () {
	  return EdgeEndStar
	};

	var DirectedEdgeStar = (function (EdgeEndStar$$1) {
	  function DirectedEdgeStar () {
	    EdgeEndStar$$1.call(this);
	    this._resultAreaEdgeList = null;
	    this._label = null;
	    this._SCANNING_FOR_INCOMING = 1;
	    this._LINKING_TO_OUTGOING = 2;
	  }

	  if ( EdgeEndStar$$1 ) DirectedEdgeStar.__proto__ = EdgeEndStar$$1;
	  DirectedEdgeStar.prototype = Object.create( EdgeEndStar$$1 && EdgeEndStar$$1.prototype );
	  DirectedEdgeStar.prototype.constructor = DirectedEdgeStar;
	  DirectedEdgeStar.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {
	    var this$1$1 = this;

	    this.getResultAreaEdges();
	    var firstOut = null;
	    var incoming = null;
	    var state = this._SCANNING_FOR_INCOMING;
	    for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
	      var nextOut = this$1$1._resultAreaEdgeList.get(i);
	      var nextIn = nextOut.getSym();
	      if (!nextOut.getLabel().isArea()) { continue }
	      if (firstOut === null && nextOut.isInResult()) { firstOut = nextOut; }
	      switch (state) {
	        case this$1$1._SCANNING_FOR_INCOMING:
	          if (!nextIn.isInResult()) { continue }
	          incoming = nextIn;
	          state = this$1$1._LINKING_TO_OUTGOING;
	          break
	        case this$1$1._LINKING_TO_OUTGOING:
	          if (!nextOut.isInResult()) { continue }
	          incoming.setNext(nextOut);
	          state = this$1$1._SCANNING_FOR_INCOMING;
	          break
	      }
	    }
	    if (state === this._LINKING_TO_OUTGOING) {
	      if (firstOut === null) { throw new TopologyException('no outgoing dirEdge found', this.getCoordinate()) }
	      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
	      incoming.setNext(firstOut);
	    }
	  };
	  DirectedEdgeStar.prototype.insert = function insert (ee) {
	    var de = ee;
	    this.insertEdgeEnd(de, de);
	  };
	  DirectedEdgeStar.prototype.getRightmostEdge = function getRightmostEdge () {
	    var edges = this.getEdges();
	    var size = edges.size();
	    if (size < 1) { return null }
	    var de0 = edges.get(0);
	    if (size === 1) { return de0 }
	    var deLast = edges.get(size - 1);
	    var quad0 = de0.getQuadrant();
	    var quad1 = deLast.getQuadrant();
	    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) { return de0; } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) { return deLast; } else {
	      // const nonHorizontalEdge = null
	      if (de0.getDy() !== 0) { return de0; } else if (deLast.getDy() !== 0) { return deLast }
	    }
	    Assert.shouldNeverReachHere('found two horizontal edges incident on node');
	    return null
	  };
	  DirectedEdgeStar.prototype.print = function print (out) {
	    System.out.println('DirectedEdgeStar: ' + this.getCoordinate());
	    for (var it = this.iterator(); it.hasNext();) {
	      var de = it.next();
	      out.print('out ');
	      de.print(out);
	      out.println();
	      out.print('in ');
	      de.getSym().print(out);
	      out.println();
	    }
	  };
	  DirectedEdgeStar.prototype.getResultAreaEdges = function getResultAreaEdges () {
	    var this$1$1 = this;

	    if (this._resultAreaEdgeList !== null) { return this._resultAreaEdgeList }
	    this._resultAreaEdgeList = new ArrayList();
	    for (var it = this.iterator(); it.hasNext();) {
	      var de = it.next();
	      if (de.isInResult() || de.getSym().isInResult()) { this$1$1._resultAreaEdgeList.add(de); }
	    }
	    return this._resultAreaEdgeList
	  };
	  DirectedEdgeStar.prototype.updateLabelling = function updateLabelling (nodeLabel) {
	    for (var it = this.iterator(); it.hasNext();) {
	      var de = it.next();
	      var label = de.getLabel();
	      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
	      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
	    }
	  };
	  DirectedEdgeStar.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {
	    var this$1$1 = this;

	    this.getEdges();
	    var prevOut = null;
	    var firstIn = null;
	    for (var i = this._edgeList.size() - 1; i >= 0; i--) {
	      var nextOut = this$1$1._edgeList.get(i);
	      var nextIn = nextOut.getSym();
	      if (firstIn === null) { firstIn = nextIn; }
	      if (prevOut !== null) { nextIn.setNext(prevOut); }
	      prevOut = nextOut;
	    }
	    firstIn.setNext(prevOut);
	  };
	  DirectedEdgeStar.prototype.computeDepths = function computeDepths () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var de = arguments[0];
	      var edgeIndex = this.findIndex(de);
	      // const label = de.getLabel()
	      var startDepth = de.getDepth(Position$1.LEFT);
	      var targetLastDepth = de.getDepth(Position$1.RIGHT);
	      var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
	      var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
	      if (lastDepth !== targetLastDepth) { throw new TopologyException('depth mismatch at ' + de.getCoordinate()) }
	    } else if (arguments.length === 3) {
	      var startIndex = arguments[0];
	      var endIndex = arguments[1];
	      var startDepth$1 = arguments[2];
	      var currDepth = startDepth$1;
	      for (var i = startIndex; i < endIndex; i++) {
	        var nextDe = this$1$1._edgeList.get(i);
	        // const label = nextDe.getLabel()
	        nextDe.setEdgeDepths(Position$1.RIGHT, currDepth);
	        currDepth = nextDe.getDepth(Position$1.LEFT);
	      }
	      return currDepth
	    }
	  };
	  DirectedEdgeStar.prototype.mergeSymLabels = function mergeSymLabels () {
	    for (var it = this.iterator(); it.hasNext();) {
	      var de = it.next();
	      var label = de.getLabel();
	      label.merge(de.getSym().getLabel());
	    }
	  };
	  DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges (er) {
	    var this$1$1 = this;

	    var firstOut = null;
	    var incoming = null;
	    var state = this._SCANNING_FOR_INCOMING;
	    for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
	      var nextOut = this$1$1._resultAreaEdgeList.get(i);
	      var nextIn = nextOut.getSym();
	      if (firstOut === null && nextOut.getEdgeRing() === er) { firstOut = nextOut; }
	      switch (state) {
	        case this$1$1._SCANNING_FOR_INCOMING:
	          if (nextIn.getEdgeRing() !== er) { continue }
	          incoming = nextIn;
	          state = this$1$1._LINKING_TO_OUTGOING;
	          break
	        case this$1$1._LINKING_TO_OUTGOING:
	          if (nextOut.getEdgeRing() !== er) { continue }
	          incoming.setNextMin(nextOut);
	          state = this$1$1._SCANNING_FOR_INCOMING;
	          break
	      }
	    }
	    if (state === this._LINKING_TO_OUTGOING) {
	      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
	      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
	      incoming.setNextMin(firstOut);
	    }
	  };
	  DirectedEdgeStar.prototype.getOutgoingDegree = function getOutgoingDegree () {
	    if (arguments.length === 0) {
	      var degree = 0;
	      for (var it = this.iterator(); it.hasNext();) {
	        var de = it.next();
	        if (de.isInResult()) { degree++; }
	      }
	      return degree
	    } else if (arguments.length === 1) {
	      var er = arguments[0];
	      var degree$1 = 0;
	      for (var it$1 = this.iterator(); it$1.hasNext();) {
	        var de$1 = it$1.next();
	        if (de$1.getEdgeRing() === er) { degree$1++; }
	      }
	      return degree$1
	    }
	  };
	  DirectedEdgeStar.prototype.getLabel = function getLabel () {
	    return this._label
	  };
	  DirectedEdgeStar.prototype.findCoveredLineEdges = function findCoveredLineEdges () {
	    var startLoc = Location.NONE;
	    for (var it = this.iterator(); it.hasNext();) {
	      var nextOut = it.next();
	      var nextIn = nextOut.getSym();
	      if (!nextOut.isLineEdge()) {
	        if (nextOut.isInResult()) {
	          startLoc = Location.INTERIOR;
	          break
	        }
	        if (nextIn.isInResult()) {
	          startLoc = Location.EXTERIOR;
	          break
	        }
	      }
	    }
	    if (startLoc === Location.NONE) { return null }
	    var currLoc = startLoc;
	    for (var it$1 = this.iterator(); it$1.hasNext();) {
	      var nextOut$1 = it$1.next();
	      var nextIn$1 = nextOut$1.getSym();
	      if (nextOut$1.isLineEdge()) {
	        nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);
	      } else {
	        if (nextOut$1.isInResult()) { currLoc = Location.EXTERIOR; }
	        if (nextIn$1.isInResult()) { currLoc = Location.INTERIOR; }
	      }
	    }
	  };
	  DirectedEdgeStar.prototype.computeLabelling = function computeLabelling (geom) {
	    var this$1$1 = this;

	    EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);
	    this._label = new Label(Location.NONE);
	    for (var it = this.iterator(); it.hasNext();) {
	      var ee = it.next();
	      var e = ee.getEdge();
	      var eLabel = e.getLabel();
	      for (var i = 0; i < 2; i++) {
	        var eLoc = eLabel.getLocation(i);
	        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) { this$1$1._label.setLocation(i, Location.INTERIOR); }
	      }
	    }
	  };
	  DirectedEdgeStar.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  DirectedEdgeStar.prototype.getClass = function getClass () {
	    return DirectedEdgeStar
	  };

	  return DirectedEdgeStar;
	}(EdgeEndStar));

	var OverlayNodeFactory = (function (NodeFactory$$1) {
	  function OverlayNodeFactory () {
	    NodeFactory$$1.apply(this, arguments);
	  }

	  if ( NodeFactory$$1 ) OverlayNodeFactory.__proto__ = NodeFactory$$1;
	  OverlayNodeFactory.prototype = Object.create( NodeFactory$$1 && NodeFactory$$1.prototype );
	  OverlayNodeFactory.prototype.constructor = OverlayNodeFactory;

	  OverlayNodeFactory.prototype.createNode = function createNode (coord) {
	    return new Node$2(coord, new DirectedEdgeStar())
	  };
	  OverlayNodeFactory.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  OverlayNodeFactory.prototype.getClass = function getClass () {
	    return OverlayNodeFactory
	  };

	  return OverlayNodeFactory;
	}(NodeFactory));

	var OrientedCoordinateArray = function OrientedCoordinateArray () {
	  this._pts = null;
	  this._orientation = null;
	  var pts = arguments[0];
	  this._pts = pts;
	  this._orientation = OrientedCoordinateArray.orientation(pts);
	};
	OrientedCoordinateArray.prototype.compareTo = function compareTo (o1) {
	  var oca = o1;
	  var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
	  return comp
	};
	OrientedCoordinateArray.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	OrientedCoordinateArray.prototype.getClass = function getClass () {
	  return OrientedCoordinateArray
	};
	OrientedCoordinateArray.orientation = function orientation (pts) {
	  return CoordinateArrays.increasingDirection(pts) === 1
	};
	OrientedCoordinateArray.compareOriented = function compareOriented (pts1, orientation1, pts2, orientation2) {
	  var dir1 = orientation1 ? 1 : -1;
	  var dir2 = orientation2 ? 1 : -1;
	  var limit1 = orientation1 ? pts1.length : -1;
	  var limit2 = orientation2 ? pts2.length : -1;
	  var i1 = orientation1 ? 0 : pts1.length - 1;
	  var i2 = orientation2 ? 0 : pts2.length - 1;
	  // const comp = 0
	  while (true) {
	    var compPt = pts1[i1].compareTo(pts2[i2]);
	    if (compPt !== 0) { return compPt }
	    i1 += dir1;
	    i2 += dir2;
	    var done1 = i1 === limit1;
	    var done2 = i2 === limit2;
	    if (done1 && !done2) { return -1 }
	    if (!done1 && done2) { return 1 }
	    if (done1 && done2) { return 0 }
	  }
	};

	var EdgeList = function EdgeList () {
	  this._edges = new ArrayList();
	  this._ocaMap = new TreeMap();
	};
	EdgeList.prototype.print = function print (out) {
	    var this$1$1 = this;

	  out.print('MULTILINESTRING ( ');
	  for (var j = 0; j < this._edges.size(); j++) {
	    var e = this$1$1._edges.get(j);
	    if (j > 0) { out.print(','); }
	    out.print('(');
	    var pts = e.getCoordinates();
	    for (var i = 0; i < pts.length; i++) {
	      if (i > 0) { out.print(','); }
	      out.print(pts[i].x + ' ' + pts[i].y);
	    }
	    out.println(')');
	  }
	  out.print(')  ');
	};
	EdgeList.prototype.addAll = function addAll (edgeColl) {
	    var this$1$1 = this;

	  for (var i = edgeColl.iterator(); i.hasNext();) {
	    this$1$1.add(i.next());
	  }
	};
	EdgeList.prototype.findEdgeIndex = function findEdgeIndex (e) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._edges.size(); i++) {
	    if (this$1$1._edges.get(i).equals(e)) { return i }
	  }
	  return -1
	};
	EdgeList.prototype.iterator = function iterator () {
	  return this._edges.iterator()
	};
	EdgeList.prototype.getEdges = function getEdges () {
	  return this._edges
	};
	EdgeList.prototype.get = function get (i) {
	  return this._edges.get(i)
	};
	EdgeList.prototype.findEqualEdge = function findEqualEdge (e) {
	  var oca = new OrientedCoordinateArray(e.getCoordinates());
	  var matchEdge = this._ocaMap.get(oca);
	  return matchEdge
	};
	EdgeList.prototype.add = function add (e) {
	  this._edges.add(e);
	  var oca = new OrientedCoordinateArray(e.getCoordinates());
	  this._ocaMap.put(oca, e);
	};
	EdgeList.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	EdgeList.prototype.getClass = function getClass () {
	  return EdgeList
	};

	var SegmentIntersector = function SegmentIntersector () {};

	SegmentIntersector.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {};
	SegmentIntersector.prototype.isDone = function isDone () {};
	SegmentIntersector.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SegmentIntersector.prototype.getClass = function getClass () {
	  return SegmentIntersector
	};

	var IntersectionAdder = function IntersectionAdder () {
	  this._hasIntersection = false;
	  this._hasProper = false;
	  this._hasProperInterior = false;
	  this._hasInterior = false;
	  this._properIntersectionPoint = null;
	  this._li = null;
	  this._isSelfIntersection = null;
	  this.numIntersections = 0;
	  this.numInteriorIntersections = 0;
	  this.numProperIntersections = 0;
	  this.numTests = 0;
	  var li = arguments[0];
	  this._li = li;
	};
	IntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {
	  if (e0 === e1) {
	    if (this._li.getIntersectionNum() === 1) {
	      if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) { return true }
	      if (e0.isClosed()) {
	        var maxSegIndex = e0.size() - 1;
	        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
	            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {
	          return true
	        }
	      }
	    }
	  }
	  return false
	};
	IntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {
	  return this._properIntersectionPoint
	};
	IntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {
	  return this._hasProperInterior
	};
	IntersectionAdder.prototype.getLineIntersector = function getLineIntersector () {
	  return this._li
	};
	IntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection () {
	  return this._hasProper
	};
	IntersectionAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {
	  if (e0 === e1 && segIndex0 === segIndex1) { return null }
	  this.numTests++;
	  var p00 = e0.getCoordinates()[segIndex0];
	  var p01 = e0.getCoordinates()[segIndex0 + 1];
	  var p10 = e1.getCoordinates()[segIndex1];
	  var p11 = e1.getCoordinates()[segIndex1 + 1];
	  this._li.computeIntersection(p00, p01, p10, p11);
	  if (this._li.hasIntersection()) {
	    this.numIntersections++;
	    if (this._li.isInteriorIntersection()) {
	      this.numInteriorIntersections++;
	      this._hasInterior = true;
	    }
	    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
	      this._hasIntersection = true;
	      e0.addIntersections(this._li, segIndex0, 0);
	      e1.addIntersections(this._li, segIndex1, 1);
	      if (this._li.isProper()) {
	        this.numProperIntersections++;
	        this._hasProper = true;
	        this._hasProperInterior = true;
	      }
	    }
	  }
	};
	IntersectionAdder.prototype.hasIntersection = function hasIntersection () {
	  return this._hasIntersection
	};
	IntersectionAdder.prototype.isDone = function isDone () {
	  return false
	};
	IntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection () {
	  return this._hasInterior
	};
	IntersectionAdder.prototype.interfaces_ = function interfaces_ () {
	  return [SegmentIntersector]
	};
	IntersectionAdder.prototype.getClass = function getClass () {
	  return IntersectionAdder
	};
	IntersectionAdder.isAdjacentSegments = function isAdjacentSegments (i1, i2) {
	  return Math.abs(i1 - i2) === 1
	};

	var EdgeIntersection = function EdgeIntersection () {
	  this.coord = null;
	  this.segmentIndex = null;
	  this.dist = null;
	  var coord = arguments[0];
	  var segmentIndex = arguments[1];
	  var dist = arguments[2];
	  this.coord = new Coordinate(coord);
	  this.segmentIndex = segmentIndex;
	  this.dist = dist;
	};
	EdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex () {
	  return this.segmentIndex
	};
	EdgeIntersection.prototype.getCoordinate = function getCoordinate () {
	  return this.coord
	};
	EdgeIntersection.prototype.print = function print (out) {
	  out.print(this.coord);
	  out.print(' seg # = ' + this.segmentIndex);
	  out.println(' dist = ' + this.dist);
	};
	EdgeIntersection.prototype.compareTo = function compareTo (obj) {
	  var other = obj;
	  return this.compare(other.segmentIndex, other.dist)
	};
	EdgeIntersection.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {
	  if (this.segmentIndex === 0 && this.dist === 0.0) { return true }
	  if (this.segmentIndex === maxSegmentIndex) { return true }
	  return false
	};
	EdgeIntersection.prototype.toString = function toString () {
	  return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist
	};
	EdgeIntersection.prototype.getDistance = function getDistance () {
	  return this.dist
	};
	EdgeIntersection.prototype.compare = function compare (segmentIndex, dist) {
	  if (this.segmentIndex < segmentIndex) { return -1 }
	  if (this.segmentIndex > segmentIndex) { return 1 }
	  if (this.dist < dist) { return -1 }
	  if (this.dist > dist) { return 1 }
	  return 0
	};
	EdgeIntersection.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	EdgeIntersection.prototype.getClass = function getClass () {
	  return EdgeIntersection
	};

	var EdgeIntersectionList = function EdgeIntersectionList () {
	  this._nodeMap = new TreeMap();
	  this.edge = null;
	  var edge = arguments[0];
	  this.edge = edge;
	};
	EdgeIntersectionList.prototype.print = function print (out) {
	  out.println('Intersections:');
	  for (var it = this.iterator(); it.hasNext();) {
	    var ei = it.next();
	    ei.print(out);
	  }
	};
	EdgeIntersectionList.prototype.iterator = function iterator () {
	  return this._nodeMap.values().iterator()
	};
	EdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges (edgeList) {
	    var this$1$1 = this;

	  this.addEndpoints();
	  var it = this.iterator();
	  var eiPrev = it.next();
	  while (it.hasNext()) {
	    var ei = it.next();
	    var newEdge = this$1$1.createSplitEdge(eiPrev, ei);
	    edgeList.add(newEdge);
	    eiPrev = ei;
	  }
	};
	EdgeIntersectionList.prototype.addEndpoints = function addEndpoints () {
	  var maxSegIndex = this.edge.pts.length - 1;
	  this.add(this.edge.pts[0], 0, 0.0);
	  this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
	};
	EdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {
	    var this$1$1 = this;

	  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
	  var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
	  var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
	  if (!useIntPt1) {
	    npts--;
	  }
	  var pts = new Array(npts).fill(null);
	  var ipt = 0;
	  pts[ipt++] = new Coordinate(ei0.coord);
	  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
	    pts[ipt++] = this$1$1.edge.pts[i];
	  }
	  if (useIntPt1) { pts[ipt] = ei1.coord; }
	  return new Edge$1(pts, new Label(this.edge._label))
	};
	EdgeIntersectionList.prototype.add = function add (intPt, segmentIndex, dist) {
	  var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
	  var ei = this._nodeMap.get(eiNew);
	  if (ei !== null) {
	    return ei
	  }
	  this._nodeMap.put(eiNew, eiNew);
	  return eiNew
	};
	EdgeIntersectionList.prototype.isIntersection = function isIntersection (pt) {
	  for (var it = this.iterator(); it.hasNext();) {
	    var ei = it.next();
	    if (ei.coord.equals(pt)) { return true }
	  }
	  return false
	};
	EdgeIntersectionList.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	EdgeIntersectionList.prototype.getClass = function getClass () {
	  return EdgeIntersectionList
	};

	var MonotoneChainIndexer = function MonotoneChainIndexer () {};

	MonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices (pts) {
	    var this$1$1 = this;

	  var start = 0;
	  var startIndexList = new ArrayList();
	  startIndexList.add(new Integer(start));
	  do {
	    var last = this$1$1.findChainEnd(pts, start);
	    startIndexList.add(new Integer(last));
	    start = last;
	  } while (start < pts.length - 1)
	  var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
	  return startIndex
	};
	MonotoneChainIndexer.prototype.findChainEnd = function findChainEnd (pts, start) {
	  var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
	  var last = start + 1;
	  while (last < pts.length) {
	    var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
	    if (quad !== chainQuad) { break }
	    last++;
	  }
	  return last - 1
	};
	MonotoneChainIndexer.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChainIndexer.prototype.getClass = function getClass () {
	  return MonotoneChainIndexer
	};
	MonotoneChainIndexer.toIntArray = function toIntArray (list) {
	  var array = new Array(list.size()).fill(null);
	  for (var i = 0; i < array.length; i++) {
	    array[i] = list.get(i).intValue();
	  }
	  return array
	};

	var MonotoneChainEdge = function MonotoneChainEdge () {
	  this.e = null;
	  this.pts = null;
	  this.startIndex = null;
	  this.env1 = new Envelope();
	  this.env2 = new Envelope();
	  var e = arguments[0];
	  this.e = e;
	  this.pts = e.getCoordinates();
	  var mcb = new MonotoneChainIndexer();
	  this.startIndex = mcb.getChainStartIndices(this.pts);
	};
	MonotoneChainEdge.prototype.getCoordinates = function getCoordinates () {
	  return this.pts
	};
	MonotoneChainEdge.prototype.getMaxX = function getMaxX (chainIndex) {
	  var x1 = this.pts[this.startIndex[chainIndex]].x;
	  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
	  return x1 > x2 ? x1 : x2
	};
	MonotoneChainEdge.prototype.getMinX = function getMinX (chainIndex) {
	  var x1 = this.pts[this.startIndex[chainIndex]].x;
	  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
	  return x1 < x2 ? x1 : x2
	};
	MonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain () {
	  if (arguments.length === 4) {
	    var chainIndex0 = arguments[0];
	    var mce = arguments[1];
	    var chainIndex1 = arguments[2];
	    var si = arguments[3];
	    this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
	  } else if (arguments.length === 6) {
	    var start0 = arguments[0];
	    var end0 = arguments[1];
	    var mce$1 = arguments[2];
	    var start1 = arguments[3];
	    var end1 = arguments[4];
	    var ei = arguments[5];
	    var p00 = this.pts[start0];
	    var p01 = this.pts[end0];
	    var p10 = mce$1.pts[start1];
	    var p11 = mce$1.pts[end1];
	    if (end0 - start0 === 1 && end1 - start1 === 1) {
	      ei.addIntersections(this.e, start0, mce$1.e, start1);
	      return null
	    }
	    this.env1.init(p00, p01);
	    this.env2.init(p10, p11);
	    if (!this.env1.intersects(this.env2)) { return null }
	    var mid0 = Math.trunc((start0 + end0) / 2);
	    var mid1 = Math.trunc((start1 + end1) / 2);
	    if (start0 < mid0) {
	      if (start1 < mid1) { this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei); }
	      if (mid1 < end1) { this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei); }
	    }
	    if (mid0 < end0) {
	      if (start1 < mid1) { this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei); }
	      if (mid1 < end1) { this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei); }
	    }
	  }
	};
	MonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes () {
	  return this.startIndex
	};
	MonotoneChainEdge.prototype.computeIntersects = function computeIntersects (mce, si) {
	    var this$1$1 = this;

	  for (var i = 0; i < this.startIndex.length - 1; i++) {
	    for (var j = 0; j < mce.startIndex.length - 1; j++) {
	      this$1$1.computeIntersectsForChain(i, mce, j, si);
	    }
	  }
	};
	MonotoneChainEdge.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChainEdge.prototype.getClass = function getClass () {
	  return MonotoneChainEdge
	};

	var Depth = function Depth () {
	  var this$1$1 = this;

	  this._depth = Array(2).fill().map(function () { return Array(3); });
	  for (var i = 0; i < 2; i++) {
	    for (var j = 0; j < 3; j++) {
	      this$1$1._depth[i][j] = Depth.NULL_VALUE;
	    }
	  }
	};

	var staticAccessors$31 = { NULL_VALUE: { configurable: true } };
	Depth.prototype.getDepth = function getDepth (geomIndex, posIndex) {
	  return this._depth[geomIndex][posIndex]
	};
	Depth.prototype.setDepth = function setDepth (geomIndex, posIndex, depthValue) {
	  this._depth[geomIndex][posIndex] = depthValue;
	};
	Depth.prototype.isNull = function isNull () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    for (var i = 0; i < 2; i++) {
	      for (var j = 0; j < 3; j++) {
	        if (this$1$1._depth[i][j] !== Depth.NULL_VALUE) { return false }
	      }
	    }
	    return true
	  } else if (arguments.length === 1) {
	    var geomIndex = arguments[0];
	    return this._depth[geomIndex][1] === Depth.NULL_VALUE
	  } else if (arguments.length === 2) {
	    var geomIndex$1 = arguments[0];
	    var posIndex = arguments[1];
	    return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE
	  }
	};
	Depth.prototype.normalize = function normalize () {
	    var this$1$1 = this;

	  for (var i = 0; i < 2; i++) {
	    if (!this$1$1.isNull(i)) {
	      var minDepth = this$1$1._depth[i][1];
	      if (this$1$1._depth[i][2] < minDepth) { minDepth = this$1$1._depth[i][2]; }
	      if (minDepth < 0) { minDepth = 0; }
	      for (var j = 1; j < 3; j++) {
	        var newValue = 0;
	        if (this$1$1._depth[i][j] > minDepth) { newValue = 1; }
	        this$1$1._depth[i][j] = newValue;
	      }
	    }
	  }
	};
	Depth.prototype.getDelta = function getDelta (geomIndex) {
	  return this._depth[geomIndex][Position$1.RIGHT] - this._depth[geomIndex][Position$1.LEFT]
	};
	Depth.prototype.getLocation = function getLocation (geomIndex, posIndex) {
	  if (this._depth[geomIndex][posIndex] <= 0) { return Location.EXTERIOR }
	  return Location.INTERIOR
	};
	Depth.prototype.toString = function toString () {
	  return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]
	};
	Depth.prototype.add = function add () {
	    var this$1$1 = this;

	  if (arguments.length === 1) {
	    var lbl = arguments[0];
	    for (var i = 0; i < 2; i++) {
	      for (var j = 1; j < 3; j++) {
	        var loc = lbl.getLocation(i, j);
	        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
	          if (this$1$1.isNull(i, j)) {
	            this$1$1._depth[i][j] = Depth.depthAtLocation(loc);
	          } else { this$1$1._depth[i][j] += Depth.depthAtLocation(loc); }
	        }
	      }
	    }
	  } else if (arguments.length === 3) {
	    var geomIndex = arguments[0];
	    var posIndex = arguments[1];
	    var location = arguments[2];
	    if (location === Location.INTERIOR) { this._depth[geomIndex][posIndex]++; }
	  }
	};
	Depth.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	Depth.prototype.getClass = function getClass () {
	  return Depth
	};
	Depth.depthAtLocation = function depthAtLocation (location) {
	  if (location === Location.EXTERIOR) { return 0 }
	  if (location === Location.INTERIOR) { return 1 }
	  return Depth.NULL_VALUE
	};
	staticAccessors$31.NULL_VALUE.get = function () { return -1 };

	Object.defineProperties( Depth, staticAccessors$31 );

	var Edge$1 = (function (GraphComponent$$1) {
	  function Edge () {
	    GraphComponent$$1.call(this);
	    this.pts = null;
	    this._env = null;
	    this.eiList = new EdgeIntersectionList(this);
	    this._name = null;
	    this._mce = null;
	    this._isIsolated = true;
	    this._depth = new Depth();
	    this._depthDelta = 0;
	    if (arguments.length === 1) {
	      var pts = arguments[0];
	      Edge.call(this, pts, null);
	    } else if (arguments.length === 2) {
	      var pts$1 = arguments[0];
	      var label = arguments[1];
	      this.pts = pts$1;
	      this._label = label;
	    }
	  }

	  if ( GraphComponent$$1 ) Edge.__proto__ = GraphComponent$$1;
	  Edge.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );
	  Edge.prototype.constructor = Edge;
	  Edge.prototype.getDepth = function getDepth () {
	    return this._depth
	  };
	  Edge.prototype.getCollapsedEdge = function getCollapsedEdge () {
	    var newPts = new Array(2).fill(null);
	    newPts[0] = this.pts[0];
	    newPts[1] = this.pts[1];
	    var newe = new Edge(newPts, Label.toLineLabel(this._label));
	    return newe
	  };
	  Edge.prototype.isIsolated = function isIsolated () {
	    return this._isIsolated
	  };
	  Edge.prototype.getCoordinates = function getCoordinates () {
	    return this.pts
	  };
	  Edge.prototype.setIsolated = function setIsolated (isIsolated) {
	    this._isIsolated = isIsolated;
	  };
	  Edge.prototype.setName = function setName (name) {
	    this._name = name;
	  };
	  Edge.prototype.equals = function equals (o) {
	    var this$1$1 = this;

	    if (!(o instanceof Edge)) { return false }
	    var e = o;
	    if (this.pts.length !== e.pts.length) { return false }
	    var isEqualForward = true;
	    var isEqualReverse = true;
	    var iRev = this.pts.length;
	    for (var i = 0; i < this.pts.length; i++) {
	      if (!this$1$1.pts[i].equals2D(e.pts[i])) {
	        isEqualForward = false;
	      }
	      if (!this$1$1.pts[i].equals2D(e.pts[--iRev])) {
	        isEqualReverse = false;
	      }
	      if (!isEqualForward && !isEqualReverse) { return false }
	    }
	    return true
	  };
	  Edge.prototype.getCoordinate = function getCoordinate () {
	    if (arguments.length === 0) {
	      if (this.pts.length > 0) { return this.pts[0] }
	      return null
	    } else if (arguments.length === 1) {
	      var i = arguments[0];
	      return this.pts[i]
	    }
	  };
	  Edge.prototype.print = function print (out) {
	    var this$1$1 = this;

	    out.print('edge ' + this._name + ': ');
	    out.print('LINESTRING (');
	    for (var i = 0; i < this.pts.length; i++) {
	      if (i > 0) { out.print(','); }
	      out.print(this$1$1.pts[i].x + ' ' + this$1$1.pts[i].y);
	    }
	    out.print(')  ' + this._label + ' ' + this._depthDelta);
	  };
	  Edge.prototype.computeIM = function computeIM (im) {
	    Edge.updateIM(this._label, im);
	  };
	  Edge.prototype.isCollapsed = function isCollapsed () {
	    if (!this._label.isArea()) { return false }
	    if (this.pts.length !== 3) { return false }
	    if (this.pts[0].equals(this.pts[2])) { return true }
	    return false
	  };
	  Edge.prototype.isClosed = function isClosed () {
	    return this.pts[0].equals(this.pts[this.pts.length - 1])
	  };
	  Edge.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex () {
	    return this.pts.length - 1
	  };
	  Edge.prototype.getDepthDelta = function getDepthDelta () {
	    return this._depthDelta
	  };
	  Edge.prototype.getNumPoints = function getNumPoints () {
	    return this.pts.length
	  };
	  Edge.prototype.printReverse = function printReverse (out) {
	    var this$1$1 = this;

	    out.print('edge ' + this._name + ': ');
	    for (var i = this.pts.length - 1; i >= 0; i--) {
	      out.print(this$1$1.pts[i] + ' ');
	    }
	    out.println('');
	  };
	  Edge.prototype.getMonotoneChainEdge = function getMonotoneChainEdge () {
	    if (this._mce === null) { this._mce = new MonotoneChainEdge(this); }
	    return this._mce
	  };
	  Edge.prototype.getEnvelope = function getEnvelope () {
	    var this$1$1 = this;

	    if (this._env === null) {
	      this._env = new Envelope();
	      for (var i = 0; i < this.pts.length; i++) {
	        this$1$1._env.expandToInclude(this$1$1.pts[i]);
	      }
	    }
	    return this._env
	  };
	  Edge.prototype.addIntersection = function addIntersection (li, segmentIndex, geomIndex, intIndex) {
	    var intPt = new Coordinate(li.getIntersection(intIndex));
	    var normalizedSegmentIndex = segmentIndex;
	    var dist = li.getEdgeDistance(geomIndex, intIndex);
	    var nextSegIndex = normalizedSegmentIndex + 1;
	    if (nextSegIndex < this.pts.length) {
	      var nextPt = this.pts[nextSegIndex];
	      if (intPt.equals2D(nextPt)) {
	        normalizedSegmentIndex = nextSegIndex;
	        dist = 0.0;
	      }
	    }
	    this.eiList.add(intPt, normalizedSegmentIndex, dist);
	  };
	  Edge.prototype.toString = function toString () {
	    var this$1$1 = this;

	    var buf = new StringBuffer();
	    buf.append('edge ' + this._name + ': ');
	    buf.append('LINESTRING (');
	    for (var i = 0; i < this.pts.length; i++) {
	      if (i > 0) { buf.append(','); }
	      buf.append(this$1$1.pts[i].x + ' ' + this$1$1.pts[i].y);
	    }
	    buf.append(')  ' + this._label + ' ' + this._depthDelta);
	    return buf.toString()
	  };
	  Edge.prototype.isPointwiseEqual = function isPointwiseEqual (e) {
	    var this$1$1 = this;

	    if (this.pts.length !== e.pts.length) { return false }
	    for (var i = 0; i < this.pts.length; i++) {
	      if (!this$1$1.pts[i].equals2D(e.pts[i])) {
	        return false
	      }
	    }
	    return true
	  };
	  Edge.prototype.setDepthDelta = function setDepthDelta (depthDelta) {
	    this._depthDelta = depthDelta;
	  };
	  Edge.prototype.getEdgeIntersectionList = function getEdgeIntersectionList () {
	    return this.eiList
	  };
	  Edge.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {
	    var this$1$1 = this;

	    for (var i = 0; i < li.getIntersectionNum(); i++) {
	      this$1$1.addIntersection(li, segmentIndex, geomIndex, i);
	    }
	  };
	  Edge.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  Edge.prototype.getClass = function getClass () {
	    return Edge
	  };
	  Edge.updateIM = function updateIM () {
	    if (arguments.length === 2) {
	      var label = arguments[0];
	      var im = arguments[1];
	      im.setAtLeastIfValid(label.getLocation(0, Position$1.ON), label.getLocation(1, Position$1.ON), 1);
	      if (label.isArea()) {
	        im.setAtLeastIfValid(label.getLocation(0, Position$1.LEFT), label.getLocation(1, Position$1.LEFT), 2);
	        im.setAtLeastIfValid(label.getLocation(0, Position$1.RIGHT), label.getLocation(1, Position$1.RIGHT), 2);
	      }
	    } else { return GraphComponent$$1.prototype.updateIM.apply(this, arguments) }
	  };

	  return Edge;
	}(GraphComponent));

	var BufferBuilder = function BufferBuilder (bufParams) {
	  this._workingPrecisionModel = null;
	  this._workingNoder = null;
	  this._geomFact = null;
	  this._graph = null;
	  this._edgeList = new EdgeList();
	  this._bufParams = bufParams || null;
	};
	BufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel (pm) {
	  this._workingPrecisionModel = pm;
	};
	BufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge (e) {
	  var existingEdge = this._edgeList.findEqualEdge(e);
	  if (existingEdge !== null) {
	    var existingLabel = existingEdge.getLabel();
	    var labelToMerge = e.getLabel();
	    if (!existingEdge.isPointwiseEqual(e)) {
	      labelToMerge = new Label(e.getLabel());
	      labelToMerge.flip();
	    }
	    existingLabel.merge(labelToMerge);
	    var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
	    var existingDelta = existingEdge.getDepthDelta();
	    var newDelta = existingDelta + mergeDelta;
	    existingEdge.setDepthDelta(newDelta);
	  } else {
	    this._edgeList.add(e);
	    e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
	  }
	};
	BufferBuilder.prototype.buildSubgraphs = function buildSubgraphs (subgraphList, polyBuilder) {
	  var processedGraphs = new ArrayList();
	  for (var i = subgraphList.iterator(); i.hasNext();) {
	    var subgraph = i.next();
	    var p = subgraph.getRightmostCoordinate();
	    var locater = new SubgraphDepthLocater(processedGraphs);
	    var outsideDepth = locater.getDepth(p);
	    subgraph.computeDepth(outsideDepth);
	    subgraph.findResultEdges();
	    processedGraphs.add(subgraph);
	    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
	  }
	};
	BufferBuilder.prototype.createSubgraphs = function createSubgraphs (graph) {
	  var subgraphList = new ArrayList();
	  for (var i = graph.getNodes().iterator(); i.hasNext();) {
	    var node = i.next();
	    if (!node.isVisited()) {
	      var subgraph = new BufferSubgraph();
	      subgraph.create(node);
	      subgraphList.add(subgraph);
	    }
	  }
	  Collections.sort(subgraphList, Collections.reverseOrder());
	  return subgraphList
	};
	BufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry () {
	  var emptyGeom = this._geomFact.createPolygon();
	  return emptyGeom
	};
	BufferBuilder.prototype.getNoder = function getNoder (precisionModel) {
	  if (this._workingNoder !== null) { return this._workingNoder }
	  var noder = new MCIndexNoder();
	  var li = new RobustLineIntersector();
	  li.setPrecisionModel(precisionModel);
	  noder.setSegmentIntersector(new IntersectionAdder(li));
	  return noder
	};
	BufferBuilder.prototype.buffer = function buffer (g, distance) {
	  var precisionModel = this._workingPrecisionModel;
	  if (precisionModel === null) { precisionModel = g.getPrecisionModel(); }
	  this._geomFact = g.getFactory();
	  var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
	  var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
	  var bufferSegStrList = curveSetBuilder.getCurves();
	  if (bufferSegStrList.size() <= 0) {
	    return this.createEmptyResultGeometry()
	  }
	  this.computeNodedEdges(bufferSegStrList, precisionModel);
	  this._graph = new PlanarGraph(new OverlayNodeFactory());
	  this._graph.addEdges(this._edgeList.getEdges());
	  var subgraphList = this.createSubgraphs(this._graph);
	  var polyBuilder = new PolygonBuilder(this._geomFact);
	  this.buildSubgraphs(subgraphList, polyBuilder);
	  var resultPolyList = polyBuilder.getPolygons();
	  if (resultPolyList.size() <= 0) {
	    return this.createEmptyResultGeometry()
	  }
	  var resultGeom = this._geomFact.buildGeometry(resultPolyList);
	  return resultGeom
	};
	BufferBuilder.prototype.computeNodedEdges = function computeNodedEdges (bufferSegStrList, precisionModel) {
	    var this$1$1 = this;

	  var noder = this.getNoder(precisionModel);
	  noder.computeNodes(bufferSegStrList);
	  var nodedSegStrings = noder.getNodedSubstrings();
	  for (var i = nodedSegStrings.iterator(); i.hasNext();) {
	    var segStr = i.next();
	    var pts = segStr.getCoordinates();
	    if (pts.length === 2 && pts[0].equals2D(pts[1])) { continue }
	    var oldLabel = segStr.getData();
	    var edge = new Edge$1(segStr.getCoordinates(), new Label(oldLabel));
	    this$1$1.insertUniqueEdge(edge);
	  }
	};
	BufferBuilder.prototype.setNoder = function setNoder (noder) {
	  this._workingNoder = noder;
	};
	BufferBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferBuilder.prototype.getClass = function getClass () {
	  return BufferBuilder
	};
	BufferBuilder.depthDelta = function depthDelta (label) {
	  var lLoc = label.getLocation(0, Position$1.LEFT);
	  var rLoc = label.getLocation(0, Position$1.RIGHT);
	  if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) { return 1; } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) { return -1 }
	  return 0
	};
	BufferBuilder.convertSegStrings = function convertSegStrings (it) {
	  var fact = new GeometryFactory();
	  var lines = new ArrayList();
	  while (it.hasNext()) {
	    var ss = it.next();
	    var line = fact.createLineString(ss.getCoordinates());
	    lines.add(line);
	  }
	  return fact.buildGeometry(lines)
	};

	var ScaledNoder = function ScaledNoder () {
	  this._noder = null;
	  this._scaleFactor = null;
	  this._offsetX = null;
	  this._offsetY = null;
	  this._isScaled = false;
	  if (arguments.length === 2) {
	    var noder = arguments[0];
	    var scaleFactor = arguments[1];
	    this._noder = noder;
	    this._scaleFactor = scaleFactor;
	    this._offsetX = 0.0;
	    this._offsetY = 0.0;
	    this._isScaled = !this.isIntegerPrecision();
	  } else if (arguments.length === 4) {
	    var noder$1 = arguments[0];
	    var scaleFactor$1 = arguments[1];
	    var offsetX = arguments[2];
	    var offsetY = arguments[3];
	    this._noder = noder$1;
	    this._scaleFactor = scaleFactor$1;
	    this._offsetX = offsetX;
	    this._offsetY = offsetY;
	    this._isScaled = !this.isIntegerPrecision();
	  }
	};
	ScaledNoder.prototype.rescale = function rescale () {
	    var this$1$1 = this;

	  if (hasInterface(arguments[0], Collection)) {
	    var segStrings = arguments[0];
	    for (var i = segStrings.iterator(); i.hasNext();) {
	      var ss = i.next();
	      this$1$1.rescale(ss.getCoordinates());
	    }
	  } else if (arguments[0] instanceof Array) {
	    var pts = arguments[0];
	    // let p0 = null
	    // let p1 = null
	    // if (pts.length === 2) {
	    // p0 = new Coordinate(pts[0])
	    // p1 = new Coordinate(pts[1])
	    // }
	    for (var i$1 = 0; i$1 < pts.length; i$1++) {
	      pts[i$1].x = pts[i$1].x / this$1$1._scaleFactor + this$1$1._offsetX;
	      pts[i$1].y = pts[i$1].y / this$1$1._scaleFactor + this$1$1._offsetY;
	    }
	    if (pts.length === 2 && pts[0].equals2D(pts[1])) {
	      System.out.println(pts);
	    }
	  }
	};
	ScaledNoder.prototype.scale = function scale () {
	    var this$1$1 = this;

	  if (hasInterface(arguments[0], Collection)) {
	    var segStrings = arguments[0];
	    var nodedSegmentStrings = new ArrayList();
	    for (var i = segStrings.iterator(); i.hasNext();) {
	      var ss = i.next();
	      nodedSegmentStrings.add(new NodedSegmentString(this$1$1.scale(ss.getCoordinates()), ss.getData()));
	    }
	    return nodedSegmentStrings
	  } else if (arguments[0] instanceof Array) {
	    var pts = arguments[0];
	    var roundPts = new Array(pts.length).fill(null);
	    for (var i$1 = 0; i$1 < pts.length; i$1++) {
	      roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1$1._offsetX) * this$1$1._scaleFactor), Math.round((pts[i$1].y - this$1$1._offsetY) * this$1$1._scaleFactor), pts[i$1].z);
	    }
	    var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
	    return roundPtsNoDup
	  }
	};
	ScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision () {
	  return this._scaleFactor === 1.0
	};
	ScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {
	  var splitSS = this._noder.getNodedSubstrings();
	  if (this._isScaled) { this.rescale(splitSS); }
	  return splitSS
	};
	ScaledNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {
	  var intSegStrings = inputSegStrings;
	  if (this._isScaled) { intSegStrings = this.scale(inputSegStrings); }
	  this._noder.computeNodes(intSegStrings);
	};
	ScaledNoder.prototype.interfaces_ = function interfaces_ () {
	  return [Noder]
	};
	ScaledNoder.prototype.getClass = function getClass () {
	  return ScaledNoder
	};

	var NodingValidator = function NodingValidator () {
	  this._li = new RobustLineIntersector();
	  this._segStrings = null;
	  var segStrings = arguments[0];
	  this._segStrings = segStrings;
	};

	var staticAccessors$33 = { fact: { configurable: true } };
	NodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    for (var i = this._segStrings.iterator(); i.hasNext();) {
	      var ss = i.next();
	      var pts = ss.getCoordinates();
	      this$1$1.checkEndPtVertexIntersections(pts[0], this$1$1._segStrings);
	      this$1$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1$1._segStrings);
	    }
	  } else if (arguments.length === 2) {
	    var testPt = arguments[0];
	    var segStrings = arguments[1];
	    for (var i$1 = segStrings.iterator(); i$1.hasNext();) {
	      var ss$1 = i$1.next();
	      var pts$1 = ss$1.getCoordinates();
	      for (var j = 1; j < pts$1.length - 1; j++) {
	        if (pts$1[j].equals(testPt)) { throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt) }
	      }
	    }
	  }
	};
	NodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    for (var i = this._segStrings.iterator(); i.hasNext();) {
	      var ss0 = i.next();
	      for (var j = this._segStrings.iterator(); j.hasNext();) {
	        var ss1 = j.next();
	        this$1$1.checkInteriorIntersections(ss0, ss1);
	      }
	    }
	  } else if (arguments.length === 2) {
	    var ss0$1 = arguments[0];
	    var ss1$1 = arguments[1];
	    var pts0 = ss0$1.getCoordinates();
	    var pts1 = ss1$1.getCoordinates();
	    for (var i0 = 0; i0 < pts0.length - 1; i0++) {
	      for (var i1 = 0; i1 < pts1.length - 1; i1++) {
	        this$1$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);
	      }
	    }
	  } else if (arguments.length === 4) {
	    var e0 = arguments[0];
	    var segIndex0 = arguments[1];
	    var e1 = arguments[2];
	    var segIndex1 = arguments[3];
	    if (e0 === e1 && segIndex0 === segIndex1) { return null }
	    var p00 = e0.getCoordinates()[segIndex0];
	    var p01 = e0.getCoordinates()[segIndex0 + 1];
	    var p10 = e1.getCoordinates()[segIndex1];
	    var p11 = e1.getCoordinates()[segIndex1 + 1];
	    this._li.computeIntersection(p00, p01, p10, p11);
	    if (this._li.hasIntersection()) {
	      if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
	        throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)
	      }
	    }
	  }
	};
	NodingValidator.prototype.checkValid = function checkValid () {
	  this.checkEndPtVertexIntersections();
	  this.checkInteriorIntersections();
	  this.checkCollapses();
	};
	NodingValidator.prototype.checkCollapses = function checkCollapses () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    for (var i = this._segStrings.iterator(); i.hasNext();) {
	      var ss = i.next();
	      this$1$1.checkCollapses(ss);
	    }
	  } else if (arguments.length === 1) {
	    var ss$1 = arguments[0];
	    var pts = ss$1.getCoordinates();
	    for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {
	      this$1$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);
	    }
	  }
	};
	NodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection (li, p0, p1) {
	  for (var i = 0; i < li.getIntersectionNum(); i++) {
	    var intPt = li.getIntersection(i);
	    if (!(intPt.equals(p0) || intPt.equals(p1))) { return true }
	  }
	  return false
	};
	NodingValidator.prototype.checkCollapse = function checkCollapse (p0, p1, p2) {
	  if (p0.equals(p2)) { throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2])) }
	};
	NodingValidator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	NodingValidator.prototype.getClass = function getClass () {
	  return NodingValidator
	};
	staticAccessors$33.fact.get = function () { return new GeometryFactory() };

	Object.defineProperties( NodingValidator, staticAccessors$33 );

	var HotPixel = function HotPixel () {
	  this._li = null;
	  this._pt = null;
	  this._originalPt = null;
	  this._ptScaled = null;
	  this._p0Scaled = null;
	  this._p1Scaled = null;
	  this._scaleFactor = null;
	  this._minx = null;
	  this._maxx = null;
	  this._miny = null;
	  this._maxy = null;
	  this._corner = new Array(4).fill(null);
	  this._safeEnv = null;
	  var pt = arguments[0];
	  var scaleFactor = arguments[1];
	  var li = arguments[2];
	  this._originalPt = pt;
	  this._pt = pt;
	  this._scaleFactor = scaleFactor;
	  this._li = li;
	  if (scaleFactor <= 0) { throw new IllegalArgumentException() }
	  if (scaleFactor !== 1.0) {
	    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
	    this._p0Scaled = new Coordinate();
	    this._p1Scaled = new Coordinate();
	  }
	  this.initCorners(this._pt);
	};

	var staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
	HotPixel.prototype.intersectsScaled = function intersectsScaled (p0, p1) {
	  var segMinx = Math.min(p0.x, p1.x);
	  var segMaxx = Math.max(p0.x, p1.x);
	  var segMiny = Math.min(p0.y, p1.y);
	  var segMaxy = Math.max(p0.y, p1.y);
	  var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
	  if (isOutsidePixelEnv) { return false }
	  var intersects = this.intersectsToleranceSquare(p0, p1);
	  Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
	  return intersects
	};
	HotPixel.prototype.initCorners = function initCorners (pt) {
	  var tolerance = 0.5;
	  this._minx = pt.x - tolerance;
	  this._maxx = pt.x + tolerance;
	  this._miny = pt.y - tolerance;
	  this._maxy = pt.y + tolerance;
	  this._corner[0] = new Coordinate(this._maxx, this._maxy);
	  this._corner[1] = new Coordinate(this._minx, this._maxy);
	  this._corner[2] = new Coordinate(this._minx, this._miny);
	  this._corner[3] = new Coordinate(this._maxx, this._miny);
	};
	HotPixel.prototype.intersects = function intersects (p0, p1) {
	  if (this._scaleFactor === 1.0) { return this.intersectsScaled(p0, p1) }
	  this.copyScaled(p0, this._p0Scaled);
	  this.copyScaled(p1, this._p1Scaled);
	  return this.intersectsScaled(this._p0Scaled, this._p1Scaled)
	};
	HotPixel.prototype.scale = function scale (val) {
	  return Math.round(val * this._scaleFactor)
	};
	HotPixel.prototype.getCoordinate = function getCoordinate () {
	  return this._originalPt
	};
	HotPixel.prototype.copyScaled = function copyScaled (p, pScaled) {
	  pScaled.x = this.scale(p.x);
	  pScaled.y = this.scale(p.y);
	};
	HotPixel.prototype.getSafeEnvelope = function getSafeEnvelope () {
	  if (this._safeEnv === null) {
	    var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
	    this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
	  }
	  return this._safeEnv
	};
	HotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure (p0, p1) {
	  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
	  if (this._li.hasIntersection()) { return true }
	  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
	  if (this._li.hasIntersection()) { return true }
	  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
	  if (this._li.hasIntersection()) { return true }
	  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
	  if (this._li.hasIntersection()) { return true }
	  return false
	};
	HotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare (p0, p1) {
	  var intersectsLeft = false;
	  var intersectsBottom = false;
	  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
	  if (this._li.isProper()) { return true }
	  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
	  if (this._li.isProper()) { return true }
	  if (this._li.hasIntersection()) { intersectsLeft = true; }
	  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
	  if (this._li.isProper()) { return true }
	  if (this._li.hasIntersection()) { intersectsBottom = true; }
	  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
	  if (this._li.isProper()) { return true }
	  if (intersectsLeft && intersectsBottom) { return true }
	  if (p0.equals(this._pt)) { return true }
	  if (p1.equals(this._pt)) { return true }
	  return false
	};
	HotPixel.prototype.addSnappedNode = function addSnappedNode (segStr, segIndex) {
	  var p0 = segStr.getCoordinate(segIndex);
	  var p1 = segStr.getCoordinate(segIndex + 1);
	  if (this.intersects(p0, p1)) {
	    segStr.addIntersection(this.getCoordinate(), segIndex);
	    return true
	  }
	  return false
	};
	HotPixel.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	HotPixel.prototype.getClass = function getClass () {
	  return HotPixel
	};
	staticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function () { return 0.75 };

	Object.defineProperties( HotPixel, staticAccessors$34 );

	var MonotoneChainSelectAction = function MonotoneChainSelectAction () {
	  this.tempEnv1 = new Envelope();
	  this.selectedSegment = new LineSegment();
	};
	MonotoneChainSelectAction.prototype.select = function select () {
	  if (arguments.length === 1) ; else if (arguments.length === 2) {
	    var mc = arguments[0];
	    var startIndex = arguments[1];
	    mc.getLineSegment(startIndex, this.selectedSegment);
	    this.select(this.selectedSegment);
	  }
	};
	MonotoneChainSelectAction.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChainSelectAction.prototype.getClass = function getClass () {
	  return MonotoneChainSelectAction
	};

	var MCIndexPointSnapper = function MCIndexPointSnapper () {
	  this._index = null;
	  var index = arguments[0];
	  this._index = index;
	};

	var staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };
	MCIndexPointSnapper.prototype.snap = function snap () {
	  if (arguments.length === 1) {
	    var hotPixel = arguments[0];
	    return this.snap(hotPixel, null, -1)
	  } else if (arguments.length === 3) {
	    var hotPixel$1 = arguments[0];
	    var parentEdge = arguments[1];
	    var hotPixelVertexIndex = arguments[2];
	    var pixelEnv = hotPixel$1.getSafeEnvelope();
	    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);
	    this._index.query(pixelEnv, {
	      interfaces_: function () {
	        return [ItemVisitor]
	      },
	      visitItem: function (item) {
	        var testChain = item;
	        testChain.select(pixelEnv, hotPixelSnapAction);
	      }
	    });
	    return hotPixelSnapAction.isNodeAdded()
	  }
	};
	MCIndexPointSnapper.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MCIndexPointSnapper.prototype.getClass = function getClass () {
	  return MCIndexPointSnapper
	};
	staticAccessors$35.HotPixelSnapAction.get = function () { return HotPixelSnapAction };

	Object.defineProperties( MCIndexPointSnapper, staticAccessors$35 );

	var HotPixelSnapAction = (function (MonotoneChainSelectAction$$1) {
	  function HotPixelSnapAction () {
	    MonotoneChainSelectAction$$1.call(this);
	    this._hotPixel = null;
	    this._parentEdge = null;
	    this._hotPixelVertexIndex = null;
	    this._isNodeAdded = false;
	    var hotPixel = arguments[0];
	    var parentEdge = arguments[1];
	    var hotPixelVertexIndex = arguments[2];
	    this._hotPixel = hotPixel;
	    this._parentEdge = parentEdge;
	    this._hotPixelVertexIndex = hotPixelVertexIndex;
	  }

	  if ( MonotoneChainSelectAction$$1 ) HotPixelSnapAction.__proto__ = MonotoneChainSelectAction$$1;
	  HotPixelSnapAction.prototype = Object.create( MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype );
	  HotPixelSnapAction.prototype.constructor = HotPixelSnapAction;
	  HotPixelSnapAction.prototype.isNodeAdded = function isNodeAdded () {
	    return this._isNodeAdded
	  };
	  HotPixelSnapAction.prototype.select = function select () {
	    if (arguments.length === 2) {
	      var mc = arguments[0];
	      var startIndex = arguments[1];
	      var ss = mc.getContext();
	      if (this._parentEdge !== null) {
	        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) { return null }
	      }
	      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
	    } else { return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments) }
	  };
	  HotPixelSnapAction.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  HotPixelSnapAction.prototype.getClass = function getClass () {
	    return HotPixelSnapAction
	  };

	  return HotPixelSnapAction;
	}(MonotoneChainSelectAction));

	var InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder () {
	  this._li = null;
	  this._interiorIntersections = null;
	  var li = arguments[0];
	  this._li = li;
	  this._interiorIntersections = new ArrayList();
	};
	InteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {
	    var this$1$1 = this;

	  if (e0 === e1 && segIndex0 === segIndex1) { return null }
	  var p00 = e0.getCoordinates()[segIndex0];
	  var p01 = e0.getCoordinates()[segIndex0 + 1];
	  var p10 = e1.getCoordinates()[segIndex1];
	  var p11 = e1.getCoordinates()[segIndex1 + 1];
	  this._li.computeIntersection(p00, p01, p10, p11);
	  if (this._li.hasIntersection()) {
	    if (this._li.isInteriorIntersection()) {
	      for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
	        this$1$1._interiorIntersections.add(this$1$1._li.getIntersection(intIndex));
	      }
	      e0.addIntersections(this._li, segIndex0, 0);
	      e1.addIntersections(this._li, segIndex1, 1);
	    }
	  }
	};
	InteriorIntersectionFinderAdder.prototype.isDone = function isDone () {
	  return false
	};
	InteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections () {
	  return this._interiorIntersections
	};
	InteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_ () {
	  return [SegmentIntersector]
	};
	InteriorIntersectionFinderAdder.prototype.getClass = function getClass () {
	  return InteriorIntersectionFinderAdder
	};

	var MCIndexSnapRounder = function MCIndexSnapRounder () {
	  this._pm = null;
	  this._li = null;
	  this._scaleFactor = null;
	  this._noder = null;
	  this._pointSnapper = null;
	  this._nodedSegStrings = null;
	  var pm = arguments[0];
	  this._pm = pm;
	  this._li = new RobustLineIntersector();
	  this._li.setPrecisionModel(pm);
	  this._scaleFactor = pm.getScale();
	};
	MCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness (inputSegmentStrings) {
	  var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
	  var nv = new NodingValidator(resultSegStrings);
	  try {
	    nv.checkValid();
	  } catch (ex) {
	    if (ex instanceof Exception) {
	      ex.printStackTrace();
	    } else { throw ex }
	  } finally {}
	};
	MCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings () {
	  return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
	};
	MCIndexSnapRounder.prototype.snapRound = function snapRound (segStrings, li) {
	  var intersections = this.findInteriorIntersections(segStrings, li);
	  this.computeIntersectionSnaps(intersections);
	  this.computeVertexSnaps(segStrings);
	};
	MCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections (segStrings, li) {
	  var intFinderAdder = new InteriorIntersectionFinderAdder(li);
	  this._noder.setSegmentIntersector(intFinderAdder);
	  this._noder.computeNodes(segStrings);
	  return intFinderAdder.getInteriorIntersections()
	};
	MCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps () {
	    var this$1$1 = this;

	  if (hasInterface(arguments[0], Collection)) {
	    var edges = arguments[0];
	    for (var i0 = edges.iterator(); i0.hasNext();) {
	      var edge0 = i0.next();
	      this$1$1.computeVertexSnaps(edge0);
	    }
	  } else if (arguments[0] instanceof NodedSegmentString) {
	    var e = arguments[0];
	    var pts0 = e.getCoordinates();
	    for (var i = 0; i < pts0.length; i++) {
	      var hotPixel = new HotPixel(pts0[i], this$1$1._scaleFactor, this$1$1._li);
	      var isNodeAdded = this$1$1._pointSnapper.snap(hotPixel, e, i);
	      if (isNodeAdded) {
	        e.addIntersection(pts0[i], i);
	      }
	    }
	  }
	};
	MCIndexSnapRounder.prototype.computeNodes = function computeNodes (inputSegmentStrings) {
	  this._nodedSegStrings = inputSegmentStrings;
	  this._noder = new MCIndexNoder();
	  this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
	  this.snapRound(inputSegmentStrings, this._li);
	};
	MCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps (snapPts) {
	    var this$1$1 = this;

	  for (var it = snapPts.iterator(); it.hasNext();) {
	    var snapPt = it.next();
	    var hotPixel = new HotPixel(snapPt, this$1$1._scaleFactor, this$1$1._li);
	    this$1$1._pointSnapper.snap(hotPixel);
	  }
	};
	MCIndexSnapRounder.prototype.interfaces_ = function interfaces_ () {
	  return [Noder]
	};
	MCIndexSnapRounder.prototype.getClass = function getClass () {
	  return MCIndexSnapRounder
	};

	var BufferOp = function BufferOp () {
	  this._argGeom = null;
	  this._distance = null;
	  this._bufParams = new BufferParameters();
	  this._resultGeometry = null;
	  this._saveException = null;
	  if (arguments.length === 1) {
	    var g = arguments[0];
	    this._argGeom = g;
	  } else if (arguments.length === 2) {
	    var g$1 = arguments[0];
	    var bufParams = arguments[1];
	    this._argGeom = g$1;
	    this._bufParams = bufParams;
	  }
	};

	var staticAccessors$32 = { CAP_ROUND: { configurable: true },CAP_BUTT: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },MAX_PRECISION_DIGITS: { configurable: true } };
	BufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision (fixedPM) {
	  var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());
	  var bufBuilder = new BufferBuilder(this._bufParams);
	  bufBuilder.setWorkingPrecisionModel(fixedPM);
	  bufBuilder.setNoder(noder);
	  this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
	};
	BufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
	      try {
	        this$1$1.bufferReducedPrecision(precDigits);
	      } catch (ex) {
	        if (ex instanceof TopologyException) {
	          this$1$1._saveException = ex;
	        } else { throw ex }
	      } finally {}
	      if (this$1$1._resultGeometry !== null) { return null }
	    }
	    throw this._saveException
	  } else if (arguments.length === 1) {
	    var precisionDigits = arguments[0];
	    var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
	    var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
	    this.bufferFixedPrecision(fixedPM);
	  }
	};
	BufferOp.prototype.computeGeometry = function computeGeometry () {
	  this.bufferOriginalPrecision();
	  if (this._resultGeometry !== null) { return null }
	  var argPM = this._argGeom.getFactory().getPrecisionModel();
	  if (argPM.getType() === PrecisionModel.FIXED) { this.bufferFixedPrecision(argPM); } else { this.bufferReducedPrecision(); }
	};
	BufferOp.prototype.setQuadrantSegments = function setQuadrantSegments (quadrantSegments) {
	  this._bufParams.setQuadrantSegments(quadrantSegments);
	};
	BufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision () {
	  try {
	    var bufBuilder = new BufferBuilder(this._bufParams);
	    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
	  } catch (ex) {
	    if (ex instanceof RuntimeException) {
	      this._saveException = ex;
	    } else { throw ex }
	  } finally {}
	};
	BufferOp.prototype.getResultGeometry = function getResultGeometry (distance) {
	  this._distance = distance;
	  this.computeGeometry();
	  return this._resultGeometry
	};
	BufferOp.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {
	  this._bufParams.setEndCapStyle(endCapStyle);
	};
	BufferOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferOp.prototype.getClass = function getClass () {
	  return BufferOp
	};
	BufferOp.bufferOp = function bufferOp () {
	  if (arguments.length === 2) {
	    var g = arguments[0];
	    var distance = arguments[1];
	    var gBuf = new BufferOp(g);
	    var geomBuf = gBuf.getResultGeometry(distance);
	    return geomBuf
	  } else if (arguments.length === 3) {
	    if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
	      var g$1 = arguments[0];
	      var distance$1 = arguments[1];
	      var quadrantSegments = arguments[2];
	      var bufOp = new BufferOp(g$1);
	      bufOp.setQuadrantSegments(quadrantSegments);
	      var geomBuf$1 = bufOp.getResultGeometry(distance$1);
	      return geomBuf$1
	    } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
	      var g$2 = arguments[0];
	      var distance$2 = arguments[1];
	      var params = arguments[2];
	      var bufOp$1 = new BufferOp(g$2, params);
	      var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);
	      return geomBuf$2
	    }
	  } else if (arguments.length === 4) {
	    var g$3 = arguments[0];
	    var distance$3 = arguments[1];
	    var quadrantSegments$1 = arguments[2];
	    var endCapStyle = arguments[3];
	    var bufOp$2 = new BufferOp(g$3);
	    bufOp$2.setQuadrantSegments(quadrantSegments$1);
	    bufOp$2.setEndCapStyle(endCapStyle);
	    var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);
	    return geomBuf$3
	  }
	};
	BufferOp.precisionScaleFactor = function precisionScaleFactor (g, distance, maxPrecisionDigits) {
	  var env = g.getEnvelopeInternal();
	  var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
	  var expandByDistance = distance > 0.0 ? distance : 0.0;
	  var bufEnvMax = envMax + 2 * expandByDistance;
	  var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
	  var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
	  var scaleFactor = Math.pow(10.0, minUnitLog10);
	  return scaleFactor
	};
	staticAccessors$32.CAP_ROUND.get = function () { return BufferParameters.CAP_ROUND };
	staticAccessors$32.CAP_BUTT.get = function () { return BufferParameters.CAP_FLAT };
	staticAccessors$32.CAP_FLAT.get = function () { return BufferParameters.CAP_FLAT };
	staticAccessors$32.CAP_SQUARE.get = function () { return BufferParameters.CAP_SQUARE };
	staticAccessors$32.MAX_PRECISION_DIGITS.get = function () { return 12 };

	Object.defineProperties( BufferOp, staticAccessors$32 );

	var PointPairDistance = function PointPairDistance () {
	  this._pt = [new Coordinate(), new Coordinate()];
	  this._distance = Double.NaN;
	  this._isNull = true;
	};
	PointPairDistance.prototype.getCoordinates = function getCoordinates () {
	  return this._pt
	};
	PointPairDistance.prototype.getCoordinate = function getCoordinate (i) {
	  return this._pt[i]
	};
	PointPairDistance.prototype.setMinimum = function setMinimum () {
	  if (arguments.length === 1) {
	    var ptDist = arguments[0];
	    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    if (this._isNull) {
	      this.initialize(p0, p1);
	      return null
	    }
	    var dist = p0.distance(p1);
	    if (dist < this._distance) { this.initialize(p0, p1, dist); }
	  }
	};
	PointPairDistance.prototype.initialize = function initialize () {
	  if (arguments.length === 0) {
	    this._isNull = true;
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    this._pt[0].setCoordinate(p0);
	    this._pt[1].setCoordinate(p1);
	    this._distance = p0.distance(p1);
	    this._isNull = false;
	  } else if (arguments.length === 3) {
	    var p0$1 = arguments[0];
	    var p1$1 = arguments[1];
	    var distance = arguments[2];
	    this._pt[0].setCoordinate(p0$1);
	    this._pt[1].setCoordinate(p1$1);
	    this._distance = distance;
	    this._isNull = false;
	  }
	};
	PointPairDistance.prototype.getDistance = function getDistance () {
	  return this._distance
	};
	PointPairDistance.prototype.setMaximum = function setMaximum () {
	  if (arguments.length === 1) {
	    var ptDist = arguments[0];
	    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    if (this._isNull) {
	      this.initialize(p0, p1);
	      return null
	    }
	    var dist = p0.distance(p1);
	    if (dist > this._distance) { this.initialize(p0, p1, dist); }
	  }
	};
	PointPairDistance.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PointPairDistance.prototype.getClass = function getClass () {
	  return PointPairDistance
	};

	var DistanceToPointFinder = function DistanceToPointFinder () {};

	DistanceToPointFinder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	DistanceToPointFinder.prototype.getClass = function getClass () {
	  return DistanceToPointFinder
	};
	DistanceToPointFinder.computeDistance = function computeDistance () {
	  if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString$1 && arguments[1] instanceof Coordinate)) {
	    var line = arguments[0];
	    var pt = arguments[1];
	    var ptDist = arguments[2];
	    var coords = line.getCoordinates();
	    var tempSegment = new LineSegment();
	    for (var i = 0; i < coords.length - 1; i++) {
	      tempSegment.setCoordinates(coords[i], coords[i + 1]);
	      var closestPt = tempSegment.closestPoint(pt);
	      ptDist.setMinimum(closestPt, pt);
	    }
	  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
	    var poly = arguments[0];
	    var pt$1 = arguments[1];
	    var ptDist$1 = arguments[2];
	    DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
	    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
	      DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
	    }
	  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
	    var geom = arguments[0];
	    var pt$2 = arguments[1];
	    var ptDist$2 = arguments[2];
	    if (geom instanceof LineString$1) {
	      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
	    } else if (geom instanceof Polygon) {
	      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
	    } else if (geom instanceof GeometryCollection) {
	      var gc = geom;
	      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
	        var g = gc.getGeometryN(i$2);
	        DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);
	      }
	    } else {
	      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
	    }
	  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
	    var segment = arguments[0];
	    var pt$3 = arguments[1];
	    var ptDist$3 = arguments[2];
	    var closestPt$1 = segment.closestPoint(pt$3);
	    ptDist$3.setMinimum(closestPt$1, pt$3);
	  }
	};

	var BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder (inputGeom) {
	  this._maxPtDist = new PointPairDistance();
	  this._inputGeom = inputGeom || null;
	};

	var staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true },MaxMidpointDistanceFilter: { configurable: true } };
	BufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance (curve) {
	  var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);
	  curve.apply(distFilter);
	  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
	};
	BufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance (curve) {
	  var distFilter = new MaxPointDistanceFilter(this._inputGeom);
	  curve.apply(distFilter);
	  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
	};
	BufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance (bufferCurve) {
	  this.computeMaxVertexDistance(bufferCurve);
	  this.computeMaxMidpointDistance(bufferCurve);
	  return this._maxPtDist.getDistance()
	};
	BufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints () {
	  return this._maxPtDist
	};
	BufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferCurveMaximumDistanceFinder.prototype.getClass = function getClass () {
	  return BufferCurveMaximumDistanceFinder
	};
	staticAccessors$36.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter };
	staticAccessors$36.MaxMidpointDistanceFilter.get = function () { return MaxMidpointDistanceFilter };

	Object.defineProperties( BufferCurveMaximumDistanceFinder, staticAccessors$36 );

	var MaxPointDistanceFilter = function MaxPointDistanceFilter (geom) {
	  this._maxPtDist = new PointPairDistance();
	  this._minPtDist = new PointPairDistance();
	  this._geom = geom || null;
	};
	MaxPointDistanceFilter.prototype.filter = function filter (pt) {
	  this._minPtDist.initialize();
	  DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);
	  this._maxPtDist.setMaximum(this._minPtDist);
	};
	MaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {
	  return this._maxPtDist
	};
	MaxPointDistanceFilter.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateFilter]
	};
	MaxPointDistanceFilter.prototype.getClass = function getClass () {
	  return MaxPointDistanceFilter
	};

	var MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter (geom) {
	  this._maxPtDist = new PointPairDistance();
	  this._minPtDist = new PointPairDistance();
	  this._geom = geom || null;
	};
	MaxMidpointDistanceFilter.prototype.filter = function filter (seq, index) {
	  if (index === 0) { return null }
	  var p0 = seq.getCoordinate(index - 1);
	  var p1 = seq.getCoordinate(index);
	  var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
	  this._minPtDist.initialize();
	  DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);
	  this._maxPtDist.setMaximum(this._minPtDist);
	};
	MaxMidpointDistanceFilter.prototype.isDone = function isDone () {
	  return false
	};
	MaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {
	  return false
	};
	MaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {
	  return this._maxPtDist
	};
	MaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateSequenceFilter]
	};
	MaxMidpointDistanceFilter.prototype.getClass = function getClass () {
	  return MaxMidpointDistanceFilter
	};

	var PolygonExtracter = function PolygonExtracter (comps) {
	  this._comps = comps || null;
	};
	PolygonExtracter.prototype.filter = function filter (geom) {
	  if (geom instanceof Polygon) { this._comps.add(geom); }
	};
	PolygonExtracter.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryFilter]
	};
	PolygonExtracter.prototype.getClass = function getClass () {
	  return PolygonExtracter
	};
	PolygonExtracter.getPolygons = function getPolygons () {
	  if (arguments.length === 1) {
	    var geom = arguments[0];
	    return PolygonExtracter.getPolygons(geom, new ArrayList())
	  } else if (arguments.length === 2) {
	    var geom$1 = arguments[0];
	    var list = arguments[1];
	    if (geom$1 instanceof Polygon) {
	      list.add(geom$1);
	    } else if (geom$1 instanceof GeometryCollection) {
	      geom$1.apply(new PolygonExtracter(list));
	    }
	    return list
	  }
	};

	var LinearComponentExtracter = function LinearComponentExtracter () {
	  this._lines = null;
	  this._isForcedToLineString = false;
	  if (arguments.length === 1) {
	    var lines = arguments[0];
	    this._lines = lines;
	  } else if (arguments.length === 2) {
	    var lines$1 = arguments[0];
	    var isForcedToLineString = arguments[1];
	    this._lines = lines$1;
	    this._isForcedToLineString = isForcedToLineString;
	  }
	};
	LinearComponentExtracter.prototype.filter = function filter (geom) {
	  if (this._isForcedToLineString && geom instanceof LinearRing) {
	    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
	    this._lines.add(line);
	    return null
	  }
	  if (geom instanceof LineString$1) { this._lines.add(geom); }
	};
	LinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString (isForcedToLineString) {
	  this._isForcedToLineString = isForcedToLineString;
	};
	LinearComponentExtracter.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryComponentFilter]
	};
	LinearComponentExtracter.prototype.getClass = function getClass () {
	  return LinearComponentExtracter
	};
	LinearComponentExtracter.getGeometry = function getGeometry () {
	  if (arguments.length === 1) {
	    var geom = arguments[0];
	    return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom))
	  } else if (arguments.length === 2) {
	    var geom$1 = arguments[0];
	    var forceToLineString = arguments[1];
	    return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString))
	  }
	};
	LinearComponentExtracter.getLines = function getLines () {
	  if (arguments.length === 1) {
	    var geom = arguments[0];
	    return LinearComponentExtracter.getLines(geom, false)
	  } else if (arguments.length === 2) {
	    if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
	      var geoms = arguments[0];
	      var lines$1 = arguments[1];
	      for (var i = geoms.iterator(); i.hasNext();) {
	        var g = i.next();
	        LinearComponentExtracter.getLines(g, lines$1);
	      }
	      return lines$1
	    } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {
	      var geom$1 = arguments[0];
	      var forceToLineString = arguments[1];
	      var lines = new ArrayList();
	      geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));
	      return lines
	    } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
	      var geom$2 = arguments[0];
	      var lines$2 = arguments[1];
	      if (geom$2 instanceof LineString$1) {
	        lines$2.add(geom$2);
	      } else {
	        geom$2.apply(new LinearComponentExtracter(lines$2));
	      }
	      return lines$2
	    }
	  } else if (arguments.length === 3) {
	    if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {
	      var geoms$1 = arguments[0];
	      var lines$3 = arguments[1];
	      var forceToLineString$1 = arguments[2];
	      for (var i$1 = geoms$1.iterator(); i$1.hasNext();) {
	        var g$1 = i$1.next();
	        LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);
	      }
	      return lines$3
	    } else if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {
	      var geom$3 = arguments[0];
	      var lines$4 = arguments[1];
	      var forceToLineString$2 = arguments[2];
	      geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));
	      return lines$4
	    }
	  }
	};

	var PointLocator = function PointLocator () {
	  this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
	  this._isIn = null;
	  this._numBoundaries = null;
	  if (arguments.length === 0) ; else if (arguments.length === 1) {
	    var boundaryRule = arguments[0];
	    if (boundaryRule === null) { throw new IllegalArgumentException() }
	    this._boundaryRule = boundaryRule;
	  }
	};
	PointLocator.prototype.locateInternal = function locateInternal () {
	    var this$1$1 = this;

	  if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {
	    var p = arguments[0];
	    var poly = arguments[1];
	    if (poly.isEmpty()) { return Location.EXTERIOR }
	    var shell = poly.getExteriorRing();
	    var shellLoc = this.locateInPolygonRing(p, shell);
	    if (shellLoc === Location.EXTERIOR) { return Location.EXTERIOR }
	    if (shellLoc === Location.BOUNDARY) { return Location.BOUNDARY }
	    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
	      var hole = poly.getInteriorRingN(i);
	      var holeLoc = this$1$1.locateInPolygonRing(p, hole);
	      if (holeLoc === Location.INTERIOR) { return Location.EXTERIOR }
	      if (holeLoc === Location.BOUNDARY) { return Location.BOUNDARY }
	    }
	    return Location.INTERIOR
	  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString$1) {
	    var p$1 = arguments[0];
	    var l = arguments[1];
	    if (!l.getEnvelopeInternal().intersects(p$1)) { return Location.EXTERIOR }
	    var pt = l.getCoordinates();
	    if (!l.isClosed()) {
	      if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {
	        return Location.BOUNDARY
	      }
	    }
	    if (CGAlgorithms.isOnLine(p$1, pt)) { return Location.INTERIOR }
	    return Location.EXTERIOR
	  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {
	    var p$2 = arguments[0];
	    var pt$1 = arguments[1];
	    var ptCoord = pt$1.getCoordinate();
	    if (ptCoord.equals2D(p$2)) { return Location.INTERIOR }
	    return Location.EXTERIOR
	  }
	};
	PointLocator.prototype.locateInPolygonRing = function locateInPolygonRing (p, ring) {
	  if (!ring.getEnvelopeInternal().intersects(p)) { return Location.EXTERIOR }
	  return CGAlgorithms.locatePointInRing(p, ring.getCoordinates())
	};
	PointLocator.prototype.intersects = function intersects (p, geom) {
	  return this.locate(p, geom) !== Location.EXTERIOR
	};
	PointLocator.prototype.updateLocationInfo = function updateLocationInfo (loc) {
	  if (loc === Location.INTERIOR) { this._isIn = true; }
	  if (loc === Location.BOUNDARY) { this._numBoundaries++; }
	};
	PointLocator.prototype.computeLocation = function computeLocation (p, geom) {
	    var this$1$1 = this;

	  if (geom instanceof Point) {
	    this.updateLocationInfo(this.locateInternal(p, geom));
	  }
	  if (geom instanceof LineString$1) {
	    this.updateLocationInfo(this.locateInternal(p, geom));
	  } else if (geom instanceof Polygon) {
	    this.updateLocationInfo(this.locateInternal(p, geom));
	  } else if (geom instanceof MultiLineString) {
	    var ml = geom;
	    for (var i = 0; i < ml.getNumGeometries(); i++) {
	      var l = ml.getGeometryN(i);
	      this$1$1.updateLocationInfo(this$1$1.locateInternal(p, l));
	    }
	  } else if (geom instanceof MultiPolygon) {
	    var mpoly = geom;
	    for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {
	      var poly = mpoly.getGeometryN(i$1);
	      this$1$1.updateLocationInfo(this$1$1.locateInternal(p, poly));
	    }
	  } else if (geom instanceof GeometryCollection) {
	    var geomi = new GeometryCollectionIterator(geom);
	    while (geomi.hasNext()) {
	      var g2 = geomi.next();
	      if (g2 !== geom) { this$1$1.computeLocation(p, g2); }
	    }
	  }
	};
	PointLocator.prototype.locate = function locate (p, geom) {
	  if (geom.isEmpty()) { return Location.EXTERIOR }
	  if (geom instanceof LineString$1) {
	    return this.locateInternal(p, geom)
	  } else if (geom instanceof Polygon) {
	    return this.locateInternal(p, geom)
	  }
	  this._isIn = false;
	  this._numBoundaries = 0;
	  this.computeLocation(p, geom);
	  if (this._boundaryRule.isInBoundary(this._numBoundaries)) { return Location.BOUNDARY }
	  if (this._numBoundaries > 0 || this._isIn) { return Location.INTERIOR }
	  return Location.EXTERIOR
	};
	PointLocator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PointLocator.prototype.getClass = function getClass () {
	  return PointLocator
	};

	var GeometryLocation = function GeometryLocation () {
	  this._component = null;
	  this._segIndex = null;
	  this._pt = null;
	  if (arguments.length === 2) {
	    var component = arguments[0];
	    var pt = arguments[1];
	    GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);
	  } else if (arguments.length === 3) {
	    var component$1 = arguments[0];
	    var segIndex = arguments[1];
	    var pt$1 = arguments[2];
	    this._component = component$1;
	    this._segIndex = segIndex;
	    this._pt = pt$1;
	  }
	};

	var staticAccessors$38 = { INSIDE_AREA: { configurable: true } };
	GeometryLocation.prototype.isInsideArea = function isInsideArea () {
	  return this._segIndex === GeometryLocation.INSIDE_AREA
	};
	GeometryLocation.prototype.getCoordinate = function getCoordinate () {
	  return this._pt
	};
	GeometryLocation.prototype.getGeometryComponent = function getGeometryComponent () {
	  return this._component
	};
	GeometryLocation.prototype.getSegmentIndex = function getSegmentIndex () {
	  return this._segIndex
	};
	GeometryLocation.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryLocation.prototype.getClass = function getClass () {
	  return GeometryLocation
	};
	staticAccessors$38.INSIDE_AREA.get = function () { return -1 };

	Object.defineProperties( GeometryLocation, staticAccessors$38 );

	var PointExtracter = function PointExtracter (pts) {
	  this._pts = pts || null;
	};
	PointExtracter.prototype.filter = function filter (geom) {
	  if (geom instanceof Point) { this._pts.add(geom); }
	};
	PointExtracter.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryFilter]
	};
	PointExtracter.prototype.getClass = function getClass () {
	  return PointExtracter
	};
	PointExtracter.getPoints = function getPoints () {
	  if (arguments.length === 1) {
	    var geom = arguments[0];
	    if (geom instanceof Point) {
	      return Collections.singletonList(geom)
	    }
	    return PointExtracter.getPoints(geom, new ArrayList())
	  } else if (arguments.length === 2) {
	    var geom$1 = arguments[0];
	    var list = arguments[1];
	    if (geom$1 instanceof Point) {
	      list.add(geom$1);
	    } else if (geom$1 instanceof GeometryCollection) {
	      geom$1.apply(new PointExtracter(list));
	    }
	    return list
	  }
	};

	var ConnectedElementLocationFilter = function ConnectedElementLocationFilter () {
	  this._locations = null;
	  var locations = arguments[0];
	  this._locations = locations;
	};
	ConnectedElementLocationFilter.prototype.filter = function filter (geom) {
	  if (geom instanceof Point || geom instanceof LineString$1 || geom instanceof Polygon) { this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate())); }
	};
	ConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryFilter]
	};
	ConnectedElementLocationFilter.prototype.getClass = function getClass () {
	  return ConnectedElementLocationFilter
	};
	ConnectedElementLocationFilter.getLocations = function getLocations (geom) {
	  var locations = new ArrayList();
	  geom.apply(new ConnectedElementLocationFilter(locations));
	  return locations
	};

	var DistanceOp = function DistanceOp () {
	  this._geom = null;
	  this._terminateDistance = 0.0;
	  this._ptLocator = new PointLocator();
	  this._minDistanceLocation = null;
	  this._minDistance = Double.MAX_VALUE;
	  if (arguments.length === 2) {
	    var g0 = arguments[0];
	    var g1 = arguments[1];
	    this._geom = [g0, g1];
	    this._terminateDistance = 0.0;
	  } else if (arguments.length === 3) {
	    var g0$1 = arguments[0];
	    var g1$1 = arguments[1];
	    var terminateDistance = arguments[2];
	    this._geom = new Array(2).fill(null);
	    this._geom[0] = g0$1;
	    this._geom[1] = g1$1;
	    this._terminateDistance = terminateDistance;
	  }
	};
	DistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    var locPtPoly = new Array(2).fill(null);
	    this.computeContainmentDistance(0, locPtPoly);
	    if (this._minDistance <= this._terminateDistance) { return null }
	    this.computeContainmentDistance(1, locPtPoly);
	  } else if (arguments.length === 2) {
	    var polyGeomIndex = arguments[0];
	    var locPtPoly$1 = arguments[1];
	    var locationsIndex = 1 - polyGeomIndex;
	    var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);
	    if (polys.size() > 0) {
	      var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
	      this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);
	      if (this._minDistance <= this._terminateDistance) {
	        this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];
	        this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];
	        return null
	      }
	    }
	  } else if (arguments.length === 3) {
	    if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
	      var locs = arguments[0];
	      var polys$1 = arguments[1];
	      var locPtPoly$2 = arguments[2];
	      for (var i = 0; i < locs.size(); i++) {
	        var loc = locs.get(i);
	        for (var j = 0; j < polys$1.size(); j++) {
	          this$1$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);
	          if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
	        }
	      }
	    } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {
	      var ptLoc = arguments[0];
	      var poly = arguments[1];
	      var locPtPoly$3 = arguments[2];
	      var pt = ptLoc.getCoordinate();
	      if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
	        this._minDistance = 0.0;
	        locPtPoly$3[0] = ptLoc;
	        locPtPoly$3[1] = new GeometryLocation(poly, pt);

	        return null
	      }
	    }
	  }
	};
	DistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints (lines, points, locGeom) {
	    var this$1$1 = this;

	  for (var i = 0; i < lines.size(); i++) {
	    var line = lines.get(i);
	    for (var j = 0; j < points.size(); j++) {
	      var pt = points.get(j);
	      this$1$1.computeMinDistance(line, pt, locGeom);
	      if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
	    }
	  }
	};
	DistanceOp.prototype.computeFacetDistance = function computeFacetDistance () {
	  var locGeom = new Array(2).fill(null);
	  var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
	  var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
	  var pts0 = PointExtracter.getPoints(this._geom[0]);
	  var pts1 = PointExtracter.getPoints(this._geom[1]);
	  this.computeMinDistanceLines(lines0, lines1, locGeom);
	  this.updateMinDistance(locGeom, false);
	  if (this._minDistance <= this._terminateDistance) { return null }
	  locGeom[0] = null;
	  locGeom[1] = null;
	  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
	  this.updateMinDistance(locGeom, false);
	  if (this._minDistance <= this._terminateDistance) { return null }
	  locGeom[0] = null;
	  locGeom[1] = null;
	  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
	  this.updateMinDistance(locGeom, true);
	  if (this._minDistance <= this._terminateDistance) { return null }
	  locGeom[0] = null;
	  locGeom[1] = null;
	  this.computeMinDistancePoints(pts0, pts1, locGeom);
	  this.updateMinDistance(locGeom, false);
	};
	DistanceOp.prototype.nearestLocations = function nearestLocations () {
	  this.computeMinDistance();
	  return this._minDistanceLocation
	};
	DistanceOp.prototype.updateMinDistance = function updateMinDistance (locGeom, flip) {
	  if (locGeom[0] === null) { return null }
	  if (flip) {
	    this._minDistanceLocation[0] = locGeom[1];
	    this._minDistanceLocation[1] = locGeom[0];
	  } else {
	    this._minDistanceLocation[0] = locGeom[0];
	    this._minDistanceLocation[1] = locGeom[1];
	  }
	};
	DistanceOp.prototype.nearestPoints = function nearestPoints () {
	  this.computeMinDistance();
	  var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
	  return nearestPts
	};
	DistanceOp.prototype.computeMinDistance = function computeMinDistance () {
	    var this$1$1 = this;

	  if (arguments.length === 0) {
	    if (this._minDistanceLocation !== null) { return null }
	    this._minDistanceLocation = new Array(2).fill(null);
	    this.computeContainmentDistance();
	    if (this._minDistance <= this._terminateDistance) { return null }
	    this.computeFacetDistance();
	  } else if (arguments.length === 3) {
	    if (arguments[2] instanceof Array && (arguments[0] instanceof LineString$1 && arguments[1] instanceof Point)) {
	      var line = arguments[0];
	      var pt = arguments[1];
	      var locGeom = arguments[2];
	      if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) { return null }
	      var coord0 = line.getCoordinates();
	      var coord = pt.getCoordinate();
	      for (var i = 0; i < coord0.length - 1; i++) {
	        var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
	        if (dist < this$1$1._minDistance) {
	          this$1$1._minDistance = dist;
	          var seg = new LineSegment(coord0[i], coord0[i + 1]);
	          var segClosestPoint = seg.closestPoint(coord);
	          locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
	          locGeom[1] = new GeometryLocation(pt, 0, coord);
	        }
	        if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
	      }
	    } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString$1 && arguments[1] instanceof LineString$1)) {
	      var line0 = arguments[0];
	      var line1 = arguments[1];
	      var locGeom$1 = arguments[2];
	      if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) { return null }
	      var coord0$1 = line0.getCoordinates();
	      var coord1 = line1.getCoordinates();
	      for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {
	        for (var j = 0; j < coord1.length - 1; j++) {
	          var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);
	          if (dist$1 < this$1$1._minDistance) {
	            this$1$1._minDistance = dist$1;
	            var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);
	            var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
	            var closestPt = seg0.closestPoints(seg1);
	            locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);
	            locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);
	          }
	          if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
	        }
	      }
	    }
	  }
	};
	DistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints (points0, points1, locGeom) {
	    var this$1$1 = this;

	  for (var i = 0; i < points0.size(); i++) {
	    var pt0 = points0.get(i);
	    for (var j = 0; j < points1.size(); j++) {
	      var pt1 = points1.get(j);
	      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
	      if (dist < this$1$1._minDistance) {
	        this$1$1._minDistance = dist;
	        locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());
	        locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());
	      }
	      if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
	    }
	  }
	};
	DistanceOp.prototype.distance = function distance () {
	  if (this._geom[0] === null || this._geom[1] === null) { throw new IllegalArgumentException() }
	  if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) { return 0.0 }
	  this.computeMinDistance();
	  return this._minDistance
	};
	DistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines (lines0, lines1, locGeom) {
	    var this$1$1 = this;

	  for (var i = 0; i < lines0.size(); i++) {
	    var line0 = lines0.get(i);
	    for (var j = 0; j < lines1.size(); j++) {
	      var line1 = lines1.get(j);
	      this$1$1.computeMinDistance(line0, line1, locGeom);
	      if (this$1$1._minDistance <= this$1$1._terminateDistance) { return null }
	    }
	  }
	};
	DistanceOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	DistanceOp.prototype.getClass = function getClass () {
	  return DistanceOp
	};
	DistanceOp.distance = function distance (g0, g1) {
	  var distOp = new DistanceOp(g0, g1);
	  return distOp.distance()
	};
	DistanceOp.isWithinDistance = function isWithinDistance (g0, g1, distance) {
	  var distOp = new DistanceOp(g0, g1, distance);
	  return distOp.distance() <= distance
	};
	DistanceOp.nearestPoints = function nearestPoints (g0, g1) {
	  var distOp = new DistanceOp(g0, g1);
	  return distOp.nearestPoints()
	};

	var PointPairDistance$2 = function PointPairDistance () {
	  this._pt = [new Coordinate(), new Coordinate()];
	  this._distance = Double.NaN;
	  this._isNull = true;
	};
	PointPairDistance$2.prototype.getCoordinates = function getCoordinates () {
	  return this._pt
	};
	PointPairDistance$2.prototype.getCoordinate = function getCoordinate (i) {
	  return this._pt[i]
	};
	PointPairDistance$2.prototype.setMinimum = function setMinimum () {
	  if (arguments.length === 1) {
	    var ptDist = arguments[0];
	    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    if (this._isNull) {
	      this.initialize(p0, p1);
	      return null
	    }
	    var dist = p0.distance(p1);
	    if (dist < this._distance) { this.initialize(p0, p1, dist); }
	  }
	};
	PointPairDistance$2.prototype.initialize = function initialize () {
	  if (arguments.length === 0) {
	    this._isNull = true;
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    this._pt[0].setCoordinate(p0);
	    this._pt[1].setCoordinate(p1);
	    this._distance = p0.distance(p1);
	    this._isNull = false;
	  } else if (arguments.length === 3) {
	    var p0$1 = arguments[0];
	    var p1$1 = arguments[1];
	    var distance = arguments[2];
	    this._pt[0].setCoordinate(p0$1);
	    this._pt[1].setCoordinate(p1$1);
	    this._distance = distance;
	    this._isNull = false;
	  }
	};
	PointPairDistance$2.prototype.toString = function toString () {
	  return WKTWriter.toLineString(this._pt[0], this._pt[1])
	};
	PointPairDistance$2.prototype.getDistance = function getDistance () {
	  return this._distance
	};
	PointPairDistance$2.prototype.setMaximum = function setMaximum () {
	  if (arguments.length === 1) {
	    var ptDist = arguments[0];
	    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
	  } else if (arguments.length === 2) {
	    var p0 = arguments[0];
	    var p1 = arguments[1];
	    if (this._isNull) {
	      this.initialize(p0, p1);
	      return null
	    }
	    var dist = p0.distance(p1);
	    if (dist > this._distance) { this.initialize(p0, p1, dist); }
	  }
	};
	PointPairDistance$2.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PointPairDistance$2.prototype.getClass = function getClass () {
	  return PointPairDistance$2
	};

	var DistanceToPoint = function DistanceToPoint () {};

	DistanceToPoint.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	DistanceToPoint.prototype.getClass = function getClass () {
	  return DistanceToPoint
	};
	DistanceToPoint.computeDistance = function computeDistance () {
	  if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString$1 && arguments[1] instanceof Coordinate)) {
	    var line = arguments[0];
	    var pt = arguments[1];
	    var ptDist = arguments[2];
	    var tempSegment = new LineSegment();
	    var coords = line.getCoordinates();
	    for (var i = 0; i < coords.length - 1; i++) {
	      tempSegment.setCoordinates(coords[i], coords[i + 1]);
	      var closestPt = tempSegment.closestPoint(pt);
	      ptDist.setMinimum(closestPt, pt);
	    }
	  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
	    var poly = arguments[0];
	    var pt$1 = arguments[1];
	    var ptDist$1 = arguments[2];
	    DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
	    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
	      DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
	    }
	  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
	    var geom = arguments[0];
	    var pt$2 = arguments[1];
	    var ptDist$2 = arguments[2];
	    if (geom instanceof LineString$1) {
	      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
	    } else if (geom instanceof Polygon) {
	      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
	    } else if (geom instanceof GeometryCollection) {
	      var gc = geom;
	      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
	        var g = gc.getGeometryN(i$2);
	        DistanceToPoint.computeDistance(g, pt$2, ptDist$2);
	      }
	    } else {
	      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
	    }
	  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
	    var segment = arguments[0];
	    var pt$3 = arguments[1];
	    var ptDist$3 = arguments[2];
	    var closestPt$1 = segment.closestPoint(pt$3);
	    ptDist$3.setMinimum(closestPt$1, pt$3);
	  }
	};

	var DiscreteHausdorffDistance = function DiscreteHausdorffDistance () {
	  this._g0 = null;
	  this._g1 = null;
	  this._ptDist = new PointPairDistance$2();
	  this._densifyFrac = 0.0;
	  var g0 = arguments[0];
	  var g1 = arguments[1];
	  this._g0 = g0;
	  this._g1 = g1;
	};

	var staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true },MaxDensifiedByFractionDistanceFilter: { configurable: true } };
	DiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates () {
	  return this._ptDist.getCoordinates()
	};
	DiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction (densifyFrac) {
	  if (densifyFrac > 1.0 || densifyFrac <= 0.0) { throw new IllegalArgumentException() }
	  this._densifyFrac = densifyFrac;
	};
	DiscreteHausdorffDistance.prototype.compute = function compute (g0, g1) {
	  this.computeOrientedDistance(g0, g1, this._ptDist);
	  this.computeOrientedDistance(g1, g0, this._ptDist);
	};
	DiscreteHausdorffDistance.prototype.distance = function distance () {
	  this.compute(this._g0, this._g1);
	  return this._ptDist.getDistance()
	};
	DiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance (discreteGeom, geom, ptDist) {
	  var distFilter = new MaxPointDistanceFilter$1(geom);
	  discreteGeom.apply(distFilter);
	  ptDist.setMaximum(distFilter.getMaxPointDistance());
	  if (this._densifyFrac > 0) {
	    var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
	    discreteGeom.apply(fracFilter);
	    ptDist.setMaximum(fracFilter.getMaxPointDistance());
	  }
	};
	DiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance () {
	  this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
	  return this._ptDist.getDistance()
	};
	DiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	DiscreteHausdorffDistance.prototype.getClass = function getClass () {
	  return DiscreteHausdorffDistance
	};
	DiscreteHausdorffDistance.distance = function distance () {
	  if (arguments.length === 2) {
	    var g0 = arguments[0];
	    var g1 = arguments[1];
	    var dist = new DiscreteHausdorffDistance(g0, g1);
	    return dist.distance()
	  } else if (arguments.length === 3) {
	    var g0$1 = arguments[0];
	    var g1$1 = arguments[1];
	    var densifyFrac = arguments[2];
	    var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);
	    dist$1.setDensifyFraction(densifyFrac);
	    return dist$1.distance()
	  }
	};
	staticAccessors$39.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter$1 };
	staticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function () { return MaxDensifiedByFractionDistanceFilter };

	Object.defineProperties( DiscreteHausdorffDistance, staticAccessors$39 );

	var MaxPointDistanceFilter$1 = function MaxPointDistanceFilter () {
	  this._maxPtDist = new PointPairDistance$2();
	  this._minPtDist = new PointPairDistance$2();
	  this._euclideanDist = new DistanceToPoint();
	  this._geom = null;
	  var geom = arguments[0];
	  this._geom = geom;
	};
	MaxPointDistanceFilter$1.prototype.filter = function filter (pt) {
	  this._minPtDist.initialize();
	  DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
	  this._maxPtDist.setMaximum(this._minPtDist);
	};
	MaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance () {
	  return this._maxPtDist
	};
	MaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateFilter]
	};
	MaxPointDistanceFilter$1.prototype.getClass = function getClass () {
	  return MaxPointDistanceFilter$1
	};

	var MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter () {
	  this._maxPtDist = new PointPairDistance$2();
	  this._minPtDist = new PointPairDistance$2();
	  this._geom = null;
	  this._numSubSegs = 0;
	  var geom = arguments[0];
	  var fraction = arguments[1];
	  this._geom = geom;
	  this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));
	};
	MaxDensifiedByFractionDistanceFilter.prototype.filter = function filter (seq, index) {
	    var this$1$1 = this;

	  if (index === 0) { return null }
	  var p0 = seq.getCoordinate(index - 1);
	  var p1 = seq.getCoordinate(index);
	  var delx = (p1.x - p0.x) / this._numSubSegs;
	  var dely = (p1.y - p0.y) / this._numSubSegs;
	  for (var i = 0; i < this._numSubSegs; i++) {
	    var x = p0.x + i * delx;
	    var y = p0.y + i * dely;
	    var pt = new Coordinate(x, y);
	    this$1$1._minPtDist.initialize();
	    DistanceToPoint.computeDistance(this$1$1._geom, pt, this$1$1._minPtDist);
	    this$1$1._maxPtDist.setMaximum(this$1$1._minPtDist);
	  }
	};
	MaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone () {
	  return false
	};
	MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {
	  return false
	};
	MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {
	  return this._maxPtDist
	};
	MaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateSequenceFilter]
	};
	MaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass () {
	  return MaxDensifiedByFractionDistanceFilter
	};

	var BufferDistanceValidator = function BufferDistanceValidator (input, bufDistance, result) {
	  this._minValidDistance = null;
	  this._maxValidDistance = null;
	  this._minDistanceFound = null;
	  this._maxDistanceFound = null;
	  this._isValid = true;
	  this._errMsg = null;
	  this._errorLocation = null;
	  this._errorIndicator = null;
	  this._input = input || null;
	  this._bufDistance = bufDistance || null;
	  this._result = result || null;
	};

	var staticAccessors$37 = { VERBOSE: { configurable: true },MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
	BufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance (input, bufCurve, maxDist) {
	  var haus = new DiscreteHausdorffDistance(bufCurve, input);
	  haus.setDensifyFraction(0.25);
	  this._maxDistanceFound = haus.orientedDistance();
	  if (this._maxDistanceFound > maxDist) {
	    this._isValid = false;
	    var pts = haus.getCoordinates();
	    this._errorLocation = pts[1];
	    this._errorIndicator = input.getFactory().createLineString(pts);
	    this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ')';
	  }
	};
	BufferDistanceValidator.prototype.isValid = function isValid () {
	  var posDistance = Math.abs(this._bufDistance);
	  var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;
	  this._minValidDistance = posDistance - distDelta;
	  this._maxValidDistance = posDistance + distDelta;
	  if (this._input.isEmpty() || this._result.isEmpty()) { return true }
	  if (this._bufDistance > 0.0) {
	    this.checkPositiveValid();
	  } else {
	    this.checkNegativeValid();
	  }
	  if (BufferDistanceValidator.VERBOSE) {
	    System.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1.0 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1.0));
	  }
	  return this._isValid
	};
	BufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid () {
	  if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {
	    return null
	  }
	  var inputCurve = this.getPolygonLines(this._input);
	  this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);
	  if (!this._isValid) { return null }
	  this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);
	};
	BufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator () {
	  return this._errorIndicator
	};
	BufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance (g1, g2, minDist) {
	  var distOp = new DistanceOp(g1, g2, minDist);
	  this._minDistanceFound = distOp.distance();
	  if (this._minDistanceFound < minDist) {
	    this._isValid = false;
	    var pts = distOp.nearestPoints();
	    this._errorLocation = distOp.nearestPoints()[1];
	    this._errorIndicator = g1.getFactory().createLineString(pts);
	    this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ' )';
	  }
	};
	BufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid () {
	  var bufCurve = this._result.getBoundary();
	  this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);
	  if (!this._isValid) { return null }
	  this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);
	};
	BufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation () {
	  return this._errorLocation
	};
	BufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines (g) {
	  var lines = new ArrayList();
	  var lineExtracter = new LinearComponentExtracter(lines);
	  var polys = PolygonExtracter.getPolygons(g);
	  for (var i = polys.iterator(); i.hasNext();) {
	    var poly = i.next();
	    poly.apply(lineExtracter);
	  }
	  return g.getFactory().buildGeometry(lines)
	};
	BufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage () {
	  return this._errMsg
	};
	BufferDistanceValidator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferDistanceValidator.prototype.getClass = function getClass () {
	  return BufferDistanceValidator
	};
	staticAccessors$37.VERBOSE.get = function () { return false };
	staticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function () { return 0.012 };

	Object.defineProperties( BufferDistanceValidator, staticAccessors$37 );

	var BufferResultValidator = function BufferResultValidator (input, distance, result) {
	  this._isValid = true;
	  this._errorMsg = null;
	  this._errorLocation = null;
	  this._errorIndicator = null;
	  this._input = input || null;
	  this._distance = distance || null;
	  this._result = result || null;
	};

	var staticAccessors$40 = { VERBOSE: { configurable: true },MAX_ENV_DIFF_FRAC: { configurable: true } };
	BufferResultValidator.prototype.isValid = function isValid () {
	  this.checkPolygonal();
	  if (!this._isValid) { return this._isValid }
	  this.checkExpectedEmpty();
	  if (!this._isValid) { return this._isValid }
	  this.checkEnvelope();
	  if (!this._isValid) { return this._isValid }
	  this.checkArea();
	  if (!this._isValid) { return this._isValid }
	  this.checkDistance();
	  return this._isValid
	};
	BufferResultValidator.prototype.checkEnvelope = function checkEnvelope () {
	  if (this._distance < 0.0) { return null }
	  var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;
	  if (padding === 0.0) { padding = 0.001; }
	  var expectedEnv = new Envelope(this._input.getEnvelopeInternal());
	  expectedEnv.expandBy(this._distance);
	  var bufEnv = new Envelope(this._result.getEnvelopeInternal());
	  bufEnv.expandBy(padding);
	  if (!bufEnv.contains(expectedEnv)) {
	    this._isValid = false;
	    this._errorMsg = 'Buffer envelope is incorrect';
	    this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);
	  }
	  this.report('Envelope');
	};
	BufferResultValidator.prototype.checkDistance = function checkDistance () {
	  var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);
	  if (!distValid.isValid()) {
	    this._isValid = false;
	    this._errorMsg = distValid.getErrorMessage();
	    this._errorLocation = distValid.getErrorLocation();
	    this._errorIndicator = distValid.getErrorIndicator();
	  }
	  this.report('Distance');
	};
	BufferResultValidator.prototype.checkArea = function checkArea () {
	  var inputArea = this._input.getArea();
	  var resultArea = this._result.getArea();
	  if (this._distance > 0.0 && inputArea > resultArea) {
	    this._isValid = false;
	    this._errorMsg = 'Area of positive buffer is smaller than input';
	    this._errorIndicator = this._result;
	  }
	  if (this._distance < 0.0 && inputArea < resultArea) {
	    this._isValid = false;
	    this._errorMsg = 'Area of negative buffer is larger than input';
	    this._errorIndicator = this._result;
	  }
	  this.report('Area');
	};
	BufferResultValidator.prototype.checkPolygonal = function checkPolygonal () {
	  if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) { this._isValid = false; }
	  this._errorMsg = 'Result is not polygonal';
	  this._errorIndicator = this._result;
	  this.report('Polygonal');
	};
	BufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator () {
	  return this._errorIndicator
	};
	BufferResultValidator.prototype.getErrorLocation = function getErrorLocation () {
	  return this._errorLocation
	};
	BufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty () {
	  if (this._input.getDimension() >= 2) { return null }
	  if (this._distance > 0.0) { return null }
	  if (!this._result.isEmpty()) {
	    this._isValid = false;
	    this._errorMsg = 'Result is non-empty';
	    this._errorIndicator = this._result;
	  }
	  this.report('ExpectedEmpty');
	};
	BufferResultValidator.prototype.report = function report (checkName) {
	  if (!BufferResultValidator.VERBOSE) { return null }
	  System.out.println('Check ' + checkName + ': ' + (this._isValid ? 'passed' : 'FAILED'));
	};
	BufferResultValidator.prototype.getErrorMessage = function getErrorMessage () {
	  return this._errorMsg
	};
	BufferResultValidator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	BufferResultValidator.prototype.getClass = function getClass () {
	  return BufferResultValidator
	};
	BufferResultValidator.isValidMsg = function isValidMsg (g, distance, result) {
	  var validator = new BufferResultValidator(g, distance, result);
	  if (!validator.isValid()) { return validator.getErrorMessage() }
	  return null
	};
	BufferResultValidator.isValid = function isValid (g, distance, result) {
	  var validator = new BufferResultValidator(g, distance, result);
	  if (validator.isValid()) { return true }
	  return false
	};
	staticAccessors$40.VERBOSE.get = function () { return false };
	staticAccessors$40.MAX_ENV_DIFF_FRAC.get = function () { return 0.012 };

	Object.defineProperties( BufferResultValidator, staticAccessors$40 );

	// operation.buffer

	var BasicSegmentString = function BasicSegmentString () {
	  this._pts = null;
	  this._data = null;
	  var pts = arguments[0];
	  var data = arguments[1];
	  this._pts = pts;
	  this._data = data;
	};
	BasicSegmentString.prototype.getCoordinates = function getCoordinates () {
	  return this._pts
	};
	BasicSegmentString.prototype.size = function size () {
	  return this._pts.length
	};
	BasicSegmentString.prototype.getCoordinate = function getCoordinate (i) {
	  return this._pts[i]
	};
	BasicSegmentString.prototype.isClosed = function isClosed () {
	  return this._pts[0].equals(this._pts[this._pts.length - 1])
	};
	BasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {
	  if (index === this._pts.length - 1) { return -1 }
	  return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1))
	};
	BasicSegmentString.prototype.setData = function setData (data) {
	  this._data = data;
	};
	BasicSegmentString.prototype.getData = function getData () {
	  return this._data
	};
	BasicSegmentString.prototype.toString = function toString () {
	  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
	};
	BasicSegmentString.prototype.interfaces_ = function interfaces_ () {
	  return [SegmentString]
	};
	BasicSegmentString.prototype.getClass = function getClass () {
	  return BasicSegmentString
	};

	var InteriorIntersectionFinder = function InteriorIntersectionFinder () {
	  this._findAllIntersections = false;
	  this._isCheckEndSegmentsOnly = false;
	  this._li = null;
	  this._interiorIntersection = null;
	  this._intSegments = null;
	  this._intersections = new ArrayList();
	  this._intersectionCount = 0;
	  this._keepIntersections = true;
	  var li = arguments[0];
	  this._li = li;
	  this._interiorIntersection = null;
	};
	InteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection () {
	  return this._interiorIntersection
	};
	InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly (isCheckEndSegmentsOnly) {
	  this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
	};
	InteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments () {
	  return this._intSegments
	};
	InteriorIntersectionFinder.prototype.count = function count () {
	  return this._intersectionCount
	};
	InteriorIntersectionFinder.prototype.getIntersections = function getIntersections () {
	  return this._intersections
	};
	InteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {
	  this._findAllIntersections = findAllIntersections;
	};
	InteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections (keepIntersections) {
	  this._keepIntersections = keepIntersections;
	};
	InteriorIntersectionFinder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {
	  if (!this._findAllIntersections && this.hasIntersection()) { return null }
	  if (e0 === e1 && segIndex0 === segIndex1) { return null }
	  if (this._isCheckEndSegmentsOnly) {
	    var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
	    if (!isEndSegPresent) { return null }
	  }
	  var p00 = e0.getCoordinates()[segIndex0];
	  var p01 = e0.getCoordinates()[segIndex0 + 1];
	  var p10 = e1.getCoordinates()[segIndex1];
	  var p11 = e1.getCoordinates()[segIndex1 + 1];
	  this._li.computeIntersection(p00, p01, p10, p11);
	  if (this._li.hasIntersection()) {
	    if (this._li.isInteriorIntersection()) {
	      this._intSegments = new Array(4).fill(null);
	      this._intSegments[0] = p00;
	      this._intSegments[1] = p01;
	      this._intSegments[2] = p10;
	      this._intSegments[3] = p11;
	      this._interiorIntersection = this._li.getIntersection(0);
	      if (this._keepIntersections) { this._intersections.add(this._interiorIntersection); }
	      this._intersectionCount++;
	    }
	  }
	};
	InteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment (segStr, index) {
	  if (index === 0) { return true }
	  if (index >= segStr.size() - 2) { return true }
	  return false
	};
	InteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection () {
	  return this._interiorIntersection !== null
	};
	InteriorIntersectionFinder.prototype.isDone = function isDone () {
	  if (this._findAllIntersections) { return false }
	  return this._interiorIntersection !== null
	};
	InteriorIntersectionFinder.prototype.interfaces_ = function interfaces_ () {
	  return [SegmentIntersector]
	};
	InteriorIntersectionFinder.prototype.getClass = function getClass () {
	  return InteriorIntersectionFinder
	};
	InteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder (li) {
	  var finder = new InteriorIntersectionFinder(li);
	  finder.setFindAllIntersections(true);
	  return finder
	};
	InteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder (li) {
	  return new InteriorIntersectionFinder(li)
	};
	InteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter (li) {
	  var finder = new InteriorIntersectionFinder(li);
	  finder.setFindAllIntersections(true);
	  finder.setKeepIntersections(false);
	  return finder
	};

	var FastNodingValidator = function FastNodingValidator () {
	  this._li = new RobustLineIntersector();
	  this._segStrings = null;
	  this._findAllIntersections = false;
	  this._segInt = null;
	  this._isValid = true;
	  var segStrings = arguments[0];
	  this._segStrings = segStrings;
	};
	FastNodingValidator.prototype.execute = function execute () {
	  if (this._segInt !== null) { return null }
	  this.checkInteriorIntersections();
	};
	FastNodingValidator.prototype.getIntersections = function getIntersections () {
	  return this._segInt.getIntersections()
	};
	FastNodingValidator.prototype.isValid = function isValid () {
	  this.execute();
	  return this._isValid
	};
	FastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {
	  this._findAllIntersections = findAllIntersections;
	};
	FastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {
	  this._isValid = true;
	  this._segInt = new InteriorIntersectionFinder(this._li);
	  this._segInt.setFindAllIntersections(this._findAllIntersections);
	  var noder = new MCIndexNoder();
	  noder.setSegmentIntersector(this._segInt);
	  noder.computeNodes(this._segStrings);
	  if (this._segInt.hasIntersection()) {
	    this._isValid = false;
	    return null
	  }
	};
	FastNodingValidator.prototype.checkValid = function checkValid () {
	  this.execute();
	  if (!this._isValid) { throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection()) }
	};
	FastNodingValidator.prototype.getErrorMessage = function getErrorMessage () {
	  if (this._isValid) { return 'no intersections found' }
	  var intSegs = this._segInt.getIntersectionSegments();
	  return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3])
	};
	FastNodingValidator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	FastNodingValidator.prototype.getClass = function getClass () {
	  return FastNodingValidator
	};
	FastNodingValidator.computeIntersections = function computeIntersections (segStrings) {
	  var nv = new FastNodingValidator(segStrings);
	  nv.setFindAllIntersections(true);
	  nv.isValid();
	  return nv.getIntersections()
	};

	var EdgeNodingValidator = function EdgeNodingValidator () {
	  this._nv = null;
	  var edges = arguments[0];
	  this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));
	};
	EdgeNodingValidator.prototype.checkValid = function checkValid () {
	  this._nv.checkValid();
	};
	EdgeNodingValidator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	EdgeNodingValidator.prototype.getClass = function getClass () {
	  return EdgeNodingValidator
	};
	EdgeNodingValidator.toSegmentStrings = function toSegmentStrings (edges) {
	  var segStrings = new ArrayList();
	  for (var i = edges.iterator(); i.hasNext();) {
	    var e = i.next();
	    segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
	  }
	  return segStrings
	};
	EdgeNodingValidator.checkValid = function checkValid (edges) {
	  var validator = new EdgeNodingValidator(edges);
	  validator.checkValid();
	};

	var GeometryCollectionMapper = function GeometryCollectionMapper (mapOp) {
	  this._mapOp = mapOp;
	};
	GeometryCollectionMapper.prototype.map = function map (gc) {
	    var this$1$1 = this;

	  var mapped = new ArrayList();
	  for (var i = 0; i < gc.getNumGeometries(); i++) {
	    var g = this$1$1._mapOp.map(gc.getGeometryN(i));
	    if (!g.isEmpty()) { mapped.add(g); }
	  }
	  return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped))
	};
	GeometryCollectionMapper.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryCollectionMapper.prototype.getClass = function getClass () {
	  return GeometryCollectionMapper
	};
	GeometryCollectionMapper.map = function map (gc, op) {
	  var mapper = new GeometryCollectionMapper(op);
	  return mapper.map(gc)
	};

	var LineBuilder = function LineBuilder () {
	  this._op = null;
	  this._geometryFactory = null;
	  this._ptLocator = null;
	  this._lineEdgesList = new ArrayList();
	  this._resultLineList = new ArrayList();
	  var op = arguments[0];
	  var geometryFactory = arguments[1];
	  var ptLocator = arguments[2];
	  this._op = op;
	  this._geometryFactory = geometryFactory;
	  this._ptLocator = ptLocator;
	};
	LineBuilder.prototype.collectLines = function collectLines (opCode) {
	    var this$1$1 = this;

	  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
	    var de = it.next();
	    this$1$1.collectLineEdge(de, opCode, this$1$1._lineEdgesList);
	    this$1$1.collectBoundaryTouchEdge(de, opCode, this$1$1._lineEdgesList);
	  }
	};
	LineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine (e, targetIndex) {
	  var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
	  e.getLabel().setLocation(targetIndex, loc);
	};
	LineBuilder.prototype.build = function build (opCode) {
	  this.findCoveredLineEdges();
	  this.collectLines(opCode);
	  this.buildLines(opCode);
	  return this._resultLineList
	};
	LineBuilder.prototype.collectLineEdge = function collectLineEdge (de, opCode, edges) {
	  var label = de.getLabel();
	  var e = de.getEdge();
	  if (de.isLineEdge()) {
	    if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
	      edges.add(e);
	      de.setVisitedEdge(true);
	    }
	  }
	};
	LineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges () {
	    var this$1$1 = this;

	  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
	    var node = nodeit.next();
	    node.getEdges().findCoveredLineEdges();
	  }
	  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
	    var de = it.next();
	    var e = de.getEdge();
	    if (de.isLineEdge() && !e.isCoveredSet()) {
	      var isCovered = this$1$1._op.isCoveredByA(de.getCoordinate());
	      e.setCovered(isCovered);
	    }
	  }
	};
	LineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines (edgesList) {
	    var this$1$1 = this;

	  for (var it = edgesList.iterator(); it.hasNext();) {
	    var e = it.next();
	    var label = e.getLabel();
	    if (e.isIsolated()) {
	      if (label.isNull(0)) { this$1$1.labelIsolatedLine(e, 0); } else { this$1$1.labelIsolatedLine(e, 1); }
	    }
	  }
	};
	LineBuilder.prototype.buildLines = function buildLines (opCode) {
	    var this$1$1 = this;

	  for (var it = this._lineEdgesList.iterator(); it.hasNext();) {
	    var e = it.next();
	    // const label = e.getLabel()
	    var line = this$1$1._geometryFactory.createLineString(e.getCoordinates());
	    this$1$1._resultLineList.add(line);
	    e.setInResult(true);
	  }
	};
	LineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge (de, opCode, edges) {
	  var label = de.getLabel();
	  if (de.isLineEdge()) { return null }
	  if (de.isVisited()) { return null }
	  if (de.isInteriorAreaEdge()) { return null }
	  if (de.getEdge().isInResult()) { return null }
	  Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
	  if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
	    edges.add(de.getEdge());
	    de.setVisitedEdge(true);
	  }
	};
	LineBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	LineBuilder.prototype.getClass = function getClass () {
	  return LineBuilder
	};

	var PointBuilder = function PointBuilder () {
	  this._op = null;
	  this._geometryFactory = null;
	  this._resultPointList = new ArrayList();
	  var op = arguments[0];
	  var geometryFactory = arguments[1];
	  // const ptLocator = arguments[2]
	  this._op = op;
	  this._geometryFactory = geometryFactory;
	};
	PointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint (n) {
	  var coord = n.getCoordinate();
	  if (!this._op.isCoveredByLA(coord)) {
	    var pt = this._geometryFactory.createPoint(coord);
	    this._resultPointList.add(pt);
	  }
	};
	PointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes (opCode) {
	    var this$1$1 = this;

	  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
	    var n = nodeit.next();
	    if (n.isInResult()) { continue }
	    if (n.isIncidentEdgeInResult()) { continue }
	    if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
	      var label = n.getLabel();
	      if (OverlayOp.isResultOfOp(label, opCode)) {
	        this$1$1.filterCoveredNodeToPoint(n);
	      }
	    }
	  }
	};
	PointBuilder.prototype.build = function build (opCode) {
	  this.extractNonCoveredResultNodes(opCode);
	  return this._resultPointList
	};
	PointBuilder.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	PointBuilder.prototype.getClass = function getClass () {
	  return PointBuilder
	};

	var GeometryTransformer = function GeometryTransformer () {
	  this._inputGeom = null;
	  this._factory = null;
	  this._pruneEmptyGeometry = true;
	  this._preserveGeometryCollectionType = true;
	  this._preserveCollections = false;
	  this._preserveType = false;
	};
	GeometryTransformer.prototype.transformPoint = function transformPoint (geom, parent) {
	  return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom))
	};
	GeometryTransformer.prototype.transformPolygon = function transformPolygon (geom, parent) {
	    var this$1$1 = this;

	  var isAllValidLinearRings = true;
	  var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
	  if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) { isAllValidLinearRings = false; }
	  var holes = new ArrayList();
	  for (var i = 0; i < geom.getNumInteriorRing(); i++) {
	    var hole = this$1$1.transformLinearRing(geom.getInteriorRingN(i), geom);
	    if (hole === null || hole.isEmpty()) {
	      continue
	    }
	    if (!(hole instanceof LinearRing)) { isAllValidLinearRings = false; }
	    holes.add(hole);
	  }
	  if (isAllValidLinearRings) { return this._factory.createPolygon(shell, holes.toArray([])); } else {
	    var components = new ArrayList();
	    if (shell !== null) { components.add(shell); }
	    components.addAll(holes);
	    return this._factory.buildGeometry(components)
	  }
	};
	GeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence (coords) {
	  return this._factory.getCoordinateSequenceFactory().create(coords)
	};
	GeometryTransformer.prototype.getInputGeometry = function getInputGeometry () {
	  return this._inputGeom
	};
	GeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString (geom, parent) {
	    var this$1$1 = this;

	  var transGeomList = new ArrayList();
	  for (var i = 0; i < geom.getNumGeometries(); i++) {
	    var transformGeom = this$1$1.transformLineString(geom.getGeometryN(i), geom);
	    if (transformGeom === null) { continue }
	    if (transformGeom.isEmpty()) { continue }
	    transGeomList.add(transformGeom);
	  }
	  return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {
	  return this.copy(coords)
	};
	GeometryTransformer.prototype.transformLineString = function transformLineString (geom, parent) {
	  return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom))
	};
	GeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint (geom, parent) {
	    var this$1$1 = this;

	  var transGeomList = new ArrayList();
	  for (var i = 0; i < geom.getNumGeometries(); i++) {
	    var transformGeom = this$1$1.transformPoint(geom.getGeometryN(i), geom);
	    if (transformGeom === null) { continue }
	    if (transformGeom.isEmpty()) { continue }
	    transGeomList.add(transformGeom);
	  }
	  return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon (geom, parent) {
	    var this$1$1 = this;

	  var transGeomList = new ArrayList();
	  for (var i = 0; i < geom.getNumGeometries(); i++) {
	    var transformGeom = this$1$1.transformPolygon(geom.getGeometryN(i), geom);
	    if (transformGeom === null) { continue }
	    if (transformGeom.isEmpty()) { continue }
	    transGeomList.add(transformGeom);
	  }
	  return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.copy = function copy (seq) {
	  return seq.copy()
	};
	GeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection (geom, parent) {
	    var this$1$1 = this;

	  var transGeomList = new ArrayList();
	  for (var i = 0; i < geom.getNumGeometries(); i++) {
	    var transformGeom = this$1$1.transform(geom.getGeometryN(i));
	    if (transformGeom === null) { continue }
	    if (this$1$1._pruneEmptyGeometry && transformGeom.isEmpty()) { continue }
	    transGeomList.add(transformGeom);
	  }
	  if (this._preserveGeometryCollectionType) { return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList)) }
	  return this._factory.buildGeometry(transGeomList)
	};
	GeometryTransformer.prototype.transform = function transform (inputGeom) {
	  this._inputGeom = inputGeom;
	  this._factory = inputGeom.getFactory();
	  if (inputGeom instanceof Point) { return this.transformPoint(inputGeom, null) }
	  if (inputGeom instanceof MultiPoint) { return this.transformMultiPoint(inputGeom, null) }
	  if (inputGeom instanceof LinearRing) { return this.transformLinearRing(inputGeom, null) }
	  if (inputGeom instanceof LineString$1) { return this.transformLineString(inputGeom, null) }
	  if (inputGeom instanceof MultiLineString) { return this.transformMultiLineString(inputGeom, null) }
	  if (inputGeom instanceof Polygon) { return this.transformPolygon(inputGeom, null) }
	  if (inputGeom instanceof MultiPolygon) { return this.transformMultiPolygon(inputGeom, null) }
	  if (inputGeom instanceof GeometryCollection) { return this.transformGeometryCollection(inputGeom, null) }
	  throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName())
	};
	GeometryTransformer.prototype.transformLinearRing = function transformLinearRing (geom, parent) {
	  var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
	  if (seq === null) { return this._factory.createLinearRing(null) }
	  var seqSize = seq.size();
	  if (seqSize > 0 && seqSize < 4 && !this._preserveType) { return this._factory.createLineString(seq) }
	  return this._factory.createLinearRing(seq)
	};
	GeometryTransformer.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryTransformer.prototype.getClass = function getClass () {
	  return GeometryTransformer
	};

	var LineStringSnapper = function LineStringSnapper () {
	  this._snapTolerance = 0.0;
	  this._srcPts = null;
	  this._seg = new LineSegment();
	  this._allowSnappingToSourceVertices = false;
	  this._isClosed = false;
	  if (arguments[0] instanceof LineString$1 && typeof arguments[1] === 'number') {
	    var srcLine = arguments[0];
	    var snapTolerance = arguments[1];
	    LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);
	  } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {
	    var srcPts = arguments[0];
	    var snapTolerance$1 = arguments[1];
	    this._srcPts = srcPts;
	    this._isClosed = LineStringSnapper.isClosed(srcPts);
	    this._snapTolerance = snapTolerance$1;
	  }
	};
	LineStringSnapper.prototype.snapVertices = function snapVertices (srcCoords, snapPts) {
	    var this$1$1 = this;

	  var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
	  for (var i = 0; i < end; i++) {
	    var srcPt = srcCoords.get(i);
	    var snapVert = this$1$1.findSnapForVertex(srcPt, snapPts);
	    if (snapVert !== null) {
	      srcCoords.set(i, new Coordinate(snapVert));
	      if (i === 0 && this$1$1._isClosed) { srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert)); }
	    }
	  }
	};
	LineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex (pt, snapPts) {
	    var this$1$1 = this;

	  for (var i = 0; i < snapPts.length; i++) {
	    if (pt.equals2D(snapPts[i])) { return null }
	    if (pt.distance(snapPts[i]) < this$1$1._snapTolerance) { return snapPts[i] }
	  }
	  return null
	};
	LineStringSnapper.prototype.snapTo = function snapTo (snapPts) {
	  var coordList = new CoordinateList(this._srcPts);
	  this.snapVertices(coordList, snapPts);
	  this.snapSegments(coordList, snapPts);
	  var newPts = coordList.toCoordinateArray();
	  return newPts
	};
	LineStringSnapper.prototype.snapSegments = function snapSegments (srcCoords, snapPts) {
	    var this$1$1 = this;

	  if (snapPts.length === 0) { return null }
	  var distinctPtCount = snapPts.length;
	  if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) { distinctPtCount = snapPts.length - 1; }
	  for (var i = 0; i < distinctPtCount; i++) {
	    var snapPt = snapPts[i];
	    var index = this$1$1.findSegmentIndexToSnap(snapPt, srcCoords);
	    if (index >= 0) {
	      srcCoords.add(index + 1, new Coordinate(snapPt), false);
	    }
	  }
	};
	LineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap (snapPt, srcCoords) {
	    var this$1$1 = this;

	  var minDist = Double.MAX_VALUE;
	  var snapIndex = -1;
	  for (var i = 0; i < srcCoords.size() - 1; i++) {
	    this$1$1._seg.p0 = srcCoords.get(i);
	    this$1$1._seg.p1 = srcCoords.get(i + 1);
	    if (this$1$1._seg.p0.equals2D(snapPt) || this$1$1._seg.p1.equals2D(snapPt)) {
	      if (this$1$1._allowSnappingToSourceVertices) { continue; } else { return -1 }
	    }
	    var dist = this$1$1._seg.distance(snapPt);
	    if (dist < this$1$1._snapTolerance && dist < minDist) {
	      minDist = dist;
	      snapIndex = i;
	    }
	  }
	  return snapIndex
	};
	LineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices (allowSnappingToSourceVertices) {
	  this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
	};
	LineStringSnapper.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	LineStringSnapper.prototype.getClass = function getClass () {
	  return LineStringSnapper
	};
	LineStringSnapper.isClosed = function isClosed (pts) {
	  if (pts.length <= 1) { return false }
	  return pts[0].equals2D(pts[pts.length - 1])
	};

	var GeometrySnapper = function GeometrySnapper (srcGeom) {
	  this._srcGeom = srcGeom || null;
	};

	var staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };
	GeometrySnapper.prototype.snapTo = function snapTo (snapGeom, snapTolerance) {
	  var snapPts = this.extractTargetCoordinates(snapGeom);
	  var snapTrans = new SnapTransformer(snapTolerance, snapPts);
	  return snapTrans.transform(this._srcGeom)
	};
	GeometrySnapper.prototype.snapToSelf = function snapToSelf (snapTolerance, cleanResult) {
	  var snapPts = this.extractTargetCoordinates(this._srcGeom);
	  var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
	  var snappedGeom = snapTrans.transform(this._srcGeom);
	  var result = snappedGeom;
	  if (cleanResult && hasInterface(result, Polygonal)) {
	    result = snappedGeom.buffer(0);
	  }
	  return result
	};
	GeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance (ringPts) {
	  var minSegLen = this.computeMinimumSegmentLength(ringPts);
	  var snapTol = minSegLen / 10;
	  return snapTol
	};
	GeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates (g) {
	  var ptSet = new TreeSet();
	  var pts = g.getCoordinates();
	  for (var i = 0; i < pts.length; i++) {
	    ptSet.add(pts[i]);
	  }
	  return ptSet.toArray(new Array(0).fill(null))
	};
	GeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength (pts) {
	  var minSegLen = Double.MAX_VALUE;
	  for (var i = 0; i < pts.length - 1; i++) {
	    var segLen = pts[i].distance(pts[i + 1]);
	    if (segLen < minSegLen) { minSegLen = segLen; }
	  }
	  return minSegLen
	};
	GeometrySnapper.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometrySnapper.prototype.getClass = function getClass () {
	  return GeometrySnapper
	};
	GeometrySnapper.snap = function snap (g0, g1, snapTolerance) {
	  var snapGeom = new Array(2).fill(null);
	  var snapper0 = new GeometrySnapper(g0);
	  snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
	  var snapper1 = new GeometrySnapper(g1);
	  snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
	  return snapGeom
	};
	GeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance () {
	  if (arguments.length === 1) {
	    var g = arguments[0];
	    var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
	    var pm = g.getPrecisionModel();
	    if (pm.getType() === PrecisionModel.FIXED) {
	      var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
	      if (fixedSnapTol > snapTolerance) { snapTolerance = fixedSnapTol; }
	    }
	    return snapTolerance
	  } else if (arguments.length === 2) {
	    var g0 = arguments[0];
	    var g1 = arguments[1];
	    return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1))
	  }
	};
	GeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance (g) {
	  var env = g.getEnvelopeInternal();
	  var minDimension = Math.min(env.getHeight(), env.getWidth());
	  var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
	  return snapTol
	};
	GeometrySnapper.snapToSelf = function snapToSelf (geom, snapTolerance, cleanResult) {
	  var snapper0 = new GeometrySnapper(geom);
	  return snapper0.snapToSelf(snapTolerance, cleanResult)
	};
	staticAccessors$41.SNAP_PRECISION_FACTOR.get = function () { return 1e-9 };

	Object.defineProperties( GeometrySnapper, staticAccessors$41 );

	var SnapTransformer = (function (GeometryTransformer$$1) {
	  function SnapTransformer (snapTolerance, snapPts, isSelfSnap) {
	    GeometryTransformer$$1.call(this);
	    this._snapTolerance = snapTolerance || null;
	    this._snapPts = snapPts || null;
	    this._isSelfSnap = (isSelfSnap !== undefined) ? isSelfSnap : false;
	  }

	  if ( GeometryTransformer$$1 ) SnapTransformer.__proto__ = GeometryTransformer$$1;
	  SnapTransformer.prototype = Object.create( GeometryTransformer$$1 && GeometryTransformer$$1.prototype );
	  SnapTransformer.prototype.constructor = SnapTransformer;
	  SnapTransformer.prototype.snapLine = function snapLine (srcPts, snapPts) {
	    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
	    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
	    return snapper.snapTo(snapPts)
	  };
	  SnapTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {
	    var srcPts = coords.toCoordinateArray();
	    var newPts = this.snapLine(srcPts, this._snapPts);
	    return this._factory.getCoordinateSequenceFactory().create(newPts)
	  };
	  SnapTransformer.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  SnapTransformer.prototype.getClass = function getClass () {
	    return SnapTransformer
	  };

	  return SnapTransformer;
	}(GeometryTransformer));

	var CommonBits = function CommonBits () {
	  this._isFirst = true;
	  this._commonMantissaBitsCount = 53;
	  this._commonBits = 0;
	  this._commonSignExp = null;
	};
	CommonBits.prototype.getCommon = function getCommon () {
	  return Double.longBitsToDouble(this._commonBits)
	};
	CommonBits.prototype.add = function add (num) {
	  var numBits = Double.doubleToLongBits(num);
	  if (this._isFirst) {
	    this._commonBits = numBits;
	    this._commonSignExp = CommonBits.signExpBits(this._commonBits);
	    this._isFirst = false;
	    return null
	  }
	  var numSignExp = CommonBits.signExpBits(numBits);
	  if (numSignExp !== this._commonSignExp) {
	    this._commonBits = 0;
	    return null
	  }
	  this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
	  this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
	};
	CommonBits.prototype.toString = function toString () {
	  if (arguments.length === 1) {
	    var bits = arguments[0];
	    var x = Double.longBitsToDouble(bits);
	    var numStr = Double.toBinaryString(bits);
	    var padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;
	    var bitStr = padStr.substring(padStr.length - 64);
	    var str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';
	    return str
	  }
	};
	CommonBits.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CommonBits.prototype.getClass = function getClass () {
	  return CommonBits
	};
	CommonBits.getBit = function getBit (bits, i) {
	  var mask = 1 << i;
	  return (bits & mask) !== 0 ? 1 : 0
	};
	CommonBits.signExpBits = function signExpBits (num) {
	  return num >> 52
	};
	CommonBits.zeroLowerBits = function zeroLowerBits (bits, nBits) {
	  var invMask = (1 << nBits) - 1;
	  var mask = ~invMask;
	  var zeroed = bits & mask;
	  return zeroed
	};
	CommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits (num1, num2) {
	  var count = 0;
	  for (var i = 52; i >= 0; i--) {
	    if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) { return count }
	    count++;
	  }
	  return 52
	};

	var CommonBitsRemover = function CommonBitsRemover () {
	  this._commonCoord = null;
	  this._ccFilter = new CommonCoordinateFilter();
	};

	var staticAccessors$42 = { CommonCoordinateFilter: { configurable: true },Translater: { configurable: true } };
	CommonBitsRemover.prototype.addCommonBits = function addCommonBits (geom) {
	  var trans = new Translater(this._commonCoord);
	  geom.apply(trans);
	  geom.geometryChanged();
	};
	CommonBitsRemover.prototype.removeCommonBits = function removeCommonBits (geom) {
	  if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) { return geom }
	  var invCoord = new Coordinate(this._commonCoord);
	  invCoord.x = -invCoord.x;
	  invCoord.y = -invCoord.y;
	  var trans = new Translater(invCoord);
	  geom.apply(trans);
	  geom.geometryChanged();
	  return geom
	};
	CommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate () {
	  return this._commonCoord
	};
	CommonBitsRemover.prototype.add = function add (geom) {
	  geom.apply(this._ccFilter);
	  this._commonCoord = this._ccFilter.getCommonCoordinate();
	};
	CommonBitsRemover.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CommonBitsRemover.prototype.getClass = function getClass () {
	  return CommonBitsRemover
	};
	staticAccessors$42.CommonCoordinateFilter.get = function () { return CommonCoordinateFilter };
	staticAccessors$42.Translater.get = function () { return Translater };

	Object.defineProperties( CommonBitsRemover, staticAccessors$42 );

	var CommonCoordinateFilter = function CommonCoordinateFilter () {
	  this._commonBitsX = new CommonBits();
	  this._commonBitsY = new CommonBits();
	};
	CommonCoordinateFilter.prototype.filter = function filter (coord) {
	  this._commonBitsX.add(coord.x);
	  this._commonBitsY.add(coord.y);
	};
	CommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate () {
	  return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
	};
	CommonCoordinateFilter.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateFilter]
	};
	CommonCoordinateFilter.prototype.getClass = function getClass () {
	  return CommonCoordinateFilter
	};

	var Translater = function Translater () {
	  this.trans = null;
	  var trans = arguments[0];
	  this.trans = trans;
	};
	Translater.prototype.filter = function filter (seq, i) {
	  var xp = seq.getOrdinate(i, 0) + this.trans.x;
	  var yp = seq.getOrdinate(i, 1) + this.trans.y;
	  seq.setOrdinate(i, 0, xp);
	  seq.setOrdinate(i, 1, yp);
	};
	Translater.prototype.isDone = function isDone () {
	  return false
	};
	Translater.prototype.isGeometryChanged = function isGeometryChanged () {
	  return true
	};
	Translater.prototype.interfaces_ = function interfaces_ () {
	  return [CoordinateSequenceFilter]
	};
	Translater.prototype.getClass = function getClass () {
	  return Translater
	};

	var SnapOverlayOp = function SnapOverlayOp (g1, g2) {
	  this._geom = new Array(2).fill(null);
	  this._snapTolerance = null;
	  this._cbr = null;
	  this._geom[0] = g1;
	  this._geom[1] = g2;
	  this.computeSnapTolerance();
	};
	SnapOverlayOp.prototype.selfSnap = function selfSnap (geom) {
	  var snapper0 = new GeometrySnapper(geom);
	  var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
	  return snapGeom
	};
	SnapOverlayOp.prototype.removeCommonBits = function removeCommonBits (geom) {
	  this._cbr = new CommonBitsRemover();
	  this._cbr.add(geom[0]);
	  this._cbr.add(geom[1]);
	  var remGeom = new Array(2).fill(null);
	  remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
	  remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
	  return remGeom
	};
	SnapOverlayOp.prototype.prepareResult = function prepareResult (geom) {
	  this._cbr.addCommonBits(geom);
	  return geom
	};
	SnapOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {
	  var prepGeom = this.snap(this._geom);
	  var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
	  return this.prepareResult(result)
	};
	SnapOverlayOp.prototype.checkValid = function checkValid (g) {
	  if (!g.isValid()) {
	    System.out.println('Snapped geometry is invalid');
	  }
	};
	SnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance () {
	  this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
	};
	SnapOverlayOp.prototype.snap = function snap (geom) {
	  var remGeom = this.removeCommonBits(geom);
	  var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
	  return snapGeom
	};
	SnapOverlayOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SnapOverlayOp.prototype.getClass = function getClass () {
	  return SnapOverlayOp
	};
	SnapOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {
	  var op = new SnapOverlayOp(g0, g1);
	  return op.getResultGeometry(opCode)
	};
	SnapOverlayOp.union = function union (g0, g1) {
	  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)
	};
	SnapOverlayOp.intersection = function intersection (g0, g1) {
	  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)
	};
	SnapOverlayOp.symDifference = function symDifference (g0, g1) {
	  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)
	};
	SnapOverlayOp.difference = function difference (g0, g1) {
	  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)
	};

	var SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp (g1, g2) {
	  this._geom = new Array(2).fill(null);
	  this._geom[0] = g1;
	  this._geom[1] = g2;
	};
	SnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {
	  var result = null;
	  var isSuccess = false;
	  var savedException = null;
	  try {
	    result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
	    var isValid = true;
	    if (isValid) { isSuccess = true; }
	  } catch (ex) {
	    if (ex instanceof RuntimeException) {
	      savedException = ex;
	    } else { throw ex }
	  } finally {}
	  if (!isSuccess) {
	    try {
	      result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
	    } catch (ex) {
	      if (ex instanceof RuntimeException) {
	        throw savedException
	      } else { throw ex }
	    } finally {}
	  }
	  return result
	};
	SnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SnapIfNeededOverlayOp.prototype.getClass = function getClass () {
	  return SnapIfNeededOverlayOp
	};
	SnapIfNeededOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {
	  var op = new SnapIfNeededOverlayOp(g0, g1);
	  return op.getResultGeometry(opCode)
	};
	SnapIfNeededOverlayOp.union = function union (g0, g1) {
	  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)
	};
	SnapIfNeededOverlayOp.intersection = function intersection (g0, g1) {
	  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)
	};
	SnapIfNeededOverlayOp.symDifference = function symDifference (g0, g1) {
	  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)
	};
	SnapIfNeededOverlayOp.difference = function difference (g0, g1) {
	  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)
	};

	var MonotoneChain$2 = function MonotoneChain () {
	  this.mce = null;
	  this.chainIndex = null;
	  var mce = arguments[0];
	  var chainIndex = arguments[1];
	  this.mce = mce;
	  this.chainIndex = chainIndex;
	};
	MonotoneChain$2.prototype.computeIntersections = function computeIntersections (mc, si) {
	  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
	};
	MonotoneChain$2.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	MonotoneChain$2.prototype.getClass = function getClass () {
	  return MonotoneChain$2
	};

	var SweepLineEvent = function SweepLineEvent () {
	  this._label = null;
	  this._xValue = null;
	  this._eventType = null;
	  this._insertEvent = null;
	  this._deleteEventIndex = null;
	  this._obj = null;
	  if (arguments.length === 2) {
	    var x = arguments[0];
	    var insertEvent = arguments[1];
	    this._eventType = SweepLineEvent.DELETE;
	    this._xValue = x;
	    this._insertEvent = insertEvent;
	  } else if (arguments.length === 3) {
	    var label = arguments[0];
	    var x$1 = arguments[1];
	    var obj = arguments[2];
	    this._eventType = SweepLineEvent.INSERT;
	    this._label = label;
	    this._xValue = x$1;
	    this._obj = obj;
	  }
	};

	var staticAccessors$43 = { INSERT: { configurable: true },DELETE: { configurable: true } };
	SweepLineEvent.prototype.isDelete = function isDelete () {
	  return this._eventType === SweepLineEvent.DELETE
	};
	SweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex (deleteEventIndex) {
	  this._deleteEventIndex = deleteEventIndex;
	};
	SweepLineEvent.prototype.getObject = function getObject () {
	  return this._obj
	};
	SweepLineEvent.prototype.compareTo = function compareTo (o) {
	  var pe = o;
	  if (this._xValue < pe._xValue) { return -1 }
	  if (this._xValue > pe._xValue) { return 1 }
	  if (this._eventType < pe._eventType) { return -1 }
	  if (this._eventType > pe._eventType) { return 1 }
	  return 0
	};
	SweepLineEvent.prototype.getInsertEvent = function getInsertEvent () {
	  return this._insertEvent
	};
	SweepLineEvent.prototype.isInsert = function isInsert () {
	  return this._eventType === SweepLineEvent.INSERT
	};
	SweepLineEvent.prototype.isSameLabel = function isSameLabel (ev) {
	  if (this._label === null) { return false }
	  return this._label === ev._label
	};
	SweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex () {
	  return this._deleteEventIndex
	};
	SweepLineEvent.prototype.interfaces_ = function interfaces_ () {
	  return [Comparable]
	};
	SweepLineEvent.prototype.getClass = function getClass () {
	  return SweepLineEvent
	};
	staticAccessors$43.INSERT.get = function () { return 1 };
	staticAccessors$43.DELETE.get = function () { return 2 };

	Object.defineProperties( SweepLineEvent, staticAccessors$43 );

	var EdgeSetIntersector = function EdgeSetIntersector () {};

	EdgeSetIntersector.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	EdgeSetIntersector.prototype.getClass = function getClass () {
	  return EdgeSetIntersector
	};

	var SegmentIntersector$2 = function SegmentIntersector () {
	  this._hasIntersection = false;
	  this._hasProper = false;
	  this._hasProperInterior = false;
	  this._properIntersectionPoint = null;
	  this._li = null;
	  this._includeProper = null;
	  this._recordIsolated = null;
	  this._isSelfIntersection = null;
	  this._numIntersections = 0;
	  this.numTests = 0;
	  this._bdyNodes = null;
	  this._isDone = false;
	  this._isDoneWhenProperInt = false;
	  var li = arguments[0];
	  var includeProper = arguments[1];
	  var recordIsolated = arguments[2];
	  this._li = li;
	  this._includeProper = includeProper;
	  this._recordIsolated = recordIsolated;
	};
	SegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {
	  if (e0 === e1) {
	    if (this._li.getIntersectionNum() === 1) {
	      if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) { return true }
	      if (e0.isClosed()) {
	        var maxSegIndex = e0.getNumPoints() - 1;
	        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
	            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {
	          return true
	        }
	      }
	    }
	  }
	  return false
	};
	SegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {
	  return this._properIntersectionPoint
	};
	SegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt (isDoneWhenProperInt) {
	  this._isDoneWhenProperInt = isDoneWhenProperInt;
	};
	SegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {
	  return this._hasProperInterior
	};
	SegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal (li, bdyNodes) {
	  for (var i = bdyNodes.iterator(); i.hasNext();) {
	    var node = i.next();
	    var pt = node.getCoordinate();
	    if (li.isIntersection(pt)) { return true }
	  }
	  return false
	};
	SegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection () {
	  return this._hasProper
	};
	SegmentIntersector$2.prototype.hasIntersection = function hasIntersection () {
	  return this._hasIntersection
	};
	SegmentIntersector$2.prototype.isDone = function isDone () {
	  return this._isDone
	};
	SegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint (li, bdyNodes) {
	  if (bdyNodes === null) { return false }
	  if (this.isBoundaryPointInternal(li, bdyNodes[0])) { return true }
	  if (this.isBoundaryPointInternal(li, bdyNodes[1])) { return true }
	  return false
	};
	SegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes (bdyNodes0, bdyNodes1) {
	  this._bdyNodes = new Array(2).fill(null);
	  this._bdyNodes[0] = bdyNodes0;
	  this._bdyNodes[1] = bdyNodes1;
	};
	SegmentIntersector$2.prototype.addIntersections = function addIntersections (e0, segIndex0, e1, segIndex1) {
	  if (e0 === e1 && segIndex0 === segIndex1) { return null }
	  this.numTests++;
	  var p00 = e0.getCoordinates()[segIndex0];
	  var p01 = e0.getCoordinates()[segIndex0 + 1];
	  var p10 = e1.getCoordinates()[segIndex1];
	  var p11 = e1.getCoordinates()[segIndex1 + 1];
	  this._li.computeIntersection(p00, p01, p10, p11);
	  if (this._li.hasIntersection()) {
	    if (this._recordIsolated) {
	      e0.setIsolated(false);
	      e1.setIsolated(false);
	    }
	    this._numIntersections++;
	    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
	      this._hasIntersection = true;
	      if (this._includeProper || !this._li.isProper()) {
	        e0.addIntersections(this._li, segIndex0, 0);
	        e1.addIntersections(this._li, segIndex1, 1);
	      }
	      if (this._li.isProper()) {
	        this._properIntersectionPoint = this._li.getIntersection(0).copy();
	        this._hasProper = true;
	        if (this._isDoneWhenProperInt) {
	          this._isDone = true;
	        }
	        if (!this.isBoundaryPoint(this._li, this._bdyNodes)) { this._hasProperInterior = true; }
	      }
	    }
	  }
	};
	SegmentIntersector$2.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SegmentIntersector$2.prototype.getClass = function getClass () {
	  return SegmentIntersector$2
	};
	SegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments (i1, i2) {
	  return Math.abs(i1 - i2) === 1
	};

	var SimpleMCSweepLineIntersector = (function (EdgeSetIntersector$$1) {
	  function SimpleMCSweepLineIntersector () {
	    EdgeSetIntersector$$1.call(this);
	    this.events = new ArrayList();
	    this.nOverlaps = null;
	  }

	  if ( EdgeSetIntersector$$1 ) SimpleMCSweepLineIntersector.__proto__ = EdgeSetIntersector$$1;
	  SimpleMCSweepLineIntersector.prototype = Object.create( EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype );
	  SimpleMCSweepLineIntersector.prototype.constructor = SimpleMCSweepLineIntersector;
	  SimpleMCSweepLineIntersector.prototype.prepareEvents = function prepareEvents () {
	    var this$1$1 = this;

	    Collections.sort(this.events);
	    for (var i = 0; i < this.events.size(); i++) {
	      var ev = this$1$1.events.get(i);
	      if (ev.isDelete()) {
	        ev.getInsertEvent().setDeleteEventIndex(i);
	      }
	    }
	  };
	  SimpleMCSweepLineIntersector.prototype.computeIntersections = function computeIntersections () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var si = arguments[0];
	      this.nOverlaps = 0;
	      this.prepareEvents();
	      for (var i = 0; i < this.events.size(); i++) {
	        var ev = this$1$1.events.get(i);
	        if (ev.isInsert()) {
	          this$1$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
	        }
	        if (si.isDone()) {
	          break
	        }
	      }
	    } else if (arguments.length === 3) {
	      if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
	        var edges0 = arguments[0];
	        var edges1 = arguments[1];
	        var si$1 = arguments[2];
	        this.addEdges(edges0, edges0);
	        this.addEdges(edges1, edges1);
	        this.computeIntersections(si$1);
	      } else if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {
	        var edges = arguments[0];
	        var si$2 = arguments[1];
	        var testAllSegments = arguments[2];
	        if (testAllSegments) { this.addEdges(edges, null); } else { this.addEdges(edges); }
	        this.computeIntersections(si$2);
	      }
	    }
	  };
	  SimpleMCSweepLineIntersector.prototype.addEdge = function addEdge (edge, edgeSet) {
	    var this$1$1 = this;

	    var mce = edge.getMonotoneChainEdge();
	    var startIndex = mce.getStartIndexes();
	    for (var i = 0; i < startIndex.length - 1; i++) {
	      var mc = new MonotoneChain$2(mce, i);
	      var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
	      this$1$1.events.add(insertEvent);
	      this$1$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
	    }
	  };
	  SimpleMCSweepLineIntersector.prototype.processOverlaps = function processOverlaps (start, end, ev0, si) {
	    var this$1$1 = this;

	    var mc0 = ev0.getObject();
	    for (var i = start; i < end; i++) {
	      var ev1 = this$1$1.events.get(i);
	      if (ev1.isInsert()) {
	        var mc1 = ev1.getObject();
	        if (!ev0.isSameLabel(ev1)) {
	          mc0.computeIntersections(mc1, si);
	          this$1$1.nOverlaps++;
	        }
	      }
	    }
	  };
	  SimpleMCSweepLineIntersector.prototype.addEdges = function addEdges () {
	    var this$1$1 = this;

	    if (arguments.length === 1) {
	      var edges = arguments[0];
	      for (var i = edges.iterator(); i.hasNext();) {
	        var edge = i.next();
	        this$1$1.addEdge(edge, edge);
	      }
	    } else if (arguments.length === 2) {
	      var edges$1 = arguments[0];
	      var edgeSet = arguments[1];
	      for (var i$1 = edges$1.iterator(); i$1.hasNext();) {
	        var edge$1 = i$1.next();
	        this$1$1.addEdge(edge$1, edgeSet);
	      }
	    }
	  };
	  SimpleMCSweepLineIntersector.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  SimpleMCSweepLineIntersector.prototype.getClass = function getClass () {
	    return SimpleMCSweepLineIntersector
	  };

	  return SimpleMCSweepLineIntersector;
	}(EdgeSetIntersector));

	var IntervalRTreeNode = function IntervalRTreeNode () {
	  this._min = Double.POSITIVE_INFINITY;
	  this._max = Double.NEGATIVE_INFINITY;
	};

	var staticAccessors$45 = { NodeComparator: { configurable: true } };
	IntervalRTreeNode.prototype.getMin = function getMin () {
	  return this._min
	};
	IntervalRTreeNode.prototype.intersects = function intersects (queryMin, queryMax) {
	  if (this._min > queryMax || this._max < queryMin) { return false }
	  return true
	};
	IntervalRTreeNode.prototype.getMax = function getMax () {
	  return this._max
	};
	IntervalRTreeNode.prototype.toString = function toString () {
	  return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0))
	};
	IntervalRTreeNode.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	IntervalRTreeNode.prototype.getClass = function getClass () {
	  return IntervalRTreeNode
	};
	staticAccessors$45.NodeComparator.get = function () { return NodeComparator };

	Object.defineProperties( IntervalRTreeNode, staticAccessors$45 );

	var NodeComparator = function NodeComparator () {};

	NodeComparator.prototype.compare = function compare (o1, o2) {
	  var n1 = o1;
	  var n2 = o2;
	  var mid1 = (n1._min + n1._max) / 2;
	  var mid2 = (n2._min + n2._max) / 2;
	  if (mid1 < mid2) { return -1 }
	  if (mid1 > mid2) { return 1 }
	  return 0
	};
	NodeComparator.prototype.interfaces_ = function interfaces_ () {
	  return [Comparator]
	};
	NodeComparator.prototype.getClass = function getClass () {
	  return NodeComparator
	};

	var IntervalRTreeLeafNode = (function (IntervalRTreeNode$$1) {
	  function IntervalRTreeLeafNode () {
	    IntervalRTreeNode$$1.call(this);
	    this._item = null;
	    var min = arguments[0];
	    var max = arguments[1];
	    var item = arguments[2];
	    this._min = min;
	    this._max = max;
	    this._item = item;
	  }

	  if ( IntervalRTreeNode$$1 ) IntervalRTreeLeafNode.__proto__ = IntervalRTreeNode$$1;
	  IntervalRTreeLeafNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );
	  IntervalRTreeLeafNode.prototype.constructor = IntervalRTreeLeafNode;
	  IntervalRTreeLeafNode.prototype.query = function query (queryMin, queryMax, visitor) {
	    if (!this.intersects(queryMin, queryMax)) { return null }
	    visitor.visitItem(this._item);
	  };
	  IntervalRTreeLeafNode.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  IntervalRTreeLeafNode.prototype.getClass = function getClass () {
	    return IntervalRTreeLeafNode
	  };

	  return IntervalRTreeLeafNode;
	}(IntervalRTreeNode));

	var IntervalRTreeBranchNode = (function (IntervalRTreeNode$$1) {
	  function IntervalRTreeBranchNode () {
	    IntervalRTreeNode$$1.call(this);
	    this._node1 = null;
	    this._node2 = null;
	    var n1 = arguments[0];
	    var n2 = arguments[1];
	    this._node1 = n1;
	    this._node2 = n2;
	    this.buildExtent(this._node1, this._node2);
	  }

	  if ( IntervalRTreeNode$$1 ) IntervalRTreeBranchNode.__proto__ = IntervalRTreeNode$$1;
	  IntervalRTreeBranchNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );
	  IntervalRTreeBranchNode.prototype.constructor = IntervalRTreeBranchNode;
	  IntervalRTreeBranchNode.prototype.buildExtent = function buildExtent (n1, n2) {
	    this._min = Math.min(n1._min, n2._min);
	    this._max = Math.max(n1._max, n2._max);
	  };
	  IntervalRTreeBranchNode.prototype.query = function query (queryMin, queryMax, visitor) {
	    if (!this.intersects(queryMin, queryMax)) {
	      return null
	    }
	    if (this._node1 !== null) { this._node1.query(queryMin, queryMax, visitor); }
	    if (this._node2 !== null) { this._node2.query(queryMin, queryMax, visitor); }
	  };
	  IntervalRTreeBranchNode.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  IntervalRTreeBranchNode.prototype.getClass = function getClass () {
	    return IntervalRTreeBranchNode
	  };

	  return IntervalRTreeBranchNode;
	}(IntervalRTreeNode));

	var SortedPackedIntervalRTree = function SortedPackedIntervalRTree () {
	  this._leaves = new ArrayList();
	  this._root = null;
	  this._level = 0;
	};
	SortedPackedIntervalRTree.prototype.buildTree = function buildTree () {
	    var this$1$1 = this;

	  Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
	  var src = this._leaves;
	  var temp = null;
	  var dest = new ArrayList();
	  while (true) {
	    this$1$1.buildLevel(src, dest);
	    if (dest.size() === 1) { return dest.get(0) }
	    temp = src;
	    src = dest;
	    dest = temp;
	  }
	};
	SortedPackedIntervalRTree.prototype.insert = function insert (min, max, item) {
	  if (this._root !== null) { throw new Error('Index cannot be added to once it has been queried') }
	  this._leaves.add(new IntervalRTreeLeafNode(min, max, item));
	};
	SortedPackedIntervalRTree.prototype.query = function query (min, max, visitor) {
	  this.init();
	  this._root.query(min, max, visitor);
	};
	SortedPackedIntervalRTree.prototype.buildRoot = function buildRoot () {
	  if (this._root !== null) { return null }
	  this._root = this.buildTree();
	};
	SortedPackedIntervalRTree.prototype.printNode = function printNode (node) {
	  System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
	};
	SortedPackedIntervalRTree.prototype.init = function init () {
	  if (this._root !== null) { return null }
	  this.buildRoot();
	};
	SortedPackedIntervalRTree.prototype.buildLevel = function buildLevel (src, dest) {
	  this._level++;
	  dest.clear();
	  for (var i = 0; i < src.size(); i += 2) {
	    var n1 = src.get(i);
	    var n2 = i + 1 < src.size() ? src.get(i) : null;
	    if (n2 === null) {
	      dest.add(n1);
	    } else {
	      var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
	      dest.add(node);
	    }
	  }
	};
	SortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	SortedPackedIntervalRTree.prototype.getClass = function getClass () {
	  return SortedPackedIntervalRTree
	};

	var ArrayListVisitor = function ArrayListVisitor () {
	  this._items = new ArrayList();
	};
	ArrayListVisitor.prototype.visitItem = function visitItem (item) {
	  this._items.add(item);
	};
	ArrayListVisitor.prototype.getItems = function getItems () {
	  return this._items
	};
	ArrayListVisitor.prototype.interfaces_ = function interfaces_ () {
	  return [ItemVisitor]
	};
	ArrayListVisitor.prototype.getClass = function getClass () {
	  return ArrayListVisitor
	};

	var IndexedPointInAreaLocator = function IndexedPointInAreaLocator () {
	  this._index = null;
	  var g = arguments[0];
	  if (!hasInterface(g, Polygonal)) { throw new IllegalArgumentException() }
	  this._index = new IntervalIndexedGeometry(g);
	};

	var staticAccessors$44 = { SegmentVisitor: { configurable: true },IntervalIndexedGeometry: { configurable: true } };
	IndexedPointInAreaLocator.prototype.locate = function locate (p) {
	  var rcc = new RayCrossingCounter(p);
	  var visitor = new SegmentVisitor(rcc);
	  this._index.query(p.y, p.y, visitor);
	  return rcc.getLocation()
	};
	IndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_ () {
	  return [PointOnGeometryLocator]
	};
	IndexedPointInAreaLocator.prototype.getClass = function getClass () {
	  return IndexedPointInAreaLocator
	};
	staticAccessors$44.SegmentVisitor.get = function () { return SegmentVisitor };
	staticAccessors$44.IntervalIndexedGeometry.get = function () { return IntervalIndexedGeometry };

	Object.defineProperties( IndexedPointInAreaLocator, staticAccessors$44 );

	var SegmentVisitor = function SegmentVisitor () {
	  this._counter = null;
	  var counter = arguments[0];
	  this._counter = counter;
	};
	SegmentVisitor.prototype.visitItem = function visitItem (item) {
	  var seg = item;
	  this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
	};
	SegmentVisitor.prototype.interfaces_ = function interfaces_ () {
	  return [ItemVisitor]
	};
	SegmentVisitor.prototype.getClass = function getClass () {
	  return SegmentVisitor
	};

	var IntervalIndexedGeometry = function IntervalIndexedGeometry () {
	  this._index = new SortedPackedIntervalRTree();
	  var geom = arguments[0];
	  this.init(geom);
	};
	IntervalIndexedGeometry.prototype.init = function init (geom) {
	    var this$1$1 = this;

	  var lines = LinearComponentExtracter.getLines(geom);
	  for (var i = lines.iterator(); i.hasNext();) {
	    var line = i.next();
	    var pts = line.getCoordinates();
	    this$1$1.addLine(pts);
	  }
	};
	IntervalIndexedGeometry.prototype.addLine = function addLine (pts) {
	    var this$1$1 = this;

	  for (var i = 1; i < pts.length; i++) {
	    var seg = new LineSegment(pts[i - 1], pts[i]);
	    var min = Math.min(seg.p0.y, seg.p1.y);
	    var max = Math.max(seg.p0.y, seg.p1.y);
	    this$1$1._index.insert(min, max, seg);
	  }
	};
	IntervalIndexedGeometry.prototype.query = function query () {
	  if (arguments.length === 2) {
	    var min = arguments[0];
	    var max = arguments[1];
	    var visitor = new ArrayListVisitor();
	    this._index.query(min, max, visitor);
	    return visitor.getItems()
	  } else if (arguments.length === 3) {
	    var min$1 = arguments[0];
	    var max$1 = arguments[1];
	    var visitor$1 = arguments[2];
	    this._index.query(min$1, max$1, visitor$1);
	  }
	};
	IntervalIndexedGeometry.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	IntervalIndexedGeometry.prototype.getClass = function getClass () {
	  return IntervalIndexedGeometry
	};

	var GeometryGraph = (function (PlanarGraph$$1) {
	  function GeometryGraph () {
	    PlanarGraph$$1.call(this);
	    this._parentGeom = null;
	    this._lineEdgeMap = new HashMap();
	    this._boundaryNodeRule = null;
	    this._useBoundaryDeterminationRule = true;
	    this._argIndex = null;
	    this._boundaryNodes = null;
	    this._hasTooFewPoints = false;
	    this._invalidPoint = null;
	    this._areaPtLocator = null;
	    this._ptLocator = new PointLocator();
	    if (arguments.length === 2) {
	      var argIndex = arguments[0];
	      var parentGeom = arguments[1];
	      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
	      this._argIndex = argIndex;
	      this._parentGeom = parentGeom;
	      this._boundaryNodeRule = boundaryNodeRule;
	      if (parentGeom !== null) {
	        this.add(parentGeom);
	      }
	    } else if (arguments.length === 3) {
	      var argIndex$1 = arguments[0];
	      var parentGeom$1 = arguments[1];
	      var boundaryNodeRule$1 = arguments[2];
	      this._argIndex = argIndex$1;
	      this._parentGeom = parentGeom$1;
	      this._boundaryNodeRule = boundaryNodeRule$1;
	      if (parentGeom$1 !== null) {
	        this.add(parentGeom$1);
	      }
	    }
	  }

	  if ( PlanarGraph$$1 ) GeometryGraph.__proto__ = PlanarGraph$$1;
	  GeometryGraph.prototype = Object.create( PlanarGraph$$1 && PlanarGraph$$1.prototype );
	  GeometryGraph.prototype.constructor = GeometryGraph;
	  GeometryGraph.prototype.insertBoundaryPoint = function insertBoundaryPoint (argIndex, coord) {
	    var n = this._nodes.addNode(coord);
	    var lbl = n.getLabel();
	    var boundaryCount = 1;
	    var loc = Location.NONE;
	    loc = lbl.getLocation(argIndex, Position$1.ON);
	    if (loc === Location.BOUNDARY) { boundaryCount++; }
	    var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
	    lbl.setLocation(argIndex, newLoc);
	  };
	  GeometryGraph.prototype.computeSelfNodes = function computeSelfNodes () {
	    if (arguments.length === 2) {
	      var li = arguments[0];
	      var computeRingSelfNodes = arguments[1];
	      return this.computeSelfNodes(li, computeRingSelfNodes, false)
	    } else if (arguments.length === 3) {
	      var li$1 = arguments[0];
	      var computeRingSelfNodes$1 = arguments[1];
	      var isDoneIfProperInt = arguments[2];
	      var si = new SegmentIntersector$2(li$1, true, false);
	      si.setIsDoneIfProperInt(isDoneIfProperInt);
	      var esi = this.createEdgeSetIntersector();
	      var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
	      var computeAllSegments = computeRingSelfNodes$1 || !isRings;
	      esi.computeIntersections(this._edges, si, computeAllSegments);
	      this.addSelfIntersectionNodes(this._argIndex);
	      return si
	    }
	  };
	  GeometryGraph.prototype.computeSplitEdges = function computeSplitEdges (edgelist) {
	    for (var i = this._edges.iterator(); i.hasNext();) {
	      var e = i.next();
	      e.eiList.addSplitEdges(edgelist);
	    }
	  };
	  GeometryGraph.prototype.computeEdgeIntersections = function computeEdgeIntersections (g, li, includeProper) {
	    var si = new SegmentIntersector$2(li, includeProper, true);
	    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
	    var esi = this.createEdgeSetIntersector();
	    esi.computeIntersections(this._edges, g._edges, si);
	    return si
	  };
	  GeometryGraph.prototype.getGeometry = function getGeometry () {
	    return this._parentGeom
	  };
	  GeometryGraph.prototype.getBoundaryNodeRule = function getBoundaryNodeRule () {
	    return this._boundaryNodeRule
	  };
	  GeometryGraph.prototype.hasTooFewPoints = function hasTooFewPoints () {
	    return this._hasTooFewPoints
	  };
	  GeometryGraph.prototype.addPoint = function addPoint () {
	    if (arguments[0] instanceof Point) {
	      var p = arguments[0];
	      var coord = p.getCoordinate();
	      this.insertPoint(this._argIndex, coord, Location.INTERIOR);
	    } else if (arguments[0] instanceof Coordinate) {
	      var pt = arguments[0];
	      this.insertPoint(this._argIndex, pt, Location.INTERIOR);
	    }
	  };
	  GeometryGraph.prototype.addPolygon = function addPolygon (p) {
	    var this$1$1 = this;

	    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
	    for (var i = 0; i < p.getNumInteriorRing(); i++) {
	      var hole = p.getInteriorRingN(i);
	      this$1$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
	    }
	  };
	  GeometryGraph.prototype.addEdge = function addEdge (e) {
	    this.insertEdge(e);
	    var coord = e.getCoordinates();
	    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
	    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
	  };
	  GeometryGraph.prototype.addLineString = function addLineString (line) {
	    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
	    if (coord.length < 2) {
	      this._hasTooFewPoints = true;
	      this._invalidPoint = coord[0];
	      return null
	    }
	    var e = new Edge$1(coord, new Label(this._argIndex, Location.INTERIOR));
	    this._lineEdgeMap.put(line, e);
	    this.insertEdge(e);
	    Assert.isTrue(coord.length >= 2, 'found LineString with single point');
	    this.insertBoundaryPoint(this._argIndex, coord[0]);
	    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
	  };
	  GeometryGraph.prototype.getInvalidPoint = function getInvalidPoint () {
	    return this._invalidPoint
	  };
	  GeometryGraph.prototype.getBoundaryPoints = function getBoundaryPoints () {
	    var coll = this.getBoundaryNodes();
	    var pts = new Array(coll.size()).fill(null);
	    var i = 0;
	    for (var it = coll.iterator(); it.hasNext();) {
	      var node = it.next();
	      pts[i++] = node.getCoordinate().copy();
	    }
	    return pts
	  };
	  GeometryGraph.prototype.getBoundaryNodes = function getBoundaryNodes () {
	    if (this._boundaryNodes === null) { this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex); }
	    return this._boundaryNodes
	  };
	  GeometryGraph.prototype.addSelfIntersectionNode = function addSelfIntersectionNode (argIndex, coord, loc) {
	    if (this.isBoundaryNode(argIndex, coord)) { return null }
	    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) { this.insertBoundaryPoint(argIndex, coord); } else { this.insertPoint(argIndex, coord, loc); }
	  };
	  GeometryGraph.prototype.addPolygonRing = function addPolygonRing (lr, cwLeft, cwRight) {
	    if (lr.isEmpty()) { return null }
	    var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
	    if (coord.length < 4) {
	      this._hasTooFewPoints = true;
	      this._invalidPoint = coord[0];
	      return null
	    }
	    var left = cwLeft;
	    var right = cwRight;
	    if (CGAlgorithms.isCCW(coord)) {
	      left = cwRight;
	      right = cwLeft;
	    }
	    var e = new Edge$1(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
	    this._lineEdgeMap.put(lr, e);
	    this.insertEdge(e);
	    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
	  };
	  GeometryGraph.prototype.insertPoint = function insertPoint (argIndex, coord, onLocation) {
	    var n = this._nodes.addNode(coord);
	    var lbl = n.getLabel();
	    if (lbl === null) {
	      n._label = new Label(argIndex, onLocation);
	    } else { lbl.setLocation(argIndex, onLocation); }
	  };
	  GeometryGraph.prototype.createEdgeSetIntersector = function createEdgeSetIntersector () {
	    return new SimpleMCSweepLineIntersector()
	  };
	  GeometryGraph.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes (argIndex) {
	    var this$1$1 = this;

	    for (var i = this._edges.iterator(); i.hasNext();) {
	      var e = i.next();
	      var eLoc = e.getLabel().getLocation(argIndex);
	      for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {
	        var ei = eiIt.next();
	        this$1$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
	      }
	    }
	  };
	  GeometryGraph.prototype.add = function add () {
	    if (arguments.length === 1) {
	      var g = arguments[0];
	      if (g.isEmpty()) { return null }
	      if (g instanceof MultiPolygon) { this._useBoundaryDeterminationRule = false; }
	      if (g instanceof Polygon) { this.addPolygon(g); }
	      else if (g instanceof LineString$1) { this.addLineString(g); }
	      else if (g instanceof Point) { this.addPoint(g); }
	      else if (g instanceof MultiPoint) { this.addCollection(g); }
	      else if (g instanceof MultiLineString) { this.addCollection(g); }
	      else if (g instanceof MultiPolygon) { this.addCollection(g); }
	      else if (g instanceof GeometryCollection) { this.addCollection(g); }
	      else { throw new Error(g.getClass().getName()) }
	    } else { return PlanarGraph$$1.prototype.add.apply(this, arguments) }
	  };
	  GeometryGraph.prototype.addCollection = function addCollection (gc) {
	    var this$1$1 = this;

	    for (var i = 0; i < gc.getNumGeometries(); i++) {
	      var g = gc.getGeometryN(i);
	      this$1$1.add(g);
	    }
	  };
	  GeometryGraph.prototype.locate = function locate (pt) {
	    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
	      if (this._areaPtLocator === null) {
	        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
	      }
	      return this._areaPtLocator.locate(pt)
	    }
	    return this._ptLocator.locate(pt, this._parentGeom)
	  };
	  GeometryGraph.prototype.findEdge = function findEdge () {
	    if (arguments.length === 1) {
	      var line = arguments[0];
	      return this._lineEdgeMap.get(line)
	    } else { return PlanarGraph$$1.prototype.findEdge.apply(this, arguments) }
	  };
	  GeometryGraph.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  GeometryGraph.prototype.getClass = function getClass () {
	    return GeometryGraph
	  };
	  GeometryGraph.determineBoundary = function determineBoundary (boundaryNodeRule, boundaryCount) {
	    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR
	  };

	  return GeometryGraph;
	}(PlanarGraph));

	var GeometryGraphOp = function GeometryGraphOp () {
	  this._li = new RobustLineIntersector();
	  this._resultPrecisionModel = null;
	  this._arg = null;
	  if (arguments.length === 1) {
	    var g0 = arguments[0];
	    this.setComputationPrecision(g0.getPrecisionModel());
	    this._arg = new Array(1).fill(null);
	    this._arg[0] = new GeometryGraph(0, g0);
	  } else if (arguments.length === 2) {
	    var g0$1 = arguments[0];
	    var g1 = arguments[1];
	    var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
	    if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$1.getPrecisionModel()); } else { this.setComputationPrecision(g1.getPrecisionModel()); }
	    this._arg = new Array(2).fill(null);
	    this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);
	    this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
	  } else if (arguments.length === 3) {
	    var g0$2 = arguments[0];
	    var g1$1 = arguments[1];
	    var boundaryNodeRule$1 = arguments[2];
	    if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$2.getPrecisionModel()); } else { this.setComputationPrecision(g1$1.getPrecisionModel()); }
	    this._arg = new Array(2).fill(null);
	    this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);
	    this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);
	  }
	};
	GeometryGraphOp.prototype.getArgGeometry = function getArgGeometry (i) {
	  return this._arg[i].getGeometry()
	};
	GeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision (pm) {
	  this._resultPrecisionModel = pm;
	  this._li.setPrecisionModel(this._resultPrecisionModel);
	};
	GeometryGraphOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryGraphOp.prototype.getClass = function getClass () {
	  return GeometryGraphOp
	};

	// operation.geometrygraph

	var GeometryMapper = function GeometryMapper () {};

	GeometryMapper.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryMapper.prototype.getClass = function getClass () {
	  return GeometryMapper
	};
	GeometryMapper.map = function map () {
	  if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
	    var geom = arguments[0];
	    var op = arguments[1];
	    var mapped = new ArrayList();
	    for (var i = 0; i < geom.getNumGeometries(); i++) {
	      var g = op.map(geom.getGeometryN(i));
	      if (g !== null) { mapped.add(g); }
	    }
	    return geom.getFactory().buildGeometry(mapped)
	  } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
	    var geoms = arguments[0];
	    var op$1 = arguments[1];
	    var mapped$1 = new ArrayList();
	    for (var i$1 = geoms.iterator(); i$1.hasNext();) {
	      var g$1 = i$1.next();
	      var gr = op$1.map(g$1);
	      if (gr !== null) { mapped$1.add(gr); }
	    }
	    return mapped$1
	  }
	};
	GeometryMapper.MapOp = function MapOp () {};

	var OverlayOp = (function (GeometryGraphOp) {
	  function OverlayOp () {
	    var g0 = arguments[0];
	    var g1 = arguments[1];
	    GeometryGraphOp.call(this, g0, g1);
	    this._ptLocator = new PointLocator();
	    this._geomFact = null;
	    this._resultGeom = null;
	    this._graph = null;
	    this._edgeList = new EdgeList();
	    this._resultPolyList = new ArrayList();
	    this._resultLineList = new ArrayList();
	    this._resultPointList = new ArrayList();
	    this._graph = new PlanarGraph(new OverlayNodeFactory());
	    this._geomFact = g0.getFactory();
	  }

	  if ( GeometryGraphOp ) OverlayOp.__proto__ = GeometryGraphOp;
	  OverlayOp.prototype = Object.create( GeometryGraphOp && GeometryGraphOp.prototype );
	  OverlayOp.prototype.constructor = OverlayOp;
	  OverlayOp.prototype.insertUniqueEdge = function insertUniqueEdge (e) {
	    var existingEdge = this._edgeList.findEqualEdge(e);
	    if (existingEdge !== null) {
	      var existingLabel = existingEdge.getLabel();
	      var labelToMerge = e.getLabel();
	      if (!existingEdge.isPointwiseEqual(e)) {
	        labelToMerge = new Label(e.getLabel());
	        labelToMerge.flip();
	      }
	      var depth = existingEdge.getDepth();
	      if (depth.isNull()) {
	        depth.add(existingLabel);
	      }
	      depth.add(labelToMerge);
	      existingLabel.merge(labelToMerge);
	    } else {
	      this._edgeList.add(e);
	    }
	  };
	  OverlayOp.prototype.getGraph = function getGraph () {
	    return this._graph
	  };
	  OverlayOp.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges () {
	    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
	      var de = it.next();
	      var sym = de.getSym();
	      if (de.isInResult() && sym.isInResult()) {
	        de.setInResult(false);
	        sym.setInResult(false);
	      }
	    }
	  };
	  OverlayOp.prototype.isCoveredByLA = function isCoveredByLA (coord) {
	    if (this.isCovered(coord, this._resultLineList)) { return true }
	    if (this.isCovered(coord, this._resultPolyList)) { return true }
	    return false
	  };
	  OverlayOp.prototype.computeGeometry = function computeGeometry (resultPointList, resultLineList, resultPolyList, opcode) {
	    var geomList = new ArrayList();
	    geomList.addAll(resultPointList);
	    geomList.addAll(resultLineList);
	    geomList.addAll(resultPolyList);
	    if (geomList.isEmpty()) { return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) }
	    return this._geomFact.buildGeometry(geomList)
	  };
	  OverlayOp.prototype.mergeSymLabels = function mergeSymLabels () {
	    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
	      var node = nodeit.next();
	      node.getEdges().mergeSymLabels();
	    }
	  };
	  OverlayOp.prototype.isCovered = function isCovered (coord, geomList) {
	    var this$1$1 = this;

	    for (var it = geomList.iterator(); it.hasNext();) {
	      var geom = it.next();
	      var loc = this$1$1._ptLocator.locate(coord, geom);
	      if (loc !== Location.EXTERIOR) { return true }
	    }
	    return false
	  };
	  OverlayOp.prototype.replaceCollapsedEdges = function replaceCollapsedEdges () {
	    var newEdges = new ArrayList();
	    for (var it = this._edgeList.iterator(); it.hasNext();) {
	      var e = it.next();
	      if (e.isCollapsed()) {
	        it.remove();
	        newEdges.add(e.getCollapsedEdge());
	      }
	    }
	    this._edgeList.addAll(newEdges);
	  };
	  OverlayOp.prototype.updateNodeLabelling = function updateNodeLabelling () {
	    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
	      var node = nodeit.next();
	      var lbl = node.getEdges().getLabel();
	      node.getLabel().merge(lbl);
	    }
	  };
	  OverlayOp.prototype.getResultGeometry = function getResultGeometry (overlayOpCode) {
	    this.computeOverlay(overlayOpCode);
	    return this._resultGeom
	  };
	  OverlayOp.prototype.insertUniqueEdges = function insertUniqueEdges (edges) {
	    var this$1$1 = this;

	    for (var i = edges.iterator(); i.hasNext();) {
	      var e = i.next();
	      this$1$1.insertUniqueEdge(e);
	    }
	  };
	  OverlayOp.prototype.computeOverlay = function computeOverlay (opCode) {
	    this.copyPoints(0);
	    this.copyPoints(1);
	    this._arg[0].computeSelfNodes(this._li, false);
	    this._arg[1].computeSelfNodes(this._li, false);
	    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
	    var baseSplitEdges = new ArrayList();
	    this._arg[0].computeSplitEdges(baseSplitEdges);
	    this._arg[1].computeSplitEdges(baseSplitEdges);
	    // const splitEdges = baseSplitEdges
	    this.insertUniqueEdges(baseSplitEdges);
	    this.computeLabelsFromDepths();
	    this.replaceCollapsedEdges();
	    EdgeNodingValidator.checkValid(this._edgeList.getEdges());
	    this._graph.addEdges(this._edgeList.getEdges());
	    this.computeLabelling();
	    this.labelIncompleteNodes();
	    this.findResultAreaEdges(opCode);
	    this.cancelDuplicateResultEdges();
	    var polyBuilder = new PolygonBuilder(this._geomFact);
	    polyBuilder.add(this._graph);
	    this._resultPolyList = polyBuilder.getPolygons();
	    var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
	    this._resultLineList = lineBuilder.build(opCode);
	    var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
	    this._resultPointList = pointBuilder.build(opCode);
	    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
	  };
	  OverlayOp.prototype.labelIncompleteNode = function labelIncompleteNode (n, targetIndex) {
	    var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
	    n.getLabel().setLocation(targetIndex, loc);
	  };
	  OverlayOp.prototype.copyPoints = function copyPoints (argIndex) {
	    var this$1$1 = this;

	    for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {
	      var graphNode = i.next();
	      var newNode = this$1$1._graph.addNode(graphNode.getCoordinate());
	      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
	    }
	  };
	  OverlayOp.prototype.findResultAreaEdges = function findResultAreaEdges (opCode) {
	    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
	      var de = it.next();
	      var label = de.getLabel();
	      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position$1.RIGHT), label.getLocation(1, Position$1.RIGHT), opCode)) {
	        de.setInResult(true);
	      }
	    }
	  };
	  OverlayOp.prototype.computeLabelsFromDepths = function computeLabelsFromDepths () {
	    for (var it = this._edgeList.iterator(); it.hasNext();) {
	      var e = it.next();
	      var lbl = e.getLabel();
	      var depth = e.getDepth();
	      if (!depth.isNull()) {
	        depth.normalize();
	        for (var i = 0; i < 2; i++) {
	          if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
	            if (depth.getDelta(i) === 0) {
	              lbl.toLine(i);
	            } else {
	              Assert.isTrue(!depth.isNull(i, Position$1.LEFT), 'depth of LEFT side has not been initialized');
	              lbl.setLocation(i, Position$1.LEFT, depth.getLocation(i, Position$1.LEFT));
	              Assert.isTrue(!depth.isNull(i, Position$1.RIGHT), 'depth of RIGHT side has not been initialized');
	              lbl.setLocation(i, Position$1.RIGHT, depth.getLocation(i, Position$1.RIGHT));
	            }
	          }
	        }
	      }
	    }
	  };
	  OverlayOp.prototype.computeLabelling = function computeLabelling () {
	    var this$1$1 = this;

	    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
	      var node = nodeit.next();
	      node.getEdges().computeLabelling(this$1$1._arg);
	    }
	    this.mergeSymLabels();
	    this.updateNodeLabelling();
	  };
	  OverlayOp.prototype.labelIncompleteNodes = function labelIncompleteNodes () {
	    var this$1$1 = this;

	    // let nodeCount = 0
	    for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {
	      var n = ni.next();
	      var label = n.getLabel();
	      if (n.isIsolated()) {
	        // nodeCount++
	        if (label.isNull(0)) { this$1$1.labelIncompleteNode(n, 0); } else { this$1$1.labelIncompleteNode(n, 1); }
	      }
	      n.getEdges().updateLabelling(label);
	    }
	  };
	  OverlayOp.prototype.isCoveredByA = function isCoveredByA (coord) {
	    if (this.isCovered(coord, this._resultPolyList)) { return true }
	    return false
	  };
	  OverlayOp.prototype.interfaces_ = function interfaces_ () {
	    return []
	  };
	  OverlayOp.prototype.getClass = function getClass () {
	    return OverlayOp
	  };

	  return OverlayOp;
	}(GeometryGraphOp));

	OverlayOp.overlayOp = function (geom0, geom1, opCode) {
	  var gov = new OverlayOp(geom0, geom1);
	  var geomOv = gov.getResultGeometry(opCode);
	  return geomOv
	};
	OverlayOp.intersection = function (g, other) {
	  if (g.isEmpty() || other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory()) }
	  if (g.isGeometryCollection()) {
	    var g2 = other;
	    return GeometryCollectionMapper.map(g, {
	      interfaces_: function () {
	        return [GeometryMapper.MapOp]
	      },
	      map: function (g) {
	        return g.intersection(g2)
	      }
	    })
	  }
	  g.checkNotGeometryCollection(g);
	  g.checkNotGeometryCollection(other);
	  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION)
	};
	OverlayOp.symDifference = function (g, other) {
	  if (g.isEmpty() || other.isEmpty()) {
	    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory()) }
	    if (g.isEmpty()) { return other.copy() }
	    if (other.isEmpty()) { return g.copy() }
	  }
	  g.checkNotGeometryCollection(g);
	  g.checkNotGeometryCollection(other);
	  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE)
	};
	OverlayOp.resultDimension = function (opCode, g0, g1) {
	  var dim0 = g0.getDimension();
	  var dim1 = g1.getDimension();
	  var resultDimension = -1;
	  switch (opCode) {
	    case OverlayOp.INTERSECTION:
	      resultDimension = Math.min(dim0, dim1);
	      break
	    case OverlayOp.UNION:
	      resultDimension = Math.max(dim0, dim1);
	      break
	    case OverlayOp.DIFFERENCE:
	      resultDimension = dim0;
	      break
	    case OverlayOp.SYMDIFFERENCE:
	      resultDimension = Math.max(dim0, dim1);
	      break
	  }
	  return resultDimension
	};
	OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {
	  var result = null;
	  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
	    case -1:
	      result = geomFact.createGeometryCollection(new Array(0).fill(null));
	      break
	    case 0:
	      result = geomFact.createPoint();
	      break
	    case 1:
	      result = geomFact.createLineString();
	      break
	    case 2:
	      result = geomFact.createPolygon();
	      break
	  }
	  return result
	};
	OverlayOp.difference = function (g, other) {
	  if (g.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory()) }
	  if (other.isEmpty()) { return g.copy() }
	  g.checkNotGeometryCollection(g);
	  g.checkNotGeometryCollection(other);
	  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE)
	};
	OverlayOp.isResultOfOp = function () {
	  if (arguments.length === 2) {
	    var label = arguments[0];
	    var opCode = arguments[1];
	    var loc0 = label.getLocation(0);
	    var loc1 = label.getLocation(1);
	    return OverlayOp.isResultOfOp(loc0, loc1, opCode)
	  } else if (arguments.length === 3) {
	    var loc0$1 = arguments[0];
	    var loc1$1 = arguments[1];
	    var overlayOpCode = arguments[2];
	    if (loc0$1 === Location.BOUNDARY) { loc0$1 = Location.INTERIOR; }
	    if (loc1$1 === Location.BOUNDARY) { loc1$1 = Location.INTERIOR; }
	    switch (overlayOpCode) {
	      case OverlayOp.INTERSECTION:
	        return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR
	      case OverlayOp.UNION:
	        return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR
	      case OverlayOp.DIFFERENCE:
	        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR
	      case OverlayOp.SYMDIFFERENCE:
	        return (loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR) || (loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR)
	    }
	    return false
	  }
	};
	OverlayOp.INTERSECTION = 1;
	OverlayOp.UNION = 2;
	OverlayOp.DIFFERENCE = 3;
	OverlayOp.SYMDIFFERENCE = 4;

	var FuzzyPointLocator = function FuzzyPointLocator () {
	  this._g = null;
	  this._boundaryDistanceTolerance = null;
	  this._linework = null;
	  this._ptLocator = new PointLocator();
	  this._seg = new LineSegment();
	  var g = arguments[0];
	  var boundaryDistanceTolerance = arguments[1];
	  this._g = g;
	  this._boundaryDistanceTolerance = boundaryDistanceTolerance;
	  this._linework = this.extractLinework(g);
	};
	FuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary (pt) {
	    var this$1$1 = this;

	  for (var i = 0; i < this._linework.getNumGeometries(); i++) {
	    var line = this$1$1._linework.getGeometryN(i);
	    var seq = line.getCoordinateSequence();
	    for (var j = 0; j < seq.size() - 1; j++) {
	      seq.getCoordinate(j, this$1$1._seg.p0);
	      seq.getCoordinate(j + 1, this$1$1._seg.p1);
	      var dist = this$1$1._seg.distance(pt);
	      if (dist <= this$1$1._boundaryDistanceTolerance) { return true }
	    }
	  }
	  return false
	};
	FuzzyPointLocator.prototype.getLocation = function getLocation (pt) {
	  if (this.isWithinToleranceOfBoundary(pt)) { return Location.BOUNDARY }
	  return this._ptLocator.locate(pt, this._g)
	};
	FuzzyPointLocator.prototype.extractLinework = function extractLinework (g) {
	  var extracter = new PolygonalLineworkExtracter();
	  g.apply(extracter);
	  var linework = extracter.getLinework();
	  var lines = GeometryFactory.toLineStringArray(linework);
	  return g.getFactory().createMultiLineString(lines)
	};
	FuzzyPointLocator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	FuzzyPointLocator.prototype.getClass = function getClass () {
	  return FuzzyPointLocator
	};

	var PolygonalLineworkExtracter = function PolygonalLineworkExtracter () {
	  this._linework = null;
	  this._linework = new ArrayList();
	};
	PolygonalLineworkExtracter.prototype.getLinework = function getLinework () {
	  return this._linework
	};
	PolygonalLineworkExtracter.prototype.filter = function filter (g) {
	    var this$1$1 = this;

	  if (g instanceof Polygon) {
	    var poly = g;
	    this._linework.add(poly.getExteriorRing());
	    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
	      this$1$1._linework.add(poly.getInteriorRingN(i));
	    }
	  }
	};
	PolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_ () {
	  return [GeometryFilter]
	};
	PolygonalLineworkExtracter.prototype.getClass = function getClass () {
	  return PolygonalLineworkExtracter
	};

	var OffsetPointGenerator = function OffsetPointGenerator () {
	  this._g = null;
	  this._doLeft = true;
	  this._doRight = true;
	  var g = arguments[0];
	  this._g = g;
	};
	OffsetPointGenerator.prototype.extractPoints = function extractPoints (line, offsetDistance, offsetPts) {
	    var this$1$1 = this;

	  var pts = line.getCoordinates();
	  for (var i = 0; i < pts.length - 1; i++) {
	    this$1$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);
	  }
	};
	OffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate (doLeft, doRight) {
	  this._doLeft = doLeft;
	  this._doRight = doRight;
	};
	OffsetPointGenerator.prototype.getPoints = function getPoints (offsetDistance) {
	    var this$1$1 = this;

	  var offsetPts = new ArrayList();
	  var lines = LinearComponentExtracter.getLines(this._g);
	  for (var i = lines.iterator(); i.hasNext();) {
	    var line = i.next();
	    this$1$1.extractPoints(line, offsetDistance, offsetPts);
	  }
	  return offsetPts
	};
	OffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints (p0, p1, offsetDistance, offsetPts) {
	  var dx = p1.x - p0.x;
	  var dy = p1.y - p0.y;
	  var len = Math.sqrt(dx * dx + dy * dy);
	  var ux = offsetDistance * dx / len;
	  var uy = offsetDistance * dy / len;
	  var midX = (p1.x + p0.x) / 2;
	  var midY = (p1.y + p0.y) / 2;
	  if (this._doLeft) {
	    var offsetLeft = new Coordinate(midX - uy, midY + ux);
	    offsetPts.add(offsetLeft);
	  }
	  if (this._doRight) {
	    var offsetRight = new Coordinate(midX + uy, midY - ux);
	    offsetPts.add(offsetRight);
	  }
	};
	OffsetPointGenerator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	OffsetPointGenerator.prototype.getClass = function getClass () {
	  return OffsetPointGenerator
	};

	var OverlayResultValidator = function OverlayResultValidator () {
	  this._geom = null;
	  this._locFinder = null;
	  this._location = new Array(3).fill(null);
	  this._invalidLocation = null;
	  this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;
	  this._testCoords = new ArrayList();
	  var a = arguments[0];
	  var b = arguments[1];
	  var result = arguments[2];
	  this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);
	  this._geom = [a, b, result];
	  this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];
	};

	var staticAccessors$46 = { TOLERANCE: { configurable: true } };
	OverlayResultValidator.prototype.reportResult = function reportResult (overlayOp, location, expectedInterior) {
	  System.out.println('Overlay result invalid - A:' + Location.toLocationSymbol(location[0]) + ' B:' + Location.toLocationSymbol(location[1]) + ' expected:' + (expectedInterior ? 'i' : 'e') + ' actual:' + Location.toLocationSymbol(location[2]));
	};
	OverlayResultValidator.prototype.isValid = function isValid (overlayOp) {
	  this.addTestPts(this._geom[0]);
	  this.addTestPts(this._geom[1]);
	  var isValid = this.checkValid(overlayOp);
	  return isValid
	};
	OverlayResultValidator.prototype.checkValid = function checkValid () {
	    var this$1$1 = this;

	  if (arguments.length === 1) {
	    var overlayOp = arguments[0];
	    for (var i = 0; i < this._testCoords.size(); i++) {
	      var pt = this$1$1._testCoords.get(i);
	      if (!this$1$1.checkValid(overlayOp, pt)) {
	        this$1$1._invalidLocation = pt;
	        return false
	      }
	    }
	    return true
	  } else if (arguments.length === 2) {
	    var overlayOp$1 = arguments[0];
	    var pt$1 = arguments[1];
	    this._location[0] = this._locFinder[0].getLocation(pt$1);
	    this._location[1] = this._locFinder[1].getLocation(pt$1);
	    this._location[2] = this._locFinder[2].getLocation(pt$1);
	    if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) { return true }
	    return this.isValidResult(overlayOp$1, this._location)
	  }
	};
	OverlayResultValidator.prototype.addTestPts = function addTestPts (g) {
	  var ptGen = new OffsetPointGenerator(g);
	  this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));
	};
	OverlayResultValidator.prototype.isValidResult = function isValidResult (overlayOp, location) {
	  var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);
	  var resultInInterior = location[2] === Location.INTERIOR;
	  var isValid = !(expectedInterior ^ resultInInterior);
	  if (!isValid) { this.reportResult(overlayOp, location, expectedInterior); }
	  return isValid
	};
	OverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation () {
	  return this._invalidLocation
	};
	OverlayResultValidator.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	OverlayResultValidator.prototype.getClass = function getClass () {
	  return OverlayResultValidator
	};
	OverlayResultValidator.hasLocation = function hasLocation (location, loc) {
	  for (var i = 0; i < 3; i++) {
	    if (location[i] === loc) { return true }
	  }
	  return false
	};
	OverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance (g0, g1) {
	  return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1))
	};
	OverlayResultValidator.isValid = function isValid (a, b, overlayOp, result) {
	  var validator = new OverlayResultValidator(a, b, result);
	  return validator.isValid(overlayOp)
	};
	staticAccessors$46.TOLERANCE.get = function () { return 0.000001 };

	Object.defineProperties( OverlayResultValidator, staticAccessors$46 );

	// operation.overlay

	var GeometryCombiner = function GeometryCombiner (geoms) {
	  this._geomFactory = null;
	  this._skipEmpty = false;
	  this._inputGeoms = null;
	  this._geomFactory = GeometryCombiner.extractFactory(geoms);
	  this._inputGeoms = geoms;
	};
	GeometryCombiner.prototype.extractElements = function extractElements (geom, elems) {
	    var this$1$1 = this;

	  if (geom === null) { return null }
	  for (var i = 0; i < geom.getNumGeometries(); i++) {
	    var elemGeom = geom.getGeometryN(i);
	    if (this$1$1._skipEmpty && elemGeom.isEmpty()) { continue }
	    elems.add(elemGeom);
	  }
	};
	GeometryCombiner.prototype.combine = function combine () {
	    var this$1$1 = this;

	  var elems = new ArrayList();
	  for (var i = this._inputGeoms.iterator(); i.hasNext();) {
	    var g = i.next();
	    this$1$1.extractElements(g, elems);
	  }
	  if (elems.size() === 0) {
	    if (this._geomFactory !== null) {
	      return this._geomFactory.createGeometryCollection(null)
	    }
	    return null
	  }
	  return this._geomFactory.buildGeometry(elems)
	};
	GeometryCombiner.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	GeometryCombiner.prototype.getClass = function getClass () {
	  return GeometryCombiner
	};
	GeometryCombiner.combine = function combine () {
	  if (arguments.length === 1) {
	    var geoms = arguments[0];
	    var combiner = new GeometryCombiner(geoms);
	    return combiner.combine()
	  } else if (arguments.length === 2) {
	    var g0 = arguments[0];
	    var g1 = arguments[1];
	    var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
	    return combiner$1.combine()
	  } else if (arguments.length === 3) {
	    var g0$1 = arguments[0];
	    var g1$1 = arguments[1];
	    var g2 = arguments[2];
	    var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));
	    return combiner$2.combine()
	  }
	};
	GeometryCombiner.extractFactory = function extractFactory (geoms) {
	  if (geoms.isEmpty()) { return null }
	  return geoms.iterator().next().getFactory()
	};
	GeometryCombiner.createList = function createList () {
	  if (arguments.length === 2) {
	    var obj0 = arguments[0];
	    var obj1 = arguments[1];
	    var list = new ArrayList();
	    list.add(obj0);
	    list.add(obj1);
	    return list
	  } else if (arguments.length === 3) {
	    var obj0$1 = arguments[0];
	    var obj1$1 = arguments[1];
	    var obj2 = arguments[2];
	    var list$1 = new ArrayList();
	    list$1.add(obj0$1);
	    list$1.add(obj1$1);
	    list$1.add(obj2);
	    return list$1
	  }
	};

	var CascadedPolygonUnion = function CascadedPolygonUnion () {
	  this._inputPolys = null;
	  this._geomFactory = null;
	  var polys = arguments[0];
	  this._inputPolys = polys;
	  if (this._inputPolys === null) { this._inputPolys = new ArrayList(); }
	};

	var staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };
	CascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries (geomTree) {
	    var this$1$1 = this;

	  var geoms = new ArrayList();
	  for (var i = geomTree.iterator(); i.hasNext();) {
	    var o = i.next();
	    var geom = null;
	    if (hasInterface(o, List)) {
	      geom = this$1$1.unionTree(o);
	    } else if (o instanceof Geometry) {
	      geom = o;
	    }
	    geoms.add(geom);
	  }
	  return geoms
	};
	CascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope (env, geom, disjointGeoms) {
	  var intersectingGeoms = new ArrayList();
	  for (var i = 0; i < geom.getNumGeometries(); i++) {
	    var elem = geom.getGeometryN(i);
	    if (elem.getEnvelopeInternal().intersects(env)) { intersectingGeoms.add(elem); } else { disjointGeoms.add(elem); }
	  }
	  return this._geomFactory.buildGeometry(intersectingGeoms)
	};
	CascadedPolygonUnion.prototype.unionOptimized = function unionOptimized (g0, g1) {
	  var g0Env = g0.getEnvelopeInternal();
	  var g1Env = g1.getEnvelopeInternal();
	  if (!g0Env.intersects(g1Env)) {
	    var combo = GeometryCombiner.combine(g0, g1);
	    return combo
	  }
	  if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) { return this.unionActual(g0, g1) }
	  var commonEnv = g0Env.intersection(g1Env);
	  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv)
	};
	CascadedPolygonUnion.prototype.union = function union () {
	  if (this._inputPolys === null) { throw new Error('union() method cannot be called twice') }
	  if (this._inputPolys.isEmpty()) { return null }
	  this._geomFactory = this._inputPolys.iterator().next().getFactory();
	  var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
	  for (var i = this._inputPolys.iterator(); i.hasNext();) {
	    var item = i.next();
	    index.insert(item.getEnvelopeInternal(), item);
	  }
	  this._inputPolys = null;
	  var itemTree = index.itemsTree();
	  var unionAll = this.unionTree(itemTree);
	  return unionAll
	};
	CascadedPolygonUnion.prototype.binaryUnion = function binaryUnion () {
	  if (arguments.length === 1) {
	    var geoms = arguments[0];
	    return this.binaryUnion(geoms, 0, geoms.size())
	  } else if (arguments.length === 3) {
	    var geoms$1 = arguments[0];
	    var start = arguments[1];
	    var end = arguments[2];
	    if (end - start <= 1) {
	      var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);
	      return this.unionSafe(g0, null)
	    } else if (end - start === 2) {
	      return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1))
	    } else {
	      var mid = Math.trunc((end + start) / 2);
	      var g0$1 = this.binaryUnion(geoms$1, start, mid);
	      var g1 = this.binaryUnion(geoms$1, mid, end);
	      return this.unionSafe(g0$1, g1)
	    }
	  }
	};
	CascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion (geoms) {
	  var union = null;
	  for (var i = geoms.iterator(); i.hasNext();) {
	    var g = i.next();
	    if (union === null) { union = g.copy(); } else { union = union.union(g); }
	  }
	  return union
	};
	CascadedPolygonUnion.prototype.unionSafe = function unionSafe (g0, g1) {
	  if (g0 === null && g1 === null) { return null }
	  if (g0 === null) { return g1.copy() }
	  if (g1 === null) { return g0.copy() }
	  return this.unionOptimized(g0, g1)
	};
	CascadedPolygonUnion.prototype.unionActual = function unionActual (g0, g1) {
	  return CascadedPolygonUnion.restrictToPolygons(g0.union(g1))
	};
	CascadedPolygonUnion.prototype.unionTree = function unionTree (geomTree) {
	  var geoms = this.reduceToGeometries(geomTree);
	  var union = this.binaryUnion(geoms);
	  return union
	};
	CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection (g0, g1, common) {
	  var disjointPolys = new ArrayList();
	  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
	  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
	  var union = this.unionActual(g0Int, g1Int);
	  disjointPolys.add(union);
	  var overallUnion = GeometryCombiner.combine(disjointPolys);
	  return overallUnion
	};
	CascadedPolygonUnion.prototype.bufferUnion = function bufferUnion () {
	  if (arguments.length === 1) {
	    var geoms = arguments[0];
	    var factory = geoms.get(0).getFactory();
	    var gColl = factory.buildGeometry(geoms);
	    var unionAll = gColl.buffer(0.0);
	    return unionAll
	  } else if (arguments.length === 2) {
	    var g0 = arguments[0];
	    var g1 = arguments[1];
	    var factory$1 = g0.getFactory();
	    var gColl$1 = factory$1.createGeometryCollection([g0, g1]);
	    var unionAll$1 = gColl$1.buffer(0.0);
	    return unionAll$1
	  }
	};
	CascadedPolygonUnion.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	CascadedPolygonUnion.prototype.getClass = function getClass () {
	  return CascadedPolygonUnion
	};
	CascadedPolygonUnion.restrictToPolygons = function restrictToPolygons (g) {
	  if (hasInterface(g, Polygonal)) {
	    return g
	  }
	  var polygons = PolygonExtracter.getPolygons(g);
	  if (polygons.size() === 1) { return polygons.get(0) }
	  return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons))
	};
	CascadedPolygonUnion.getGeometry = function getGeometry (list, index) {
	  if (index >= list.size()) { return null }
	  return list.get(index)
	};
	CascadedPolygonUnion.union = function union (polys) {
	  var op = new CascadedPolygonUnion(polys);
	  return op.union()
	};
	staticAccessors$47.STRTREE_NODE_CAPACITY.get = function () { return 4 };

	Object.defineProperties( CascadedPolygonUnion, staticAccessors$47 );

	var UnionOp = function UnionOp () {};

	UnionOp.prototype.interfaces_ = function interfaces_ () {
	  return []
	};
	UnionOp.prototype.getClass = function getClass () {
	  return UnionOp
	};
	UnionOp.union = function union (g, other) {
	  if (g.isEmpty() || other.isEmpty()) {
	    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory()) }
	    if (g.isEmpty()) { return other.copy() }
	    if (other.isEmpty()) { return g.copy() }
	  }
	  g.checkNotGeometryCollection(g);
	  g.checkNotGeometryCollection(other);
	  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION)
	};

	/**
	 * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.
	 *
	 * @name difference
	 * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature
	 * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1
	 * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)
	 * @example
	 * var polygon1 = turf.polygon([[
	 *   [128, -26],
	 *   [141, -26],
	 *   [141, -21],
	 *   [128, -21],
	 *   [128, -26]
	 * ]], {
	 *   "fill": "#F00",
	 *   "fill-opacity": 0.1
	 * });
	 * var polygon2 = turf.polygon([[
	 *   [126, -28],
	 *   [140, -28],
	 *   [140, -20],
	 *   [126, -20],
	 *   [126, -28]
	 * ]], {
	 *   "fill": "#00F",
	 *   "fill-opacity": 0.1
	 * });
	 *
	 * var difference = turf.difference(polygon1, polygon2);
	 *
	 * //addToMap
	 * var addToMap = [polygon1, polygon2, difference];
	 */
	function difference(polygon1, polygon2) {
	    var geom1 = getGeom(polygon1);
	    var geom2 = getGeom(polygon2);
	    var properties = polygon1.properties || {};

	    // Issue #721 - JSTS can't handle empty polygons
	    geom1 = removeEmptyPolygon(geom1);
	    geom2 = removeEmptyPolygon(geom2);
	    if (!geom1) return null;
	    if (!geom2) return feature(geom1, properties);

	    // JSTS difference operation
	    var reader = new GeoJSONReader();
	    var a = reader.read(geom1);
	    var b = reader.read(geom2);
	    var differenced = OverlayOp.difference(a, b);
	    if (differenced.isEmpty()) return null;
	    var writer = new GeoJSONWriter();
	    var geom = writer.write(differenced);

	    return feature(geom, properties);
	}

	/**
	 * Detect Empty Polygon
	 *
	 * @private
	 * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object
	 * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas
	 */
	function removeEmptyPolygon(geom) {
	    switch (geom.type) {
	    case 'Polygon':
	        if (area$1(geom) > 1) return geom;
	        return null;
	    case 'MultiPolygon':
	        var coordinates = [];
	        flattenEach(geom, function (feature$$1) {
	            if (area$1(feature$$1) > 1) coordinates.push(feature$$1.geometry.coordinates);
	        });
	        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};
	    }
	}

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	var adder = function() {
	  return new Adder;
	};

	function Adder() {
	  this.reset();
	}

	Adder.prototype = {
	  constructor: Adder,
	  reset: function() {
	    this.s = // rounded value
	    this.t = 0; // exact error
	  },
	  add: function(y) {
	    add$1(temp, y, this.t);
	    add$1(this, temp.s, this.s);
	    if (this.s) this.t += temp.t;
	    else this.s = temp.t;
	  },
	  valueOf: function() {
	    return this.s;
	  }
	};

	var temp = new Adder;

	function add$1(adder, a, b) {
	  var x = adder.s = a + b,
	      bv = x - a,
	      av = x - bv;
	  adder.t = (a - av) + (b - bv);
	}

	var pi = Math.PI;
	var tau = pi * 2;

	adder();

	adder();

	adder();

	function rotationIdentity(lambda, phi) {
	  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	}

	rotationIdentity.invert = rotationIdentity;

	var ascending = function(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	};

	var bisector = function(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	};

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	bisector(ascending);

	adder();

	adder();

	adder();
	adder();

	adder();

	function TransformStream() {}

	TransformStream.prototype = {
	  constructor: TransformStream,
	  point: function(x, y) { this.stream.point(x, y); },
	  sphere: function() { this.stream.sphere(); },
	  lineStart: function() { this.stream.lineStart(); },
	  lineEnd: function() { this.stream.lineEnd(); },
	  polygonStart: function() { this.stream.polygonStart(); },
	  polygonEnd: function() { this.stream.polygonEnd(); }
	};

	// depend on jsts for now http://bjornharrtell.github.io/jsts/
	/**
	 * Takes two {@link Polygon|polygons} and finds their intersection. If they share a border, returns the border; if they don't intersect, returns undefined.
	 *
	 * @name intersect
	 * @param {Feature<Polygon>} poly1 the first polygon
	 * @param {Feature<Polygon>} poly2 the second polygon
	 * @returns {Feature|null} returns a feature representing the point(s) they share (in case of a {@link Point}  or {@link MultiPoint}), the borders they share (in case of a {@link LineString} or a {@link MultiLineString}), the area they share (in case of {@link Polygon} or {@link MultiPolygon}). If they do not share any point, returns `null`.
	 * @example
	 * var poly1 = turf.polygon([[
	 *   [-122.801742, 45.48565],
	 *   [-122.801742, 45.60491],
	 *   [-122.584762, 45.60491],
	 *   [-122.584762, 45.48565],
	 *   [-122.801742, 45.48565]
	 * ]]);
	 *
	 * var poly2 = turf.polygon([[
	 *   [-122.520217, 45.535693],
	 *   [-122.64038, 45.553967],
	 *   [-122.720031, 45.526554],
	 *   [-122.669906, 45.507309],
	 *   [-122.723464, 45.446643],
	 *   [-122.532577, 45.408574],
	 *   [-122.487258, 45.477466],
	 *   [-122.520217, 45.535693]
	 * ]]);
	 *
	 * var intersection = turf.intersect(poly1, poly2);
	 *
	 * //addToMap
	 * var addToMap = [poly1, poly2, intersection];
	 */
	function intersect$2(poly1, poly2) {
	    var geom1 = getGeom(poly1);
	    var geom2 = getGeom(poly2);

	    // Return null if geometry is too narrow in coordinate precision
	    // fixes topology errors with JSTS
	    // https://github.com/Turfjs/turf/issues/463
	    // https://github.com/Turfjs/turf/pull/1004
	    if (cleanCoords(truncate(geom2, {precision: 4})).coordinates[0].length < 4) return null;
	    if (cleanCoords(truncate(geom1, {precision: 4})).coordinates[0].length < 4) return null;

	    var reader = new GeoJSONReader();
	    var a = reader.read(truncate(geom1));
	    var b = reader.read(truncate(geom2));
	    var intersection = OverlayOp.intersection(a, b);

	    // https://github.com/Turfjs/turf/issues/951
	    if (intersection.isEmpty()) return null;

	    var writer = new GeoJSONWriter();
	    var geom = writer.write(intersection);
	    return feature(geom);
	}

	/**
	 * @description Perform constrained triangulation of feature.
	 * @param {Polygon} polygon Polygon to triangulate.
	 * @private
	 * @return {FeatureCollection<Polygon>} Feature collection of triangles.
	 */
	const triangulate = (polygon) => {
	  const data = earcut$2.exports.flatten(polygon.geometry.coordinates);
	  const triangles = earcut$2.exports(data.vertices, data.holes, data.dimensions);

	  const polygons = [];

	  // Unflatten each triangle vertex data from earcut data and triangulation.
	  const numTriangles = triangles.length / 3;
	  for (let i = 0; i < numTriangles; ++i) {
	    // Collect each triangle vertex
	    const vertices = [];

	    for (let j = 0; j < 3; ++j) {
	      // Collect each vertex dimension
	      const vertex = [];
	      for (let k = 0; k < data.dimensions; ++k) {
	        const index = data.dimensions * triangles[3 * i + j] + k;
	        vertex.push(data.vertices[index]);
	      }
	      vertices.push(vertex);
	    }

	    // Close triangle coordinate array with initial coordinate.
	    vertices.push(vertices[0]);

	    polygons.push(polygon$8([vertices]));
	  }

	  return featureCollection(polygons);
	};

	/**
	 * @description Perform constrained triangulation of polygon(s). Triangulation
	 *              is performed on each polygon separately and then combined.
	 * @param {Polygons} geojson Features to triangulate.
	 * @private
	 * @return {FeatureCollection<Polygon>} Feature collection of triangles.
	 */
	var triangulate$1 = (geojson) => {
	  const polygons = [];
	  flattenEach(geojson, (feature) => {
	    const triangles = triangulate(feature);
	    featureEach$1(triangles, (triangle) => {
	      polygons.push(triangle);
	    });
	  });
	  return featureCollection(polygons);
	};

	/**
	 * @description Clip subject triangle using a triangle clipper. The result will
	 *              be a collection of triangles that partition the subject triangle
	 *              and preserve the clipping boundary.
	 * @param {Polygon} subject Triangle to be clipped.
	 * @param {Polygon} clipper Triangle with which to clip.
	 * @private
	 * @return {FeatureCollection<Polygon>} Triangle clipped components.
	 */
	const clip = (subject, clipper) => {
	  const triangles = [];

	  // Intersect subject with clipper and retriangulate intersection.
	  const intersection = clipIntersection(subject, clipper);
	  if (intersection) {
	    Array.prototype.push.apply(triangles, intersection);
	  }

	  // Difference subject with clipper and retriangulate difference.
	  const difference = clipDifference(subject, clipper);
	  if (difference) {
	    Array.prototype.push.apply(triangles, difference);
	  }

	  // If no triangles were found then assume subject was not clipped.
	  // This should only happen if Turf failed during intersection and
	  // difference due to an on-going numerical precision bug.
	  if (triangles.length === 0) {
	    triangles.push(subject);
	  }

	  return featureCollection(triangles);
	};

	/**
	 * @description Clip subject triangle using a triangle clipper. The result will
	 *              be a collection of triangles that are the difference of the
	 *              subject triangle and the clipper.
	 * @param {Polygon} subject Triangle to be clipped.
	 * @param {Polygon} clipper Triangle with which to clip.
	 * @private
	 * @return {FeatureCollection<Polygon>} Collection of clipped intersections
	 *                                      or null if intersection failed.
	 */
	const clipDifference = (subject, clipper) => {
	  const triangles = [];

	  // Difference subject with clipper and retriangulate difference.
	  try {
	    const difference$1 = difference(subject, clipper);
	    if (difference$1 === null) {
	      return null;
	    }
	    flattenEach(difference$1, (flattened) => {
	      featureEach$1(triangulate$1(flattened), (feature) => {
	        triangles.push(feature);
	      });
	    });
	  } catch (e) {
	    // Turf differrence can fail for edge cases due to one of their
	    // dependencies not handling numerical precision well.
	    // It is discussed at length in their issue tracker.
	    // https://github.com/Turfjs/turf/issues
	    return null;
	  }

	  return triangles;
	};

	/**
	 * @description Clip subject triangle using a triangle clipper. The result will
	 *              be a collection of triangles that intersect the subject triangle
	 *              and the clipper.
	 * @param {Polygon} subject Triangle to be clipped.
	 * @param {Polygon} clipper Triangle with which to clip.
	 * @private
	 * @return {FeatureCollection<Polygon>} Collection of clipped intersections
	 *                                      or null if intersection failed.
	 */
	const clipIntersection = (subject, clipper) => {
	  const triangles = [];

	  // Intersect subject with clipper and retriangulate intersection.
	  try {
	    const intersection = intersect$2(subject, clipper);
	    if (intersection === null) {
	      return null;
	    }
	    if (intersection && intersection.geometry.type.includes('Polygon')) {
	      flattenEach(intersection, (flattened) => {
	        featureEach$1(triangulate$1(flattened), (feature) => {
	          triangles.push(feature);
	        });
	      });
	    }
	  } catch (e) {
	    // Turf intersect can fail for edge cases due to one of their
	    // dependencies not handling numerical precision well.
	    // It is discussed at length in their issue tracker.
	    // https://github.com/Turfjs/turf/issues
	    return null;
	  }

	  return triangles;
	};

	/**
	 * @description Clip subject segment using a collection of segment clippers.
	 *              The result will be a collection of segments that partition the
	 *              subject segment and preserve the clipping boundaries.
	 * @param {LineString} subject Segment to be clipped.
	 * @param {FeatureCollection<LineString>} clippers Segments with which to clip.
	 * @private
	 * @return {LineString} Segment clipped partitioning. Note line may contain
	 *                      duplicate points if partitioned but multiple clippers.
	 */
	const segment = (subject, clippers) => {
	  const vertices = subject.geometry.coordinates.concat();

	  // Split subject at intersection points and collect coordinates.
	  // Turf only finds interections where the segments are non-parallel.
	  const intersections = lineIntersect(subject, clippers);
	  coordEach$1(intersections, (coordinate) => {
	    vertices.push(coordinate);
	  });

	  // Split subject at overlap points if no intersections found.
	  // If turf found no intersections between two segments then
	  // the only case left is an overlap in which case one or both
	  // end points of the clipper will be on the subject.
	  coordEach$1(clippers, (coordinate) => {
	    if (booleanPointOnLine(coordinate, subject, {
	      ignoreEndVertices: true,
	    })) {
	      vertices.push(coordinate);
	    }
	  });

	  // Sort all coordinates in order from first vertex.
	  vertices.sort((a, b) => {
	    const start = subject.geometry.coordinates[0];
	    return distance(a, start) - distance(b, start);
	  });

	  return lineString(vertices);
	};

	/**
	 * @description Clip subject triangle using a collection of triangle clippers.
	 *              The result will be a collection of triangles that partition the
	 *              subject triangle and preserve the clipping boundaries.
	 * @param {Polygon} subject Triangle to be clipped.
	 * @param {FeatureCollection<Polygon>} clippers Triangles with which to clip.
	 * @private
	 * @return {FeatureCollection<Polygon>} Triangle clipped partitioning.
	 */
	const triangle = (subject, clippers) => {
	  let subjects = [subject];

	  featureEach$1(clippers, (clipper, i) => {
	    // Clip all subjects with the current clipper and then put the resulting
	    // triangle partition back in the queue to be clipped by the next clipper.
	    const parts = [];
	    for (let i = 0; i < subjects.length; i++) {
	      const triangles = clip(subjects[i], clipper);
	      featureEach$1(triangles, (facet) => {
	        parts.push(facet);
	      });
	    }
	    subjects = parts;
	  });

	  return featureCollection(subjects);
	};

	var clipper = {
	  segment,
	  triangle,
	};

	/**
	 * @description Compute centroid of each segment in GeoJSON.
	 * @param {GeoJSON} geojson GeoJSON of ilne features to process.
	 * @private
	 * @return {FeatureCollection<Point>} Collection of segment centroids.
	 */
	const centroids = (geojson) => {
	  // Compute centroid of each feature.
	  const centers = [];
	  segmentEach(geojson, (feature) => {
	    centers.push(centroid(feature));
	  });
	  return featureCollection(centers);
	};

	/**
	 * @description Test if two GeoJSON bounding boxes are disjoint.
	 * @param {GeoJSON} geojson1 GeoJSON #1 to test.
	 * @param {GeoJSON} geojson2 GeoJSON #2 to test.
	 * @private
	 * @return {Boolean} True if bounding boxes are disjoint otherwise false.
	 */
	const disjoint$1 = (geojson1, geojson2) => {
	  const bbox1 = (geojson1.bbox ? geojson1.bbox : bbox(geojson1));
	  const bbox2 = (geojson2.bbox ? geojson2.bbox : bbox(geojson2));
	  const ndim1 = bbox1.length / 2;
	  const ndim2 = bbox2.length / 2;
	  if ((bbox1[0] > bbox2[ndim2]) || (bbox1[ndim1] < bbox2[0])) {
	    return true;
	  }
	  if ((bbox1[1] > bbox2[ndim2+1]) || (bbox1[ndim1+1] < bbox2[1])) {
	    return true;
	  }
	  return false;
	};

	/**
	 * @description Test if two arrays are similar. Similarity is equality where
	 *              offset and direction are ignored. When array ends are reached
	 *              the comparison wraps around to the other end and continues.
	 * @param {Array} array1 Array #1.
	 * @param {Array} array2 Array #2.
	 * @param {Number} [start1=0] Starting index of array #1.
	 * @param {Number} [start2=0] Starting index of array #2.
	 * @param {Number} [count=-1] Number of elements to check for equality from
	 *                            starting index. If -1 then all checked.
	 * @param {Boolean} [reverse=false] True if coordinates #2 should be checked
	 *                                  in reverse order from #1 otherwise false.
	 * @private
	 * @return {Boolean} True if are equal otherwise false.
	 */
	const similar = (array1, array2, start1 = 0, start2 = 0, count =-1,
	    reverse = false) => {
	  if (array1.length !== array2.length) {
	    return false;
	  }

	  // Determine how many elements to check for equality.
	  const length = array1.length;
	  if (count < 0) {
	    count = length;
	  }
	  count = Math.min(length, Math.max(count, 0));

	  for (let i = 0; i < count; i = i + 1) {
	    // Choose direction to traverse array #2
	    const delta = (reverse ? -i : i);

	    // Wrapped around starting index of each array
	    const index1 = ((start1 + i) + length) % length;
	    const index2 = ((start2 + delta) + length) % length;

	    // Check if all coordinate dimensions are equal.
	    const isEqual = array1[index1].every((dimension, j) => {
	      return dimension === array2[index2][j];
	    });
	    if (isEqual === false) {
	      return false;
	    }
	  }

	  return true;
	};

	var helpers = {
	  centroids,
	  disjoint: disjoint$1,
	  similar,
	};

	/**
	 * @description Get base geometry type. Defined only for homogenous geometries.
	 * @param {GeoJSON} geojson GeoJSON object.
	 * @private
	 * @return {Point|LineString|Polygon|Mixed|Unknown} Base geometry type.
	 */
	const type$1 = (geojson) => {
	  // Check if we have a single geometry type.
	  const geoType = getType(geojson);
	  const isMany = ['Collection', 'Multi'].some((many) => geoType.includes(many));
	  if (isMany === false) {
	    return geoType;
	  }

	  // For a collection or multipart geometry, flatten to find a common type.
	  return flattenReduce(geojson, (baseType, feature, index) => {
	    if (baseType === 'Mixed') {
	      return baseType;
	    }
	    const currentType = getType(feature);
	    if (baseType !== 'Unknown' && baseType !== currentType) {
	      return 'Mixed';
	    }
	    return currentType;
	  }, 'Unknown');
	};

	var invariant = {
	  type: type$1,
	};

	/**
	 * @description Check if callback is true for every coordinate.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each coordinate of GeoJSON.
	 * @private
	 * @return {Boolean} True if every coordinate returns true otherwise false.
	 */
	const coordEvery = (geojson, callback) => {
	  return reduceEvery(geojson, callback, coordReduce);
	};

	/**
	 * @description Check if callback is true for some coordinate.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each coordinate of GeoJSON.
	 * @private
	 * @return {Boolean} True if some coordinate returns true otherwise false.
	 */
	const coordSome = (geojson, callback) => {
	  return reduceSome(geojson, callback, coordReduce);
	};

	/**
	 * @description Check if callback is true for every feature.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each feature of GeoJSON.
	 * @private
	 * @return {Boolean} True if every feature returns true otherwise false.
	 */
	const featureEvery = (geojson, callback) => {
	  return reduceEvery(geojson, callback, featureReduce);
	};

	/**
	 * @description Check if callback is true for some feature.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each feature of GeoJSON.
	 * @private
	 * @return {Boolean} True if some feature returns true otherwise false.
	 */
	const featureSome = (geojson, callback) => {
	  return reduceSome(geojson, callback, featureReduce);
	};

	/**
	 * @description Check if callback is true for every flattened feature.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each feature of GeoJSON.
	 * @private
	 * @return {Boolean} True if some feature returns true otherwise false.
	 */
	const flattenEvery = (geojson, callback) => {
	  return reduceEvery(geojson, callback, flattenReduce);
	};

	/**
	 * @description Check if callback is true for some flattened feature.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each feature of GeoJSON.
	 * @private
	 * @return {Boolean} True if some feature returns true otherwise false.
	 */
	const flattenSome = (geojson, callback) => {
	  return reduceSome(geojson, callback, flattenReduce);
	};

	/**
	 * @description Check if callback is true for every reduce item.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each GeoJSON reduction item.
	 * @param {function} reducer Turf reduction function.
	 * @private
	 * @return {Boolean} True if every item returns true otherwise false.
	 */
	const reduceEvery = (geojson, callback, reducer) => {
	  return reducer(geojson, (value, feature) => {
	    return value && callback(feature);
	  }, true);
	};

	/**
	 * @description Check if callback is true for some reduce item.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each GeoJSON reduction item.
	 * @param {function} reducer Turf reduction function.
	 * @private
	 * @return {Boolean} True if some item returns true otherwise false.
	 */
	const reduceSome = (geojson, callback, reducer) => {
	  return reducer(geojson, (value, feature) => {
	    return value || callback(feature);
	  }, false);
	};

	/**
	 * @description Check if callback is true for every segment.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each segment of GeoJSON.
	 * @private
	 * @return {Boolean} True if every segment returns true otherwise false.
	 */
	const segmentEvery = (geojson, callback) => {
	  return reduceEvery(geojson, callback, segmentReduce);
	};

	/**
	 * @description Check if callback is true for some segment.
	 * @param {GeoJSON} geojson Any GeoJSON.
	 * @param {function} callback Callback for each segment of GeoJSON.
	 * @private
	 * @return {Boolean} True if some segment returns true otherwise false.
	 */
	const segmentSome = (geojson, callback) => {
	  return reduceSome(geojson, callback, segmentReduce);
	};

	var meta = {
	  coordEvery,
	  coordSome,
	  featureEvery,
	  featureSome,
	  flattenEvery,
	  flattenSome,
	  segmentEvery,
	  segmentSome,
	};

	function quickselect(arr, k, left, right, compare) {
	    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
	}

	function quickselectStep(arr, k, left, right, compare) {
	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            quickselectStep(arr, k, newLeft, newRight, compare);
	        }

	        var t = arr[k];
	        var i = left;
	        var j = right;

	        swap(arr, left, k);
	        if (compare(arr[right], t) > 0) swap(arr, left, right);

	        while (i < j) {
	            swap(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) i++;
	            while (compare(arr[j], t) > 0) j--;
	        }

	        if (compare(arr[left], t) === 0) swap(arr, left, j);
	        else {
	            j++;
	            swap(arr, j, right);
	        }

	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}

	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultCompare(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}

	function rbush(maxEntries, format) {
	    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

	    if (format) {
	        this._initFormat(format);
	    }

	    this.clear();
	}

	rbush.prototype = {

	    all: function () {
	        return this._all(this.data, []);
	    },

	    search: function (bbox) {

	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;

	        if (!intersects$1(bbox, node)) return result;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects$1(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);
	                    else if (contains$2(bbox, childBBox)) this._all(child, result);
	                    else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return result;
	    },

	    collides: function (bbox) {

	        var node = this.data,
	            toBBox = this.toBBox;

	        if (!intersects$1(bbox, node)) return false;

	        var nodesToSearch = [],
	            i, len, child, childBBox;

	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {

	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child;

	                if (intersects$1(bbox, childBBox)) {
	                    if (node.leaf || contains$2(bbox, childBBox)) return true;
	                    nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }

	        return false;
	    },

	    load: function (data) {
	        if (!(data && data.length)) return this;

	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }

	        // recursively build the tree with the given data from scratch using OMT algorithm
	        var node = this._build(data.slice(), 0, data.length - 1, 0);

	        if (!this.data.children.length) {
	            // save as is if tree is empty
	            this.data = node;

	        } else if (this.data.height === node.height) {
	            // split root if trees have the same height
	            this._splitRoot(this.data, node);

	        } else {
	            if (this.data.height < node.height) {
	                // swap trees if inserted one is bigger
	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }

	            // insert the small tree into the large tree at appropriate level
	            this._insert(node, this.data.height - node.height - 1, true);
	        }

	        return this;
	    },

	    insert: function (item) {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },

	    clear: function () {
	        this.data = createNode([]);
	        return this;
	    },

	    remove: function (item, equalsFn) {
	        if (!item) return this;

	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i, parent, index, goingUp;

	        // depth-first iterative tree traversal
	        while (node || path.length) {

	            if (!node) { // go up
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }

	            if (node.leaf) { // check current node
	                index = findItem(item, node.children, equalsFn);

	                if (index !== -1) {
	                    // item found, remove the item and condense tree upwards
	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }

	            if (!goingUp && !node.leaf && contains$2(node, bbox)) { // go down
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];

	            } else if (parent) { // go right
	                i++;
	                node = parent.children[i];
	                goingUp = false;

	            } else node = null; // nothing found
	        }

	        return this;
	    },

	    toBBox: function (item) { return item; },

	    compareMinX: compareNodeMinX,
	    compareMinY: compareNodeMinY,

	    toJSON: function () { return this.data; },

	    fromJSON: function (data) {
	        this.data = data;
	        return this;
	    },

	    _all: function (node, result) {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);
	            else nodesToSearch.push.apply(nodesToSearch, node.children);

	            node = nodesToSearch.pop();
	        }
	        return result;
	    },

	    _build: function (items, left, right, height) {

	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;

	        if (N <= M) {
	            // reached leaf level; return leaf
	            node = createNode(items.slice(left, right + 1));
	            calcBBox(node, this.toBBox);
	            return node;
	        }

	        if (!height) {
	            // target height of the bulk-loaded tree
	            height = Math.ceil(Math.log(N) / Math.log(M));

	            // target number of root entries to maximize storage utilization
	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }

	        node = createNode([]);
	        node.leaf = false;
	        node.height = height;

	        // split the items into M mostly square tiles

	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i, j, right2, right3;

	        multiSelect(items, left, right, N1, this.compareMinX);

	        for (i = left; i <= right; i += N1) {

	            right2 = Math.min(i + N1 - 1, right);

	            multiSelect(items, i, right2, N2, this.compareMinY);

	            for (j = i; j <= right2; j += N2) {

	                right3 = Math.min(j + N2 - 1, right2);

	                // pack each entry recursively
	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }

	        calcBBox(node, this.toBBox);

	        return node;
	    },

	    _chooseSubtree: function (bbox, node, level, path) {

	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

	        while (true) {
	            path.push(node);

	            if (node.leaf || path.length - 1 === level) break;

	            minArea = minEnlargement = Infinity;

	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea(child);
	                enlargement = enlargedArea(bbox, child) - area;

	                // choose entry with the least area enlargement
	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;

	                } else if (enlargement === minEnlargement) {
	                    // otherwise choose one with the smallest area
	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }

	            node = targetNode || node.children[0];
	        }

	        return node;
	    },

	    _insert: function (item, level, isNode) {

	        var toBBox = this.toBBox,
	            bbox = isNode ? item : toBBox(item),
	            insertPath = [];

	        // find the best node for accommodating the item, saving all nodes along the path too
	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

	        // put the item into the node
	        node.children.push(item);
	        extend(node, bbox);

	        // split on node overflow; propagate upwards if necessary
	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }

	        // adjust bboxes along the insertion path
	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },

	    // split overflowed node into two
	    _split: function (insertPath, level) {

	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;

	        this._chooseSplitAxis(node, m, M);

	        var splitIndex = this._chooseSplitIndex(node, m, M);

	        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
	        newNode.height = node.height;
	        newNode.leaf = node.leaf;

	        calcBBox(node, this.toBBox);
	        calcBBox(newNode, this.toBBox);

	        if (level) insertPath[level - 1].children.push(newNode);
	        else this._splitRoot(node, newNode);
	    },

	    _splitRoot: function (node, newNode) {
	        // split root node
	        this.data = createNode([node, newNode]);
	        this.data.height = node.height + 1;
	        this.data.leaf = false;
	        calcBBox(this.data, this.toBBox);
	    },

	    _chooseSplitIndex: function (node, m, M) {

	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

	        minOverlap = minArea = Infinity;

	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox(node, 0, i, this.toBBox);
	            bbox2 = distBBox(node, i, M, this.toBBox);

	            overlap = intersectionArea(bbox1, bbox2);
	            area = bboxArea(bbox1) + bboxArea(bbox2);

	            // choose distribution with minimum overlap
	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;

	                minArea = area < minArea ? area : minArea;

	            } else if (overlap === minOverlap) {
	                // otherwise choose distribution with minimum area
	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }

	        return index;
	    },

	    // sorts node children by the best axis for split
	    _chooseSplitAxis: function (node, m, M) {

	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);

	        // if total distributions margin value is minimal for x, sort by minX,
	        // otherwise it's already sorted by minY
	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },

	    // total margin of all possible split distributions where each node is at least m full
	    _allDistMargin: function (node, m, M, compare) {

	        node.children.sort(compare);

	        var toBBox = this.toBBox,
	            leftBBox = distBBox(node, 0, m, toBBox),
	            rightBBox = distBBox(node, M - m, M, toBBox),
	            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
	            i, child;

	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend(leftBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin(leftBBox);
	        }

	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend(rightBBox, node.leaf ? toBBox(child) : child);
	            margin += bboxMargin(rightBBox);
	        }

	        return margin;
	    },

	    _adjustParentBBoxes: function (bbox, path, level) {
	        // adjust bboxes along the given tree path
	        for (var i = level; i >= 0; i--) {
	            extend(path[i], bbox);
	        }
	    },

	    _condense: function (path) {
	        // go through the path, removing empty nodes and updating bboxes
	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);

	                } else this.clear();

	            } else calcBBox(path[i], this.toBBox);
	        }
	    },

	    _initFormat: function (format) {
	        // data format (minX, minY, maxX, maxY accessors)

	        // uses eval-type function compilation instead of just accepting a toBBox function
	        // because the algorithms are very sensitive to sorting functions performance,
	        // so they should be dead simple and without inner calls

	        var compareArr = ['return a', ' - b', ';'];

	        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
	        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

	        this.toBBox = new Function('a',
	            'return {minX: a' + format[0] +
	            ', minY: a' + format[1] +
	            ', maxX: a' + format[2] +
	            ', maxY: a' + format[3] + '};');
	    }
	};

	function findItem(item, items, equalsFn) {
	    if (!equalsFn) return items.indexOf(item);

	    for (var i = 0; i < items.length; i++) {
	        if (equalsFn(item, items[i])) return i;
	    }
	    return -1;
	}

	// calculate node's bbox from bboxes of its children
	function calcBBox(node, toBBox) {
	    distBBox(node, 0, node.children.length, toBBox, node);
	}

	// min bounding rectangle of node children from k to p-1
	function distBBox(node, k, p, toBBox, destNode) {
	    if (!destNode) destNode = createNode(null);
	    destNode.minX = Infinity;
	    destNode.minY = Infinity;
	    destNode.maxX = -Infinity;
	    destNode.maxY = -Infinity;

	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend(destNode, node.leaf ? toBBox(child) : child);
	    }

	    return destNode;
	}

	function extend(a, b) {
	    a.minX = Math.min(a.minX, b.minX);
	    a.minY = Math.min(a.minY, b.minY);
	    a.maxX = Math.max(a.maxX, b.maxX);
	    a.maxY = Math.max(a.maxY, b.maxY);
	    return a;
	}

	function compareNodeMinX(a, b) { return a.minX - b.minX; }
	function compareNodeMinY(a, b) { return a.minY - b.minY; }

	function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
	function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

	function enlargedArea(a, b) {
	    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
	           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
	}

	function intersectionArea(a, b) {
	    var minX = Math.max(a.minX, b.minX),
	        minY = Math.max(a.minY, b.minY),
	        maxX = Math.min(a.maxX, b.maxX),
	        maxY = Math.min(a.maxY, b.maxY);

	    return Math.max(0, maxX - minX) *
	           Math.max(0, maxY - minY);
	}

	function contains$2(a, b) {
	    return a.minX <= b.minX &&
	           a.minY <= b.minY &&
	           b.maxX <= a.maxX &&
	           b.maxY <= a.maxY;
	}

	function intersects$1(a, b) {
	    return b.minX <= a.maxX &&
	           b.minY <= a.maxY &&
	           b.maxX >= a.minX &&
	           b.maxY >= a.minY;
	}

	function createNode(children) {
	    return {
	        children: children,
	        height: 1,
	        leaf: true,
	        minX: Infinity,
	        minY: Infinity,
	        maxX: -Infinity,
	        maxY: -Infinity
	    };
	}

	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach

	function multiSelect(arr, left, right, n, compare) {
	    var stack = [left, right],
	        mid;

	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();

	        if (right - left <= n) continue;

	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        quickselect(arr, mid, left, right, compare);

	        stack.push(left, mid, mid, right);
	    }
	}

	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach(geojson, callback, excludeWrapCoord) {
	    // Handles null Geometry -- Skips this GeoJSON
	    if (geojson === null) return;
	    var j, k, l, geometry, stopG, coords,
	        geometryMaybeCollection,
	        wrapShrink = 0,
	        coordIndex = 0,
	        isGeometryCollection,
	        type = geojson.type,
	        isFeatureCollection = type === 'FeatureCollection',
	        isFeature = type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
	            var multiFeatureIndex = 0;
	            var geometryIndex = 0;
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

	            // Handles null Geometry -- Skips this geometry
	            if (geometry === null) continue;
	            coords = geometry.coordinates;
	            var geomType = geometry.type;

	            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

	            switch (geomType) {
	            case null:
	                break;
	            case 'Point':
	                callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                coordIndex++;
	                multiFeatureIndex++;
	                break;
	            case 'LineString':
	            case 'MultiPoint':
	                for (j = 0; j < coords.length; j++) {
	                    callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                    coordIndex++;
	                    if (geomType === 'MultiPoint') multiFeatureIndex++;
	                }
	                if (geomType === 'LineString') multiFeatureIndex++;
	                break;
	            case 'Polygon':
	            case 'MultiLineString':
	                for (j = 0; j < coords.length; j++) {
	                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
	                        callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                        coordIndex++;
	                    }
	                    if (geomType === 'MultiLineString') multiFeatureIndex++;
	                    if (geomType === 'Polygon') geometryIndex++;
	                }
	                if (geomType === 'Polygon') multiFeatureIndex++;
	                break;
	            case 'MultiPolygon':
	                for (j = 0; j < coords.length; j++) {
	                    if (geomType === 'MultiPolygon') geometryIndex = 0;
	                    for (k = 0; k < coords[j].length; k++) {
	                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
	                            callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	                            coordIndex++;
	                        }
	                        geometryIndex++;
	                    }
	                    multiFeatureIndex++;
	                }
	                break;
	            case 'GeometryCollection':
	                for (j = 0; j < geometry.geometries.length; j++)
	                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
	                break;
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	    }
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach(geojson, callback) {
	    if (geojson.type === 'Feature') {
	        callback(geojson, 0);
	    } else if (geojson.type === 'FeatureCollection') {
	        for (var i = 0; i < geojson.features.length; i++) {
	            callback(geojson.features[i], i);
	        }
	    }
	}

	/**
	 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
	 *
	 * @name rbush
	 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
	 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
	 * @returns {RBush} GeoJSON RBush
	 * @example
	 * import rbush from 'geojson-rbush';
	 * const tree = rbush();
	 */
	function geojsonRbush(maxEntries) {
	    var tree = rbush(maxEntries);
	    /**
	     * [insert](https://github.com/mourner/rbush#data-format)
	     *
	     * @param {Feature<any>} feature insert single GeoJSON Feature
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.insert(polygon)
	     */
	    tree.insert = function (feature) {
	        if (Array.isArray(feature)) {
	            var bbox = feature;
	            feature = bboxPolygon(bbox);
	            feature.bbox = bbox;
	        } else {
	            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
	        }
	        return rbush.prototype.insert.call(this, feature);
	    };

	    /**
	     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
	     *
	     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var polygons = {
	     *   "type": "FeatureCollection",
	     *   "features": [
	     *     {
	     *       "type": "Feature",
	     *       "properties": {},
	     *       "geometry": {
	     *         "type": "Polygon",
	     *         "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *       }
	     *     },
	     *     {
	     *       "type": "Feature",
	     *       "properties": {},
	     *       "geometry": {
	     *         "type": "Polygon",
	     *         "coordinates": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
	     *       }
	     *     }
	     *   ]
	     * }
	     * tree.load(polygons)
	     */
	    tree.load = function (features) {
	        var load = [];
	        // Load an Array of BBox
	        if (Array.isArray(features)) {
	            features.forEach(function (bbox) {
	                var feature = bboxPolygon(bbox);
	                feature.bbox = bbox;
	                load.push(feature);
	            });
	        } else {
	            // Load FeatureCollection
	            featureEach(features, function (feature) {
	                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
	                load.push(feature);
	            });
	        }
	        return rbush.prototype.load.call(this, load);
	    };

	    /**
	     * [remove](https://github.com/mourner/rbush#removing-data)
	     *
	     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.remove(polygon)
	     */
	    tree.remove = function (feature) {
	        if (Array.isArray(feature)) {
	            var bbox = feature;
	            feature = bboxPolygon(bbox);
	            feature.bbox = bbox;
	        }
	        return rbush.prototype.remove.call(this, feature);
	    };

	    /**
	     * [clear](https://github.com/mourner/rbush#removing-data)
	     *
	     * @returns {RBush} GeoJSON Rbush
	     * @example
	     * tree.clear()
	     */
	    tree.clear = function () {
	        return rbush.prototype.clear.call(this);
	    };

	    /**
	     * [search](https://github.com/mourner/rbush#search)
	     *
	     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON
	     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.search(polygon)
	     */
	    tree.search = function (geojson) {
	        var features = rbush.prototype.search.call(this, this.toBBox(geojson));
	        return {
	            type: 'FeatureCollection',
	            features: features
	        };
	    };

	    /**
	     * [collides](https://github.com/mourner/rbush#collisions)
	     *
	     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON
	     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
	     * @example
	     * var polygon = {
	     *   "type": "Feature",
	     *   "properties": {},
	     *   "geometry": {
	     *     "type": "Polygon",
	     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
	     *   }
	     * }
	     * tree.collides(polygon)
	     */
	    tree.collides = function (geojson) {
	        return rbush.prototype.collides.call(this, this.toBBox(geojson));
	    };

	    /**
	     * [all](https://github.com/mourner/rbush#search)
	     *
	     * @returns {FeatureCollection<any>} all the features in RBush
	     * @example
	     * tree.all()
	     * //=FeatureCollection
	     */
	    tree.all = function () {
	        var features = rbush.prototype.all.call(this);
	        return {
	            type: 'FeatureCollection',
	            features: features
	        };
	    };

	    /**
	     * [toJSON](https://github.com/mourner/rbush#export-and-import)
	     *
	     * @returns {any} export data as JSON object
	     * @example
	     * var exported = tree.toJSON()
	     * //=JSON object
	     */
	    tree.toJSON = function () {
	        return rbush.prototype.toJSON.call(this);
	    };

	    /**
	     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
	     *
	     * @param {any} json import previously exported data
	     * @returns {RBush} GeoJSON RBush
	     * @example
	     * var exported = {
	     *   "children": [
	     *     {
	     *       "type": "Feature",
	     *       "geometry": {
	     *         "type": "Point",
	     *         "coordinates": [110, 50]
	     *       },
	     *       "properties": {},
	     *       "bbox": [110, 50, 110, 50]
	     *     }
	     *   ],
	     *   "height": 1,
	     *   "leaf": true,
	     *   "minX": 110,
	     *   "minY": 50,
	     *   "maxX": 110,
	     *   "maxY": 50
	     * }
	     * tree.fromJSON(exported)
	     */
	    tree.fromJSON = function (json) {
	        return rbush.prototype.fromJSON.call(this, json);
	    };

	    /**
	     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
	     *
	     * @private
	     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from
	     * @returns {Object} converted to {minX, minY, maxX, maxY}
	     */
	    tree.toBBox = function (geojson) {
	        var bbox;
	        if (geojson.bbox) bbox = geojson.bbox;
	        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
	        else bbox = turfBBox(geojson);

	        return {
	            minX: bbox[0],
	            minY: bbox[1],
	            maxX: bbox[2],
	            maxY: bbox[3]
	        };
	    };
	    return tree;
	}

	/**
	 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
	 *
	 * @private
	 * @name bboxPolygon
	 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
	 * @returns {Feature<Polygon>} a Polygon representation of the bounding box
	 * @example
	 * var bbox = [0, 0, 10, 10];
	 *
	 * var poly = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [poly]
	 */
	function bboxPolygon(bbox) {
	    var lowLeft = [bbox[0], bbox[1]];
	    var topLeft = [bbox[0], bbox[3]];
	    var topRight = [bbox[2], bbox[3]];
	    var lowRight = [bbox[2], bbox[1]];
	    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];

	    return {
	        type: 'Feature',
	        bbox: bbox,
	        properties: {},
	        geometry: {
	            type: 'Polygon',
	            coordinates: coordinates
	        }
	    };
	}

	/**
	 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
	 *
	 * @private
	 * @name bbox
	 * @param {FeatureCollection|Feature<any>} geojson input features
	 * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
	 * @example
	 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
	 * var bbox = turf.bbox(line);
	 * var bboxPolygon = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [line, bboxPolygon]
	 */
	function turfBBox(geojson) {
	    var bbox = [Infinity, Infinity, -Infinity, -Infinity];
	    coordEach(geojson, function (coord) {
	        if (bbox[0] > coord[0]) bbox[0] = coord[0];
	        if (bbox[1] > coord[1]) bbox[1] = coord[1];
	        if (bbox[2] < coord[0]) bbox[2] = coord[0];
	        if (bbox[3] < coord[1]) bbox[3] = coord[1];
	    });
	    return bbox;
	}

	/**
	 * @description Compute partition of line relative to boundaries of polygons.
	 * @param {LineString} linestring Line to be partitioned.
	 * @param {Polgons} polygons Polygon with which to partition.
	 * @private
	 * @return {LineString} Partitioned line.
	 */
	const boundaries = (linestring, polygons) => {
	  let linePartition = linestring;
	  flattenEach(polygons, (poly) => {
	    const boundary = polygonToLine(poly);
	    linePartition = line$7(linePartition, boundary);
	  });
	  return linePartition;
	};

	/**
	 * @description Compute partition of line #1 relative to line(s) #2.
	 *              The partition is itself a line that ensures that
	 *              each line segment intersects only one line #2 segment.
	 * @param {LineString} line1 Line #1.
	 * @param {Lines} lines2 Line #2.
	 * @private
	 * @return {LineString} Line partition of line #1.
	 */
	const line$7 = (line1, lines2) => {
	  const coordinates = [];

	  // Load line #2 segments into R-Tree for quick searching.
	  const segments2 = lineSegment(lines2);
	  const tree = geojsonRbush();
	  tree.load(segments2);

	  // Clip each line #1 segment with nearby line #2 segments.
	  segmentEach(line1, (segment1) => {
	    const clippers = tree.search(segment1);
	    const vertices = clipper.segment(segment1, clippers);
	    const coords = getCoords(vertices);
	    Array.prototype.push.apply(coordinates, coords);
	  });

	  // Remove sequential duplicate coordinates.
	  const lines = coordinates.filter((current, i) => {
	    if (i === 0) {
	      return true;
	    }
	    return current.some((dimension, j) => {
	      return (dimension !== coordinates[i-1][j]);
	    });
	  });

	  return lineString(lines);
	};

	/**
	 * @description Compute partition of polygon #1 relative to polygon #2.
	 *              The partition is itself a triangulation that ensures that
	 *              each partition triangle is either in polygon #1 or #2.
	 * @param {FeatureCollection<Polygon>} triangulation1 Polygon #1 triangulation.
	 * @param {FeatureCollection<Polygon>} triangulation2 Polygon #2 triangulation.
	 * @private
	 * @return {FeatureCollection<Polygon>} Triangle partition of polygon #1.
	 */
	const polygon$7 = (triangulation1, triangulation2) => {
	  const triangles = [];

	  // Load triangulation #2 into R-Tree for quick searching.
	  const tree = geojsonRbush();
	  tree.load(triangulation2);

	  featureEach$1(triangulation1, (triangle1) => {
	    const clippers = tree.search(triangle1);
	    const clips = clipper.triangle(triangle1, clippers);
	    Array.prototype.push.apply(triangles, clips.features);
	  });

	  return featureCollection(triangles);
	};

	var partition = {
	  boundaries,
	  line: line$7,
	  polygon: polygon$7,
	};

	/**
	 * @description One or more points.
	 * @private
	 * @typedef {Feature|FeatureCollection<Point|MultiPoint>} Points
	 */

	/**
	 * @description Test if point(s) in GeoJSON is in line.
	 * @param {GeoJSON} geojson GeoJSON points to test.
	 * @param {Lines} lines Line(s) to contain points.
	 * @param {Boolean} [boundary] True if line boundary should be included.
	 *                  Default is true.
	 * @param {Boolean} [every] True if every point should be in line.
	 *                  False if only some points should be in line.
	 *                  Default is true.
	 * @param {Boolean} [within] True if relationship is "within" otherwise
	 *                           "outside". Default is true.
	 * @private
	 * @return {Boolean} True if point(s) is in line otherwise false.
	 */
	const isInLine = (geojson, lines, boundary, every, within) => {
	  boundary = boundary !== false;
	  every = every !== false;
	  within = within !== false;

	  if (helpers.disjoint(geojson, lines)) {
	    return within === false;
	  }

	  const reducerGeo = (every ? meta.coordEvery : meta.coordSome);
	  const reducerLines = (within ? meta.flattenSome : meta.flattenEvery);

	  return reducerGeo(geojson, (coordinate) => {
	    return reducerLines(lines, (linestring) => {
	      return booleanPointOnLine(coordinate, linestring, {
	        ignoreEndVertices: boundary === false,
	      }) === within;
	    });
	  });
	};

	/**
	 * @description Test if every point in GeoJSON is in points.
	 * @param {GeoJSON} geojson GeoJSON points to test.
	 * @param {Points} points Points(s) to contain points.
	 * @param {Boolean} [every] True if every point should be in points.
	 *                  False if only some points should be in points.
	 *                  Default is true.
	 * @param {Boolean} [within] True if relationship is "within" otherwise
	 *                           "outside". Default is true.
	 * @private
	 * @return {Boolean} True if point(s) is in point otherwise false.
	 */
	const isInPoint = (geojson, points, every, within) => {
	  every = every !== false;
	  within = within !== false;

	  if (helpers.disjoint(geojson, points)) {
	    return within === false;
	  }

	  const reducerGeo = (every ? meta.coordEvery : meta.coordSome);
	  const reducerPts = (within ? meta.flattenSome : meta.flattenEvery);

	  return reducerGeo(geojson, (coordinate) => {
	    const point1 = point$7(coordinate);
	    return reducerPts(points, (point2) => {
	      return point1.geometry.coordinates.every((dimension, index) => {
	        return dimension === point2.geometry.coordinates[index];
	      }) === within;
	    });
	  });
	};

	/**
	 * @description Test if point(s) in GeoJSON is in polygon.
	 * @param {GeoJSON} geojson GeoJSON points to test.
	 * @param {Polygons} polygons Polygon(s) to contain point.
	 * @param {Boolean} [boundary] True if polygon boundary should be included.
	 *                  Default is true.
	 * @param {Boolean} [every] True if every point should be in polygon.
	 *                  False if only some points should be in polygon.
	 *                  Default is true.
	 * @param {Boolean} [within] True if relationship is "within" otherwise
	 *                           "outside". Default is true.
	 * @private
	 * @return {Boolean} True if point(s) is in polygon otherwise false.
	 */
	const isInPolygon$1 = (geojson, polygons, boundary, every, within) => {
	  boundary = boundary !== false;
	  every = every !== false;
	  within = within !== false;

	  if (helpers.disjoint(geojson, polygons)) {
	    return within === false;
	  }

	  const reducerGeo = (every ? meta.coordEvery : meta.coordSome);
	  const reducerPoly = (within ? meta.flattenSome : meta.flattenEvery);

	  return reducerGeo(geojson, (coordinate) => {
	    return reducerPoly(polygons, (polygon) => {
	      return booleanPointInPolygon(coordinate, polygon, {
	        ignoreBoundary: boundary === false,
	      }) === within;
	    });
	  });
	};

	var point$6 = {
	  isInLine,
	  isInPoint,
	  isInPolygon: isInPolygon$1,
	};

	/**
	 * @description One or more lines.
	 * @private
	 * @typedef {Feature|FeatureCollection<LineString|MultiLineString>} Lines
	 */

	/**
	 * @description Get line ending point.
	 * @param {LineString} linestring Line from which to get ending point.
	 * @private
	 * @return {Point} Ending point.
	 */
	const end = (linestring) => {
	  const length = linestring.geometry.coordinates.length;
	  return point$7(linestring.geometry.coordinates[length-1]);
	};

	/**
	 * @description Test if line(s) #1 is disjoint from line(s) #2.
	 * @param {Lines} lines1 Line #1 to be tested.
	 * @param {Lines} lines2 Line #2 to be tested.
	 * @private
	 * @return {Boolean} True if they are disjoint otherwise false.
	 */
	const isDisjoint = (lines1, lines2) => {
	  // Check for segment/segment overlaps.
	  const overlaps = isOverlapping(lines1, lines2, true, false, true);
	  if (overlaps) {
	    return false;
	  }

	  // Check for any proper sement/segment intersections.
	  const intersections = isIntersecting(lines1, lines2, true);
	  if (intersections) {
	    return false;
	  }

	  // Final case is boundaries touching
	  const touches = isTouching(lines1, lines2);
	  if (touches) {
	    return false;
	  }

	  return true;
	};

	/**
	 * @description Test if line(s) #1 and line(s) #2 have any intersections.
	 * @param {Lines} lines1 Line #1 to be intersected.
	 * @param {Lines} lines2 Line #2 to be intersected.
	 * @param {Boolean} [boundary] True if line boundary should be included.
	 *                  Default is true.
	 * @private
	 * @return {Boolean} True if they have intersections otherwise false.
	 */
	const isIntersecting = (lines1, lines2, boundary) => {
	  boundary = boundary !== false;

	  // Check for any proper sement/segment intersections.
	  // Turf only finds interections where the segments are non-parallel.
	  return meta.flattenSome(lines1, (line1) => {
	    return meta.flattenSome(lines2, (line2) => {
	      const intersects = lineIntersect(line1, line2);
	      if (boundary === false) {
	        const lines = featureCollection([line1, line2]);
	        if (isOnBoundary(lines, intersects)) {
	          return false;
	        }
	      }
	      return intersects.features.length > 0;
	    });
	  });
	};

	/**
	 * @description Test if point(s) is on line(s) boundary.
	 * @param {Lines} lines Line to be tested.
	 * @param {Points} points Points to be tested.
	 * @private
	 * @return {Boolean} True if on boundary otherwise false.
	 */
	const isOnBoundary = (lines, points) => {
	  return meta.featureEvery(points, (pt) => {
	    // Flatten lines and check if point is on any boundary.
	    return meta.flattenSome(lines, (linestring) => {
	      const lineStart = start(linestring);
	      const lineEnd = end(linestring);
	      if (point$6.isInPoint(pt, lineStart) ||
	          point$6.isInPoint(pt, lineEnd)) {
	        return true;
	      }
	    });
	  });
	};

	/**
	 * @description Test if line(s) #1 and line(s) #2 have overlaps.
	 * @param {Lines} lines1 Line #1 to be tested.
	 * @param {Lines} lines2 Line #2 to be tested.
	 * @param {Boolean} [boundary] True if line boundary should be included.
	 *                  Default is true.
	 * @param {Boolean} [every] True if every segment should overlap line.
	 *                  False if only some segments should overlap line.
	 *                  Default is true.
	 * @param {Boolean} [within] True if relationship is "within" otherwise
	 *                           "outside". Default is true.
	 * @param {Number} [tolerance] Tolerance distance to match overlapping line
	 *                             segments (kilometers). Default is 0.
	 * @private
	 * @return {Boolean} True if they have overlaps otherwise false.
	 */
	const isOverlapping = (lines1, lines2, boundary, every, within, tolerance) => {
	  boundary = boundary !== false;
	  every = every !== false;
	  tolerance = tolerance || 0;
	  within = within !== false;

	  const reducer = (every ? meta.segmentEvery : meta.segmentSome);
	  return reducer(lines1, (line1) => {
	    // Partition line #1 using line #2 as clipper.
	    const partition1 = partition.line(line1, lines2);
	    return reducer(partition1, (segment) => {
	      // Check for segment/segment overlaps by testing centroid.
	      const centroid$1 = centroid(segment);
	      let inLine = point$6.isInLine(centroid$1, lines2, boundary);
	      if (inLine === false && tolerance > 0) {
	        const nearest = nearestPointOnLine(lines2, centroid$1);
	        inLine = nearest.properties.dist <= tolerance;
	      }
	      return inLine === within;
	    });
	  });
	};

	/**
	 * @description Test if two line coordinates are similar. Similarity is
	 *              vertex equality with array shift and direction ignored.
	 * @example
	 *  similar(turf.lineString([[0, 0], [1, 1], [2, 3], [3, 4]]),
	 *          turf.lineString([[1, 1], [0, 0], [3, 4], [2, 3]])); // = true
	 * @param {Lines} lines1 Line #1.
	 * @param {Lines} lines2 Line #2.
	 * @private
	 * @return {Boolean} True if similar otherwise false.
	 */
	const isSimilar = (lines1, lines2) => {
	  // Flatten all lines then search for matches.
	  const findMatch = (features1, features2) => {
	    return meta.flattenEvery(features1, (line1) => {
	      return meta.flattenSome(features2, (line2) => {
	        const coords1 = line1.geometry.coordinates;
	        const coords2 = line2.geometry.coordinates;
	        const length2 = coords2.length-1;
	        return (helpers.similar(coords1, coords2) ||
	                helpers.similar(coords1, coords2, 0, length2, length2, true));
	      });
	    });
	  };
	  return findMatch(lines1, lines2) && findMatch(lines2, lines1);
	};

	/**
	 * @description Test if any line(s) #1 boundary touches line(s) #2 boundary.
	 * @param {Lines} lines1 Line #1 to be tested.
	 * @param {Lines} lines2 Line #2 to be tested.
	 * @private
	 * @return {Boolean} True if their boundaries touch otherwise false.
	 */
	const isTouching = (lines1, lines2) => {
	  // Flatten both lines and check if end points are equal.
	  return meta.flattenSome(lines1, (line1) => {
	    const start1 = start(line1);
	    const end1 = end(line1);

	    return meta.flattenSome(lines2, (line2) => {
	      const start2 = start(line2);
	      if (point$6.isInPoint(start1, start2) ||
	          point$6.isInPoint(end1, start2)) {
	        return true;
	      }

	      const end2 = end(line2);
	      if (point$6.isInPoint(start1, end2) ||
	          point$6.isInPoint(end1, end2)) {
	        return true;
	      }
	    });
	  });
	};

	/**
	 * @description Get line starting point.
	 * @param {LineString} linestring Line from which to get starting point.
	 * @private
	 * @return {Point} Starting point.
	 */
	const start = (linestring) => {
	  return point$7(linestring.geometry.coordinates[0]);
	};

	var line$6 = {
	  end,
	  isDisjoint,
	  isIntersecting,
	  isOverlapping,
	  isSimilar,
	  isTouching,
	  start,
	};

	/**
	 * @description One or more polygons.
	 * @private
	 * @typedef {Feature|FeatureCollection<Polygon|MultiPolygon>} Polygons
	 */

	/**
	 * @description Test if polygon boundaries intersect.
	 * @param {Polygons} polygons1 Polygons #1.
	 * @param {Polygons} polygons2 Polygons #2.
	 * @private
	 * @return {Boolean} True if boundary's intersect otherwise false.
	 */
	const isBoundaryIntersecting = (polygons1, polygons2) => {
	  // Flatten both polygons then intersect their boundaries.
	  return meta.flattenSome(polygons1, (polygon1) => {
	    const boundary1 = polygonToLine(polygon1);
	    return meta.flattenSome(polygons2, (polygon2) => {
	      const boundary2 = polygonToLine(polygon2);
	      return line$6.isDisjoint(boundary1, boundary2) === false;
	    });
	  });
	};

	/**
	 * @description Test if two coordinate arrays are similar. Similarity is
	 *              equality where shift and direction changes are ignored.
	 *              Arrays must be of same length.
	 * @param {Array} coordinates1 Coordinates #1 array.
	 * @param {Array} coordinates2 Coordinates #2 array.
	 * @private
	 * @return {Boolean} True if coordinates are similar otherwise false.
	 */
	const isCoordinateSimilar = (coordinates1, coordinates2) => {
	  // First find a pair of coordinates that are equal then check rest of array
	  const length = coordinates1.length - 1;
	  for (let i = 0; i < length; ++i) {
	    if (helpers.similar(coordinates1, coordinates2, 0, i, 1)) {
	      if (helpers.similar(coordinates1, coordinates2, 0, i, length)) {
	        return true;
	      }
	    }
	  }
	  return false;
	};

	/**
	 * @description Test if polygon(s) #1 is within polygon(s) #2.
	 * @param {Polygons} polygons1 Polygon #1.
	 * @param {Polygons} polygons2 Polygon #2.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const isInPolygon = (polygons1, polygons2) => {
	  // Check that all vertices in #1 are in the interior of #2
	  if (point$6.isInPolygon(polygons1, polygons2, true, true) === false) {
	    return false;
	  }

	  // Check the centroid of each partition triangle is within polygon #2.
	  return relate(polygons1, polygons2, false, true, true);
	};

	/**
	 * @description Test if two polygon coordinates are similar. Similarity is
	 *              vertex equality with array shift and direction ignored.
	 * @example
	 *  similar(turf.polygon([[[0, 0], [1, 1], [2, 3], [3, 4]]]),
	 *          turf.polygon([[[1, 1], [0, 0], [3, 4], [2, 3]]])); // = true
	 * @param {Polygons} polygons1 Polygon #1.
	 * @param {Polygons} polygons2 Polygon #2.
	 * @private
	 * @return {Boolean} True if similar otherwise false.
	 */
	const isPolygonSimilar = (polygons1, polygons2) => {
	  // Flatten all polygon rings into lines then search for matches.
	  const findMatch = (features1, features2) => {
	    return meta.flattenEvery(features1, (feature1) => {
	      return feature1.geometry.coordinates.every((line1) => {
	        return meta.flattenSome(features2, (feature2) => {
	          return feature2.geometry.coordinates.some((line2) => {
	            return isCoordinateSimilar(line1, line2);
	          });
	        });
	      });
	    });
	  };

	  return findMatch(polygons1, polygons2) && findMatch(polygons2, polygons1);
	};

	/**
	 * @description Relate polygon(s) #1 to polygon(s) #2.
	 * @param {Polygons} polygons1 Polygon #1 to relate.
	 * @param {Polygons} polygons2 Polygon #2 to relate.
	 * @param {Boolean} [boundary] True if boundary should be included.
	 *                  Default is true.
	 * @param {Boolean} [every] True if every polygon(s) #1 meets relationship.
	 *                  False if only some of polygon(s) #1 meets relationship.
	 *                  Default is true.
	 * @param {Boolean} [within] True if relationship is "within" otherwise
	 *                           "outside". Default is true.
	 * @private
	 * @return {Boolean} True if relationship met otherwise false.
	 */
	const relate = (polygons1, polygons2, boundary, every, within) => {
	  boundary = boundary !== false;
	  every = every !== false;
	  within = within !== false;

	  // Rule out case where polygon coordinates are identical which can cause
	  // trouble for the clipping tools used during partitioning if the
	  // triangulations are identical and vertices are high precision.
	  if (isPolygonSimilar(polygons1, polygons2)) {
	    return within === true;
	  }

	  // Compute the partition of polygon #1 relative to #2 so that each partition
	  // triangle is either entirely within or outside polygon #2. Then, we have
	  // to check if the centroid of each partition triangle satisfies relation.
	  const triangulation1 = triangulate$1(polygons1);
	  const triangulation2 = triangulate$1(polygons2);
	  const partition1 = partition.polygon(triangulation1, triangulation2);

	  const reducer = (every ? meta.featureEvery : meta.featureSome);
	  return reducer(partition1, (triangle) => {
	    const centroid$1 = centroid(triangle);
	    return point$6.isInPolygon(centroid$1, polygons2, boundary) === within;
	  });
	};

	var polygon$6 = {
	  isBoundaryIntersecting,
	  isInPolygon,
	  relate,
	};

	var util = {
	  clipper,
	  helpers,
	  invariant,
	  line: line$6,
	  meta,
	  partition,
	  point: point$6,
	  polygon: polygon$6,
	  triangulate: triangulate$1,
	};

	/**
	 * @description Test if line(s) #1 is within line(s) #2.
	 * @param {Lines} lines1 Line #1.
	 * @param {Lines} lines2 Line #2.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const withinLine$1 = (lines1, lines2) => {
	  if (util.helpers.disjoint(lines1, lines2)) {
	    return false;
	  }

	  // Rule out case where line coordinates are identical which can cause
	  // trouble for the clipping tools used during partitioning if the
	  // line strings are identical and vertices are high precision.
	  if (util.line.isSimilar(lines1, lines2)) {
	    return true;
	  }

	  // Check that all vertex in #1 are in the interior of #2
	  if (util.point.isInLine(lines1, lines2, true, true) === false) {
	    return false;
	  }

	  // Check if the centroid of each partition segment is within lines #2.
	  const overlaps = util.line.isOverlapping(lines1, lines2, false, true, true);
	  if (overlaps) {
	    return true;
	  }

	  return false;
	};

	/**
	 * @description Test if line(s) is within polygon(s).
	 * @param {Lines} lines Line to be tested.
	 * @param {Polgons} polygons Polygon to be tested.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const withinPolygon$2 = (lines, polygons) => {
	  if (util.helpers.disjoint(lines, polygons)) {
	    return false;
	  }

	  // Partition each line using polygon boundaries so that each partition
	  // segment is either within or outside the polygons.
	  return util.meta.flattenEvery(lines, (linestring) => {
	    // Check that no centroid is in the exterior of all polygons
	    const linePartition = util.partition.boundaries(linestring, polygons);
	    const centroids = util.helpers.centroids(linePartition);
	    const notExterior = util.point.isInPolygon(centroids, polygons, true, true);
	    if (notExterior === false) {
	      return false;
	    }

	    // Check that atleast one point is in the interior.
	    return util.point.isInPolygon(centroids, polygons, false, false);
	  });
	};

	var line$5 = {
	  withinLine: withinLine$1,
	  withinPolygon: withinPolygon$2,
	};

	/**
	 * @description Test if point(s) are within line(s).
	 * @param {Points} points Point to test.
	 * @param {Lines} lines Lines to test.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const withinLine = (points, lines) => {
	  if (util.helpers.disjoint(points, lines)) {
	    return false;
	  }

	  // Check that no point is in the exterior of all polygons
	  // and there is at least one interior point.
	  const notExterior = util.point.isInLine(points, lines, true, true);
	  if (notExterior === false) {
	    return false;
	  }

	  // Check that atleast one point is in the interior.
	  return util.point.isInLine(points, lines, false, false);
	};

	/**
	 * @description Test if point(s) #1 are within point(s) #2.
	 * @param {Points} points1 Point #1 to test.
	 * @param {Points} points2 Point #2 to test.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const withinPoint = (points1, points2) => {
	  if (util.helpers.disjoint(points1, points2)) {
	    return false;
	  }

	  // Test that every point in #1 equals some in #2.
	  return util.point.isInPoint(points1, points2, true);
	};

	/**
	 * @description Test if point(s) are within polygon(s).
	 * @param {Points} points Point to test.
	 * @param {Polygons} polygons Polygons to test.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const withinPolygon$1 = (points, polygons) => {
	  if (util.helpers.disjoint(points, polygons)) {
	    return false;
	  }

	  // Check that no point is in the exterior of all polygons
	  // and there is at least one interior point.
	  const notExterior = util.point.isInPolygon(points, polygons, true, true);
	  if (notExterior === false) {
	    return false;
	  }

	  // Check that atleast one point is in the interior.
	  return util.point.isInPolygon(points, polygons, false, false);
	};

	var point$5 = {
	  withinLine,
	  withinPoint,
	  withinPolygon: withinPolygon$1,
	};

	/**
	 * @description Test if polygon(s) #1 is within polygon(s) #2.
	 * @param {Polygons} polygons1 Polygon #1.
	 * @param {Polygons} polygons2 Polygon #2.
	 * @private
	 * @return {Boolean} True if within otherwise false.
	 */
	const withinPolygon = (polygons1, polygons2) => {
	  if (util.helpers.disjoint(polygons1, polygons2)) {
	    return false;
	  }

	  // Check the polygon #1 is within polygon #2.
	  return util.polygon.isInPolygon(polygons1, polygons2);
	};

	var polygon$5 = {
	  withinPolygon,
	};

	/**
	 * @description Check if geojson #1 is within geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if within otherwise false.
	 */
	const within = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	      return line$5.withinLine(geojson1, geojson2);
	    case 'LineString-Polygon':
	      return line$5.withinPolygon(geojson1, geojson2);
	    case 'Point-LineString':
	      return point$5.withinLine(geojson1, geojson2);
	    case 'Point-Point':
	      return point$5.withinPoint(geojson1, geojson2);
	    case 'Point-Polygon':
	      return point$5.withinPolygon(geojson1, geojson2);
	    case 'Polygon-Polygon':
	      return polygon$5.withinPolygon(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} within ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Check if geojson #1 contains geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if contained otherwise false.
	 */
	const contains$1 = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	    case 'LineString-Point':
	    case 'Point-Point':
	    case 'Polygon-LineString':
	    case 'Polygon-Point':
	    case 'Polygon-Polygon':
	      return within(geojson2, geojson1);
	    default:
	      if (error) {
	        throw new Error(`${type1} contains ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Test if line(s) #1 covered by line(s) #2.
	 * @param {Lines} lines1 Line #1 to be tested.
	 * @param {Lines} lines2 Line #2 to be tested.
	 * @private
	 * @return {Boolean} True if line is covered by otherwise false.
	 */
	const coveredbyLine$1 = (lines1, lines2) => {
	  return line$5.withinLine(lines1, lines2);
	};

	/**
	 * @description Test if line(s) coveredby polygon(s).
	 * @param {Lines} lines Lines to test.
	 * @param {Polygons} polygons Polygon to test.
	 * @private
	 * @return {Boolean} True if covers otherwise false.
	 */
	const coveredbyPolygon$2 = (lines, polygons) => {
	  if (util.helpers.disjoint(lines, polygons)) {
	    return false;
	  }

	  // Test that all line segments are within or on the boundary of the polygons.
	  return util.meta.flattenEvery(lines, (linestring) => {
	    // Partition each line with polygon boundaries and test partition centroids.
	    const linePartition = util.partition.boundaries(linestring, polygons);
	    const centroids = util.helpers.centroids(linePartition);
	    return util.point.isInPolygon(centroids, polygons, true, true, true);
	  });
	};

	var line$4 = {
	  coveredbyLine: coveredbyLine$1,
	  coveredbyPolygon: coveredbyPolygon$2,
	};

	/**
	 * @description Test if point(s) coveredby line(s).
	 * @param {Points} points Point to test.
	 * @param {Lines} lines Line to test.
	 * @private
	 * @return {Boolean} True if coveredby otherwise false.
	 */
	const coveredbyLine = (points, lines) => {
	  if (util.helpers.disjoint(points, lines)) {
	    return false;
	  }

	  // Test that all points are within or on the boundary of the polygons.
	  return util.point.isInLine(points, lines, true, true, true);
	};

	/**
	 * @description Test if point(s) #1 coveredby point(s) #2.
	 * @param {Points} points1 Point #1 to test.
	 * @param {Points} points2 Point #2 to test.
	 * @private
	 * @return {Boolean} True if coveredby otherwise false.
	 */
	const coveredbyPoint = (points1, points2) => {
	  if (util.helpers.disjoint(points1, points2)) {
	    return false;
	  }

	  // Test that every point in #1 covers points in #2.
	  return util.point.isInPoint(points1, points2, true);
	};

	/**
	 * @description Test if point(s) coveredby polygon(s).
	 * @param {Points} points Point to test.
	 * @param {Polygons} polygons Polygon to test.
	 * @private
	 * @return {Boolean} True if coveredby otherwise false.
	 */
	const coveredbyPolygon$1 = (points, polygons) => {
	  if (util.helpers.disjoint(points, polygons)) {
	    return false;
	  }

	  // Test that all points are within or on the boundary of the polygons.
	  return util.point.isInPolygon(points, polygons, true, true, true);
	};

	var point$4 = {
	  coveredbyLine,
	  coveredbyPoint,
	  coveredbyPolygon: coveredbyPolygon$1,
	};

	/**
	 * @description Test if polygon(s) #1 is coveredby polygon(s) #2.
	 * @param {Polygons} polygons1 Polygon #1.
	 * @param {Polygons} polygons2 Polygon #2.
	 * @private
	 * @return {Boolean} True if covered otherwise false.
	 */
	const coveredbyPolygon = (polygons1, polygons2) => {
	  if (util.helpers.disjoint(polygons1, polygons2)) {
	    return false;
	  }

	  // Check the polygon #1 is within polygon #2.
	  return util.polygon.isInPolygon(polygons1, polygons2);
	};

	var polygon$4 = {
	  coveredbyPolygon,
	};

	/**
	 * @description Check if geojson #1 is coveredby geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if coveredby otherwise false.
	 */
	const coveredby = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	      return line$4.coveredbyLine(geojson1, geojson2);
	    case 'LineString-Polygon':
	      return line$4.coveredbyPolygon(geojson1, geojson2);
	    case 'Point-LineString':
	      return point$4.coveredbyLine(geojson1, geojson2);
	    case 'Point-Point':
	      return point$4.coveredbyPoint(geojson1, geojson2);
	    case 'Point-Polygon':
	      return point$4.coveredbyPolygon(geojson1, geojson2);
	    case 'Polygon-Polygon':
	      return polygon$4.coveredbyPolygon(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} coveredby ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Check if geojson #1 covers geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if covers otherwise false.
	 */
	const covers = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	    case 'LineString-Point':
	    case 'Point-Point':
	    case 'Polygon-Point':
	    case 'Polygon-LineString':
	    case 'Polygon-Polygon':
	      return coveredby(geojson2, geojson1);
	    default:
	      if (error) {
	        throw new Error(`${type1} covers ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Test if point(s) crosses line(s).
	 * @param {Points} points Points to test.
	 * @param {Lines} lines Line to test.
	 * @private
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crossesLine$2 = (points, lines) => {
	  if (util.helpers.disjoint(points, lines)) {
	    return false;
	  }

	  const within = util.point.isInLine(points, lines, false, false, true);
	  if (within === false) {
	    return false;
	  }

	  return util.point.isInLine(points, lines, true, false, false);
	};

	/**
	 * @description Test if point(s) crosses polygon(s).
	 * @param {Points} points Points to test.
	 * @param {Polygons} polygons Polygon to test.
	 * @private
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crossesPolygon$1 = (points, polygons) => {
	  if (util.helpers.disjoint(points, polygons)) {
	    return false;
	  }

	  const within = util.point.isInPolygon(points, polygons, false, false, true);
	  if (within === false) {
	    return false;
	  }

	  return util.point.isInPolygon(points, polygons, true, false, false);
	};

	var point$3 = {
	  crossesLine: crossesLine$2,
	  crossesPolygon: crossesPolygon$1,
	};

	/**
	 * @description Test if line(s) #1 crosses line(s) #2.
	 * @param {Lines} lines1 Line #1.
	 * @param {Lines} lines2 Line #2.
	 * @private
	 * @return {Boolean} True if they cross otherwise false.
	 */
	const crossesLine$1 = (lines1, lines2) => {
	  if (util.helpers.disjoint(lines1, lines2)) {
	    return false;
	  }

	  // Check if some segment of line #1 is within line #2.
	  const overlaps = util.line.isOverlapping(lines1, lines2, false, false, true);
	  if (overlaps) {
	    return false;
	  }

	  // Check for any non-boundary intersections.
	  const intersections = util.line.isIntersecting(lines1, lines2, false);
	  if (intersections) {
	    return true;
	  }

	  return false;
	};

	/**
	 * @description Test if line(s) crosses point(s).
	 * @param {Lines} lines Line to test.
	 * @param {Points} points Points to test.
	 * @private
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crossesPoint$1 = (lines, points) => {
	  return point$3.crossesLine(points, lines);
	};

	/**
	 * @description Test if line(s) crosses polygon(s).
	 * @param {Lines} lines Lines to test.
	 * @param {Polygons} polygons Polygon to test.
	 * @private
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crossesPolygon = (lines, polygons) => {
	  if (util.helpers.disjoint(lines, polygons)) {
	    return false;
	  }

	  // Search for at least one point in the line that is interior to the polygon
	  // and one point that is in the line that is exterior to polygon.
	  const crosses = flattenReduce(lines, (cross1, linestring) => {
	    if (cross1.within && cross1.outside) {
	      return cross1;
	    }

	    // Partition each line with polygon boundaries and test partition centroids.
	    const linePartition = util.partition.boundaries(linestring, polygons);
	    const centroids = util.helpers.centroids(linePartition);

	    if (cross1.within === false) {
	      cross1.within = util.point.isInPolygon(
	          centroids, polygons, false, false, true);
	    }
	    if (cross1.outside === false) {
	      cross1.outside = util.point.isInPolygon(
	          centroids, polygons, true, false, false);
	    }

	    return cross1;
	  }, {
	    within: false,
	    outside: false,
	  });

	  return crosses.within && crosses.outside;
	};

	var line$3 = {
	  crossesLine: crossesLine$1,
	  crossesPoint: crossesPoint$1,
	  crossesPolygon,
	};

	/**
	 * @description Test if polygon(s) crosses line(s).
	 * @param {Polygons} polygons Polygon to test.
	 * @param {Lines} lines Lines to test.
	 * @private
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crossesLine = (polygons, lines) => {
	  return line$3.crossesPolygon(lines, polygons);
	};

	/**
	 * @description Test if polygon(s) crosses point(s).
	 * @param {Polygons} polygons Polygon to test.
	 * @param {Points} points Points to test.
	 * @private
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crossesPoint = (polygons, points) => {
	  return point$3.crossesPolygon(points, polygons);
	};

	var polygon$3 = {
	  crossesLine,
	  crossesPoint,
	};

	/**
	 * @description Check if geojson #1 crosses geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if crosses otherwise false.
	 */
	const crosses = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	      return line$3.crossesLine(geojson1, geojson2);
	    case 'LineString-Point':
	      return line$3.crossesPoint(geojson1, geojson2);
	    case 'LineString-Polygon':
	      return line$3.crossesPolygon(geojson1, geojson2);
	    case 'Point-LineString':
	      return point$3.crossesLine(geojson1, geojson2);
	    case 'Point-Polygon':
	      return point$3.crossesPolygon(geojson1, geojson2);
	    case 'Polygon-LineString':
	      return polygon$3.crossesLine(geojson1, geojson2);
	    case 'Polygon-Point':
	      return polygon$3.crossesPoint(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} crosses ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Test if point(s) intersects line(s).
	 * @param {Points} points Point to be intersected.
	 * @param {Lines} lines Line to be intersected.
	 * @private
	 * @return {Boolean} True if they intersect otherwise false.
	 */
	const intersectsLine$2 = (points, lines) => {
	  if (util.helpers.disjoint(points, lines)) {
	    return false;
	  }

	  // Test that any point is in some line.
	  return util.point.isInLine(points, lines, true, false);
	};

	/**
	 * @description Test if point(s) intersect point(s).
	 * @param {Points} points1 Point #1 to test.
	 * @param {Points} points2 Point #2 to test.
	 * @private
	 * @return {Boolean} True if they intersect otherwise false.
	 */
	const intersectsPoint$2 = (points1, points2) => {
	  if (util.helpers.disjoint(points1, points2)) {
	    return false;
	  }

	  // Check if some point #1 equals point #2.
	  return util.point.isInPoint(points1, points2, false);
	};

	/**
	 * @description Test if point(s) intersects polygon(s).
	 * @param {Points} points Points to be tested.
	 * @param {Polygons} polygons Polygons to be tested.
	 * @private
	 * @return {Boolean} True if intersecting otherwise false.
	 */
	const intersectsPolygon$2 = (points, polygons) => {
	  if (util.helpers.disjoint(points, polygons)) {
	    return false;
	  }

	  // Search for at least one point in lines that is in a polygon.
	  return util.point.isInPolygon(points, polygons, true, false);
	};

	var point$2 = {
	  intersectsLine: intersectsLine$2,
	  intersectsPoint: intersectsPoint$2,
	  intersectsPolygon: intersectsPolygon$2,
	};

	/**
	 * @description Test if line(s) #1 intersects line(s) #2.
	 * @param {Lines} lines1 Line #1 to be intersected.
	 * @param {Lines} lines2 Line #2 to be intersected.
	 * @private
	 * @return {Boolean} True if they intersect otherwise false.
	 */
	const intersectsLine$1 = (lines1, lines2) => {
	  if (util.helpers.disjoint(lines1, lines2)) {
	    return false;
	  }

	  return util.line.isDisjoint(lines1, lines2) === false;
	};

	/**
	 * @description Test if line(s) intersects line(s).
	 * @param {Lines} lines Line to be intersected.
	 * @param {Points} points Point to be intersected.
	 * @private
	 * @return {Boolean} True if they intersect otherwise false.
	 */
	const intersectsPoint$1 = (lines, points) => {
	  return point$2.intersectsLine(points, lines);
	};

	/**
	 * @description Test if line(s) intersects polygon(s).
	 * @param {Lines} lines Line to be tested.
	 * @param {Polygons} polygons Polygons to be tested.
	 * @private
	 * @return {Boolean} True if intersecting otherwise false.
	 */
	const intersectsPolygon$1 = (lines, polygons) => {
	  if (util.helpers.disjoint(lines, polygons)) {
	    return false;
	  }

	  // Test if polygon boundaries intersect lines.
	  const intersections = util.meta.flattenSome(polygons, (poly) => {
	    const boundary = polygonToLine(poly);
	    return intersectsLine$1(boundary, lines);
	  });
	  if (intersections) {
	    return true;
	  }

	  // Search for at least one point in lines that is interior to a polygon.
	  return util.point.isInPolygon(lines, polygons, true, false);
	};

	var line$2 = {
	  intersectsLine: intersectsLine$1,
	  intersectsPoint: intersectsPoint$1,
	  intersectsPolygon: intersectsPolygon$1,
	};

	/**
	 * @description Test if polygon(s) intersects line(s).
	 * @param {Polygons} polygons Polygons to be tested.
	 * @param {Lines} lines Line to be tested.
	 * @private
	 * @return {Boolean} True if intersecting otherwise false.
	 */
	const intersectsLine = (polygons, lines) => {
	  return line$2.intersectsPolygon(lines, polygons);
	};

	/**
	 * @description Test if polygon(s) intersects point(s).
	 * @param {Polygons} polygons Polygons to be tested.
	 * @param {Points} points Points to be tested.
	 * @private
	 * @return {Boolean} True if intersecting otherwise false.
	 */
	const intersectsPoint = (polygons, points) => {
	  return point$2.intersectsPolygon(points, polygons);
	};

	/**
	 * @description Test if polygon(s) #1 intersects polygon(s) #2.
	 * @param {Polygons} polygons1 Polygons #1.
	 * @param {Polygons} polygons2 Polygons #2.
	 * @private
	 * @return {Boolean} True if intersecting otherwise false.
	 */
	const intersectsPolygon = (polygons1, polygons2) => {
	  if (util.helpers.disjoint(polygons1, polygons2)) {
	    return false;
	  }

	  // Test if polygon boundaries intersect.
	  const intersections = util.polygon.isBoundaryIntersecting(
	      polygons1, polygons2);
	  if (intersections) {
	    return true;
	  }

	  // Search for at least one point in polygon #1 that is interior to polygon #2.
	  return util.polygon.relate(polygons1, polygons2, true, false, true);
	};

	var polygon$2 = {
	  intersectsLine,
	  intersectsPoint,
	  intersectsPolygon,
	};

	/**
	 * @description Check if geojson #1 intersects geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if intersects otherwise false.
	 */
	const intersects = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	      return line$2.intersectsLine(geojson1, geojson2);
	    case 'LineString-Point':
	      return line$2.intersectsPoint(geojson1, geojson2);
	    case 'LineString-Polygon':
	      return line$2.intersectsPolygon(geojson1, geojson2);
	    case 'Point-LineString':
	      return point$2.intersectsLine(geojson1, geojson2);
	    case 'Point-Point':
	      return point$2.intersectsPoint(geojson1, geojson2);
	    case 'Point-Polygon':
	      return point$2.intersectsPolygon(geojson1, geojson2);
	    case 'Polygon-LineString':
	      return polygon$2.intersectsLine(geojson1, geojson2);
	    case 'Polygon-Point':
	      return polygon$2.intersectsPoint(geojson1, geojson2);
	    case 'Polygon-Polygon':
	      return polygon$2.intersectsPolygon(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} intersects ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Check if geojson #1 is disjoint geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if disjoint otherwise false.
	 */
	const disjoint = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	    case 'LineString-Point':
	    case 'LineString-Polygon':
	    case 'Point-LineString':
	    case 'Point-Point':
	    case 'Point-Polygon':
	    case 'Polygon-LineString':
	    case 'Polygon-Point':
	    case 'Polygon-Polygon':
	      return intersects(geojson1, geojson2) === false;
	    default:
	      if (error) {
	        throw new Error(`${type1} disjoint ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Check if geojson #1 equals geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if equals otherwise false.
	 */
	const equals = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	    case 'Point-Point':
	    case 'Polygon-Polygon':
	      return within(geojson1, geojson2) && contains$1(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} equals ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Test if line(s) #1 overlaps line(s) #2.
	 * @param {Lines} lines1 Line #1 to be tested.
	 * @param {Lines} lines2 Line #2 to be tested.
	 * @private
	 * @return {Boolean} True if they overlap otherwise false.
	 */
	const overlapsLine = (lines1, lines2) => {
	  if (util.helpers.disjoint(lines1, lines2)) {
	    return false;
	  }

	  // Rule out case where line coordinates are identical which can cause
	  // trouble for the clipping tools used during partitioning if the
	  // line strings are identical and vertices are high precision.
	  if (util.line.isSimilar(lines1, lines2)) {
	    return false;
	  }

	  // Check there is line #1 segment interior to line #2
	  const interior = util.line.isOverlapping(
	      lines1, lines2, false, false, true, 0.02);
	  if (interior === false) {
	    return false;
	  }

	  // Check there is line #1 segment exterior to line #2
	  const exterior = util.line.isOverlapping(
	      lines1, lines2, true, false, false, 0.02);
	  if (exterior === false) {
	    return false;
	  }

	  // Check there is line #2 segment exterior to line #1
	  return util.line.isOverlapping(lines2, lines1, true, false, false, 0.02);
	};

	var line$1 = {
	  overlapsLine,
	};

	/**
	 * @description Test if point(s) #1 overlaps point(s) #2.
	 * @param {Points} points1 Point #1 to be tested.
	 * @param {Points} points2 Point #2 to be tested.
	 * @private
	 * @return {Boolean} True if they overlap otherwise false.
	 */
	const overlapsPoint = (points1, points2) => {
	  if (util.helpers.disjoint(points1, points2)) {
	    return false;
	  }

	  // Find point #1 in points #2
	  const oneInTwo = util.point.isInPoint(points1, points2, false, true);
	  if (oneInTwo === false) {
	    return false;
	  }

	  // Find point #1 not in points #2
	  const oneNotInTwo = util.point.isInPoint(points1, points2, false, false);
	  if (oneNotInTwo === false) {
	    return false;
	  }

	  // Find point #2 not in points #1
	  return util.point.isInPoint(points2, points1, false, false);
	};

	var point$1 = {
	  overlapsPoint,
	};

	/**
	 * @description Test if polygon(s) #1 overlaps polygon(s) #2.
	 * @param {Polygons} polygons1 Polygon #1.
	 * @param {Polygons} polygons2 Polygon #2.
	 * @private
	 * @return {Boolean} True if overlapping otherwise false.
	 */
	const overlapsPolygon = (polygons1, polygons2) => {
	  if (util.helpers.disjoint(polygons1, polygons2)) {
	    return false;
	  }

	  // Compute the partition of polygon #1 relative to #2 so that each partition.
	  // triangle is either entirely within or outside polygon #2.
	  const triangulation1 = util.triangulate(polygons1);
	  const triangulation2 = util.triangulate(polygons2);
	  const partition1 = util.partition.polygon(triangulation1, triangulation2);

	  // Search for at least one point in polygon #1 that is interior to polygon #2
	  // and one point that is in polygon #1 that is exterior to polygon #2.
	  const overlap1 = featureReduce(partition1, (overlap, triangle) => {
	    if (overlap.within && overlap.outside) {
	      return overlap;
	    }

	    const centroid$1 = centroid(triangle);
	    if (overlap.within === false &&
	        util.point.isInPolygon(centroid$1, polygons2, false)) {
	      overlap.within = true;
	    } else if (overlap.outside === false &&
	               util.point.isInPolygon(centroid$1, polygons2, true) === false) {
	      overlap.outside = true;
	    }

	    return overlap;
	  }, {
	    within: false,
	    outside: false,
	  });

	  // Stop if not found. No need to check polygon #2
	  if ((overlap1.within && overlap1.outside) === false) {
	    return false;
	  }

	  // Search for at least one point in polygon #2 that is exterior to polygon #1.
	  const partition2 = util.partition.polygon(triangulation2, triangulation1);
	  return util.meta.featureSome(partition2, (triangle) => {
	    const centroid$1 = centroid(triangle);
	    return util.point.isInPolygon(centroid$1, polygons1, true) === false;
	  });
	};

	var polygon$1 = {
	  overlapsPolygon,
	};

	/**
	 * @description Check if geojson #1 overlaps geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if overlaps otherwise false.
	 */
	const overlaps = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	      return line$1.overlapsLine(geojson1, geojson2);
	    case 'Point-Point':
	      return point$1.overlapsPoint(geojson1, geojson2);
	    case 'Polygon-Polygon':
	      return polygon$1.overlapsPolygon(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} overlaps ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	/**
	 * @description Test if point(s) touches line(s).
	 * @param {Points} points Points to be tested.
	 * @param {Lines} lines Lines to be tested.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesLine$2 = (points, lines) => {
	  if (util.helpers.disjoint(points, lines)) {
	    return false;
	  }

	  // Check that no point in #1 is in the interior of #2
	  if (util.point.isInLine(points, lines, false, false, true)) {
	    return false;
	  }

	  // Check that some point in #1 is on the boundary of #2
	  return util.point.isInLine(points, lines, true, false, true);
	};

	/**
	 * @description Test if point(s) touches polygon(s).
	 * @param {Points} points Points to be tested.
	 * @param {Polygons} polygons Polygons to be tested.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesPolygon$2 = (points, polygons) => {
	  if (util.helpers.disjoint(points, polygons)) {
	    return false;
	  }

	  // Check that no point in #1 is in the interior of #2
	  if (util.point.isInPolygon(points, polygons, false, false, true)) {
	    return false;
	  }

	  // Check that some point in #1 is on the boundary of #2
	  return util.point.isInPolygon(points, polygons, true, false, true);
	};

	var point = {
	  touchesLine: touchesLine$2,
	  touchesPolygon: touchesPolygon$2,
	};

	/**
	 * @description Test if line(s) #1 touches line(s) #2.
	 * @param {Lines} lines1 Line #1 to be tested.
	 * @param {Lines} lines2 Line #2 to be tested.
	 * @private
	 * @return {Boolean} True if they touch otherwise false.
	 */
	const touchesLine$1 = (lines1, lines2) => {
	  if (util.helpers.disjoint(lines1, lines2)) {
	    return false;
	  }

	  const intersections = util.line.isIntersecting(lines1, lines2, false);
	  if (intersections) {
	    return false;
	  }

	  const overlaps = util.line.isOverlapping(lines1, lines2, true, false, true);
	  if (overlaps) {
	    return false;
	  }

	  const touches = util.line.isTouching(lines1, lines2);
	  if (touches) {
	    return true;
	  }

	  return false;
	};

	/**
	 * @description Test if line(s) touches point(s).
	 * @param {Lines} lines Lines to test.
	 * @param {Points} points Points to test.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesPoint$1 = (lines, points) => {
	  return point.touchesLine(points, lines);
	};

	/**
	 * @description Test if lines(s) touches polygon(s).
	 * @param {Lines} lines Lines to test.
	 * @param {Polygons} polygons Polygons to test.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesPolygon$1 = (lines, polygons) => {
	  if (util.helpers.disjoint(lines, polygons)) {
	    return false;
	  }
	  const touches = flattenReduce(lines, (touches1, linestring) => {
	    // Exit if we've already found an interior point.
	    if (touches1.within) {
	      return touches1;
	    }

	    // Check if any line segment is within polygon.
	    const linePartition = util.partition.boundaries(linestring, polygons);
	    const centroids = util.helpers.centroids(linePartition);
	    if (util.point.isInPolygon(centroids, polygons, false, false, true)) {
	      touches1.within = true;
	      return touches1;
	    }

	    // Check if there are any line points exterior to polygon
	    if (touches1.exterior === false) {
	      if (util.point.isInPolygon(centroids, polygons, true, false, false)) {
	        touches1.exterior = true;
	      }
	    }

	    // Exit if we've already found a boundary point.
	    if (touches1.boundary) {
	      return touches1;
	    }

	    // Check if any line segment overlaps polygon boundary.
	    if (util.point.isInPolygon(centroids, polygons, true, false, true)) {
	      touches1.boundary = true;
	      return touches1;
	    }

	    // Check either end point falls on some flattened polygon boundary.
	    const endPoints = [util.line.start(linestring), util.line.end(linestring)];
	    const touchesEnd = endPoints.some((pt) => {
	      return util.meta.flattenSome(polygons, (poly) => {
	        const boundaries = polygonToLine(poly);
	        // Boundaries may be MultiLineString so we flatten again.
	        return util.meta.flattenSome(boundaries, (boundary) => {
	          return booleanPointOnLine(pt, boundary, {
	            ignoreEndVertices: false,
	          });
	        });
	      });
	    });
	    if (touchesEnd) {
	      touches1.boundary = true;
	    }

	    return touches1;
	  }, {
	    boundary: false,
	    exterior: false,
	    within: false,
	  });

	  return touches.within === false && touches.boundary && touches.exterior;
	};

	var line = {
	  touchesLine: touchesLine$1,
	  touchesPoint: touchesPoint$1,
	  touchesPolygon: touchesPolygon$1,
	};

	/**
	 * @description Test if polygon(s) touches lines(s).
	 * @param {Polygons} polygons Polygons to test.
	 * @param {Lines} lines Lines to test.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesLine = (polygons, lines) => {
	  return line.touchesPolygon(lines, polygons);
	};

	/**
	 * @description Test if polygon(s) touches point(s).
	 * @param {Polygons} polygons Polygons to test.
	 * @param {Points} points Points to test.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesPoint = (polygons, points) => {
	  return point.touchesPolygon(points, polygons);
	};

	/**
	 * @description Test if polygon(s) #1 touches polygon(s) #2.
	 * @param {Polygons} polygons1 Polygons #1.
	 * @param {Polygons} polygons2 Polygons #2.
	 * @private
	 * @return {Boolean} True if touching otherwise false.
	 */
	const touchesPolygon = (polygons1, polygons2) => {
	  if (util.helpers.disjoint(polygons1, polygons2)) {
	    return false;
	  }

	  // Check that no vertex in #1 is in the interior of #2
	  if (util.point.isInPolygon(polygons1, polygons2, false, false)) {
	    return false;
	  }

	  // Check that no vertex in #2 is in the interior of #1
	  if (util.point.isInPolygon(polygons2, polygons1, false, false)) {
	    return false;
	  }

	  // Test if polygon boundaries intersect.
	  const intersections = util.polygon.isBoundaryIntersecting(
	      polygons1, polygons2);
	  if (intersections === false) {
	    return false;
	  }

	  // Check that no interior point of polygon #1 is interior to polygon #2.
	  return util.polygon.relate(polygons1, polygons2, true, true, false);
	};

	var polygon = {
	  touchesLine,
	  touchesPoint,
	  touchesPolygon,
	};

	/**
	 * @description Check if geojson #1 touches geojson #2.
	 * @param {GeoJSON} geojson1 GeoJSON #1.
	 * @param {GeoJSON} geojson2 GeoJSON #2.
	 * @param {Boolean} [error=true] If true unsupported geometries throw an
	 *                               error, otherwise they return false.
	 * @return {Boolean} True if touches otherwise false.
	 */
	const touches = (geojson1, geojson2, error=true) => {
	  const type1 = util.invariant.type(geojson1);
	  const type2 = util.invariant.type(geojson2);
	  const type = `${type1}-${type2}`;
	  switch (type) {
	    case 'LineString-LineString':
	      return line.touchesLine(geojson1, geojson2);
	    case 'LineString-Point':
	      return line.touchesPoint(geojson1, geojson2);
	    case 'LineString-Polygon':
	      return line.touchesPolygon(geojson1, geojson2);
	    case 'Point-LineString':
	      return point.touchesLine(geojson1, geojson2);
	    case 'Point-Polygon':
	      return point.touchesPolygon(geojson1, geojson2);
	    case 'Polygon-LineString':
	      return polygon.touchesLine(geojson1, geojson2);
	    case 'Polygon-Point':
	      return polygon.touchesPoint(geojson1, geojson2);
	    case 'Polygon-Polygon':
	      return polygon.touchesPolygon(geojson1, geojson2);
	    default:
	      if (error) {
	        throw new Error(`${type1} touches ${type2} not supported.`);
	      }
	      return false;
	  }
	};

	var index$1 = {
	  contains: contains$1,
	  coveredby,
	  covers,
	  crosses,
	  disjoint,
	  equals,
	  intersects,
	  overlaps,
	  touches,
	  within,
	};

	/**
	 * MongoLocalDB.getProp (Private Function)
	 */
	function getProp(obj,name) {
		var path = name.split("\.");
		var result = obj[path[0]];
		for (var i=1 ; i<path.length ; i++) {
			if (result==undefined || result==null) return result;
			result = result[path[i]];
		}
		return result;
	}

	/**
	 * MongoLocalDB.LocalStorageStore
	 * 
	 * Singleton
	 */
	const LocalStorageStore = (function() {

		return {
			clear : function() {
				localStorage.clear();
			},
			get : function(i) {
				return JSON.parse(localStorage.getItem(localStorage.key(i)));
			},
			getStore : function() {
				return localStorage;
			},
			remove : function(key) {
				localStorage.removeItem(key);
			},
			set : async function(key,val) {
				localStorage.setItem(key,JSON.stringify(val));
			},
			size : function() {
				return localStorage.length;
			}
		};

	})(); // MongoLocalDB.LocalStorageStore

	/**
	 * MongoLocalDB.ObjectStore
	 * 
	 * Public Constructor Function
	 */
	const ObjectStore = function() {

		var objs = {};

		return {
			clear : function() {
				objs = {};
			},
			get : function(i) {
				return objs[Object.keys(objs)[i]];
			},
			getStore : function() {
				return objs;
			},
			remove : function(key) {
				delete objs[key];
			},
			set : function(key,val) {
				objs[key] = val;
			},
			size : function() {
				return Object.keys(objs).length;
			}
		}; // MongoLocalDB.ObjectStore return
	}; // MongoLocalDB.ObjectStore

	/**
	 * MongoLocalDB.DB (Public Constructor)
	 */
	function DB(options) {

		/**
		 * MongoLocalDB.DB.log (Private Function)
		 * 
		 * @param {String} msg The message to display.
		 */
		function log(msg) {
			if (options && options.print) options.print(msg);
			else console.log(msg);
		}

		/**
		 * MongoLocalDB.DB.id (Private Function)
		 */
		function id() {
			if (options && options.id) return options.id();
			else return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
				return v.toString(16);
			});
		}

		/**
		 * MongoLocalDB.DB.toArray (Private Function)
		 */
		function toArray(obj) {
			var arr = [];
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					var el = {};
					el[key] = obj[key];
					arr.push(el);
				}
			}
			return arr;
		}

		/**
		 * MongoLocalDB.DB.tlMatches
		 * 
		 * Private Function
		 */
		function tlMatches(doc,query) {
			var key = Object.keys(query)[0];
			var value = query[key];
			if (key.charAt(0)=="$") {
				if (key=="$and") return and(doc,value);
				else if (key=="$or") return or(doc,value);
				else if (key=="$not") return not(doc,value);
				else if (key=="$nor") return nor(doc,value);
				else if (key=="$where") return where(doc,value);
				else throw { $err : "Can't canonicalize query: BadValue unknown top level operator: " + key, code: 17287 };
			} else {
				return opMatches(doc,key,value);
			}
		}

		/**
		 * MongoLocalDB.DB.opMatches
		 * 
		 * Private Function
		 */
		function opMatches(doc,key,value) {
			if (typeof(value)=="string") return getProp(doc,key)==value;
			else if (typeof(value)=="number") return getProp(doc,key)==value;
			else if (typeof(value)=="boolean") return getProp(doc,key)==value;
			else if (typeof(value)=="object") {
				if (value instanceof RegExp) return getProp(doc,key) && getProp(doc,key).match(value);
				else if (isArray(value)) return getProp(doc,key) && arrayMatches(getProp(doc,key),value);
				else {
					var keys = Object.keys(value);
					if (keys[0].charAt(0)=="$") {
						for (var i=0 ; i<keys.length ; i++) {
							var operator = Object.keys(value)[i];
							var operand = value[operator];
							if (operator=="$eq") {
								if (getProp(doc,key)==undefined || !(getProp(doc,key) == operand)) return false;
							} else if (operator=="$gt") {
								if (getProp(doc,key)==undefined || !(getProp(doc,key) > operand)) return false;
							} else if (operator=="$gte") {
								if (getProp(doc,key)==undefined || !(getProp(doc,key) >= operand)) return false;
							} else if (operator=="$lt") {
								if (getProp(doc,key)==undefined || !(getProp(doc,key) < operand)) return false;
							} else if (operator=="$lte") {
								if (getProp(doc,key)==undefined || !(getProp(doc,key) <= operand)) return false;
							} else if (operator=="$ne") {
								if (getProp(doc,key)==undefined || !(getProp(doc,key) != operand)) return false;
							} else if (operator=="$in") {
								if (getProp(doc,key)==undefined || !isIn(getProp(doc,key),operand)) return false;
							} else if (operator=="$nin") {
								if (getProp(doc,key)==undefined ||  isIn(getProp(doc,key),operand)) return false;
							} else if (operator=="$exists") {
								if (operand?getProp(doc,key)==undefined:getProp(doc,key)!=undefined) return false;
							} else if (operator=="$type") {
								if (typeof(getProp(doc,key))!=operand) return false;
							} else if (operator=="$mod") {
								if (operand.length!=2) throw { $err : "Can't canonicalize query: BadValue malformed mod, not enough elements", code : 17287 };
								if (getProp(doc,key)==undefined || (getProp(doc,key) % operand[0] != operand[1])) return false;
							} else if (operator=="$regex") {
								if (getProp(doc,key)==undefined || !getProp(doc,key).match(operand)) return false;
							} else if (operator=="$text") {
								if (getProp(doc,key)==undefined ||  !text(getProp(doc,key),operand)) return false;
							} else if (operator=="$geoWithin") {
								if (getProp(doc,key)==undefined ||  !geoWithin(getProp(doc,key),operand)) return false;
							} else if (operator=="$not") {
								if (opMatches(doc,key,operand)) return false;
							} else {
								throw { $err : "Can't canonicalize query: BadValue unknown operator: " + operator, code : 17287 };
							}
						}
						return true;
					} else {
						return getProp(doc,key) && objectMatches(getProp(doc,key),value);
					}
				}
			}
		} // MongoLocalDB.DB.opMatches

		/**
		 * MongoLocalDB.DB.text
		 * 
		 * Private Function
		 */
		function text(prop,query) {
			const txi = new Txi().index('id',prop);
			const search = txi.search(query);
			return search.length == 1
		}

		//   { "type": "Feature",
		//   "geometry": {
		// 	"type": "Polygon",
		// 	"coordinates": [[
		// 	  [-10.0, -10.0], [10.0, -10.0], [10.0, 10.0], [-10.0, 10.0]
		// 	  ]]
		// 	}
		//   ...
		//   }

		function bboxToGeojson(bbox) {
			const minLon = bbox[0][0];
			const maxLat = bbox[0][1];
			const maxLon = bbox[1][0];
			const minLat = bbox[1][1];
			return {
				type: 'FeatureCollection',
				features: [{
					type: 'Feature',
					properties: {},
					geometry: {
						type: 'Polygon',
						coordinates: [[
							[minLon,maxLat],
							[minLon,minLat],
							[maxLon,minLat],
							[maxLon,maxLat],
							[minLon,maxLat]
						]]
					}
				}]
			}
		}

		/**
		 * MongoLocalDB.DB.geoWithin
		 * 
		 * Private Function
		 */
		 function geoWithin(prop,query) {
			try {
				return index$1.within(prop,bboxToGeojson(query),false)
			} catch (e) {
				return false
			}
		}

		/**
		 * MongoLocalDB.DB.and
		 * 
		 * Private Function
		 */
		function and(doc,els) {
			for (var i=0 ; i<els.length ; i++) {
				if (!tlMatches(doc,els[i])) {
					return false;
				}
			}
			return true;
		}

		/**
		 * MongoLocalDB.DB.or
		 * 
		 * Private Function
		 */
		function or(doc,els) {
			for (var i=0 ; i<els.length ; i++) {
				if (tlMatches(doc,els[i])) return true;
			}
			return false;
		}

		/**
		 * MongoLocalDB.DB.nor
		 * 
		 * Private Function
		 */
		function nor(doc,els) {
			for (var i=0 ; i<operand.length ; i++) {
				if (tlMatches(doc,els[i])) return false;
			}
			return true;
		}
		
		/**
		 * MongoLocalDB.DB.isArray
		 * 
		 * Private Function
		 */
		function isArray(o) {
			return Array == o.constructor;
		}

		/**
		 * MongoLocalDB.DB.matches
		 * 
		 * Private Function
		 */
		// query structure: (top level operators ( "age" : (operators) ))
		// top,top level query, implicit $and
		function matches(doc,query) {
			return and(doc,toArray(query));
		}

		/**
		 * MongoLocalDB.DB.isIn
		 * 
		 * Private Function
		 */
		function isIn(val,values) {
			for (var i=0 ; i<values.length ; i++) if (values[i]==val) return true;
			return false;
		}

		/**
		 * MongoLocalDB.DB.arrayMatches
		 * 
		 * Private Function
		 */
		function arrayMatches(x,y) {
			if (x.length!=y.length) return false;
			for (var i=0 ; i<x.length ; i++) {
				if (x[i]===y[i]) continue;
				if (typeof(x[i])!=typeof(y[i])) return false;
				if (typeof(x[i]=="object")) {
					if (isArray(x[i])) {
						if (!arrayMatches(x,y)) return false;
					} else {
						if (!objectMatches(x[i],y[i])) return false;
					}
				} else {
					if (x[i] != y[i]) return false;
				}
			}
			return true;
		}

		/**
		 * MongoLocalDB.DB.objectMatches
		 * 
		 * Private Function
		 */
		function objectMatches( x, y ) {
			  for ( var p in x ) {
			    if ( ! x.hasOwnProperty( p ) ) continue;
			    if ( ! y.hasOwnProperty( p ) ) return false;
			    if ( x[ p ] === y[ p ] ) continue;
			    if (typeof(x[p]) != typeof(y[p])) return false;
			    if (typeof(x[i])=="object") {
			    	if (isArray(x[i])) {
			    		if (!arrayMatches(x[i],y[i])) return false;
			    	} else {
			    		if (!objectMatches(x[i],y[i])) return false;
			    	}
			    } else {
			    	if (x[i]!=y[i]) return false;
			    }
			  }
			  for ( p in y ) {
			    if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
			  }
			  return true;
		}

		/**
		 * MongoLocalDB.DB.applyProjection
		 * 
		 * Private Function
		 */
		function applyProjection(projection, doc) {
			var result = {};
			var keys = Object.keys(projection);
			if (keys.length==0) return doc;
			else if (projection[keys[0]]) {
				// inclusion with _id
				result._id = doc._id;
				for (var i=0 ; i<keys.length ; i++) {
					if (!projection[keys[i]]) throw { $err: "Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.", code: 17287 };
					result[keys[i]] = doc[keys[i]];
				}
			} else {
				// exclusion
				for (var key in doc) {
					result[key] = doc[key];
				}
				for (var i=0 ; i<keys.length ; i++) {
					if (projection[keys[i]]) throw { $err: "Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.", code: 17287 };
					delete result[keys[i]];
				}
			}
			return result;
		} // MongoLocalDB.DB.applyProjection

		/**
		 * MongoLocalDB.DB.applyUpdates
		 * 
		 * Private Function
		 */
		// TODO support dot notation eg: "metrics.orders" and '$'
		function applyUpdates(updates,doc,setOnInsert) {
			var keys = Object.keys(updates);
			for (var i=0 ; i<keys.length ; i++) {
				var key = keys[i];
				var value = updates[key];
				if (key=="$inc") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var amount = value[field];
						doc[field] = doc[field] + amount;
					}
				} else if (key=="$mul") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var amount = value[field];
						doc[field] = doc[field] * amount;
					}
				} else if (key=="$rename") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var newName = value[field];
						doc[newName] = doc[field];
						delete doc[field];
					}
				} else if (key=="$setOnInsert" && setOnInsert) {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						doc[fields[j]] = value[fields[j]];
					}
				} else if (key=="$set") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						doc[fields[j]] = value[fields[j]];
					}
				} else if (key=="$unset") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						delete doc[fields[j]];
					}
				} else if (key=="$min") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var amount = value[field];
						doc[field] = Math.min(doc[field],amount);
					}
				} else if (key=="$max") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var amount = value[field];
						doc[field] = Math.max(doc[field],amount);
					}
				} else if (key=="$currentDate") {  // TODO not the same as mongo
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						doc[fields[j]] = new Date();
					}
				} else if (key=="$addToSet") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var value = value[field];
						doc[field].push(value);
					}
				} else if (key=="$pop") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var value = value[field];
						if (value==1) {
							doc[field].pop();
						} else if (value==-1) {
							doc[field].shift();
						}
					}
				} else if (key=="$pullAll") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var src = doc[fields[j]];
						var toRemove = value[fields[j]];
						var notRemoved = [];
						for (var k=0 ; k<src.length ; k++) {
							var removed = false;
							for (var l=0 ; l<toRemove.length ; l++) {
								if (src[k]==toRemove[l]) {
									removed = true;
									break;
								}
							}
							if (!removed) notRemoved.push(src[k]);
						}
						doc[fields[j]] = notRemoved;
					}
				} else if (key=="$pushAll") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						var values = value[field];
						for (var k=0 ; k<values.length ; k++) {
							doc[field].push(values[k]);
						}
					}
				} else if (key=="$push") {
					var fields = Object.keys(value);
					for (var j=0 ; j<fields.length ; j++) {
						var field = fields[j];
						doc[field].push(value[field]);
					}
				} else if (key=="$bit") {
					var field = Object.keys(value)[0];
					var operation = value[field];
					var operator = Object.keys(operation)[0];
					var operand = operation[operator];
					if (operator=="and") {
						doc[field] = doc[field] & operand;
					} else if (operator=="or") {
						doc[field] = doc[field] | operand;
					} else if (operator=="xor") {
						doc[field] = doc[field] ^ operand;
					} else {
						throw "unknown $bit operator: " + operator;
					}
				} else {
					throw "unknown update operator: " + key;
				}
			}
		} // MongoLocalDB.DB.applyUpdates

		/**
		 * MongoLocalDB.DB.createDocFromUpdate
		 * 
		 * Private Function
		 */
		function createDocFromUpdate(query,updates) {
			var newDoc = { _id : id() };
			var onlyFields = true;
			var updateKeys = Object.keys(updates);
			for (var i=0 ; i<updateKeys.length ; i++) {
				if (updateKeys[i].charAt(0)=="$") {
					onlyFields = false;
					break;
				}
			}
			if (onlyFields) {
				for (var i=0 ; i<updateKeys.length ; i++) {
					newDoc[updateKeys[i]] = updates[updateKeys[i]];
				}
			} else {
				var queryKeys = Object.keys(query);
				for (var i=0 ; i<queryKeys.length ; i++) {
					newDoc[queryKeys[i]] = query[queryKeys[i]];
				}  
				applyUpdates(updates,newDoc,true);
			}
			return newDoc;
		} // MongoLocalDB.DB.createDocFromUpdate


		/**
		 * MongoLocalDB.DB.Collection
		 * 
		 * Private Constructor Function 
		 */
		function Collection(db,storage) {

			/**
			 * MongoLocalDB.DB.Collection.Cursor
			 * 
			 * Private Constructor Function
			 */
			function Cursor(collection,query,projection) {
				var pos = 0;
				var max = 0;

				// false == unknown
				// null == no more
				// !null == next
				var next = false;

				function findNext() {
					while (pos<collection.count() && (max==0 || pos<max)) {
						var cur = storage.get(pos++);
						if (matches(cur,query)) {
							next = cur;
							return;
						}
					}
					next = null;
				}

				this.batchSize = function() { throw "Not Implemented"; };
				this.close = function() { throw "Not Implemented"; };
				this.comment = function() { throw "Not Implemented"; };
				this.count = function() {
					var num = 0;
					var c = new Cursor(collection,query);
					while (c.hasNext()) {
						num++;
						c.next();
					}
					return num;
				};
				this.explain = function() { throw "Not Implemented"; };
				this.forEach = function(fn) {
					while (this.hasNext()) {
						fn(this.next());
					}
				};
				this.hasNext = function() {
					if (next===false) findNext();
					return next != null;
				};
				this.hint = function() { throw "Not Implemented"; };
				this.itcount = function() { throw "Not Implemented"; };
				this.limit = function(_max) {
					max = _max;
					return this;
				};
				this.map = function(fn) {
					var results = [];
					while (this.hasNext()) {
						results.push(fn(this.next()));
					}
					return results;
				};
				this.maxScan = function() { throw "Not Implemented"; };
				this.maxTimeMS = function() { throw "Not Implemented"; };
				this.max = function() { throw "Not Implemented"; };
				this.min = function() { throw "Not Implemented"; };
				this.next = function() {
					if (next==null) throw "Error: error hasNext: false";
					var result = next;
					findNext();
					if (projection) return applyProjection(projection,result);
					else return result;
				};
				this.noCursorTimeout = function() { throw "Not Implemented"; };
				this.objsLeftInBatch = function() { throw "Not Implemented"; };
				this.pretty = function() { throw "Not Implemented"; };
				this.readConcern = function() { throw "Not Implemented"; };
				this.readPref = function() { throw "Not Implemented"; };
				this.returnKey = function() { throw "Not Implemented"; };
				this.showRecordId = function() { throw "Not Implemented"; };
				this.size = function() { throw "Not Implemented"; };
				this.skip = function(num) {
					while (num>0) {
						this.next();
						num--;
					}
					return this;
				};
				this.snapshot = function() { throw "Not Implemented"; };
				this.sort = function(s) {
					return new SortedCursor(collection,query,this,s);
				};
				this.tailable = function() { throw "Not Implemented"; };
				this.toArray = function() {
					var results = [];
					while (this.hasNext()) {
						results.push(this.next());
					}
					return results;
				};

				this.next();
			} // MongoLocalDB.DB.Collection.Cursor

			/**
			 * MongoLocalDB.DB.Collection.SortedCursor
			 * 
			 * Private Constructor Function
			 */
			function SortedCursor(collection,query,cursor,sort) {
				var pos = 0;
				var items = [];
				while (cursor.hasNext()) {
					items.push(cursor.next());
				}
				var sortKeys = Object.keys(sort);
				items.sort(function(a,b) {
					for (var i=0 ; i<sortKeys.length ; i++) {
						if (a[sortKeys[i]]==undefined && b[sortKeys[i]]!=undefined) return -1*sort[sortKeys[i]]; 
						if (a[sortKeys[i]]!=undefined && b[sortKeys[i]]==undefined) return  1*sort[sortKeys[i]]; 
						if (a[sortKeys[i]] < b[sortKeys[i]]) return -1*sort[sortKeys[i]];
						if (a[sortKeys[i]] > b[sortKeys[i]]) return 1*sort[sortKeys[i]];
					}
					return 0;
				});
				this.batchSize = function() { throw "Not Implemented"; };
				this.close = function() { throw "Not Implemented"; };
				this.comment  = function() { throw "Not Implemented"; };
				this.count = function() {
					return items.length;
				};
				this.explain = function() { throw "Not Implemented"; };
				this.forEach = function(fn) {
					while (this.hasNext()) {
						fn(this.next());
					}
				};
				this.hasNext = function() {
					return pos<items.length;
				};
				this.hint = function() { throw "Not Implemented"; };
				this.itcount = function() { throw "Not Implemented"; };
				this.limit = function(max) {
					items = items.slice(0,max);
					return this;
				};
				this.map = function(fn) {
					var results = [];
					while (this.hasNext()) {
						results.push(fn(this.next()));
					}
					return results;
				};
				this.maxScan = function() { throw "Not Implemented"; };
				this.maxTimeMS = function() { throw "Not Implemented"; };
				this.max = function() { throw "Not Implemented"; };
				this.min = function() { throw "Not Implemented"; };
				this.next = function() {
					return items[pos++];
				};
				this.noCursorTimeout = function() { throw "Not Implemented"; };
				this.objsLeftInBatch = function() { throw "Not Implemented"; };
				this.pretty = function() { throw "Not Implemented"; };
				this.readConcern = function() { throw "Not Implemented"; };
				this.readPref = function() { throw "Not Implemented"; };
				this.returnKey = function() { throw "Not Implemented"; };
				this.showRecordId = function() { throw "Not Implemented"; };
				this.size = function() { throw "Not Implemented"; };
				this.skip = function(num) {
					while (num>0) {
						this.next();
						num--;
					}
					return this;
				};
				this.snapshot = function() { throw "Not Implemented"; };
				this.sort = function(s) {
					return new SortedCursor(collection,query,this,s);
				};
				this.tailable = function() { throw "Not Implemented"; };
				this.toArray = function() {
					var results = [];
					while (this.hasNext()) {
						results.push(this.next());
					}
					return results;
				};
			} // MongoLocalDB.DB.Collection.SortedCursor

			/**
			 * MongoLocalDB.DB.Collection
			 * 
			 * Public Members
			 */
			return {
				isCollection : true, // TODO used by dropDatabase, ugly
				aggregate : function() { throw "Not Implemented"; },
				bulkWrite : function() { throw "Not Implemented"; },
				count : function() {
					return storage.size();
				},
				copyTo : function(destCollectionName) {
					if (!db[destCollectionName]) {
						db.createCollection(destCollectionName);
					}
					var destCol = db[destCollectionName];
					var numCopied = 0;
					var c = this.find({});
					while (c.hasNext()) {
						destCol.insertOne(c.next());
						numCopied++;
					}
					return numCopied;
				},
				createIndex : function() { throw "Not Implemented"; },
				dataSize : function() { throw "Not Implemented"; },
				deleteOne : function(query) {
					var doc = this.findOne(query);
					if (doc) {
						storage.remove(doc._id);
						return { deletedCount : 1 };
					} else {
						return { deletedCount : 0 };
					}
				},
				deleteMany : function(query) {
					var c = this.find(query);
					var ids = [];
					while (c.hasNext()) {
						ids.push(c.next()._id);
					}
					var deletedCount = ids.length;
					for (var i=0 ; i<ids.length ; i++) {
						storage.remove(ids[i]);
					}
					return { deletedCount : deletedCount };
				},
				distinct : function(field,query) {
					var vals = {};
					var c = this.find(query);
					while (c.hasNext()) {
						var d = c.next();
						if (d[field]) {
							vals[d[field]] = true;
						}
					}
					return Object.keys(vals);
				},
				drop : function() {
					storage.clear();
				},
				dropIndex : function() { throw "Not Implemented"; },
				dropIndexes : function() { throw "Not Implemented"; },
				ensureIndex : function() { throw "Not Implemented"; },
				explain : function() { throw "Not Implemented"; },
				find : function(query,projection) {
					return new Cursor(this,(query==undefined?{}:query),projection)
				},
				findAndModify : function() { throw "Not Implemented"; },
				findOne : function(query,projection) {
					var cursor = this.find(query,projection);
					if (cursor.hasNext()) {
						return cursor.next();
					} else {
						return null;
					}
				},
				findOneAndDelete : function(filter,options) {
					var c = this.find(filter);
					if (options && options.sort) c = c.sort(options.sort);
					if (!c.hasNext()) return null;
					var doc = c.next();
					storage.remove(doc._id);
					if (options && options.projection) return applyProjection(options.projection,doc);
					else return doc;
				},
				findOneAndReplace : function(filter,replacement,options) {
					var c = this.find(filter);
					if (options && options.sort) c = c.sort(options.sort);
					if (!c.hasNext()) return null;
					var doc = c.next();
					replacement._id = doc._id;
					storage.set(doc._id,replacement);
					if (options && options.returnNewDocument) doc = replacement;
					if (options && options.projection) return applyProjection(options.projection,doc);
					else return doc;
				},
				findOneAndUpdate : function(filter,update,options) {
					var c = this.find(filter);
					if (options && options.sort) c = c.sort(options.sort);
					if (!c.hasNext()) return null;
					var doc = c.next();
					var clone = Object.assign({},doc);
					applyUpdates(update,clone);
					storage.set(doc._id,clone);
					if (options && options.returnNewDocument) doc = clone;
					if (options && options.projection) return applyProjection(options.projection,doc);
					else return doc;
				},
				getIndexes : function() { throw "Not Implemented"; },
				getShardDistribution : function() { throw "Not Implemented"; },
				getShardVersion : function() { throw "Not Implemented"; },
				// non-mongo
				getStore : function() {
					return storage.getStore();
				},
				group : function() { throw "Not Implemented"; },
				insert : function(doc) {
					if (Array == doc.constructor) {
						this.insertMany(doc);
					} else {
						this.insertOne(doc);
					}
				},
				insertOne : function(doc) {
					if (doc._id==undefined) doc._id = id();
					storage.set(doc._id,doc);
				},
				insertMany : function(docs) {
					for (var i=0 ; i<docs.length ; i++) {
						this.insertOne(docs[i]);
					}
				},
				isCapped : function() { throw "Not Implemented"; },
				mapReduce : function() { throw "Not Implemented"; },
				reIndex : function() { throw "Not Implemented"; },
				replaceOne : function(query,replacement,options) { // only replace
					// first
					var result = {};
					var c = this.find(query);
					result.matchedCount = c.count();
					if (result.matchedCount==0) {
						result.modifiedCount = 0;
						if (options && options.upsert) {
							replacement._id = id();
							storage.set(replacement._id,replacement);
							result.upsertedId = replacement._id;
						}
					} else {
						result.modifiedCount = 1;
						var doc = c.next();
						replacement._id = doc._id;
						storage.set(doc._id,replacement);
					}
					return result;
				},
				remove : function(query,options) {
					var c = this.find(query);
					if (!c.hasNext()) return;
					if (options===true || (options && options.justOne)) {
						var doc = c.next();
						storage.remove(doc._id);
					} else {
						while (c.hasNext()) {
							storage.remove(c.next()._id);
						}
					}
				},
				renameCollection : function() { throw "Not Implemented"; },
				save : function() { throw "Not Implemented"; },
				stats : function() { throw "Not Implemented"; },
				storageSize : function() { throw "Not Implemented"; },
				totalSize : function() { throw "Not Implemented"; },
				totalIndexSize : function() { throw "Not Implemented"; },
				update : function(query,updates,options) {
					var c = this.find(query);
					if (c.hasNext()) {
						if (options && options.multi) {
							while (c.hasNext()) {
								var doc = c.next();
								applyUpdates(updates,doc);
								storage.set(doc._id,doc);
							}
						} else {
							var doc = c.next();
							applyUpdates(updates,doc);
							storage.set(doc._id,doc);
						}
					} else {
						if (options && options.upsert) {
							var doc = createDocFromUpdate(query,updates);
							storage.set(doc._id,doc);
						}
					}
				},
				updateOne : function(query,updates,options) {
					var c = this.find(query);
					if (c.hasNext()) {
						var doc = c.next();
						applyUpdates(updates,doc);
						storage.set(doc._id,doc);
					} else {
						if (options && options.upsert) {
							var doc = createDocFromUpdate(query,updates);
							storage.set(doc._id,doc);
						}
					}
				},
				updateMany : function(query,updates,options) {
					var c = this.find(query);
					if (c.hasNext()) {
						while (c.hasNext()) {
							var doc = c.next();
							applyUpdates(updates,doc);
							storage.set(doc._id,doc);
						}
					} else {
						if (options && options.upsert) {
							var doc = createDocFromUpdate(query,updates);
							storage.set(doc._id,doc);
						}
					}
				},
				validate : function() { throw "Not Implemented"; }
			}; // MongoLocalDB.DB.Collection return
		}
		/**
		 * MongoLocalDB.DB
		 * 
		 * Public Members
		 */
		return {
			cloneCollection : function() { throw "Not Implemented"; },
			cloneDatabase : function() { throw "Not Implemented"; },
			commandHelp : function() { throw "Not Implemented"; },
			copyDatabase : function() { throw "Not Implemented"; },
			createCollection : function(name) {
				if (!name) return;
				if (name=="localStorage") this.localStorage = new Collection(this,(options.localStorage?options.localStorage:LocalStorageStore));
				else this[name] = new Collection(this,(options && options.storage?new options.storage():new ObjectStore()));
			},
			currentOp : function() { throw "Not Implemented"; },
			dropDatabase : function() {
				for (var key in this) {
					if (this[key]!=null && this[key].isCollection) {
						this[key].drop(); // drop the contents
						delete this[key];
					}
				}
			},
			eval : function() { throw "Not Implemented"; },
			fsyncLock : function() { throw "Not Implemented"; },
			fsyncUnlock : function() { throw "Not Implemented"; },
			getCollection : function() { throw "Not Implemented"; },
			getCollectionInfos : function() { throw "Not Implemented"; },
			getCollectionNames : function() {
				var names = [];
				for (var key in this) {
					if (this[key]!=null && this[key].isCollection) {
						names.push(key);
					}
				}
				return names;
			},
			getLastError : function() { throw "Not Implemented"; },
			getLastErrorObj : function() { throw "Not Implemented"; },
			getLogComponents : function() { throw "Not Implemented"; },
			getMongo : function() { throw "Not Implemented"; },
			getName : function() { throw "Not Implemented"; },
			getPrevError : function() { throw "Not Implemented"; },
			getProfilingLevel : function() { throw "Not Implemented"; },
			getProfilingStatus : function() { throw "Not Implemented"; },
			getReplicationInfo : function() { throw "Not Implemented"; },
			getSiblingDB : function() { throw "Not Implemented"; },
			help : function() {
				log("        help mr                      mapreduce");
				log("        db.foo.find()                list objects in collection foo");
				log("        db.foo.find( { a : 1 } )     list objects in foo where a == 1");
				log("        it                           result of the last line evaluated; use to further iterate");
			},
			hostInfo : function() { throw "Not Implemented"; },
			isMaster : function() { throw "Not Implemented"; },
			killOp : function() { throw "Not Implemented"; },
			listCommands : function() { throw "Not Implemented"; },
			loadServerScripts : function() { throw "Not Implemented"; },
			localStorage : (typeof localStorage!="undefined"?new Collection(this,LocalStorageStore):null),
			logout : function() { throw "Not Implemented"; },
			printCollectionStats : function() { throw "Not Implemented"; },
			printReplicationInfo : function() { throw "Not Implemented"; },
			printShardingStatus : function() { throw "Not Implemented"; },
			printSlaveReplicationInfo : function() { throw "Not Implemented"; },
			repairDatabase : function() { throw "Not Implemented"; },
			resetError : function() { throw "Not Implemented"; },
			runCommand : function() { throw "Not Implemented"; },
			serverBuildInfo : function() { throw "Not Implemented"; },
			serverCmdLineOpts : function() { throw "Not Implemented"; },
			serverStatus : function() { throw "Not Implemented"; },
			setLogLevel : function() { throw "Not Implemented"; },
			setProfilingLevel : function() { throw "Not Implemented"; },
			shutdownServer : function() { throw "Not Implemented"; },
			stats : function() { throw "Not Implemented"; },
			version : function() { throw "Not Implemented"; },
			upgradeCheck : function() { throw "Not Implemented"; },
			upgradeCheckAllDBs : function() { throw "Not Implemented"; }
		}; // MongoLocalDB.DB return

	}

	// Could be in ticks so that we can have \n's but we dont want template
	// replacements so using double quotes (escape double quotes and new lines)
	// https://gist.github.com/getify/3667624
	function qouted(str) {
		if (str===undefined) return `""`
		str = str.replaceAll('\r','');
		str = str.replace(/\\([\s\S])|(")/g,"\\$1$2");
		str = str.replace(/\\([\s\S])|(\n)/g,"\\$1$2");
	    return `"${str}"`
	}

	function escape(s) {
	    if (s===undefined) return ''
	    return s.replaceAll('\\','\\\\').replaceAll('\`','\\\`').replaceAll('\\\\$','\\$')
	}

	function stringifyArgsObj(obj) {

	    let s = '{';
	    let first = true;
	    for (const [key, value] of Object.entries(obj)) {

	        if (first) {
	            first = false;
	        } else {
	            s += ',';
	        }

	        if (key == 'args') {
	            s += `"${key}":${value}`;
	        } else if (value === undefined) {
	            s += `"${key}":undefined`;
	        } else if (value == null) {
	            s += `"${key}":null`;
	        } else if (Array.isArray(value)) {
	            s += `"${key}":${stringifyA(value)}`;
	        } else if (typeof value === 'object') {
	            s += `"${key}":${stringifyO(value)}`;
	        } else if (typeof value === 'string') {
	            s += `"${key}":${'`'+escape(value)+'`'}`;
	        } else {
	            s += `"${key}":${JSON.stringify(value)}`;
	        }
	    }
	    s += '}';
	    return s
	}

	function stringifyInclude(obj) {
	    return `include(${stringifyArgsObj(obj)})`
	}

	function stringifyInlineTag(obj) {
	    return `inlineTag(${stringifyArgsObj(obj)})`
	}

	function stringifyYaml(obj) {
	    let s = '{';
	    let first = true;
	    for (const [key, value] of Object.entries(obj)) {

	        if (first) {
	            first = false;
	        } else {
	            s += ',';
	        }

	        if (key == 'value') {
	            s += `"${key}":${value}`;
	        } else if (value === undefined) {
	            s += `"${key}":undefined`;
	        } else if (value == null) {
	            s += `"${key}":null`;
	        } else if (Array.isArray(value)) {
	            s += `"${key}":${stringifyA(value)}`;
	        } else if (typeof value === 'object') {
	            s += `"${key}":${stringifyO(value)}`;
	        } else if (typeof value === 'string') {
	            s += `"${key}":${'`'+escape(value)+'`'}`;
	        } else {
	            s += `"${key}":${JSON.stringify(value)}`;
	        }
	    }
	    s += '}';
	    return s
	}

	function stringifyYamlLine(obj) {

	    let s = '{';
	    let first = true;
	    for (const [key, value] of Object.entries(obj)) {

	        if (first) {
	            first = false;
	        } else {
	            s += ',';
	        }

	        if (key == 'type' || key == 'name') {
	            s += `"${key}":"${value}"`;
	        } else if (key == 'yaml') {
	            s += `"${key}":${stringifyYaml(value)}`;
	        } else if (key == 'value') {
	            s += `"${key}":${value}`;
	        } else if (value === undefined) {
	            s += `"${key}":undefined`;
	        } else if (value == null) {
	            s += `"${key}":null`;
	        } else if (Array.isArray(value)) {
	            s += `"${key}":${stringifyA(value)}`;
	        } else if (typeof value === 'object') {
	            s += `"${key}":${stringifyO(value)}`;
	        } else if (typeof value === 'string') {
	            s += `"${key}":${'`'+escape(value)+'`'}`;
	        } else {
	            s += `"${key}":${JSON.stringify(value)}`;
	        }
	    }
	    s += '}';
	    return s
	}

	function stringifyMaybeYaml(obj) {
	    return `maybeYaml(${stringifyYamlLine(obj)})\n`
	}

	function stringify$2(obj) {

	    if (obj === undefined) {
	        return 'undefined'
	    } else if (obj == null) {
	        return 'null'
	    }

	    if (obj.type !== undefined) {
	        if (obj.type == 'tag') {
	            delete obj.type;
	            return stringifyInlineTag(obj)
	        } else if (obj.type == 'include') {
	            delete obj.type;
	            return stringifyInclude(obj)
	        }
	    }

	    if (Array.isArray(obj)) {
	        return stringifyA(obj)
	    } else if (typeof obj === 'object') {
	        return stringifyO(obj)
	    } else if (typeof obj === 'string') {
	        return `\`${escape(obj)}\``
	    } else {
	        return JSON.stringify(obj)
	    }

	}

	function stringifyO(obj) {

	    let s = '{';
	    let first = true;
	    for (const [key, value] of Object.entries(obj)) {

	        if (first) {
	            first = false;
	        } else {
	            s += ',';
	        }

	        if (value === undefined) {
	            s += `"${key}":undefined`;
	        } else if (value == null) {
	            s += `"${key}":null`;
	        } else if (Array.isArray(value)) {
	            s += `"${key}":${stringifyA(value)}`;
	        } else if (typeof value === 'object') {
	            s += `"${key}":${stringifyO(value)}`;
	        } else if (typeof value === 'string' && key == 'value') {
	            s += `"${key}":${'template(() => `'+escape(value)+'`)'}`;
	        } else {
	            s += `"${key}":${JSON.stringify(value)}`;
	        }
	    }
	    s += '}';
	    return s
	}

	function stringifyA(arr) {

	    let s = '[';
	    for (let i=0 ; i<arr.length ; i++) {
	        if (i>0) {
	            s += ',';
	        }
	        s += stringify$2(arr[i]);
	    }
	    s += ']';
	    return s

	}

	function jsPreCode() {
	    return `
const request = arguments[0]
const response = arguments[1]

const db = response.db

const h = response.libs.h
const t = response.libs.t
const matches = response.libs.matches
const select = response.libs.select
const selectAll = response.libs.selectAll
const processHast = response.libs.processHast

let json = response.json

const maybeYaml = response.libs.maybeYaml
const inlineTag = response.libs.inlineTag
const template = response.libs.template
const addTask = response.libs.addTask
const appendToHtml = response.libs.appendToHtml
const include = response.libs.include

`
	}

	function sxastToDebugJs(sxast) {

	    let out = '';

	    for (let i=0 ; i<sxast.length ; i++) {
	        let ln = sxast[i];
	        if (ln.type == 'script') {
	            out += ln.code + '\n';
	        } else if (ln.type == 'yaml') {
	            out += stringifyMaybeYaml(ln); // `maybeYaml(${ stringify(ln) })\n`
	        } else if (ln.type == 'unordered-list-item' && ln.yaml !== undefined) {
	            out += stringifyMaybeYaml(ln); // `maybeYaml(${ stringify(ln) })\n`
	        } else {
	            out += `appendToHtml(${ stringify$2(ln) })\n`;

	            if ((ln.type == 'ordered-list-item' || ln.type == 'unordered-list-item') && ln.task) {
	                out += `addTask(${stringify$2(ln.task)})\n`;
	            }
	        }
	    }

	    return out
	}

	function sxastToJs(collection,name,sxast) {

	    let out = jsPreCode();

	    out += 'try {\n';
	    out += '\n';

	    for (let i=0 ; i<sxast.length ; i++) {
	        let ln = sxast[i];
	        if (ln.type == 'script') {
	            out += ln.code + '\n';
	        } else if (ln.type == 'yaml') {
	            out += stringifyMaybeYaml(ln); // `maybeYaml(${ stringify(ln) })\n`
	        } else if (ln.type == 'unordered-list-item' && ln.yaml !== undefined) {
	            out += stringifyMaybeYaml(ln); // `maybeYaml(${ stringify(ln) })\n`
	        } else {
	            out += `appendToHtml(${ stringify$2(ln) })\n`;

	            if ((ln.type == 'ordered-list-item' || ln.type == 'unordered-list-item') && ln.task) {
	                out += `addTask(${stringify$2(ln.task)})\n`;
	            }
	        }
	    }

	    out += '\n';
	    out += '} catch (e) {\n';
	// out += 'console.log("==================")\n'
	// out += 'console.log(e)\n'
	    out += '  let errLine,errColumn,errMsg\n';
	    out += '  if (e.stack == undefined) {\n';
	    out += '    errLine = 0\n';
	    out += '    errColumn = 0\n';
	    out += '    errMsg = JSON.stringify(e)\n';
	    out += '  } else {\n';
	    out += '    let m = e.stack.match(/<anonymous>:([0-9]+):([0-9]+)/)\n';
	    out += '    if (m) {\n';
	                    // nodejs
	    out += '      errLine = m[1] - 27\n';
	    out += '      errColumn = m[2] - 1\n';
	    out += `      errMsg = e.stack.split('\\n')[0]\n`;
	    out += '    } else {\n';
	                    // browser
	    out += '      errLine = 0\n';
	    out += '      errColumn = 0\n';
	    out += `      errMsg = e.message\n`;
	    out += '    }\n';
	    out += '  }\n';
	// out += 'console.log(errLine,errColumn,errMsg)\n'
	    out += `  let uline = ''\n`;
	    out += `  for (let i=0 ; i<errColumn ; i++) uline += ' ';\n`;
	    out += '  const lines = []\n';

	    for (let i=0 ; i<sxast.length ; i++) {
	        let ln = sxast[i];
	        out += `  lines.push( () => appendToHtml({type: 'paragraph', indent: 1, text: ${qouted('  '+ln.text)} }) )\n`;
	    }

	    out += `  appendToHtml({type: 'div', indent: 0, tag: 'pre' })\n`;

	    out += `  for (let i=0 ; i<lines.length ; i++) {\n`;
	    out += '    lines[i]()\n';
	    out += '    if (i==errLine) {\n';
	    out += `      appendToHtml({ type: 'paragraph', indent: 1, text: '  '+uline+'^' })\n`;
	    out += `      appendToHtml({ type: 'paragraph', indent: 1, text: '  '+uline+errMsg })\n`;
	    out += '    }\n';
	    out += '  }\n';

	    out += '  throw e\n';

	    out += '}\n';      
	    
	    return out
	}

	function sxastToTextJs(collection,name,sxast,error) {

	    let out = jsPreCode();

	    out += `appendToHtml({type: 'div', indent: 0, tag: 'pre' })\n`;
	    for (let i=0 ; i<sxast.length ; i++) {
	        let ln = sxast[i];

	        out += `appendToHtml({type: 'paragraph', indent: 1, text: ${qouted('  '+ln.text)}})\n`;
	        if (i == error.errorLine - 1) {
	            let uline = '';
	            for (let i=0 ; i<error.errorColumn ; i++) uline += ' ';

	            out += `appendToHtml({type: 'paragraph', indent: 1, text: ${qouted('  '+uline+'^')} })\n`;
	            out += `appendToHtml({type: 'paragraph', indent: 1, text: ${qouted('  '+uline+error.errorMessage)} })\n`;
	        }
	    }

	    return out
	}

	let isPrimitive = (val) => {
	    
	  if ( val === Object(val) ) {
	    return false
	  } else {
	    return true
	  }
	};

	let handler$1 = {
	    has(target, property) {
	        return Reflect.has(...arguments);
	    },
	    get(target, property, receiver) {
	        if (property in target) {
	            let value = target[property];
	            if (typeof value === 'object' && value === Object(value)) {
	                return new Proxy(value,handler$1);
	            } else {
	                return value
	            }
	        } else if (isPrimitive(property)) {
	            return target[property]
	        } else {
	            return `${property} not set`
	        }
	        //   return Reflect.get(...arguments);
	    },
	    set(target, property, value, receiver) {
	    }
	};

	class SqrmRequest {

	    constructor(args = []) {
	        this.args = new Proxy(args,handler$1) ;
	    }
	}

	/**
	 * @typedef {import('./info.js').Info} Info
	 * @typedef {Record<string, Info>} Properties
	 * @typedef {Record<string, string>} Normal
	 */

	class Schema {
	  /**
	   * @constructor
	   * @param {Properties} property
	   * @param {Normal} normal
	   * @param {string} [space]
	   */
	  constructor(property, normal, space) {
	    this.property = property;
	    this.normal = normal;
	    if (space) {
	      this.space = space;
	    }
	  }
	}

	/** @type {Properties} */
	Schema.prototype.property = {};
	/** @type {Normal} */
	Schema.prototype.normal = {};
	/** @type {string|null} */
	Schema.prototype.space = null;

	/**
	 * @typedef {import('./schema.js').Properties} Properties
	 * @typedef {import('./schema.js').Normal} Normal
	 */

	/**
	 * @param {Schema[]} definitions
	 * @param {string} [space]
	 * @returns {Schema}
	 */
	function merge(definitions, space) {
	  /** @type {Properties} */
	  const property = {};
	  /** @type {Normal} */
	  const normal = {};
	  let index = -1;

	  while (++index < definitions.length) {
	    Object.assign(property, definitions[index].property);
	    Object.assign(normal, definitions[index].normal);
	  }

	  return new Schema(property, normal, space)
	}

	/**
	 * @param {string} value
	 * @returns {string}
	 */
	function normalize(value) {
	  return value.toLowerCase()
	}

	class Info {
	  /**
	   * @constructor
	   * @param {string} property
	   * @param {string} attribute
	   */
	  constructor(property, attribute) {
	    /** @type {string} */
	    this.property = property;
	    /** @type {string} */
	    this.attribute = attribute;
	  }
	}

	/** @type {string|null} */
	Info.prototype.space = null;
	Info.prototype.boolean = false;
	Info.prototype.booleanish = false;
	Info.prototype.overloadedBoolean = false;
	Info.prototype.number = false;
	Info.prototype.commaSeparated = false;
	Info.prototype.spaceSeparated = false;
	Info.prototype.commaOrSpaceSeparated = false;
	Info.prototype.mustUseProperty = false;
	Info.prototype.defined = false;

	let powers = 0;

	const boolean = increment();
	const booleanish = increment();
	const overloadedBoolean = increment();
	const number = increment();
	const spaceSeparated = increment();
	const commaSeparated = increment();
	const commaOrSpaceSeparated = increment();

	function increment() {
	  return 2 ** ++powers
	}

	var types$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		boolean: boolean,
		booleanish: booleanish,
		overloadedBoolean: overloadedBoolean,
		number: number,
		spaceSeparated: spaceSeparated,
		commaSeparated: commaSeparated,
		commaOrSpaceSeparated: commaOrSpaceSeparated
	});

	/** @type {Array<keyof types>} */
	// @ts-expect-error: hush.
	const checks = Object.keys(types$2);

	class DefinedInfo extends Info {
	  /**
	   * @constructor
	   * @param {string} property
	   * @param {string} attribute
	   * @param {number|null} [mask]
	   * @param {string} [space]
	   */
	  constructor(property, attribute, mask, space) {
	    let index = -1;

	    super(property, attribute);

	    mark(this, 'space', space);

	    if (typeof mask === 'number') {
	      while (++index < checks.length) {
	        const check = checks[index];
	        mark(this, checks[index], (mask & types$2[check]) === types$2[check]);
	      }
	    }
	  }
	}

	DefinedInfo.prototype.defined = true;

	/**
	 * @param {DefinedInfo} values
	 * @param {string} key
	 * @param {unknown} value
	 */
	function mark(values, key, value) {
	  if (value) {
	    // @ts-expect-error: assume `value` matches the expected value of `key`.
	    values[key] = value;
	  }
	}

	/**
	 * @typedef {import('./schema.js').Properties} Properties
	 * @typedef {import('./schema.js').Normal} Normal
	 *
	 * @typedef {Record<string, string>} Attributes
	 *
	 * @typedef {Object} Definition
	 * @property {Record<string, number|null>} properties
	 * @property {(attributes: Attributes, property: string) => string} transform
	 * @property {string} [space]
	 * @property {Attributes} [attributes]
	 * @property {Array<string>} [mustUseProperty]
	 */

	const own$7 = {}.hasOwnProperty;

	/**
	 * @param {Definition} definition
	 * @returns {Schema}
	 */
	function create(definition) {
	  /** @type {Properties} */
	  const property = {};
	  /** @type {Normal} */
	  const normal = {};
	  /** @type {string} */
	  let prop;

	  for (prop in definition.properties) {
	    if (own$7.call(definition.properties, prop)) {
	      const value = definition.properties[prop];
	      const info = new DefinedInfo(
	        prop,
	        definition.transform(definition.attributes || {}, prop),
	        value,
	        definition.space
	      );

	      if (
	        definition.mustUseProperty &&
	        definition.mustUseProperty.includes(prop)
	      ) {
	        info.mustUseProperty = true;
	      }

	      property[prop] = info;

	      normal[normalize(prop)] = prop;
	      normal[normalize(info.attribute)] = prop;
	    }
	  }

	  return new Schema(property, normal, definition.space)
	}

	const xlink = create({
	  space: 'xlink',
	  transform(_, prop) {
	    return 'xlink:' + prop.slice(5).toLowerCase()
	  },
	  properties: {
	    xLinkActuate: null,
	    xLinkArcRole: null,
	    xLinkHref: null,
	    xLinkRole: null,
	    xLinkShow: null,
	    xLinkTitle: null,
	    xLinkType: null
	  }
	});

	const xml = create({
	  space: 'xml',
	  transform(_, prop) {
	    return 'xml:' + prop.slice(3).toLowerCase()
	  },
	  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}
	});

	/**
	 * @param {Record<string, string>} attributes
	 * @param {string} attribute
	 * @returns {string}
	 */
	function caseSensitiveTransform(attributes, attribute) {
	  return attribute in attributes ? attributes[attribute] : attribute
	}

	/**
	 * @param {Record<string, string>} attributes
	 * @param {string} property
	 * @returns {string}
	 */
	function caseInsensitiveTransform(attributes, property) {
	  return caseSensitiveTransform(attributes, property.toLowerCase())
	}

	const xmlns = create({
	  space: 'xmlns',
	  attributes: {xmlnsxlink: 'xmlns:xlink'},
	  transform: caseInsensitiveTransform,
	  properties: {xmlns: null, xmlnsXLink: null}
	});

	const aria = create({
	  transform(_, prop) {
	    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
	  },
	  properties: {
	    ariaActiveDescendant: null,
	    ariaAtomic: booleanish,
	    ariaAutoComplete: null,
	    ariaBusy: booleanish,
	    ariaChecked: booleanish,
	    ariaColCount: number,
	    ariaColIndex: number,
	    ariaColSpan: number,
	    ariaControls: spaceSeparated,
	    ariaCurrent: null,
	    ariaDescribedBy: spaceSeparated,
	    ariaDetails: null,
	    ariaDisabled: booleanish,
	    ariaDropEffect: spaceSeparated,
	    ariaErrorMessage: null,
	    ariaExpanded: booleanish,
	    ariaFlowTo: spaceSeparated,
	    ariaGrabbed: booleanish,
	    ariaHasPopup: null,
	    ariaHidden: booleanish,
	    ariaInvalid: null,
	    ariaKeyShortcuts: null,
	    ariaLabel: null,
	    ariaLabelledBy: spaceSeparated,
	    ariaLevel: number,
	    ariaLive: null,
	    ariaModal: booleanish,
	    ariaMultiLine: booleanish,
	    ariaMultiSelectable: booleanish,
	    ariaOrientation: null,
	    ariaOwns: spaceSeparated,
	    ariaPlaceholder: null,
	    ariaPosInSet: number,
	    ariaPressed: booleanish,
	    ariaReadOnly: booleanish,
	    ariaRelevant: null,
	    ariaRequired: booleanish,
	    ariaRoleDescription: spaceSeparated,
	    ariaRowCount: number,
	    ariaRowIndex: number,
	    ariaRowSpan: number,
	    ariaSelected: booleanish,
	    ariaSetSize: number,
	    ariaSort: null,
	    ariaValueMax: number,
	    ariaValueMin: number,
	    ariaValueNow: number,
	    ariaValueText: null,
	    role: null
	  }
	});

	const html$3 = create({
	  space: 'html',
	  attributes: {
	    acceptcharset: 'accept-charset',
	    classname: 'class',
	    htmlfor: 'for',
	    httpequiv: 'http-equiv'
	  },
	  transform: caseInsensitiveTransform,
	  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
	  properties: {
	    // Standard Properties.
	    abbr: null,
	    accept: commaSeparated,
	    acceptCharset: spaceSeparated,
	    accessKey: spaceSeparated,
	    action: null,
	    allow: null,
	    allowFullScreen: boolean,
	    allowPaymentRequest: boolean,
	    allowUserMedia: boolean,
	    alt: null,
	    as: null,
	    async: boolean,
	    autoCapitalize: null,
	    autoComplete: spaceSeparated,
	    autoFocus: boolean,
	    autoPlay: boolean,
	    capture: boolean,
	    charSet: null,
	    checked: boolean,
	    cite: null,
	    className: spaceSeparated,
	    cols: number,
	    colSpan: null,
	    content: null,
	    contentEditable: booleanish,
	    controls: boolean,
	    controlsList: spaceSeparated,
	    coords: number | commaSeparated,
	    crossOrigin: null,
	    data: null,
	    dateTime: null,
	    decoding: null,
	    default: boolean,
	    defer: boolean,
	    dir: null,
	    dirName: null,
	    disabled: boolean,
	    download: overloadedBoolean,
	    draggable: booleanish,
	    encType: null,
	    enterKeyHint: null,
	    form: null,
	    formAction: null,
	    formEncType: null,
	    formMethod: null,
	    formNoValidate: boolean,
	    formTarget: null,
	    headers: spaceSeparated,
	    height: number,
	    hidden: boolean,
	    high: number,
	    href: null,
	    hrefLang: null,
	    htmlFor: spaceSeparated,
	    httpEquiv: spaceSeparated,
	    id: null,
	    imageSizes: null,
	    imageSrcSet: null,
	    inputMode: null,
	    integrity: null,
	    is: null,
	    isMap: boolean,
	    itemId: null,
	    itemProp: spaceSeparated,
	    itemRef: spaceSeparated,
	    itemScope: boolean,
	    itemType: spaceSeparated,
	    kind: null,
	    label: null,
	    lang: null,
	    language: null,
	    list: null,
	    loading: null,
	    loop: boolean,
	    low: number,
	    manifest: null,
	    max: null,
	    maxLength: number,
	    media: null,
	    method: null,
	    min: null,
	    minLength: number,
	    multiple: boolean,
	    muted: boolean,
	    name: null,
	    nonce: null,
	    noModule: boolean,
	    noValidate: boolean,
	    onAbort: null,
	    onAfterPrint: null,
	    onAuxClick: null,
	    onBeforePrint: null,
	    onBeforeUnload: null,
	    onBlur: null,
	    onCancel: null,
	    onCanPlay: null,
	    onCanPlayThrough: null,
	    onChange: null,
	    onClick: null,
	    onClose: null,
	    onContextLost: null,
	    onContextMenu: null,
	    onContextRestored: null,
	    onCopy: null,
	    onCueChange: null,
	    onCut: null,
	    onDblClick: null,
	    onDrag: null,
	    onDragEnd: null,
	    onDragEnter: null,
	    onDragExit: null,
	    onDragLeave: null,
	    onDragOver: null,
	    onDragStart: null,
	    onDrop: null,
	    onDurationChange: null,
	    onEmptied: null,
	    onEnded: null,
	    onError: null,
	    onFocus: null,
	    onFormData: null,
	    onHashChange: null,
	    onInput: null,
	    onInvalid: null,
	    onKeyDown: null,
	    onKeyPress: null,
	    onKeyUp: null,
	    onLanguageChange: null,
	    onLoad: null,
	    onLoadedData: null,
	    onLoadedMetadata: null,
	    onLoadEnd: null,
	    onLoadStart: null,
	    onMessage: null,
	    onMessageError: null,
	    onMouseDown: null,
	    onMouseEnter: null,
	    onMouseLeave: null,
	    onMouseMove: null,
	    onMouseOut: null,
	    onMouseOver: null,
	    onMouseUp: null,
	    onOffline: null,
	    onOnline: null,
	    onPageHide: null,
	    onPageShow: null,
	    onPaste: null,
	    onPause: null,
	    onPlay: null,
	    onPlaying: null,
	    onPopState: null,
	    onProgress: null,
	    onRateChange: null,
	    onRejectionHandled: null,
	    onReset: null,
	    onResize: null,
	    onScroll: null,
	    onSecurityPolicyViolation: null,
	    onSeeked: null,
	    onSeeking: null,
	    onSelect: null,
	    onSlotChange: null,
	    onStalled: null,
	    onStorage: null,
	    onSubmit: null,
	    onSuspend: null,
	    onTimeUpdate: null,
	    onToggle: null,
	    onUnhandledRejection: null,
	    onUnload: null,
	    onVolumeChange: null,
	    onWaiting: null,
	    onWheel: null,
	    open: boolean,
	    optimum: number,
	    pattern: null,
	    ping: spaceSeparated,
	    placeholder: null,
	    playsInline: boolean,
	    poster: null,
	    preload: null,
	    readOnly: boolean,
	    referrerPolicy: null,
	    rel: spaceSeparated,
	    required: boolean,
	    reversed: boolean,
	    rows: number,
	    rowSpan: number,
	    sandbox: spaceSeparated,
	    scope: null,
	    scoped: boolean,
	    seamless: boolean,
	    selected: boolean,
	    shape: null,
	    size: number,
	    sizes: null,
	    slot: null,
	    span: number,
	    spellCheck: booleanish,
	    src: null,
	    srcDoc: null,
	    srcLang: null,
	    srcSet: null,
	    start: number,
	    step: null,
	    style: null,
	    tabIndex: number,
	    target: null,
	    title: null,
	    translate: null,
	    type: null,
	    typeMustMatch: boolean,
	    useMap: null,
	    value: booleanish,
	    width: number,
	    wrap: null,

	    // Legacy.
	    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
	    align: null, // Several. Use CSS `text-align` instead,
	    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
	    archive: spaceSeparated, // `<object>`. List of URIs to archives
	    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
	    background: null, // `<body>`. Use CSS `background-image` instead
	    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
	    border: number, // `<table>`. Use CSS `border-width` instead,
	    borderColor: null, // `<table>`. Use CSS `border-color` instead,
	    bottomMargin: number, // `<body>`
	    cellPadding: null, // `<table>`
	    cellSpacing: null, // `<table>`
	    char: null, // Several table elements. When `align=char`, sets the character to align on
	    charOff: null, // Several table elements. When `char`, offsets the alignment
	    classId: null, // `<object>`
	    clear: null, // `<br>`. Use CSS `clear` instead
	    code: null, // `<object>`
	    codeBase: null, // `<object>`
	    codeType: null, // `<object>`
	    color: null, // `<font>` and `<hr>`. Use CSS instead
	    compact: boolean, // Lists. Use CSS to reduce space between items instead
	    declare: boolean, // `<object>`
	    event: null, // `<script>`
	    face: null, // `<font>`. Use CSS instead
	    frame: null, // `<table>`
	    frameBorder: null, // `<iframe>`. Use CSS `border` instead
	    hSpace: number, // `<img>` and `<object>`
	    leftMargin: number, // `<body>`
	    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
	    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
	    lowSrc: null, // `<img>`. Use a `<picture>`
	    marginHeight: number, // `<body>`
	    marginWidth: number, // `<body>`
	    noResize: boolean, // `<frame>`
	    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
	    noShade: boolean, // `<hr>`. Use background-color and height instead of borders
	    noWrap: boolean, // `<td>` and `<th>`
	    object: null, // `<applet>`
	    profile: null, // `<head>`
	    prompt: null, // `<isindex>`
	    rev: null, // `<link>`
	    rightMargin: number, // `<body>`
	    rules: null, // `<table>`
	    scheme: null, // `<meta>`
	    scrolling: booleanish, // `<frame>`. Use overflow in the child context
	    standby: null, // `<object>`
	    summary: null, // `<table>`
	    text: null, // `<body>`. Use CSS `color` instead
	    topMargin: number, // `<body>`
	    valueType: null, // `<param>`
	    version: null, // `<html>`. Use a doctype.
	    vAlign: null, // Several. Use CSS `vertical-align` instead
	    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
	    vSpace: number, // `<img>` and `<object>`

	    // Non-standard Properties.
	    allowTransparency: null,
	    autoCorrect: null,
	    autoSave: null,
	    disablePictureInPicture: boolean,
	    disableRemotePlayback: boolean,
	    prefix: null,
	    property: null,
	    results: number,
	    security: null,
	    unselectable: null
	  }
	});

	const svg$1 = create({
	  space: 'svg',
	  attributes: {
	    accentHeight: 'accent-height',
	    alignmentBaseline: 'alignment-baseline',
	    arabicForm: 'arabic-form',
	    baselineShift: 'baseline-shift',
	    capHeight: 'cap-height',
	    className: 'class',
	    clipPath: 'clip-path',
	    clipRule: 'clip-rule',
	    colorInterpolation: 'color-interpolation',
	    colorInterpolationFilters: 'color-interpolation-filters',
	    colorProfile: 'color-profile',
	    colorRendering: 'color-rendering',
	    crossOrigin: 'crossorigin',
	    dataType: 'datatype',
	    dominantBaseline: 'dominant-baseline',
	    enableBackground: 'enable-background',
	    fillOpacity: 'fill-opacity',
	    fillRule: 'fill-rule',
	    floodColor: 'flood-color',
	    floodOpacity: 'flood-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    fontSizeAdjust: 'font-size-adjust',
	    fontStretch: 'font-stretch',
	    fontStyle: 'font-style',
	    fontVariant: 'font-variant',
	    fontWeight: 'font-weight',
	    glyphName: 'glyph-name',
	    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	    glyphOrientationVertical: 'glyph-orientation-vertical',
	    hrefLang: 'hreflang',
	    horizAdvX: 'horiz-adv-x',
	    horizOriginX: 'horiz-origin-x',
	    horizOriginY: 'horiz-origin-y',
	    imageRendering: 'image-rendering',
	    letterSpacing: 'letter-spacing',
	    lightingColor: 'lighting-color',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    navDown: 'nav-down',
	    navDownLeft: 'nav-down-left',
	    navDownRight: 'nav-down-right',
	    navLeft: 'nav-left',
	    navNext: 'nav-next',
	    navPrev: 'nav-prev',
	    navRight: 'nav-right',
	    navUp: 'nav-up',
	    navUpLeft: 'nav-up-left',
	    navUpRight: 'nav-up-right',
	    onAbort: 'onabort',
	    onActivate: 'onactivate',
	    onAfterPrint: 'onafterprint',
	    onBeforePrint: 'onbeforeprint',
	    onBegin: 'onbegin',
	    onCancel: 'oncancel',
	    onCanPlay: 'oncanplay',
	    onCanPlayThrough: 'oncanplaythrough',
	    onChange: 'onchange',
	    onClick: 'onclick',
	    onClose: 'onclose',
	    onCopy: 'oncopy',
	    onCueChange: 'oncuechange',
	    onCut: 'oncut',
	    onDblClick: 'ondblclick',
	    onDrag: 'ondrag',
	    onDragEnd: 'ondragend',
	    onDragEnter: 'ondragenter',
	    onDragExit: 'ondragexit',
	    onDragLeave: 'ondragleave',
	    onDragOver: 'ondragover',
	    onDragStart: 'ondragstart',
	    onDrop: 'ondrop',
	    onDurationChange: 'ondurationchange',
	    onEmptied: 'onemptied',
	    onEnd: 'onend',
	    onEnded: 'onended',
	    onError: 'onerror',
	    onFocus: 'onfocus',
	    onFocusIn: 'onfocusin',
	    onFocusOut: 'onfocusout',
	    onHashChange: 'onhashchange',
	    onInput: 'oninput',
	    onInvalid: 'oninvalid',
	    onKeyDown: 'onkeydown',
	    onKeyPress: 'onkeypress',
	    onKeyUp: 'onkeyup',
	    onLoad: 'onload',
	    onLoadedData: 'onloadeddata',
	    onLoadedMetadata: 'onloadedmetadata',
	    onLoadStart: 'onloadstart',
	    onMessage: 'onmessage',
	    onMouseDown: 'onmousedown',
	    onMouseEnter: 'onmouseenter',
	    onMouseLeave: 'onmouseleave',
	    onMouseMove: 'onmousemove',
	    onMouseOut: 'onmouseout',
	    onMouseOver: 'onmouseover',
	    onMouseUp: 'onmouseup',
	    onMouseWheel: 'onmousewheel',
	    onOffline: 'onoffline',
	    onOnline: 'ononline',
	    onPageHide: 'onpagehide',
	    onPageShow: 'onpageshow',
	    onPaste: 'onpaste',
	    onPause: 'onpause',
	    onPlay: 'onplay',
	    onPlaying: 'onplaying',
	    onPopState: 'onpopstate',
	    onProgress: 'onprogress',
	    onRateChange: 'onratechange',
	    onRepeat: 'onrepeat',
	    onReset: 'onreset',
	    onResize: 'onresize',
	    onScroll: 'onscroll',
	    onSeeked: 'onseeked',
	    onSeeking: 'onseeking',
	    onSelect: 'onselect',
	    onShow: 'onshow',
	    onStalled: 'onstalled',
	    onStorage: 'onstorage',
	    onSubmit: 'onsubmit',
	    onSuspend: 'onsuspend',
	    onTimeUpdate: 'ontimeupdate',
	    onToggle: 'ontoggle',
	    onUnload: 'onunload',
	    onVolumeChange: 'onvolumechange',
	    onWaiting: 'onwaiting',
	    onZoom: 'onzoom',
	    overlinePosition: 'overline-position',
	    overlineThickness: 'overline-thickness',
	    paintOrder: 'paint-order',
	    panose1: 'panose-1',
	    pointerEvents: 'pointer-events',
	    referrerPolicy: 'referrerpolicy',
	    renderingIntent: 'rendering-intent',
	    shapeRendering: 'shape-rendering',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strikethroughPosition: 'strikethrough-position',
	    strikethroughThickness: 'strikethrough-thickness',
	    strokeDashArray: 'stroke-dasharray',
	    strokeDashOffset: 'stroke-dashoffset',
	    strokeLineCap: 'stroke-linecap',
	    strokeLineJoin: 'stroke-linejoin',
	    strokeMiterLimit: 'stroke-miterlimit',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    tabIndex: 'tabindex',
	    textAnchor: 'text-anchor',
	    textDecoration: 'text-decoration',
	    textRendering: 'text-rendering',
	    typeOf: 'typeof',
	    underlinePosition: 'underline-position',
	    underlineThickness: 'underline-thickness',
	    unicodeBidi: 'unicode-bidi',
	    unicodeRange: 'unicode-range',
	    unitsPerEm: 'units-per-em',
	    vAlphabetic: 'v-alphabetic',
	    vHanging: 'v-hanging',
	    vIdeographic: 'v-ideographic',
	    vMathematical: 'v-mathematical',
	    vectorEffect: 'vector-effect',
	    vertAdvY: 'vert-adv-y',
	    vertOriginX: 'vert-origin-x',
	    vertOriginY: 'vert-origin-y',
	    wordSpacing: 'word-spacing',
	    writingMode: 'writing-mode',
	    xHeight: 'x-height',
	    // These were camelcased in Tiny. Now lowercased in SVG 2
	    playbackOrder: 'playbackorder',
	    timelineBegin: 'timelinebegin'
	  },
	  transform: caseSensitiveTransform,
	  properties: {
	    about: commaOrSpaceSeparated,
	    accentHeight: number,
	    accumulate: null,
	    additive: null,
	    alignmentBaseline: null,
	    alphabetic: number,
	    amplitude: number,
	    arabicForm: null,
	    ascent: number,
	    attributeName: null,
	    attributeType: null,
	    azimuth: number,
	    bandwidth: null,
	    baselineShift: null,
	    baseFrequency: null,
	    baseProfile: null,
	    bbox: null,
	    begin: null,
	    bias: number,
	    by: null,
	    calcMode: null,
	    capHeight: number,
	    className: spaceSeparated,
	    clip: null,
	    clipPath: null,
	    clipPathUnits: null,
	    clipRule: null,
	    color: null,
	    colorInterpolation: null,
	    colorInterpolationFilters: null,
	    colorProfile: null,
	    colorRendering: null,
	    content: null,
	    contentScriptType: null,
	    contentStyleType: null,
	    crossOrigin: null,
	    cursor: null,
	    cx: null,
	    cy: null,
	    d: null,
	    dataType: null,
	    defaultAction: null,
	    descent: number,
	    diffuseConstant: number,
	    direction: null,
	    display: null,
	    dur: null,
	    divisor: number,
	    dominantBaseline: null,
	    download: boolean,
	    dx: null,
	    dy: null,
	    edgeMode: null,
	    editable: null,
	    elevation: number,
	    enableBackground: null,
	    end: null,
	    event: null,
	    exponent: number,
	    externalResourcesRequired: null,
	    fill: null,
	    fillOpacity: number,
	    fillRule: null,
	    filter: null,
	    filterRes: null,
	    filterUnits: null,
	    floodColor: null,
	    floodOpacity: null,
	    focusable: null,
	    focusHighlight: null,
	    fontFamily: null,
	    fontSize: null,
	    fontSizeAdjust: null,
	    fontStretch: null,
	    fontStyle: null,
	    fontVariant: null,
	    fontWeight: null,
	    format: null,
	    fr: null,
	    from: null,
	    fx: null,
	    fy: null,
	    g1: commaSeparated,
	    g2: commaSeparated,
	    glyphName: commaSeparated,
	    glyphOrientationHorizontal: null,
	    glyphOrientationVertical: null,
	    glyphRef: null,
	    gradientTransform: null,
	    gradientUnits: null,
	    handler: null,
	    hanging: number,
	    hatchContentUnits: null,
	    hatchUnits: null,
	    height: null,
	    href: null,
	    hrefLang: null,
	    horizAdvX: number,
	    horizOriginX: number,
	    horizOriginY: number,
	    id: null,
	    ideographic: number,
	    imageRendering: null,
	    initialVisibility: null,
	    in: null,
	    in2: null,
	    intercept: number,
	    k: number,
	    k1: number,
	    k2: number,
	    k3: number,
	    k4: number,
	    kernelMatrix: commaOrSpaceSeparated,
	    kernelUnitLength: null,
	    keyPoints: null, // SEMI_COLON_SEPARATED
	    keySplines: null, // SEMI_COLON_SEPARATED
	    keyTimes: null, // SEMI_COLON_SEPARATED
	    kerning: null,
	    lang: null,
	    lengthAdjust: null,
	    letterSpacing: null,
	    lightingColor: null,
	    limitingConeAngle: number,
	    local: null,
	    markerEnd: null,
	    markerMid: null,
	    markerStart: null,
	    markerHeight: null,
	    markerUnits: null,
	    markerWidth: null,
	    mask: null,
	    maskContentUnits: null,
	    maskUnits: null,
	    mathematical: null,
	    max: null,
	    media: null,
	    mediaCharacterEncoding: null,
	    mediaContentEncodings: null,
	    mediaSize: number,
	    mediaTime: null,
	    method: null,
	    min: null,
	    mode: null,
	    name: null,
	    navDown: null,
	    navDownLeft: null,
	    navDownRight: null,
	    navLeft: null,
	    navNext: null,
	    navPrev: null,
	    navRight: null,
	    navUp: null,
	    navUpLeft: null,
	    navUpRight: null,
	    numOctaves: null,
	    observer: null,
	    offset: null,
	    onAbort: null,
	    onActivate: null,
	    onAfterPrint: null,
	    onBeforePrint: null,
	    onBegin: null,
	    onCancel: null,
	    onCanPlay: null,
	    onCanPlayThrough: null,
	    onChange: null,
	    onClick: null,
	    onClose: null,
	    onCopy: null,
	    onCueChange: null,
	    onCut: null,
	    onDblClick: null,
	    onDrag: null,
	    onDragEnd: null,
	    onDragEnter: null,
	    onDragExit: null,
	    onDragLeave: null,
	    onDragOver: null,
	    onDragStart: null,
	    onDrop: null,
	    onDurationChange: null,
	    onEmptied: null,
	    onEnd: null,
	    onEnded: null,
	    onError: null,
	    onFocus: null,
	    onFocusIn: null,
	    onFocusOut: null,
	    onHashChange: null,
	    onInput: null,
	    onInvalid: null,
	    onKeyDown: null,
	    onKeyPress: null,
	    onKeyUp: null,
	    onLoad: null,
	    onLoadedData: null,
	    onLoadedMetadata: null,
	    onLoadStart: null,
	    onMessage: null,
	    onMouseDown: null,
	    onMouseEnter: null,
	    onMouseLeave: null,
	    onMouseMove: null,
	    onMouseOut: null,
	    onMouseOver: null,
	    onMouseUp: null,
	    onMouseWheel: null,
	    onOffline: null,
	    onOnline: null,
	    onPageHide: null,
	    onPageShow: null,
	    onPaste: null,
	    onPause: null,
	    onPlay: null,
	    onPlaying: null,
	    onPopState: null,
	    onProgress: null,
	    onRateChange: null,
	    onRepeat: null,
	    onReset: null,
	    onResize: null,
	    onScroll: null,
	    onSeeked: null,
	    onSeeking: null,
	    onSelect: null,
	    onShow: null,
	    onStalled: null,
	    onStorage: null,
	    onSubmit: null,
	    onSuspend: null,
	    onTimeUpdate: null,
	    onToggle: null,
	    onUnload: null,
	    onVolumeChange: null,
	    onWaiting: null,
	    onZoom: null,
	    opacity: null,
	    operator: null,
	    order: null,
	    orient: null,
	    orientation: null,
	    origin: null,
	    overflow: null,
	    overlay: null,
	    overlinePosition: number,
	    overlineThickness: number,
	    paintOrder: null,
	    panose1: null,
	    path: null,
	    pathLength: number,
	    patternContentUnits: null,
	    patternTransform: null,
	    patternUnits: null,
	    phase: null,
	    ping: spaceSeparated,
	    pitch: null,
	    playbackOrder: null,
	    pointerEvents: null,
	    points: null,
	    pointsAtX: number,
	    pointsAtY: number,
	    pointsAtZ: number,
	    preserveAlpha: null,
	    preserveAspectRatio: null,
	    primitiveUnits: null,
	    propagate: null,
	    property: commaOrSpaceSeparated,
	    r: null,
	    radius: null,
	    referrerPolicy: null,
	    refX: null,
	    refY: null,
	    rel: commaOrSpaceSeparated,
	    rev: commaOrSpaceSeparated,
	    renderingIntent: null,
	    repeatCount: null,
	    repeatDur: null,
	    requiredExtensions: commaOrSpaceSeparated,
	    requiredFeatures: commaOrSpaceSeparated,
	    requiredFonts: commaOrSpaceSeparated,
	    requiredFormats: commaOrSpaceSeparated,
	    resource: null,
	    restart: null,
	    result: null,
	    rotate: null,
	    rx: null,
	    ry: null,
	    scale: null,
	    seed: null,
	    shapeRendering: null,
	    side: null,
	    slope: null,
	    snapshotTime: null,
	    specularConstant: number,
	    specularExponent: number,
	    spreadMethod: null,
	    spacing: null,
	    startOffset: null,
	    stdDeviation: null,
	    stemh: null,
	    stemv: null,
	    stitchTiles: null,
	    stopColor: null,
	    stopOpacity: null,
	    strikethroughPosition: number,
	    strikethroughThickness: number,
	    string: null,
	    stroke: null,
	    strokeDashArray: commaOrSpaceSeparated,
	    strokeDashOffset: null,
	    strokeLineCap: null,
	    strokeLineJoin: null,
	    strokeMiterLimit: number,
	    strokeOpacity: number,
	    strokeWidth: null,
	    style: null,
	    surfaceScale: number,
	    syncBehavior: null,
	    syncBehaviorDefault: null,
	    syncMaster: null,
	    syncTolerance: null,
	    syncToleranceDefault: null,
	    systemLanguage: commaOrSpaceSeparated,
	    tabIndex: number,
	    tableValues: null,
	    target: null,
	    targetX: number,
	    targetY: number,
	    textAnchor: null,
	    textDecoration: null,
	    textRendering: null,
	    textLength: null,
	    timelineBegin: null,
	    title: null,
	    transformBehavior: null,
	    type: null,
	    typeOf: commaOrSpaceSeparated,
	    to: null,
	    transform: null,
	    u1: null,
	    u2: null,
	    underlinePosition: number,
	    underlineThickness: number,
	    unicode: null,
	    unicodeBidi: null,
	    unicodeRange: null,
	    unitsPerEm: number,
	    values: null,
	    vAlphabetic: number,
	    vMathematical: number,
	    vectorEffect: null,
	    vHanging: number,
	    vIdeographic: number,
	    version: null,
	    vertAdvY: number,
	    vertOriginX: number,
	    vertOriginY: number,
	    viewBox: null,
	    viewTarget: null,
	    visibility: null,
	    width: null,
	    widths: null,
	    wordSpacing: null,
	    writingMode: null,
	    x: null,
	    x1: null,
	    x2: null,
	    xChannelSelector: null,
	    xHeight: number,
	    y: null,
	    y1: null,
	    y2: null,
	    yChannelSelector: null,
	    z: null,
	    zoomAndPan: null
	  }
	});

	/**
	 * @typedef {import('./util/schema.js').Schema} Schema
	 */

	const valid = /^data[-\w.:]+$/i;
	const dash = /-[a-z]/g;
	const cap = /[A-Z]/g;

	/**
	 * @param {Schema} schema
	 * @param {string} value
	 * @returns {Info}
	 */
	function find(schema, value) {
	  const normal = normalize(value);
	  let prop = value;
	  let Type = Info;

	  if (normal in schema.normal) {
	    return schema.property[schema.normal[normal]]
	  }

	  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {
	    // Attribute or property.
	    if (value.charAt(4) === '-') {
	      // Turn it into a property.
	      const rest = value.slice(5).replace(dash, camelcase);
	      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);
	    } else {
	      // Turn it into an attribute.
	      const rest = value.slice(4);

	      if (!dash.test(rest)) {
	        let dashes = rest.replace(cap, kebab);

	        if (dashes.charAt(0) !== '-') {
	          dashes = '-' + dashes;
	        }

	        value = 'data' + dashes;
	      }
	    }

	    Type = DefinedInfo;
	  }

	  return new Type(prop, value)
	}

	/**
	 * @param {string} $0
	 * @returns {string}
	 */
	function kebab($0) {
	  return '-' + $0.toLowerCase()
	}

	/**
	 * @param {string} $0
	 * @returns {string}
	 */
	function camelcase($0) {
	  return $0.charAt(1).toUpperCase()
	}

	/**
	 * @typedef {import('./lib/util/info.js').Info} Info
	 * @typedef {import('./lib/util/schema.js').Schema} Schema
	 */
	const html$2 = merge([xml, xlink, xmlns, aria, html$3], 'html');
	const svg = merge([xml, xlink, xmlns, aria, svg$1], 'svg');

	/**
	 * @typedef {import('hast').Properties} Properties
	 * @typedef {import('hast').Element} Element
	 */

	var search = /[#.]/g;

	/**
	 * Create a hast element from a simple CSS selector.
	 *
	 * @param selector A simple CSS selector.
	 *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).
	 *   Multiple classes are allowed.
	 *   Uses the last ID if multiple IDs are found.
	 * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.
	 */
	const parseSelector =
	  /**
	   * @type {(
	   *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}
	   * )}
	   */
	  (
	    /**
	     * @param {string} [selector]
	     * @param {string} [defaultTagName='div']
	     * @returns {Element}
	     */
	    function (selector, defaultTagName = 'div') {
	      var value = selector || '';
	      /** @type {Properties} */
	      var props = {};
	      var start = 0;
	      /** @type {string} */
	      var subvalue;
	      /** @type {string} */
	      var previous;
	      /** @type {RegExpMatchArray} */
	      var match;

	      while (start < value.length) {
	        search.lastIndex = start;
	        match = search.exec(value);
	        subvalue = value.slice(start, match ? match.index : value.length);

	        if (subvalue) {
	          if (!previous) {
	            defaultTagName = subvalue;
	          } else if (previous === '#') {
	            props.id = subvalue;
	          } else if (Array.isArray(props.className)) {
	            props.className.push(subvalue);
	          } else {
	            props.className = [subvalue];
	          }

	          start += subvalue.length;
	        }

	        if (match) {
	          previous = match[0];
	          start++;
	        }
	      }

	      return {
	        type: 'element',
	        tagName: defaultTagName,
	        properties: props,
	        children: []
	      }
	    }
	  );

	/**
	 * Parse space separated tokens to an array of strings.
	 *
	 * @param {string} value Space separated tokens
	 * @returns {Array.<string>} Tokens
	 */
	function parse$4(value) {
	  const input = String(value || '').trim();
	  return input ? input.split(/[ \t\n\r\f]+/g) : []
	}

	/**
	 * Serialize an array of strings as space separated tokens.
	 *
	 * @param {Array.<string|number>} values Tokens
	 * @returns {string} Space separated tokens
	 */
	function stringify$1(values) {
	  return values.join(' ').trim()
	}

	/**
	 * @typedef {Object} StringifyOptions
	 * @property {boolean} [padLeft=true] Whether to pad a space before a token (`boolean`, default: `true`).
	 * @property {boolean} [padRight=false] Whether to pad a space after a token (`boolean`, default: `false`).
	 */

	/**
	 * Parse comma separated tokens to an array.
	 *
	 * @param {string} value
	 * @returns {Array.<string>}
	 */
	function parse$3(value) {
	  /** @type {Array.<string>} */
	  var tokens = [];
	  var input = String(value || '');
	  var index = input.indexOf(',');
	  var start = 0;
	  /** @type {boolean} */
	  var end;
	  /** @type {string} */
	  var token;

	  while (!end) {
	    if (index === -1) {
	      index = input.length;
	      end = true;
	    }

	    token = input.slice(start, index).trim();

	    if (token || !end) {
	      tokens.push(token);
	    }

	    start = index + 1;
	    index = input.indexOf(',', start);
	  }

	  return tokens
	}

	/**
	 * Serialize an array of strings to comma separated tokens.
	 *
	 * @param {Array.<string|number>} values
	 * @param {StringifyOptions} [options]
	 * @returns {string}
	 */
	function stringify(values, options) {
	  var settings = options || {};

	  // Ensure the last empty entry is seen.
	  if (values[values.length - 1] === '') {
	    values = values.concat('');
	  }

	  return values
	    .join(
	      (settings.padRight ? ' ' : '') +
	        ',' +
	        (settings.padLeft === false ? '' : ' ')
	    )
	    .trim()
	}

	/**
	 * @typedef {import('hast').Root} Root
	 * @typedef {import('hast').Element} Element
	 * @typedef {import('hast').Properties} Properties
	 * @typedef {Root['children'][number]} Child
	 * @typedef {Child|Root} Node
	 * @typedef {import('property-information').Info} Info
	 * @typedef {import('property-information').Schema} Schema
	 *
	 * @typedef {Root|Element} HResult
	 * @typedef {string|number} HStyleValue
	 * @typedef {Record<string, HStyleValue>} HStyle
	 * @typedef {string|number|boolean|null|undefined} HPrimitiveValue
	 * @typedef {Array<string|number>} HArrayValue
	 * @typedef {HPrimitiveValue|HArrayValue} HPropertyValue
	 * @typedef {{[property: string]: HPropertyValue|HStyle}} HProperties
	 *   Acceptable properties value.
	 *
	 * @typedef {string|number|null|undefined} HPrimitiveChild
	 * @typedef {Array<Node|HPrimitiveChild>} HArrayChild
	 * @typedef {Node|HPrimitiveChild|HArrayChild} HChild
	 *   Acceptable child value
	 */

	const buttonTypes = new Set(['menu', 'submit', 'reset', 'button']);

	const own$6 = {}.hasOwnProperty;

	/**
	 * @param {Schema} schema
	 * @param {string} defaultTagName
	 * @param {Array<string>} [caseSensitive]
	 */
	function core$1(schema, defaultTagName, caseSensitive) {
	  const adjust = caseSensitive && createAdjustMap(caseSensitive);

	  const h =
	    /**
	     * @type {{
	     *   (): Root
	     *   (selector: null|undefined, ...children: Array<HChild>): Root
	     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element
	     *   (selector: string, ...children: Array<HChild>): Element
	     * }}
	     */
	    (
	      /**
	       * Hyperscript compatible DSL for creating virtual hast trees.
	       *
	       * @param {string|null} [selector]
	       * @param {HProperties|HChild} [properties]
	       * @param {Array<HChild>} children
	       * @returns {HResult}
	       */
	      function (selector, properties, ...children) {
	        let index = -1;
	        /** @type {HResult} */
	        let node;

	        if (selector === undefined || selector === null) {
	          node = {type: 'root', children: []};
	          // @ts-expect-error Properties are not supported for roots.
	          children.unshift(properties);
	        } else {
	          node = parseSelector(selector, defaultTagName);
	          // Normalize the name.
	          node.tagName = node.tagName.toLowerCase();
	          if (adjust && own$6.call(adjust, node.tagName)) {
	            node.tagName = adjust[node.tagName];
	          }

	          // Handle props.
	          if (isProperties(properties, node.tagName)) {
	            /** @type {string} */
	            let key;

	            for (key in properties) {
	              if (own$6.call(properties, key)) {
	                // @ts-expect-error `node.properties` is set.
	                addProperty(schema, node.properties, key, properties[key]);
	              }
	            }
	          } else {
	            children.unshift(properties);
	          }
	        }

	        // Handle children.
	        while (++index < children.length) {
	          addChild(node.children, children[index]);
	        }

	        if (node.type === 'element' && node.tagName === 'template') {
	          node.content = {type: 'root', children: node.children};
	          node.children = [];
	        }

	        return node
	      }
	    );

	  return h
	}

	/**
	 * @param {HProperties|HChild} value
	 * @param {string} name
	 * @returns {value is HProperties}
	 */
	function isProperties(value, name) {
	  if (
	    value === null ||
	    value === undefined ||
	    typeof value !== 'object' ||
	    Array.isArray(value)
	  ) {
	    return false
	  }

	  if (name === 'input' || !value.type || typeof value.type !== 'string') {
	    return true
	  }

	  if ('children' in value && Array.isArray(value.children)) {
	    return false
	  }

	  if (name === 'button') {
	    return buttonTypes.has(value.type.toLowerCase())
	  }

	  return !('value' in value)
	}

	/**
	 * @param {Schema} schema
	 * @param {Properties} properties
	 * @param {string} key
	 * @param {HStyle|HPropertyValue} value
	 * @returns {void}
	 */
	function addProperty(schema, properties, key, value) {
	  const info = find(schema, key);
	  let index = -1;
	  /** @type {HPropertyValue} */
	  let result;

	  // Ignore nullish and NaN values.
	  if (value === undefined || value === null) return

	  if (typeof value === 'number') {
	    // Ignore NaN.
	    if (Number.isNaN(value)) return

	    result = value;
	  }
	  // Booleans.
	  else if (typeof value === 'boolean') {
	    result = value;
	  }
	  // Handle list values.
	  else if (typeof value === 'string') {
	    if (info.spaceSeparated) {
	      result = parse$4(value);
	    } else if (info.commaSeparated) {
	      result = parse$3(value);
	    } else if (info.commaOrSpaceSeparated) {
	      result = parse$4(parse$3(value).join(' '));
	    } else {
	      result = parsePrimitive(info, info.property, value);
	    }
	  } else if (Array.isArray(value)) {
	    result = value.concat();
	  } else {
	    result = info.property === 'style' ? style(value) : String(value);
	  }

	  if (Array.isArray(result)) {
	    /** @type {Array<string|number>} */
	    const finalResult = [];

	    while (++index < result.length) {
	      // @ts-expect-error Assume no booleans in array.
	      finalResult[index] = parsePrimitive(info, info.property, result[index]);
	    }

	    result = finalResult;
	  }

	  // Class names (which can be added both on the `selector` and here).
	  if (info.property === 'className' && Array.isArray(properties.className)) {
	    // @ts-expect-error Assume no booleans in `className`.
	    result = properties.className.concat(result);
	  }

	  properties[info.property] = result;
	}

	/**
	 * @param {Array<Child>} nodes
	 * @param {HChild} value
	 * @returns {void}
	 */
	function addChild(nodes, value) {
	  let index = -1;

	  if (value === undefined || value === null) ; else if (typeof value === 'string' || typeof value === 'number') {
	    nodes.push({type: 'text', value: String(value)});
	  } else if (Array.isArray(value)) {
	    while (++index < value.length) {
	      addChild(nodes, value[index]);
	    }
	  } else if (typeof value === 'object' && 'type' in value) {
	    if (value.type === 'root') {
	      addChild(nodes, value.children);
	    } else {
	      nodes.push(value);
	    }
	  } else {
	    throw new Error('Expected node, nodes, or string, got `' + value + '`')
	  }
	}

	/**
	 * Parse a single primitives.
	 *
	 * @param {Info} info
	 * @param {string} name
	 * @param {HPrimitiveValue} value
	 * @returns {HPrimitiveValue}
	 */
	function parsePrimitive(info, name, value) {
	  if (typeof value === 'string') {
	    if (info.number && value && !Number.isNaN(Number(value))) {
	      return Number(value)
	    }

	    if (
	      (info.boolean || info.overloadedBoolean) &&
	      (value === '' || normalize(value) === normalize(name))
	    ) {
	      return true
	    }
	  }

	  return value
	}

	/**
	 * @param {HStyle} value
	 * @returns {string}
	 */
	function style(value) {
	  /** @type {Array<string>} */
	  const result = [];
	  /** @type {string} */
	  let key;

	  for (key in value) {
	    if (own$6.call(value, key)) {
	      result.push([key, value[key]].join(': '));
	    }
	  }

	  return result.join('; ')
	}

	/**
	 * @param {Array<string>} values
	 * @returns {Record<string, string>}
	 */
	function createAdjustMap(values) {
	  /** @type {Record<string, string>} */
	  const result = {};
	  let index = -1;

	  while (++index < values.length) {
	    result[values[index].toLowerCase()] = values[index];
	  }

	  return result
	}

	/**
	 * @typedef {import('./core.js').HChild} Child Acceptable child value
	 * @typedef {import('./core.js').HProperties} Properties Acceptable properties value.
	 *
	 * @typedef {import('./jsx-classic').Element} h.JSX.Element
	 * @typedef {import('./jsx-classic').IntrinsicAttributes} h.JSX.IntrinsicAttributes
	 * @typedef {import('./jsx-classic').IntrinsicElements} h.JSX.IntrinsicElements
	 * @typedef {import('./jsx-classic').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute
	 */

	const h = core$1(html$2, 'div');

	const svgCaseSensitiveTagNames = [
	  'altGlyph',
	  'altGlyphDef',
	  'altGlyphItem',
	  'animateColor',
	  'animateMotion',
	  'animateTransform',
	  'clipPath',
	  'feBlend',
	  'feColorMatrix',
	  'feComponentTransfer',
	  'feComposite',
	  'feConvolveMatrix',
	  'feDiffuseLighting',
	  'feDisplacementMap',
	  'feDistantLight',
	  'feDropShadow',
	  'feFlood',
	  'feFuncA',
	  'feFuncB',
	  'feFuncG',
	  'feFuncR',
	  'feGaussianBlur',
	  'feImage',
	  'feMerge',
	  'feMergeNode',
	  'feMorphology',
	  'feOffset',
	  'fePointLight',
	  'feSpecularLighting',
	  'feSpotLight',
	  'feTile',
	  'feTurbulence',
	  'foreignObject',
	  'glyphRef',
	  'linearGradient',
	  'radialGradient',
	  'solidColor',
	  'textArea',
	  'textPath'
	];

	/**
	 * @typedef {import('./core.js').HChild} Child
	 * @typedef {import('./core.js').HProperties} Properties
	 *
	 * @typedef {import('./jsx-classic').Element} s.JSX.Element
	 * @typedef {import('./jsx-classic').IntrinsicAttributes} s.JSX.IntrinsicAttributes
	 * @typedef {import('./jsx-classic').IntrinsicElements} s.JSX.IntrinsicElements
	 * @typedef {import('./jsx-classic').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute
	 */

	core$1(svg, 'g', svgCaseSensitiveTagNames);

	var lib$2 = {};

	(function (exports) {
	Object.defineProperty(exports,"__esModule",{value:!0}),exports.emojiMap=exports.checkText=void 0;/* eslint-disable linebreak-style */var emojiMap={"o/":"\uD83D\uDC4B","</3":"\uD83D\uDC94","<3":"\uD83D\uDC97","8-D":"\uD83D\uDE01","8D":"\uD83D\uDE01",":-D":"\uD83D\uDE01",":-3":"\uD83D\uDE01",":3":"\uD83D\uDE01",":D":"\uD83D\uDE01","B^D":"\uD83D\uDE01","X-D":"\uD83D\uDE01",XD:"\uD83D\uDE01","x-D":"\uD83D\uDE01",xD:"\uD83D\uDE01",":')":"\uD83D\uDE02",":'-)":"\uD83D\uDE02",":-))":"\uD83D\uDE03","8)":"\uD83D\uDE04",":)":"\uD83D\uDE0A",":-)":"\uD83D\uDE04",":]":"\uD83D\uDE04",":^)":"\uD83D\uDE04",":c)":"\uD83D\uDE04",":o)":"\uD83D\uDE04",":}":"\uD83D\uDE04",":)":"\uD83D\uDE04","0:)":"\uD83D\uDE07","0:-)":"\uD83D\uDE07","0:-3":"\uD83D\uDE07","0:3":"\uD83D\uDE07","0;^)":"\uD83D\uDE07","O:-)":"\uD83D\uDE07","3:)":"\uD83D\uDE08","3:-)":"\uD83D\uDE08","}:)":"\uD83D\uDE08","}:-)":"\uD83D\uDE08","*)":"\uD83D\uDE09","*-)":"\uD83D\uDE09",":-,":"\uD83D\uDE09",";)":"\uD83D\uDE09",";-)":"\uD83D\uDE09",";-]":"\uD83D\uDE09",";D":"\uD83D\uDE09",";]":"\uD83D\uDE09",";^)":"\uD83D\uDE09",":-|":"\uD83D\uDE10",":|":"\uD83D\uDE10",":(":"\uD83D\uDE1E",":-(":"\uD83D\uDE12",":-<":"\uD83D\uDE12",":-[":"\uD83D\uDE12",":-c":"\uD83D\uDE12",":<":"\uD83D\uDE12",":[":"\uD83D\uDE12",":c":"\uD83D\uDE12",":{":"\uD83D\uDE12",":C":"\uD83D\uDE12","%)":"\uD83D\uDE16","%-)":"\uD83D\uDE16",":-P":"\uD83D\uDE1C",":-b":"\uD83D\uDE1C",":-p":"\uD83D\uDE1C",":-":"\uD83D\uDE1C",":-":"\uD83D\uDE1C",":P":"\uD83D\uDE1C",":b":"\uD83D\uDE1C",":p":"\uD83D\uDE1C",":":"\uD83D\uDE1C",":":"\uD83D\uDE1C",";(":"\uD83D\uDE1C","X-P":"\uD83D\uDE1C",XP:"\uD83D\uDE1C","d:":"\uD83D\uDE1C","x-p":"\uD83D\uDE1C",xp:"\uD83D\uDE1C",":-||":"\uD83D\uDE20",":@":"\uD83D\uDE20",":-.":"\uD83D\uDE21",":-/":"\uD83D\uDE21",":/":"\uD83D\uDE10",":L":"\uD83D\uDE21",":S":"\uD83D\uDE21",":\\":"\uD83D\uDE21",":'(":"\uD83D\uDE22",":'-(":"\uD83D\uDE22","^5":"\uD83D\uDE24","^<_<":"\uD83D\uDE24","o/\\o":"\uD83D\uDE24","|-O":"\uD83D\uDE2B","|;-)":"\uD83D\uDE2B",":###..":"\uD83D\uDE30",":#":"\uD83D\uDE05",":-###..":"\uD83D\uDE30","D-':":"\uD83D\uDE31",D8:"\uD83D\uDE31","D:":"\uD83D\uDE31","D:<":"\uD83D\uDE31","D;":"\uD83D\uDE31",DX:"\uD83D\uDE31","v.v":"\uD83D\uDE31","8-0":"\uD83D\uDE32",":-O":"\uD83D\uDE32",":-o":"\uD83D\uDE32",":O":"\uD83D\uDE32",":o":"\uD83D\uDE32","O-O":"\uD83D\uDE32",O_O:"\uD83D\uDE32",O_o:"\uD83D\uDE32","o-o":"\uD83D\uDE32",o_O:"\uD83D\uDE32",o_o:"\uD83D\uDE32",":$":"\uD83D\uDE33","#-)":"\uD83D\uDE35",":&":"\uD83D\uDE36",":-#":"\uD83D\uDE36",":-&":"\uD83D\uDE36",":-X":"\uD83D\uDE36",":X":"\uD83D\uDE36",":-J":"\uD83D\uDE3C",":*":"\uD83D\uDE18",":^*":"\uD83D\uDE3D","*\\0/*":"\uD83D\uDE46","\\o/":"\uD83D\uDE46",":>":"\uD83D\uDE04",">.<":"\uD83D\uDE21",">:(":"\uD83D\uDE20",">:)":"\uD83D\uDE08",">:-)":"\uD83D\uDE08",">:/":"\uD83D\uDE21",">:O":"\uD83D\uDE32",">:P":"\uD83D\uDE1C",">:[":"\uD83D\uDE12",">:\\":"\uD83D\uDE21",">;)":"\uD83D\uDE08",">_>^":"\uD83D\uDE24","^^":"\uD83D\uDE0A",":sweat":"\uD83D\uDE05",":smile:":"\uD83D\uDE04",":laughing:":"\uD83D\uDE06",":blush:":"\uD83D\uDE0A",":smiley:":"\uD83D\uDE03",":relaxed:":"\u263A\uFE0F",":smirk:":"\uD83D\uDE0F",":heart_eyes:":"\uD83D\uDE0D",":kissing_heart:":"\uD83D\uDE18",":kissing_closed_eyes:":"\uD83D\uDE1A",":flushed:":"\uD83D\uDE33",":relieved:":"\uD83D\uDE0C",":satisfied:":"\uD83D\uDE06",":grin:":"\uD83D\uDE01",":wink:":"\uD83D\uDE09",":stuck_out_tongue_winking_eye:":"\uD83D\uDE1C",":stuck_out_tongue_closed_eyes:":"\uD83D\uDE1D",":grinning:":"\uD83D\uDE00",":kissing:":"\uD83D\uDE17",":kissing_smiling_eyes:":"\uD83D\uDE19",":stuck_out_tongue:":"\uD83D\uDE1B",":sleeping:":"\uD83D\uDE34",":worried:":"\uD83D\uDE1F",":frowning:":"\uD83D\uDE26",":anguished:":"\uD83D\uDE27",":open_mouth:":"\uD83D\uDE2E",":grimacing:":"\uD83D\uDE2C",":confused:":"\uD83D\uDE15",":hushed:":"\uD83D\uDE2F",":expressionless:":"\uD83D\uDE11",":unamused:":"\uD83D\uDE12",":sweat_smile:":"\uD83D\uDE05",":sweat:":"\uD83D\uDE13",":disappointed_relieved:":"\uD83D\uDE25",":weary:":"\uD83D\uDE29",":pensive:":"\uD83D\uDE14",":disappointed:":"\uD83D\uDE1E",":confounded:":"\uD83D\uDE16",":fearful:":"\uD83D\uDE28",":cold_sweat:":"\uD83D\uDE30",":persevere:":"\uD83D\uDE23",":cry:":"\uD83D\uDE22",":sob:":"\uD83D\uDE2D",":joy:":"\uD83D\uDE02",":astonished:":"\uD83D\uDE32",":scream:":"\uD83D\uDE31",":tired_face:":"\uD83D\uDE2B",":angry:":"\uD83D\uDE20",":rage:":"\uD83D\uDE21",":triumph:":"\uD83D\uDE24",":sleepy:":"\uD83D\uDE2A",":yum:":"\uD83D\uDE0B",":mask:":"\uD83D\uDE37",":sunglasses:":"\uD83D\uDE0E",":dizzy_face:":"\uD83D\uDE35",":imp:":"\uD83D\uDC7F",":smiling_imp:":"\uD83D\uDE08",":neutral_face:":"\uD83D\uDE10",":no_mouth:":"\uD83D\uDE36",":innocent:":"\uD83D\uDE07",":alien:":"\uD83D\uDC7D",":yellow_heart:":"\uD83D\uDC9B",":blue_heart:":"\uD83D\uDC99",":purple_heart:":"\uD83D\uDC9C",":heart:":"\u2764\uFE0F",":green_heart:":"\uD83D\uDC9A",":broken_heart:":"\uD83D\uDC94",":heartbeat:":"\uD83D\uDC93",":heartpulse:":"\uD83D\uDC97",":two_hearts:":"\uD83D\uDC95",":revolving_hearts:":"\uD83D\uDC9E",":cupid:":"\uD83D\uDC98",":sparkling_heart:":"\uD83D\uDC96",":sparkles:":"\u2728",":star:":"\u2B50",":star2:":"\uD83C\uDF1F",":dizzy:":"\uD83D\uDCAB",":boom:":"\uD83D\uDCA5",":collision:":"\uD83D\uDCA5",":anger:":"\uD83D\uDCA2",":exclamation:":"\u2757",":question:":"\u2753",":grey_exclamation:":"\u2755",":grey_question:":"\u2754",":zzz:":"\uD83D\uDCA4",":dash:":"\uD83D\uDCA8",":sweat_drops:":"\uD83D\uDCA6",":notes:":"\uD83C\uDFB6",":musical_note:":"\uD83C\uDFB5",":fire:":"\uD83D\uDD25",":hankey:":"\uD83D\uDCA9",":poop:":"\uD83D\uDCA9",":shit:":"\uD83D\uDCA9",":+1:":"\uD83D\uDC4D",":thumbsup:":"\uD83D\uDC4D",":-1:":"\uD83D\uDC4E",":thumbsdown:":"\uD83D\uDC4E",":ok_hand:":"\uD83D\uDC4C",":punch:":"\uD83D\uDC4A",":facepunch:":"\uD83D\uDC4A",":fist:":"\u270A",":v:":"\u270C\uFE0F",":wave:":"\uD83D\uDC4B",":hand:":"\u270B",":raised_hand:":"\u270B",":open_hands:":"\uD83D\uDC50",":point_up:":"\u261D\uFE0F",":point_down:":"\uD83D\uDC47",":point_left:":"\uD83D\uDC48",":point_right:":"\uD83D\uDC49",":raised_hands:":"\uD83D\uDE4C",":pray:":"\uD83D\uDE4F",":point_up_2:":"\uD83D\uDC46",":clap:":"\uD83D\uDC4F",":muscle:":"\uD83D\uDCAA",":metal:":"\uD83E\uDD18",":fu:":"\uD83D\uDD95",":walking:":"\uD83D\uDEB6",":runner:":"\uD83C\uDFC3",":running:":"\uD83C\uDFC3",":couple:":"\uD83D\uDC6B",":family:":"\uD83D\uDC6A",":two_men_holding_hands:":"\uD83D\uDC6C",":two_women_holding_hands:":"\uD83D\uDC6D",":dancer:":"\uD83D\uDC83",":dancers:":"\uD83D\uDC6F",":no_good:":"\uD83D\uDE45",":information_desk_person:":"\uD83D\uDC81",":raising_hand:":"\uD83D\uDE4B",":bride_with_veil:":"\uD83D\uDC70",":bow:":"\uD83D\uDE47",":couplekiss:":"\uD83D\uDC8F",":couple_with_heart:":"\uD83D\uDC91",":massage:":"\uD83D\uDC86",":haircut:":"\uD83D\uDC87",":nail_care:":"\uD83D\uDC85",":boy:":"\uD83D\uDC66",":girl:":"\uD83D\uDC67",":woman:":"\uD83D\uDC69",":man:":"\uD83D\uDC68",":baby:":"\uD83D\uDC76",":older_woman:":"\uD83D\uDC75",":older_man:":"\uD83D\uDC74",":man_with_gua_pi_mao:":"\uD83D\uDC72",":construction_worker:":"\uD83D\uDC77",":cop:":"\uD83D\uDC6E",":angel:":"\uD83D\uDC7C",":princess:":"\uD83D\uDC78",":smiley_cat:":"\uD83D\uDE3A",":smile_cat:":"\uD83D\uDE38",":heart_eyes_cat:":"\uD83D\uDE3B",":kissing_cat:":"\uD83D\uDE3D",":smirk_cat:":"\uD83D\uDE3C",":scream_cat:":"\uD83D\uDE40",":crying_cat_face:":"\uD83D\uDE3F",":joy_cat:":"\uD83D\uDE39",":pouting_cat:":"\uD83D\uDE3E",":japanese_ogre:":"\uD83D\uDC79",":japanese_goblin:":"\uD83D\uDC7A",":see_no_evil:":"\uD83D\uDE48",":hear_no_evil:":"\uD83D\uDE49",":speak_no_evil:":"\uD83D\uDE4A",":skull:":"\uD83D\uDC80",":feet:":"\uD83D\uDC3E",":lips:":"\uD83D\uDC44",":kiss:":"\uD83D\uDC8B",":droplet:":"\uD83D\uDCA7",":ear:":"\uD83D\uDC42",":eyes:":"\uD83D\uDC40",":nose:":"\uD83D\uDC43",":tongue:":"\uD83D\uDC45",":love_letter:":"\uD83D\uDC8C",":bust_in_silhouette:":"\uD83D\uDC64",":busts_in_silhouette:":"\uD83D\uDC65",":speech_balloon:":"\uD83D\uDCAC",":thought_balloon:":"\uD83D\uDCAD",":sunny:":"\u2600\uFE0F",":umbrella:":"\u2614",":cloud:":"\u2601\uFE0F",":snowflake:":"\u2744\uFE0F",":snowman:":"\u26C4",":zap:":"\u26A1",":cyclone:":"\uD83C\uDF00",":foggy:":"\uD83C\uDF01",":ocean:":"\uD83C\uDF0A",":cat:":"\uD83D\uDC31",":dog:":"\uD83D\uDC36",":mouse:":"\uD83D\uDC2D",":hamster:":"\uD83D\uDC39",":rabbit:":"\uD83D\uDC30",":wolf:":"\uD83D\uDC3A",":frog:":"\uD83D\uDC38",":tiger:":"\uD83D\uDC2F",":koala:":"\uD83D\uDC28",":bear:":"\uD83D\uDC3B",":pig:":"\uD83D\uDC37",":pig_nose:":"\uD83D\uDC3D",":cow:":"\uD83D\uDC2E",":boar:":"\uD83D\uDC17",":monkey_face:":"\uD83D\uDC35",":monkey:":"\uD83D\uDC12",":horse:":"\uD83D\uDC34",":racehorse:":"\uD83D\uDC0E",":camel:":"\uD83D\uDC2B",":sheep:":"\uD83D\uDC11",":elephant:":"\uD83D\uDC18",":panda_face:":"\uD83D\uDC3C",":snake:":"\uD83D\uDC0D",":bird:":"\uD83D\uDC26",":baby_chick:":"\uD83D\uDC24",":hatched_chick:":"\uD83D\uDC25",":hatching_chick:":"\uD83D\uDC23",":chicken:":"\uD83D\uDC14",":penguin:":"\uD83D\uDC27",":turtle:":"\uD83D\uDC22",":bug:":"\uD83D\uDC1B",":honeybee:":"\uD83D\uDC1D",":ant:":"\uD83D\uDC1C",":beetle:":"\uD83D\uDC1E",":snail:":"\uD83D\uDC0C",":octopus:":"\uD83D\uDC19",":tropical_fish:":"\uD83D\uDC20",":fish:":"\uD83D\uDC1F",":whale:":"\uD83D\uDC33",":whale2:":"\uD83D\uDC0B",":dolphin:":"\uD83D\uDC2C",":cow2:":"\uD83D\uDC04",":ram:":"\uD83D\uDC0F",":rat:":"\uD83D\uDC00",":water_buffalo:":"\uD83D\uDC03",":tiger2:":"\uD83D\uDC05",":rabbit2:":"\uD83D\uDC07",":dragon:":"\uD83D\uDC09",":goat:":"\uD83D\uDC10",":rooster:":"\uD83D\uDC13",":dog2:":"\uD83D\uDC15",":pig2:":"\uD83D\uDC16",":mouse2:":"\uD83D\uDC01",":ox:":"\uD83D\uDC02",":dragon_face:":"\uD83D\uDC32",":blowfish:":"\uD83D\uDC21",":crocodile:":"\uD83D\uDC0A",":dromedary_camel:":"\uD83D\uDC2A",":leopard:":"\uD83D\uDC06",":cat2:":"\uD83D\uDC08",":poodle:":"\uD83D\uDC29",":paw_prints:":"\uD83D\uDC3E",":bouquet:":"\uD83D\uDC90",":cherry_blossom:":"\uD83C\uDF38",":tulip:":"\uD83C\uDF37",":four_leaf_clover:":"\uD83C\uDF40",":rose:":"\uD83C\uDF39",":sunflower:":"\uD83C\uDF3B",":hibiscus:":"\uD83C\uDF3A",":maple_leaf:":"\uD83C\uDF41",":leaves:":"\uD83C\uDF43",":fallen_leaf:":"\uD83C\uDF42",":herb:":"\uD83C\uDF3F",":mushroom:":"\uD83C\uDF44",":cactus:":"\uD83C\uDF35",":palm_tree:":"\uD83C\uDF34",":evergreen_tree:":"\uD83C\uDF32",":deciduous_tree:":"\uD83C\uDF33",":chestnut:":"\uD83C\uDF30",":seedling:":"\uD83C\uDF31",":blossom:":"\uD83C\uDF3C",":ear_of_rice:":"\uD83C\uDF3E",":shell:":"\uD83D\uDC1A",":globe_with_meridians:":"\uD83C\uDF10",":sun_with_face:":"\uD83C\uDF1E",":full_moon_with_face:":"\uD83C\uDF1D",":new_moon_with_face:":"\uD83C\uDF1A",":new_moon:":"\uD83C\uDF11",":waxing_crescent_moon:":"\uD83C\uDF12",":first_quarter_moon:":"\uD83C\uDF13",":waxing_gibbous_moon:":"\uD83C\uDF14",":full_moon:":"\uD83C\uDF15",":waning_gibbous_moon:":"\uD83C\uDF16",":last_quarter_moon:":"\uD83C\uDF17",":waning_crescent_moon:":"\uD83C\uDF18",":last_quarter_moon_with_face:":"\uD83C\uDF1C",":first_quarter_moon_with_face:":"\uD83C\uDF1B",":moon:":"\uD83C\uDF14",":earth_africa:":"\uD83C\uDF0D",":earth_americas:":"\uD83C\uDF0E",":earth_asia:":"\uD83C\uDF0F",":volcano:":"\uD83C\uDF0B",":milky_way:":"\uD83C\uDF0C",":partly_sunny:":"\u26C5",":bamboo:":"\uD83C\uDF8D",":gift_heart:":"\uD83D\uDC9D",":dolls:":"\uD83C\uDF8E",":school_satchel:":"\uD83C\uDF92",":mortar_board:":"\uD83C\uDF93",":flags:":"\uD83C\uDF8F",":fireworks:":"\uD83C\uDF86",":sparkler:":"\uD83C\uDF87",":wind_chime:":"\uD83C\uDF90",":rice_scene:":"\uD83C\uDF91",":jack_o_lantern:":"\uD83C\uDF83",":ghost:":"\uD83D\uDC7B",":santa:":"\uD83C\uDF85",":christmas_tree:":"\uD83C\uDF84",":gift:":"\uD83C\uDF81",":bell:":"\uD83D\uDD14",":no_bell:":"\uD83D\uDD15",":tanabata_tree:":"\uD83C\uDF8B",":tada:":"\uD83C\uDF89",":confetti_ball:":"\uD83C\uDF8A",":balloon:":"\uD83C\uDF88",":crystal_ball:":"\uD83D\uDD2E",":cd:":"\uD83D\uDCBF",":dvd:":"\uD83D\uDCC0",":floppy_disk:":"\uD83D\uDCBE",":camera:":"\uD83D\uDCF7",":video_camera:":"\uD83D\uDCF9",":movie_camera:":"\uD83C\uDFA5",":computer:":"\uD83D\uDCBB",":tv:":"\uD83D\uDCFA",":iphone:":"\uD83D\uDCF1",":phone:":"\u260E\uFE0F",":telephone:":"\u260E\uFE0F",":telephone_receiver:":"\uD83D\uDCDE",":pager:":"\uD83D\uDCDF",":fax:":"\uD83D\uDCE0",":minidisc:":"\uD83D\uDCBD",":vhs:":"\uD83D\uDCFC",":sound:":"\uD83D\uDD09",":speaker:":"\uD83D\uDD08",":mute:":"\uD83D\uDD07",":loudspeaker:":"\uD83D\uDCE2",":mega:":"\uD83D\uDCE3",":hourglass:":"\u231B",":hourglass_flowing_sand:":"\u23F3",":alarm_clock:":"\u23F0",":watch:":"\u231A",":radio:":"\uD83D\uDCFB",":satellite:":"\uD83D\uDCE1",":loop:":"\u27BF",":mag:":"\uD83D\uDD0D",":mag_right:":"\uD83D\uDD0E",":unlock:":"\uD83D\uDD13",":lock:":"\uD83D\uDD12",":lock_with_ink_pen:":"\uD83D\uDD0F",":closed_lock_with_key:":"\uD83D\uDD10",":key:":"\uD83D\uDD11",":bulb:":"\uD83D\uDCA1",":flashlight:":"\uD83D\uDD26",":high_brightness:":"\uD83D\uDD06",":low_brightness:":"\uD83D\uDD05",":electric_plug:":"\uD83D\uDD0C",":battery:":"\uD83D\uDD0B",":calling:":"\uD83D\uDCF2",":email:":"\u2709\uFE0F",":mailbox:":"\uD83D\uDCEB",":postbox:":"\uD83D\uDCEE",":bath:":"\uD83D\uDEC0",":bathtub:":"\uD83D\uDEC1",":shower:":"\uD83D\uDEBF",":toilet:":"\uD83D\uDEBD",":wrench:":"\uD83D\uDD27",":nut_and_bolt:":"\uD83D\uDD29",":hammer:":"\uD83D\uDD28",":seat:":"\uD83D\uDCBA",":moneybag:":"\uD83D\uDCB0",":yen:":"\uD83D\uDCB4",":dollar:":"\uD83D\uDCB5",":pound:":"\uD83D\uDCB7",":euro:":"\uD83D\uDCB6",":credit_card:":"\uD83D\uDCB3",":money_with_wings:":"\uD83D\uDCB8",":e-mail:":"\uD83D\uDCE7",":inbox_tray:":"\uD83D\uDCE5",":outbox_tray:":"\uD83D\uDCE4",":envelope:":"\u2709\uFE0F",":incoming_envelope:":"\uD83D\uDCE8",":postal_horn:":"\uD83D\uDCEF",":mailbox_closed:":"\uD83D\uDCEA",":mailbox_with_mail:":"\uD83D\uDCEC",":mailbox_with_no_mail:":"\uD83D\uDCED",":package:":"\uD83D\uDCE6",":door:":"\uD83D\uDEAA",":smoking:":"\uD83D\uDEAC",":bomb:":"\uD83D\uDCA3",":gun:":"\uD83D\uDD2B",":hocho:":"\uD83D\uDD2A",":pill:":"\uD83D\uDC8A",":syringe:":"\uD83D\uDC89",":page_facing_up:":"\uD83D\uDCC4",":page_with_curl:":"\uD83D\uDCC3",":bookmark_tabs:":"\uD83D\uDCD1",":bar_chart:":"\uD83D\uDCCA",":chart_with_upwards_trend:":"\uD83D\uDCC8",":chart_with_downwards_trend:":"\uD83D\uDCC9",":scroll:":"\uD83D\uDCDC",":clipboard:":"\uD83D\uDCCB",":calendar:":"\uD83D\uDCC6",":date:":"\uD83D\uDCC5",":card_index:":"\uD83D\uDCC7",":file_folder:":"\uD83D\uDCC1",":open_file_folder:":"\uD83D\uDCC2",":scissors:":"\u2702\uFE0F",":pushpin:":"\uD83D\uDCCC",":paperclip:":"\uD83D\uDCCE",":black_nib:":"\u2712\uFE0F",":pencil2:":"\u270F\uFE0F",":straight_ruler:":"\uD83D\uDCCF",":triangular_ruler:":"\uD83D\uDCD0",":closed_book:":"\uD83D\uDCD5",":green_book:":"\uD83D\uDCD7",":blue_book:":"\uD83D\uDCD8",":orange_book:":"\uD83D\uDCD9",":notebook:":"\uD83D\uDCD3",":notebook_with_decorative_cover:":"\uD83D\uDCD4",":ledger:":"\uD83D\uDCD2",":books:":"\uD83D\uDCDA",":bookmark:":"\uD83D\uDD16",":name_badge:":"\uD83D\uDCDB",":microscope:":"\uD83D\uDD2C",":telescope:":"\uD83D\uDD2D",":newspaper:":"\uD83D\uDCF0",":football:":"\uD83C\uDFC8",":basketball:":"\uD83C\uDFC0",":soccer:":"\u26BD",":baseball:":"\u26BE",":tennis:":"\uD83C\uDFBE",":8ball:":"\uD83C\uDFB1",":rugby_football:":"\uD83C\uDFC9",":bowling:":"\uD83C\uDFB3",":golf:":"\u26F3",":mountain_bicyclist:":"\uD83D\uDEB5",":bicyclist:":"\uD83D\uDEB4",":horse_racing:":"\uD83C\uDFC7",":snowboarder:":"\uD83C\uDFC2",":swimmer:":"\uD83C\uDFCA",":surfer:":"\uD83C\uDFC4",":ski:":"\uD83C\uDFBF",":spades:":"\u2660\uFE0F",":hearts:":"\u2665\uFE0F",":clubs:":"\u2663\uFE0F",":diamonds:":"\u2666\uFE0F",":gem:":"\uD83D\uDC8E",":ring:":"\uD83D\uDC8D",":trophy:":"\uD83C\uDFC6",":musical_score:":"\uD83C\uDFBC",":musical_keyboard:":"\uD83C\uDFB9",":violin:":"\uD83C\uDFBB",":space_invader:":"\uD83D\uDC7E",":video_game:":"\uD83C\uDFAE",":black_joker:":"\uD83C\uDCCF",":flower_playing_cards:":"\uD83C\uDFB4",":game_die:":"\uD83C\uDFB2",":dart:":"\uD83C\uDFAF",":mahjong:":"\uD83C\uDC04",":clapper:":"\uD83C\uDFAC",":memo:":"\uD83D\uDCDD",":pencil:":"\uD83D\uDCDD",":book:":"\uD83D\uDCD6",":art:":"\uD83C\uDFA8",":microphone:":"\uD83C\uDFA4",":headphones:":"\uD83C\uDFA7",":trumpet:":"\uD83C\uDFBA",":saxophone:":"\uD83C\uDFB7",":guitar:":"\uD83C\uDFB8",":shoe:":"\uD83D\uDC5E",":sandal:":"\uD83D\uDC61",":high_heel:":"\uD83D\uDC60",":lipstick:":"\uD83D\uDC84",":boot:":"\uD83D\uDC62",":shirt:":"\uD83D\uDC55",":tshirt:":"\uD83D\uDC55",":necktie:":"\uD83D\uDC54",":womans_clothes:":"\uD83D\uDC5A",":dress:":"\uD83D\uDC57",":running_shirt_with_sash:":"\uD83C\uDFBD",":jeans:":"\uD83D\uDC56",":kimono:":"\uD83D\uDC58",":bikini:":"\uD83D\uDC59",":ribbon:":"\uD83C\uDF80",":tophat:":"\uD83C\uDFA9",":crown:":"\uD83D\uDC51",":womans_hat:":"\uD83D\uDC52",":mans_shoe:":"\uD83D\uDC5E",":closed_umbrella:":"\uD83C\uDF02",":briefcase:":"\uD83D\uDCBC",":handbag:":"\uD83D\uDC5C",":pouch:":"\uD83D\uDC5D",":purse:":"\uD83D\uDC5B",":eyeglasses:":"\uD83D\uDC53",":fishing_pole_and_fish:":"\uD83C\uDFA3",":coffee:":"\u2615",":tea:":"\uD83C\uDF75",":sake:":"\uD83C\uDF76",":baby_bottle:":"\uD83C\uDF7C",":beer:":"\uD83C\uDF7A",":beers:":"\uD83C\uDF7B",":cocktail:":"\uD83C\uDF78",":tropical_drink:":"\uD83C\uDF79",":wine_glass:":"\uD83C\uDF77",":fork_and_knife:":"\uD83C\uDF74",":pizza:":"\uD83C\uDF55",":hamburger:":"\uD83C\uDF54",":fries:":"\uD83C\uDF5F",":poultry_leg:":"\uD83C\uDF57",":meat_on_bone:":"\uD83C\uDF56",":spaghetti:":"\uD83C\uDF5D",":curry:":"\uD83C\uDF5B",":fried_shrimp:":"\uD83C\uDF64",":bento:":"\uD83C\uDF71",":sushi:":"\uD83C\uDF63",":fish_cake:":"\uD83C\uDF65",":rice_ball:":"\uD83C\uDF59",":rice_cracker:":"\uD83C\uDF58",":rice:":"\uD83C\uDF5A",":ramen:":"\uD83C\uDF5C",":stew:":"\uD83C\uDF72",":oden:":"\uD83C\uDF62",":dango:":"\uD83C\uDF61",":egg:":"\uD83E\uDD5A",":bread:":"\uD83C\uDF5E",":doughnut:":"\uD83C\uDF69",":custard:":"\uD83C\uDF6E",":icecream:":"\uD83C\uDF66",":ice_cream:":"\uD83C\uDF68",":shaved_ice:":"\uD83C\uDF67",":birthday:":"\uD83C\uDF82",":cake:":"\uD83C\uDF70",":cookie:":"\uD83C\uDF6A",":chocolate_bar:":"\uD83C\uDF6B",":candy:":"\uD83C\uDF6C",":lollipop:":"\uD83C\uDF6D",":honey_pot:":"\uD83C\uDF6F",":apple:":"\uD83C\uDF4E",":green_apple:":"\uD83C\uDF4F",":tangerine:":"\uD83C\uDF4A",":lemon:":"\uD83C\uDF4B",":cherries:":"\uD83C\uDF52",":grapes:":"\uD83C\uDF47",":watermelon:":"\uD83C\uDF49",":strawberry:":"\uD83C\uDF53",":peach:":"\uD83C\uDF51",":melon:":"\uD83C\uDF48",":banana:":"\uD83C\uDF4C",":pear:":"\uD83C\uDF50",":pineapple:":"\uD83C\uDF4D",":sweet_potato:":"\uD83C\uDF60",":eggplant:":"\uD83C\uDF46",":tomato:":"\uD83C\uDF45",":corn:":"\uD83C\uDF3D",":house:":"\uD83C\uDFE0",":house_with_garden:":"\uD83C\uDFE1",":school:":"\uD83C\uDFEB",":office:":"\uD83C\uDFE2",":post_office:":"\uD83C\uDFE3",":hospital:":"\uD83C\uDFE5",":bank:":"\uD83C\uDFE6",":convenience_store:":"\uD83C\uDFEA",":love_hotel:":"\uD83C\uDFE9",":hotel:":"\uD83C\uDFE8",":wedding:":"\uD83D\uDC92",":church:":"\u26EA",":department_store:":"\uD83C\uDFEC",":european_post_office:":"\uD83C\uDFE4",":city_sunrise:":"\uD83C\uDF07",":city_sunset:":"\uD83C\uDF06",":japanese_castle:":"\uD83C\uDFEF",":european_castle:":"\uD83C\uDFF0",":tent:":"\u26FA",":factory:":"\uD83C\uDFED",":tokyo_tower:":"\uD83D\uDDFC",":japan:":"\uD83D\uDDFE",":mount_fuji:":"\uD83D\uDDFB",":sunrise_over_mountains:":"\uD83C\uDF04",":sunrise:":"\uD83C\uDF05",":stars:":"\uD83C\uDF20",":statue_of_liberty:":"\uD83D\uDDFD",":bridge_at_night:":"\uD83C\uDF09",":carousel_horse:":"\uD83C\uDFA0",":rainbow:":"\uD83C\uDF08",":ferris_wheel:":"\uD83C\uDFA1",":fountain:":"\u26F2",":roller_coaster:":"\uD83C\uDFA2",":ship:":"\uD83D\uDEA2",":speedboat:":"\uD83D\uDEA4",":boat:":"\u26F5",":sailboat:":"\u26F5",":rowboat:":"\uD83D\uDEA3",":anchor:":"\u2693",":rocket:":"\uD83D\uDE80",":airplane:":"\u2708\uFE0F",":helicopter:":"\uD83D\uDE81",":steam_locomotive:":"\uD83D\uDE82",":tram:":"\uD83D\uDE8A",":mountain_railway:":"\uD83D\uDE9E",":bike:":"\uD83D\uDEB2",":aerial_tramway:":"\uD83D\uDEA1",":suspension_railway:":"\uD83D\uDE9F",":mountain_cableway:":"\uD83D\uDEA0",":tractor:":"\uD83D\uDE9C",":blue_car:":"\uD83D\uDE99",":oncoming_automobile:":"\uD83D\uDE98",":car:":"\uD83D\uDE97",":red_car:":"\uD83D\uDE97",":taxi:":"\uD83D\uDE95",":oncoming_taxi:":"\uD83D\uDE96",":articulated_lorry:":"\uD83D\uDE9B",":bus:":"\uD83D\uDE8C",":oncoming_bus:":"\uD83D\uDE8D",":rotating_light:":"\uD83D\uDEA8",":police_car:":"\uD83D\uDE93",":oncoming_police_car:":"\uD83D\uDE94",":fire_engine:":"\uD83D\uDE92",":ambulance:":"\uD83D\uDE91",":minibus:":"\uD83D\uDE90",":truck:":"\uD83D\uDE9A",":train:":"\uD83D\uDE8B",":station:":"\uD83D\uDE89",":train2:":"\uD83D\uDE86",":bullettrain_front:":"\uD83D\uDE85",":bullettrain_side:":"\uD83D\uDE84",":light_rail:":"\uD83D\uDE88",":monorail:":"\uD83D\uDE9D",":railway_car:":"\uD83D\uDE83",":trolleybus:":"\uD83D\uDE8E",":ticket:":"\uD83C\uDFAB",":fuelpump:":"\u26FD",":vertical_traffic_light:":"\uD83D\uDEA6",":traffic_light:":"\uD83D\uDEA5",":warning:":"\u26A0\uFE0F",":construction:":"\uD83D\uDEA7",":beginner:":"\uD83D\uDD30",":atm:":"\uD83C\uDFE7",":slot_machine:":"\uD83C\uDFB0",":busstop:":"\uD83D\uDE8F",":barber:":"\uD83D\uDC88",":hotsprings:":"\u2668\uFE0F",":checkered_flag:":"\uD83C\uDFC1",":crossed_flags:":"\uD83C\uDF8C",":izakaya_lantern:":"\uD83C\uDFEE",":moyai:":"\uD83D\uDDFF",":circus_tent:":"\uD83C\uDFAA",":performing_arts:":"\uD83C\uDFAD",":round_pushpin:":"\uD83D\uDCCD",":triangular_flag_on_post:":"\uD83D\uDEA9",":jp:":"\uD83C\uDDEF\uD83C\uDDF5",":kr:":"\uD83C\uDDF0\uD83C\uDDF7",":cn:":"\uD83C\uDDE8\uD83C\uDDF3",":us:":"\uD83C\uDDFA\uD83C\uDDF8",":fr:":"\uD83C\uDDEB\uD83C\uDDF7",":es:":"\uD83C\uDDEA\uD83C\uDDF8",":it:":"\uD83C\uDDEE\uD83C\uDDF9",":ru:":"\uD83C\uDDF7\uD83C\uDDFA",":gb:":"\uD83C\uDDEC\uD83C\uDDE7",":uk:":"\uD83C\uDDEC\uD83C\uDDE7",":de:":"\uD83C\uDDE9\uD83C\uDDEA",":one:":"1\uFE0F\u20E3",":two:":"2\uFE0F\u20E3",":three:":"3\uFE0F\u20E3",":four:":"4\uFE0F\u20E3",":five:":"5\uFE0F\u20E3",":six:":"6\uFE0F\u20E3",":seven:":"7\uFE0F\u20E3",":eight:":"8\uFE0F\u20E3",":nine:":"9\uFE0F\u20E3",":keycap_ten:":"\uD83D\uDD1F",":1234:":"\uD83D\uDD22",":zero:":"0\uFE0F\u20E3",":hash:":"#\uFE0F\u20E3",":symbols:":"\uD83D\uDD23",":arrow_backward:":"\u25C0\uFE0F",":arrow_down:":"\u2B07\uFE0F",":arrow_forward:":"\u25B6\uFE0F",":arrow_left:":"\u2B05\uFE0F",":capital_abcd:":"\uD83D\uDD20",":abcd:":"\uD83D\uDD21",":abc:":"\uD83D\uDD24",":arrow_lower_left:":"\u2199\uFE0F",":arrow_lower_right:":"\u2198\uFE0F",":arrow_right:":"\u27A1\uFE0F",":arrow_up:":"\u2B06\uFE0F",":arrow_upper_left:":"\u2196\uFE0F",":arrow_upper_right:":"\u2197\uFE0F",":arrow_double_down:":"\u23EC",":arrow_double_up:":"\u23EB",":arrow_down_small:":"\uD83D\uDD3D",":arrow_heading_down:":"\u2935\uFE0F",":arrow_heading_up:":"\u2934\uFE0F",":leftwards_arrow_with_hook:":"\u21A9\uFE0F",":arrow_right_hook:":"\u21AA\uFE0F",":left_right_arrow:":"\u2194\uFE0F",":arrow_up_down:":"\u2195\uFE0F",":arrow_up_small:":"\uD83D\uDD3C",":arrows_clockwise:":"\uD83D\uDD03",":arrows_counterclockwise:":"\uD83D\uDD04",":rewind:":"\u23EA",":fast_forward:":"\u23E9",":information_source:":"\u2139\uFE0F",":ok:":"\uD83C\uDD97",":twisted_rightwards_arrows:":"\uD83D\uDD00",":repeat:":"\uD83D\uDD01",":repeat_one:":"\uD83D\uDD02",":new:":"\uD83C\uDD95",":top:":"\uD83D\uDD1D",":up:":"\uD83C\uDD99",":cool:":"\uD83C\uDD92",":free:":"\uD83C\uDD93",":ng:":"\uD83C\uDD96",":cinema:":"\uD83C\uDFA6",":koko:":"\uD83C\uDE01",":signal_strength:":"\uD83D\uDCF6",":u5272:":"\uD83C\uDE39",":u5408:":"\uD83C\uDE34",":u55b6:":"\uD83C\uDE3A",":u6307:":"\uD83C\uDE2F",":u6708:":"\uD83C\uDE37\uFE0F",":u6709:":"\uD83C\uDE36",":u6e80:":"\uD83C\uDE35",":u7121:":"\uD83C\uDE1A",":u7533:":"\uD83C\uDE38",":u7a7a:":"\uD83C\uDE33",":u7981:":"\uD83C\uDE32",":sa:":"\uD83C\uDE02\uFE0F",":restroom:":"\uD83D\uDEBB",":mens:":"\uD83D\uDEB9",":womens:":"\uD83D\uDEBA",":baby_symbol:":"\uD83D\uDEBC",":no_smoking:":"\uD83D\uDEAD",":parking:":"\uD83C\uDD7F\uFE0F",":wheelchair:":"\u267F",":metro:":"\uD83D\uDE87",":baggage_claim:":"\uD83D\uDEC4",":accept:":"\uD83C\uDE51",":wc:":"\uD83D\uDEBE",":potable_water:":"\uD83D\uDEB0",":put_litter_in_its_place:":"\uD83D\uDEAE",":secret:":"\u3299\uFE0F",":congratulations:":"\u3297\uFE0F",":m:":"\u24C2\uFE0F",":passport_control:":"\uD83D\uDEC2",":left_luggage:":"\uD83D\uDEC5",":customs:":"\uD83D\uDEC3",":ideograph_advantage:":"\uD83C\uDE50",":cl:":"\uD83C\uDD91",":sos:":"\uD83C\uDD98",":id:":"\uD83C\uDD94",":no_entry_sign:":"\uD83D\uDEAB",":underage:":"\uD83D\uDD1E",":no_mobile_phones:":"\uD83D\uDCF5",":do_not_litter:":"\uD83D\uDEAF",":non-potable_water:":"\uD83D\uDEB1",":no_bicycles:":"\uD83D\uDEB3",":no_pedestrians:":"\uD83D\uDEB7",":children_crossing:":"\uD83D\uDEB8",":no_entry:":"\u26D4",":eight_spoked_asterisk:":"\u2733\uFE0F",":sparkle:":"\u2747\uFE0F",":eight_pointed_black_star:":"\u2734\uFE0F",":heart_decoration:":"\uD83D\uDC9F",":vs:":"\uD83C\uDD9A",":vibration_mode:":"\uD83D\uDCF3",":mobile_phone_off:":"\uD83D\uDCF4",":chart:":"\uD83D\uDCB9",":currency_exchange:":"\uD83D\uDCB1",":aries:":"\u2648",":taurus:":"\u2649",":gemini:":"\u264A",":cancer:":"\u264B",":leo:":"\u264C",":virgo:":"\u264D",":libra:":"\u264E",":scorpius:":"\u264F",":sagittarius:":"\u2650",":capricorn:":"\u2651",":aquarius:":"\u2652",":pisces:":"\u2653",":ophiuchus:":"\u26CE",":six_pointed_star:":"\uD83D\uDD2F",":negative_squared_cross_mark:":"\u274E",":a:":"\uD83C\uDD70\uFE0F",":b:":"\uD83C\uDD71\uFE0F",":ab:":"\uD83C\uDD8E",":o2:":"\uD83C\uDD7E\uFE0F",":diamond_shape_with_a_dot_inside:":"\uD83D\uDCA0",":recycle:":"\u267B\uFE0F",":end:":"\uD83D\uDD1A",":back:":"\uD83D\uDD19",":on:":"\uD83D\uDD1B",":soon:":"\uD83D\uDD1C",":clock1:":"\uD83D\uDD50",":clock130:":"\uD83D\uDD5C",":clock10:":"\uD83D\uDD59",":clock1030:":"\uD83D\uDD65",":clock11:":"\uD83D\uDD5A",":clock1130:":"\uD83D\uDD66",":clock12:":"\uD83D\uDD5B",":clock1230:":"\uD83D\uDD67",":clock2:":"\uD83D\uDD51",":clock230:":"\uD83D\uDD5D",":clock3:":"\uD83D\uDD52",":clock330:":"\uD83D\uDD5E",":clock4:":"\uD83D\uDD53",":clock430:":"\uD83D\uDD5F",":clock5:":"\uD83D\uDD54",":clock530:":"\uD83D\uDD60",":clock6:":"\uD83D\uDD55",":clock630:":"\uD83D\uDD61",":clock7:":"\uD83D\uDD56",":clock730:":"\uD83D\uDD62",":clock8:":"\uD83D\uDD57",":clock830:":"\uD83D\uDD63",":clock9:":"\uD83D\uDD58",":clock930:":"\uD83D\uDD64",":heavy_dollar_sign:":"\uD83D\uDCB2",":copyright:":"\xA9\uFE0F",":registered:":"\xAE\uFE0F",":tm:":"\u2122\uFE0F",":x:":"\u274C",":heavy_exclamation_mark:":"\u2757",":bangbang:":"\u203C\uFE0F",":interrobang:":"\u2049\uFE0F",":o:":"\u2B55",":heavy_multiplication_x:":"\u2716\uFE0F",":heavy_plus_sign:":"\u2795",":heavy_minus_sign:":"\u2796",":heavy_division_sign:":"\u2797",":white_flower:":"\uD83D\uDCAE",":100:":"\uD83D\uDCAF",":heavy_check_mark:":"\u2714\uFE0F",":ballot_box_with_check:":"\u2611\uFE0F",":radio_button:":"\uD83D\uDD18",":link:":"\uD83D\uDD17",":curly_loop:":"\u27B0",":wavy_dash:":"\u3030\uFE0F",":part_alternation_mark:":"\u303D\uFE0F"};exports.emojiMap=emojiMap;var checkText=function(a){var b=a&&a.split(" "),c=[];return b&&b.forEach(function(a){var b=a;a in emojiMap&&(b=emojiMap[a]),c.push(b);}),c.join(" ")};exports.checkText=checkText;
	} (lib$2));

	var index = /*@__PURE__*/getDefaultExportFromCjs(lib$2);

	var smile2emoji = /*#__PURE__*/_mergeNamespaces({
		__proto__: null,
		'default': index
	}, [lib$2]);

	var lib$1 = {};

	var namedReferences = {};

	Object.defineProperty(namedReferences,"__esModule",{value:true});namedReferences.bodyRegExps={xml:/&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,html4:/&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,html5:/&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g};namedReferences.namedReferences={xml:{entities:{"&lt;":"<","&gt;":">","&quot;":'"',"&apos;":"'","&amp;":"&"},characters:{"<":"&lt;",">":"&gt;",'"':"&quot;","'":"&apos;","&":"&amp;"}},html4:{entities:{"&apos;":"'","&nbsp":"","&nbsp;":"","&iexcl":"","&iexcl;":"","&cent":"","&cent;":"","&pound":"","&pound;":"","&curren":"","&curren;":"","&yen":"","&yen;":"","&brvbar":"","&brvbar;":"","&sect":"","&sect;":"","&uml":"","&uml;":"","&copy":"","&copy;":"","&ordf":"","&ordf;":"","&laquo":"","&laquo;":"","&not":"","&not;":"","&shy":"","&shy;":"","&reg":"","&reg;":"","&macr":"","&macr;":"","&deg":"","&deg;":"","&plusmn":"","&plusmn;":"","&sup2":"","&sup2;":"","&sup3":"","&sup3;":"","&acute":"","&acute;":"","&micro":"","&micro;":"","&para":"","&para;":"","&middot":"","&middot;":"","&cedil":"","&cedil;":"","&sup1":"","&sup1;":"","&ordm":"","&ordm;":"","&raquo":"","&raquo;":"","&frac14":"","&frac14;":"","&frac12":"","&frac12;":"","&frac34":"","&frac34;":"","&iquest":"","&iquest;":"","&Agrave":"","&Agrave;":"","&Aacute":"","&Aacute;":"","&Acirc":"","&Acirc;":"","&Atilde":"","&Atilde;":"","&Auml":"","&Auml;":"","&Aring":"","&Aring;":"","&AElig":"","&AElig;":"","&Ccedil":"","&Ccedil;":"","&Egrave":"","&Egrave;":"","&Eacute":"","&Eacute;":"","&Ecirc":"","&Ecirc;":"","&Euml":"","&Euml;":"","&Igrave":"","&Igrave;":"","&Iacute":"","&Iacute;":"","&Icirc":"","&Icirc;":"","&Iuml":"","&Iuml;":"","&ETH":"","&ETH;":"","&Ntilde":"","&Ntilde;":"","&Ograve":"","&Ograve;":"","&Oacute":"","&Oacute;":"","&Ocirc":"","&Ocirc;":"","&Otilde":"","&Otilde;":"","&Ouml":"","&Ouml;":"","&times":"","&times;":"","&Oslash":"","&Oslash;":"","&Ugrave":"","&Ugrave;":"","&Uacute":"","&Uacute;":"","&Ucirc":"","&Ucirc;":"","&Uuml":"","&Uuml;":"","&Yacute":"","&Yacute;":"","&THORN":"","&THORN;":"","&szlig":"","&szlig;":"","&agrave":"","&agrave;":"","&aacute":"","&aacute;":"","&acirc":"","&acirc;":"","&atilde":"","&atilde;":"","&auml":"","&auml;":"","&aring":"","&aring;":"","&aelig":"","&aelig;":"","&ccedil":"","&ccedil;":"","&egrave":"","&egrave;":"","&eacute":"","&eacute;":"","&ecirc":"","&ecirc;":"","&euml":"","&euml;":"","&igrave":"","&igrave;":"","&iacute":"","&iacute;":"","&icirc":"","&icirc;":"","&iuml":"","&iuml;":"","&eth":"","&eth;":"","&ntilde":"","&ntilde;":"","&ograve":"","&ograve;":"","&oacute":"","&oacute;":"","&ocirc":"","&ocirc;":"","&otilde":"","&otilde;":"","&ouml":"","&ouml;":"","&divide":"","&divide;":"","&oslash":"","&oslash;":"","&ugrave":"","&ugrave;":"","&uacute":"","&uacute;":"","&ucirc":"","&ucirc;":"","&uuml":"","&uuml;":"","&yacute":"","&yacute;":"","&thorn":"","&thorn;":"","&yuml":"","&yuml;":"","&quot":'"',"&quot;":'"',"&amp":"&","&amp;":"&","&lt":"<","&lt;":"<","&gt":">","&gt;":">","&OElig;":"","&oelig;":"","&Scaron;":"","&scaron;":"","&Yuml;":"","&circ;":"","&tilde;":"","&ensp;":"","&emsp;":"","&thinsp;":"","&zwnj;":"","&zwj;":"","&lrm;":"","&rlm;":"","&ndash;":"","&mdash;":"","&lsquo;":"","&rsquo;":"","&sbquo;":"","&ldquo;":"","&rdquo;":"","&bdquo;":"","&dagger;":"","&Dagger;":"","&permil;":"","&lsaquo;":"","&rsaquo;":"","&euro;":"","&fnof;":"","&Alpha;":"","&Beta;":"","&Gamma;":"","&Delta;":"","&Epsilon;":"","&Zeta;":"","&Eta;":"","&Theta;":"","&Iota;":"","&Kappa;":"","&Lambda;":"","&Mu;":"","&Nu;":"","&Xi;":"","&Omicron;":"","&Pi;":"","&Rho;":"","&Sigma;":"","&Tau;":"","&Upsilon;":"","&Phi;":"","&Chi;":"","&Psi;":"","&Omega;":"","&alpha;":"","&beta;":"","&gamma;":"","&delta;":"","&epsilon;":"","&zeta;":"","&eta;":"","&theta;":"","&iota;":"","&kappa;":"","&lambda;":"","&mu;":"","&nu;":"","&xi;":"","&omicron;":"","&pi;":"","&rho;":"","&sigmaf;":"","&sigma;":"","&tau;":"","&upsilon;":"","&phi;":"","&chi;":"","&psi;":"","&omega;":"","&thetasym;":"","&upsih;":"","&piv;":"","&bull;":"","&hellip;":"","&prime;":"","&Prime;":"","&oline;":"","&frasl;":"","&weierp;":"","&image;":"","&real;":"","&trade;":"","&alefsym;":"","&larr;":"","&uarr;":"","&rarr;":"","&darr;":"","&harr;":"","&crarr;":"","&lArr;":"","&uArr;":"","&rArr;":"","&dArr;":"","&hArr;":"","&forall;":"","&part;":"","&exist;":"","&empty;":"","&nabla;":"","&isin;":"","&notin;":"","&ni;":"","&prod;":"","&sum;":"","&minus;":"","&lowast;":"","&radic;":"","&prop;":"","&infin;":"","&ang;":"","&and;":"","&or;":"","&cap;":"","&cup;":"","&int;":"","&there4;":"","&sim;":"","&cong;":"","&asymp;":"","&ne;":"","&equiv;":"","&le;":"","&ge;":"","&sub;":"","&sup;":"","&nsub;":"","&sube;":"","&supe;":"","&oplus;":"","&otimes;":"","&perp;":"","&sdot;":"","&lceil;":"","&rceil;":"","&lfloor;":"","&rfloor;":"","&lang;":"","&rang;":"","&loz;":"","&spades;":"","&clubs;":"","&hearts;":"","&diams;":""},characters:{"'":"&apos;","":"&nbsp;","":"&iexcl;","":"&cent;","":"&pound;","":"&curren;","":"&yen;","":"&brvbar;","":"&sect;","":"&uml;","":"&copy;","":"&ordf;","":"&laquo;","":"&not;","":"&shy;","":"&reg;","":"&macr;","":"&deg;","":"&plusmn;","":"&sup2;","":"&sup3;","":"&acute;","":"&micro;","":"&para;","":"&middot;","":"&cedil;","":"&sup1;","":"&ordm;","":"&raquo;","":"&frac14;","":"&frac12;","":"&frac34;","":"&iquest;","":"&Agrave;","":"&Aacute;","":"&Acirc;","":"&Atilde;","":"&Auml;","":"&Aring;","":"&AElig;","":"&Ccedil;","":"&Egrave;","":"&Eacute;","":"&Ecirc;","":"&Euml;","":"&Igrave;","":"&Iacute;","":"&Icirc;","":"&Iuml;","":"&ETH;","":"&Ntilde;","":"&Ograve;","":"&Oacute;","":"&Ocirc;","":"&Otilde;","":"&Ouml;","":"&times;","":"&Oslash;","":"&Ugrave;","":"&Uacute;","":"&Ucirc;","":"&Uuml;","":"&Yacute;","":"&THORN;","":"&szlig;","":"&agrave;","":"&aacute;","":"&acirc;","":"&atilde;","":"&auml;","":"&aring;","":"&aelig;","":"&ccedil;","":"&egrave;","":"&eacute;","":"&ecirc;","":"&euml;","":"&igrave;","":"&iacute;","":"&icirc;","":"&iuml;","":"&eth;","":"&ntilde;","":"&ograve;","":"&oacute;","":"&ocirc;","":"&otilde;","":"&ouml;","":"&divide;","":"&oslash;","":"&ugrave;","":"&uacute;","":"&ucirc;","":"&uuml;","":"&yacute;","":"&thorn;","":"&yuml;",'"':"&quot;","&":"&amp;","<":"&lt;",">":"&gt;","":"&OElig;","":"&oelig;","":"&Scaron;","":"&scaron;","":"&Yuml;","":"&circ;","":"&tilde;","":"&ensp;","":"&emsp;","":"&thinsp;","":"&zwnj;","":"&zwj;","":"&lrm;","":"&rlm;","":"&ndash;","":"&mdash;","":"&lsquo;","":"&rsquo;","":"&sbquo;","":"&ldquo;","":"&rdquo;","":"&bdquo;","":"&dagger;","":"&Dagger;","":"&permil;","":"&lsaquo;","":"&rsaquo;","":"&euro;","":"&fnof;","":"&Alpha;","":"&Beta;","":"&Gamma;","":"&Delta;","":"&Epsilon;","":"&Zeta;","":"&Eta;","":"&Theta;","":"&Iota;","":"&Kappa;","":"&Lambda;","":"&Mu;","":"&Nu;","":"&Xi;","":"&Omicron;","":"&Pi;","":"&Rho;","":"&Sigma;","":"&Tau;","":"&Upsilon;","":"&Phi;","":"&Chi;","":"&Psi;","":"&Omega;","":"&alpha;","":"&beta;","":"&gamma;","":"&delta;","":"&epsilon;","":"&zeta;","":"&eta;","":"&theta;","":"&iota;","":"&kappa;","":"&lambda;","":"&mu;","":"&nu;","":"&xi;","":"&omicron;","":"&pi;","":"&rho;","":"&sigmaf;","":"&sigma;","":"&tau;","":"&upsilon;","":"&phi;","":"&chi;","":"&psi;","":"&omega;","":"&thetasym;","":"&upsih;","":"&piv;","":"&bull;","":"&hellip;","":"&prime;","":"&Prime;","":"&oline;","":"&frasl;","":"&weierp;","":"&image;","":"&real;","":"&trade;","":"&alefsym;","":"&larr;","":"&uarr;","":"&rarr;","":"&darr;","":"&harr;","":"&crarr;","":"&lArr;","":"&uArr;","":"&rArr;","":"&dArr;","":"&hArr;","":"&forall;","":"&part;","":"&exist;","":"&empty;","":"&nabla;","":"&isin;","":"&notin;","":"&ni;","":"&prod;","":"&sum;","":"&minus;","":"&lowast;","":"&radic;","":"&prop;","":"&infin;","":"&ang;","":"&and;","":"&or;","":"&cap;","":"&cup;","":"&int;","":"&there4;","":"&sim;","":"&cong;","":"&asymp;","":"&ne;","":"&equiv;","":"&le;","":"&ge;","":"&sub;","":"&sup;","":"&nsub;","":"&sube;","":"&supe;","":"&oplus;","":"&otimes;","":"&perp;","":"&sdot;","":"&lceil;","":"&rceil;","":"&lfloor;","":"&rfloor;","":"&lang;","":"&rang;","":"&loz;","":"&spades;","":"&clubs;","":"&hearts;","":"&diams;"}},html5:{entities:{"&AElig":"","&AElig;":"","&AMP":"&","&AMP;":"&","&Aacute":"","&Aacute;":"","&Abreve;":"","&Acirc":"","&Acirc;":"","&Acy;":"","&Afr;":"","&Agrave":"","&Agrave;":"","&Alpha;":"","&Amacr;":"","&And;":"","&Aogon;":"","&Aopf;":"","&ApplyFunction;":"","&Aring":"","&Aring;":"","&Ascr;":"","&Assign;":"","&Atilde":"","&Atilde;":"","&Auml":"","&Auml;":"","&Backslash;":"","&Barv;":"","&Barwed;":"","&Bcy;":"","&Because;":"","&Bernoullis;":"","&Beta;":"","&Bfr;":"","&Bopf;":"","&Breve;":"","&Bscr;":"","&Bumpeq;":"","&CHcy;":"","&COPY":"","&COPY;":"","&Cacute;":"","&Cap;":"","&CapitalDifferentialD;":"","&Cayleys;":"","&Ccaron;":"","&Ccedil":"","&Ccedil;":"","&Ccirc;":"","&Cconint;":"","&Cdot;":"","&Cedilla;":"","&CenterDot;":"","&Cfr;":"","&Chi;":"","&CircleDot;":"","&CircleMinus;":"","&CirclePlus;":"","&CircleTimes;":"","&ClockwiseContourIntegral;":"","&CloseCurlyDoubleQuote;":"","&CloseCurlyQuote;":"","&Colon;":"","&Colone;":"","&Congruent;":"","&Conint;":"","&ContourIntegral;":"","&Copf;":"","&Coproduct;":"","&CounterClockwiseContourIntegral;":"","&Cross;":"","&Cscr;":"","&Cup;":"","&CupCap;":"","&DD;":"","&DDotrahd;":"","&DJcy;":"","&DScy;":"","&DZcy;":"","&Dagger;":"","&Darr;":"","&Dashv;":"","&Dcaron;":"","&Dcy;":"","&Del;":"","&Delta;":"","&Dfr;":"","&DiacriticalAcute;":"","&DiacriticalDot;":"","&DiacriticalDoubleAcute;":"","&DiacriticalGrave;":"`","&DiacriticalTilde;":"","&Diamond;":"","&DifferentialD;":"","&Dopf;":"","&Dot;":"","&DotDot;":"","&DotEqual;":"","&DoubleContourIntegral;":"","&DoubleDot;":"","&DoubleDownArrow;":"","&DoubleLeftArrow;":"","&DoubleLeftRightArrow;":"","&DoubleLeftTee;":"","&DoubleLongLeftArrow;":"","&DoubleLongLeftRightArrow;":"","&DoubleLongRightArrow;":"","&DoubleRightArrow;":"","&DoubleRightTee;":"","&DoubleUpArrow;":"","&DoubleUpDownArrow;":"","&DoubleVerticalBar;":"","&DownArrow;":"","&DownArrowBar;":"","&DownArrowUpArrow;":"","&DownBreve;":"","&DownLeftRightVector;":"","&DownLeftTeeVector;":"","&DownLeftVector;":"","&DownLeftVectorBar;":"","&DownRightTeeVector;":"","&DownRightVector;":"","&DownRightVectorBar;":"","&DownTee;":"","&DownTeeArrow;":"","&Downarrow;":"","&Dscr;":"","&Dstrok;":"","&ENG;":"","&ETH":"","&ETH;":"","&Eacute":"","&Eacute;":"","&Ecaron;":"","&Ecirc":"","&Ecirc;":"","&Ecy;":"","&Edot;":"","&Efr;":"","&Egrave":"","&Egrave;":"","&Element;":"","&Emacr;":"","&EmptySmallSquare;":"","&EmptyVerySmallSquare;":"","&Eogon;":"","&Eopf;":"","&Epsilon;":"","&Equal;":"","&EqualTilde;":"","&Equilibrium;":"","&Escr;":"","&Esim;":"","&Eta;":"","&Euml":"","&Euml;":"","&Exists;":"","&ExponentialE;":"","&Fcy;":"","&Ffr;":"","&FilledSmallSquare;":"","&FilledVerySmallSquare;":"","&Fopf;":"","&ForAll;":"","&Fouriertrf;":"","&Fscr;":"","&GJcy;":"","&GT":">","&GT;":">","&Gamma;":"","&Gammad;":"","&Gbreve;":"","&Gcedil;":"","&Gcirc;":"","&Gcy;":"","&Gdot;":"","&Gfr;":"","&Gg;":"","&Gopf;":"","&GreaterEqual;":"","&GreaterEqualLess;":"","&GreaterFullEqual;":"","&GreaterGreater;":"","&GreaterLess;":"","&GreaterSlantEqual;":"","&GreaterTilde;":"","&Gscr;":"","&Gt;":"","&HARDcy;":"","&Hacek;":"","&Hat;":"^","&Hcirc;":"","&Hfr;":"","&HilbertSpace;":"","&Hopf;":"","&HorizontalLine;":"","&Hscr;":"","&Hstrok;":"","&HumpDownHump;":"","&HumpEqual;":"","&IEcy;":"","&IJlig;":"","&IOcy;":"","&Iacute":"","&Iacute;":"","&Icirc":"","&Icirc;":"","&Icy;":"","&Idot;":"","&Ifr;":"","&Igrave":"","&Igrave;":"","&Im;":"","&Imacr;":"","&ImaginaryI;":"","&Implies;":"","&Int;":"","&Integral;":"","&Intersection;":"","&InvisibleComma;":"","&InvisibleTimes;":"","&Iogon;":"","&Iopf;":"","&Iota;":"","&Iscr;":"","&Itilde;":"","&Iukcy;":"","&Iuml":"","&Iuml;":"","&Jcirc;":"","&Jcy;":"","&Jfr;":"","&Jopf;":"","&Jscr;":"","&Jsercy;":"","&Jukcy;":"","&KHcy;":"","&KJcy;":"","&Kappa;":"","&Kcedil;":"","&Kcy;":"","&Kfr;":"","&Kopf;":"","&Kscr;":"","&LJcy;":"","&LT":"<","&LT;":"<","&Lacute;":"","&Lambda;":"","&Lang;":"","&Laplacetrf;":"","&Larr;":"","&Lcaron;":"","&Lcedil;":"","&Lcy;":"","&LeftAngleBracket;":"","&LeftArrow;":"","&LeftArrowBar;":"","&LeftArrowRightArrow;":"","&LeftCeiling;":"","&LeftDoubleBracket;":"","&LeftDownTeeVector;":"","&LeftDownVector;":"","&LeftDownVectorBar;":"","&LeftFloor;":"","&LeftRightArrow;":"","&LeftRightVector;":"","&LeftTee;":"","&LeftTeeArrow;":"","&LeftTeeVector;":"","&LeftTriangle;":"","&LeftTriangleBar;":"","&LeftTriangleEqual;":"","&LeftUpDownVector;":"","&LeftUpTeeVector;":"","&LeftUpVector;":"","&LeftUpVectorBar;":"","&LeftVector;":"","&LeftVectorBar;":"","&Leftarrow;":"","&Leftrightarrow;":"","&LessEqualGreater;":"","&LessFullEqual;":"","&LessGreater;":"","&LessLess;":"","&LessSlantEqual;":"","&LessTilde;":"","&Lfr;":"","&Ll;":"","&Lleftarrow;":"","&Lmidot;":"","&LongLeftArrow;":"","&LongLeftRightArrow;":"","&LongRightArrow;":"","&Longleftarrow;":"","&Longleftrightarrow;":"","&Longrightarrow;":"","&Lopf;":"","&LowerLeftArrow;":"","&LowerRightArrow;":"","&Lscr;":"","&Lsh;":"","&Lstrok;":"","&Lt;":"","&Map;":"","&Mcy;":"","&MediumSpace;":"","&Mellintrf;":"","&Mfr;":"","&MinusPlus;":"","&Mopf;":"","&Mscr;":"","&Mu;":"","&NJcy;":"","&Nacute;":"","&Ncaron;":"","&Ncedil;":"","&Ncy;":"","&NegativeMediumSpace;":"","&NegativeThickSpace;":"","&NegativeThinSpace;":"","&NegativeVeryThinSpace;":"","&NestedGreaterGreater;":"","&NestedLessLess;":"","&NewLine;":"\n","&Nfr;":"","&NoBreak;":"","&NonBreakingSpace;":"","&Nopf;":"","&Not;":"","&NotCongruent;":"","&NotCupCap;":"","&NotDoubleVerticalBar;":"","&NotElement;":"","&NotEqual;":"","&NotEqualTilde;":"","&NotExists;":"","&NotGreater;":"","&NotGreaterEqual;":"","&NotGreaterFullEqual;":"","&NotGreaterGreater;":"","&NotGreaterLess;":"","&NotGreaterSlantEqual;":"","&NotGreaterTilde;":"","&NotHumpDownHump;":"","&NotHumpEqual;":"","&NotLeftTriangle;":"","&NotLeftTriangleBar;":"","&NotLeftTriangleEqual;":"","&NotLess;":"","&NotLessEqual;":"","&NotLessGreater;":"","&NotLessLess;":"","&NotLessSlantEqual;":"","&NotLessTilde;":"","&NotNestedGreaterGreater;":"","&NotNestedLessLess;":"","&NotPrecedes;":"","&NotPrecedesEqual;":"","&NotPrecedesSlantEqual;":"","&NotReverseElement;":"","&NotRightTriangle;":"","&NotRightTriangleBar;":"","&NotRightTriangleEqual;":"","&NotSquareSubset;":"","&NotSquareSubsetEqual;":"","&NotSquareSuperset;":"","&NotSquareSupersetEqual;":"","&NotSubset;":"","&NotSubsetEqual;":"","&NotSucceeds;":"","&NotSucceedsEqual;":"","&NotSucceedsSlantEqual;":"","&NotSucceedsTilde;":"","&NotSuperset;":"","&NotSupersetEqual;":"","&NotTilde;":"","&NotTildeEqual;":"","&NotTildeFullEqual;":"","&NotTildeTilde;":"","&NotVerticalBar;":"","&Nscr;":"","&Ntilde":"","&Ntilde;":"","&Nu;":"","&OElig;":"","&Oacute":"","&Oacute;":"","&Ocirc":"","&Ocirc;":"","&Ocy;":"","&Odblac;":"","&Ofr;":"","&Ograve":"","&Ograve;":"","&Omacr;":"","&Omega;":"","&Omicron;":"","&Oopf;":"","&OpenCurlyDoubleQuote;":"","&OpenCurlyQuote;":"","&Or;":"","&Oscr;":"","&Oslash":"","&Oslash;":"","&Otilde":"","&Otilde;":"","&Otimes;":"","&Ouml":"","&Ouml;":"","&OverBar;":"","&OverBrace;":"","&OverBracket;":"","&OverParenthesis;":"","&PartialD;":"","&Pcy;":"","&Pfr;":"","&Phi;":"","&Pi;":"","&PlusMinus;":"","&Poincareplane;":"","&Popf;":"","&Pr;":"","&Precedes;":"","&PrecedesEqual;":"","&PrecedesSlantEqual;":"","&PrecedesTilde;":"","&Prime;":"","&Product;":"","&Proportion;":"","&Proportional;":"","&Pscr;":"","&Psi;":"","&QUOT":'"',"&QUOT;":'"',"&Qfr;":"","&Qopf;":"","&Qscr;":"","&RBarr;":"","&REG":"","&REG;":"","&Racute;":"","&Rang;":"","&Rarr;":"","&Rarrtl;":"","&Rcaron;":"","&Rcedil;":"","&Rcy;":"","&Re;":"","&ReverseElement;":"","&ReverseEquilibrium;":"","&ReverseUpEquilibrium;":"","&Rfr;":"","&Rho;":"","&RightAngleBracket;":"","&RightArrow;":"","&RightArrowBar;":"","&RightArrowLeftArrow;":"","&RightCeiling;":"","&RightDoubleBracket;":"","&RightDownTeeVector;":"","&RightDownVector;":"","&RightDownVectorBar;":"","&RightFloor;":"","&RightTee;":"","&RightTeeArrow;":"","&RightTeeVector;":"","&RightTriangle;":"","&RightTriangleBar;":"","&RightTriangleEqual;":"","&RightUpDownVector;":"","&RightUpTeeVector;":"","&RightUpVector;":"","&RightUpVectorBar;":"","&RightVector;":"","&RightVectorBar;":"","&Rightarrow;":"","&Ropf;":"","&RoundImplies;":"","&Rrightarrow;":"","&Rscr;":"","&Rsh;":"","&RuleDelayed;":"","&SHCHcy;":"","&SHcy;":"","&SOFTcy;":"","&Sacute;":"","&Sc;":"","&Scaron;":"","&Scedil;":"","&Scirc;":"","&Scy;":"","&Sfr;":"","&ShortDownArrow;":"","&ShortLeftArrow;":"","&ShortRightArrow;":"","&ShortUpArrow;":"","&Sigma;":"","&SmallCircle;":"","&Sopf;":"","&Sqrt;":"","&Square;":"","&SquareIntersection;":"","&SquareSubset;":"","&SquareSubsetEqual;":"","&SquareSuperset;":"","&SquareSupersetEqual;":"","&SquareUnion;":"","&Sscr;":"","&Star;":"","&Sub;":"","&Subset;":"","&SubsetEqual;":"","&Succeeds;":"","&SucceedsEqual;":"","&SucceedsSlantEqual;":"","&SucceedsTilde;":"","&SuchThat;":"","&Sum;":"","&Sup;":"","&Superset;":"","&SupersetEqual;":"","&Supset;":"","&THORN":"","&THORN;":"","&TRADE;":"","&TSHcy;":"","&TScy;":"","&Tab;":"\t","&Tau;":"","&Tcaron;":"","&Tcedil;":"","&Tcy;":"","&Tfr;":"","&Therefore;":"","&Theta;":"","&ThickSpace;":"","&ThinSpace;":"","&Tilde;":"","&TildeEqual;":"","&TildeFullEqual;":"","&TildeTilde;":"","&Topf;":"","&TripleDot;":"","&Tscr;":"","&Tstrok;":"","&Uacute":"","&Uacute;":"","&Uarr;":"","&Uarrocir;":"","&Ubrcy;":"","&Ubreve;":"","&Ucirc":"","&Ucirc;":"","&Ucy;":"","&Udblac;":"","&Ufr;":"","&Ugrave":"","&Ugrave;":"","&Umacr;":"","&UnderBar;":"_","&UnderBrace;":"","&UnderBracket;":"","&UnderParenthesis;":"","&Union;":"","&UnionPlus;":"","&Uogon;":"","&Uopf;":"","&UpArrow;":"","&UpArrowBar;":"","&UpArrowDownArrow;":"","&UpDownArrow;":"","&UpEquilibrium;":"","&UpTee;":"","&UpTeeArrow;":"","&Uparrow;":"","&Updownarrow;":"","&UpperLeftArrow;":"","&UpperRightArrow;":"","&Upsi;":"","&Upsilon;":"","&Uring;":"","&Uscr;":"","&Utilde;":"","&Uuml":"","&Uuml;":"","&VDash;":"","&Vbar;":"","&Vcy;":"","&Vdash;":"","&Vdashl;":"","&Vee;":"","&Verbar;":"","&Vert;":"","&VerticalBar;":"","&VerticalLine;":"|","&VerticalSeparator;":"","&VerticalTilde;":"","&VeryThinSpace;":"","&Vfr;":"","&Vopf;":"","&Vscr;":"","&Vvdash;":"","&Wcirc;":"","&Wedge;":"","&Wfr;":"","&Wopf;":"","&Wscr;":"","&Xfr;":"","&Xi;":"","&Xopf;":"","&Xscr;":"","&YAcy;":"","&YIcy;":"","&YUcy;":"","&Yacute":"","&Yacute;":"","&Ycirc;":"","&Ycy;":"","&Yfr;":"","&Yopf;":"","&Yscr;":"","&Yuml;":"","&ZHcy;":"","&Zacute;":"","&Zcaron;":"","&Zcy;":"","&Zdot;":"","&ZeroWidthSpace;":"","&Zeta;":"","&Zfr;":"","&Zopf;":"","&Zscr;":"","&aacute":"","&aacute;":"","&abreve;":"","&ac;":"","&acE;":"","&acd;":"","&acirc":"","&acirc;":"","&acute":"","&acute;":"","&acy;":"","&aelig":"","&aelig;":"","&af;":"","&afr;":"","&agrave":"","&agrave;":"","&alefsym;":"","&aleph;":"","&alpha;":"","&amacr;":"","&amalg;":"","&amp":"&","&amp;":"&","&and;":"","&andand;":"","&andd;":"","&andslope;":"","&andv;":"","&ang;":"","&ange;":"","&angle;":"","&angmsd;":"","&angmsdaa;":"","&angmsdab;":"","&angmsdac;":"","&angmsdad;":"","&angmsdae;":"","&angmsdaf;":"","&angmsdag;":"","&angmsdah;":"","&angrt;":"","&angrtvb;":"","&angrtvbd;":"","&angsph;":"","&angst;":"","&angzarr;":"","&aogon;":"","&aopf;":"","&ap;":"","&apE;":"","&apacir;":"","&ape;":"","&apid;":"","&apos;":"'","&approx;":"","&approxeq;":"","&aring":"","&aring;":"","&ascr;":"","&ast;":"*","&asymp;":"","&asympeq;":"","&atilde":"","&atilde;":"","&auml":"","&auml;":"","&awconint;":"","&awint;":"","&bNot;":"","&backcong;":"","&backepsilon;":"","&backprime;":"","&backsim;":"","&backsimeq;":"","&barvee;":"","&barwed;":"","&barwedge;":"","&bbrk;":"","&bbrktbrk;":"","&bcong;":"","&bcy;":"","&bdquo;":"","&becaus;":"","&because;":"","&bemptyv;":"","&bepsi;":"","&bernou;":"","&beta;":"","&beth;":"","&between;":"","&bfr;":"","&bigcap;":"","&bigcirc;":"","&bigcup;":"","&bigodot;":"","&bigoplus;":"","&bigotimes;":"","&bigsqcup;":"","&bigstar;":"","&bigtriangledown;":"","&bigtriangleup;":"","&biguplus;":"","&bigvee;":"","&bigwedge;":"","&bkarow;":"","&blacklozenge;":"","&blacksquare;":"","&blacktriangle;":"","&blacktriangledown;":"","&blacktriangleleft;":"","&blacktriangleright;":"","&blank;":"","&blk12;":"","&blk14;":"","&blk34;":"","&block;":"","&bne;":"=","&bnequiv;":"","&bnot;":"","&bopf;":"","&bot;":"","&bottom;":"","&bowtie;":"","&boxDL;":"","&boxDR;":"","&boxDl;":"","&boxDr;":"","&boxH;":"","&boxHD;":"","&boxHU;":"","&boxHd;":"","&boxHu;":"","&boxUL;":"","&boxUR;":"","&boxUl;":"","&boxUr;":"","&boxV;":"","&boxVH;":"","&boxVL;":"","&boxVR;":"","&boxVh;":"","&boxVl;":"","&boxVr;":"","&boxbox;":"","&boxdL;":"","&boxdR;":"","&boxdl;":"","&boxdr;":"","&boxh;":"","&boxhD;":"","&boxhU;":"","&boxhd;":"","&boxhu;":"","&boxminus;":"","&boxplus;":"","&boxtimes;":"","&boxuL;":"","&boxuR;":"","&boxul;":"","&boxur;":"","&boxv;":"","&boxvH;":"","&boxvL;":"","&boxvR;":"","&boxvh;":"","&boxvl;":"","&boxvr;":"","&bprime;":"","&breve;":"","&brvbar":"","&brvbar;":"","&bscr;":"","&bsemi;":"","&bsim;":"","&bsime;":"","&bsol;":"\\","&bsolb;":"","&bsolhsub;":"","&bull;":"","&bullet;":"","&bump;":"","&bumpE;":"","&bumpe;":"","&bumpeq;":"","&cacute;":"","&cap;":"","&capand;":"","&capbrcup;":"","&capcap;":"","&capcup;":"","&capdot;":"","&caps;":"","&caret;":"","&caron;":"","&ccaps;":"","&ccaron;":"","&ccedil":"","&ccedil;":"","&ccirc;":"","&ccups;":"","&ccupssm;":"","&cdot;":"","&cedil":"","&cedil;":"","&cemptyv;":"","&cent":"","&cent;":"","&centerdot;":"","&cfr;":"","&chcy;":"","&check;":"","&checkmark;":"","&chi;":"","&cir;":"","&cirE;":"","&circ;":"","&circeq;":"","&circlearrowleft;":"","&circlearrowright;":"","&circledR;":"","&circledS;":"","&circledast;":"","&circledcirc;":"","&circleddash;":"","&cire;":"","&cirfnint;":"","&cirmid;":"","&cirscir;":"","&clubs;":"","&clubsuit;":"","&colon;":":","&colone;":"","&coloneq;":"","&comma;":",","&commat;":"@","&comp;":"","&compfn;":"","&complement;":"","&complexes;":"","&cong;":"","&congdot;":"","&conint;":"","&copf;":"","&coprod;":"","&copy":"","&copy;":"","&copysr;":"","&crarr;":"","&cross;":"","&cscr;":"","&csub;":"","&csube;":"","&csup;":"","&csupe;":"","&ctdot;":"","&cudarrl;":"","&cudarrr;":"","&cuepr;":"","&cuesc;":"","&cularr;":"","&cularrp;":"","&cup;":"","&cupbrcap;":"","&cupcap;":"","&cupcup;":"","&cupdot;":"","&cupor;":"","&cups;":"","&curarr;":"","&curarrm;":"","&curlyeqprec;":"","&curlyeqsucc;":"","&curlyvee;":"","&curlywedge;":"","&curren":"","&curren;":"","&curvearrowleft;":"","&curvearrowright;":"","&cuvee;":"","&cuwed;":"","&cwconint;":"","&cwint;":"","&cylcty;":"","&dArr;":"","&dHar;":"","&dagger;":"","&daleth;":"","&darr;":"","&dash;":"","&dashv;":"","&dbkarow;":"","&dblac;":"","&dcaron;":"","&dcy;":"","&dd;":"","&ddagger;":"","&ddarr;":"","&ddotseq;":"","&deg":"","&deg;":"","&delta;":"","&demptyv;":"","&dfisht;":"","&dfr;":"","&dharl;":"","&dharr;":"","&diam;":"","&diamond;":"","&diamondsuit;":"","&diams;":"","&die;":"","&digamma;":"","&disin;":"","&div;":"","&divide":"","&divide;":"","&divideontimes;":"","&divonx;":"","&djcy;":"","&dlcorn;":"","&dlcrop;":"","&dollar;":"$","&dopf;":"","&dot;":"","&doteq;":"","&doteqdot;":"","&dotminus;":"","&dotplus;":"","&dotsquare;":"","&doublebarwedge;":"","&downarrow;":"","&downdownarrows;":"","&downharpoonleft;":"","&downharpoonright;":"","&drbkarow;":"","&drcorn;":"","&drcrop;":"","&dscr;":"","&dscy;":"","&dsol;":"","&dstrok;":"","&dtdot;":"","&dtri;":"","&dtrif;":"","&duarr;":"","&duhar;":"","&dwangle;":"","&dzcy;":"","&dzigrarr;":"","&eDDot;":"","&eDot;":"","&eacute":"","&eacute;":"","&easter;":"","&ecaron;":"","&ecir;":"","&ecirc":"","&ecirc;":"","&ecolon;":"","&ecy;":"","&edot;":"","&ee;":"","&efDot;":"","&efr;":"","&eg;":"","&egrave":"","&egrave;":"","&egs;":"","&egsdot;":"","&el;":"","&elinters;":"","&ell;":"","&els;":"","&elsdot;":"","&emacr;":"","&empty;":"","&emptyset;":"","&emptyv;":"","&emsp13;":"","&emsp14;":"","&emsp;":"","&eng;":"","&ensp;":"","&eogon;":"","&eopf;":"","&epar;":"","&eparsl;":"","&eplus;":"","&epsi;":"","&epsilon;":"","&epsiv;":"","&eqcirc;":"","&eqcolon;":"","&eqsim;":"","&eqslantgtr;":"","&eqslantless;":"","&equals;":"=","&equest;":"","&equiv;":"","&equivDD;":"","&eqvparsl;":"","&erDot;":"","&erarr;":"","&escr;":"","&esdot;":"","&esim;":"","&eta;":"","&eth":"","&eth;":"","&euml":"","&euml;":"","&euro;":"","&excl;":"!","&exist;":"","&expectation;":"","&exponentiale;":"","&fallingdotseq;":"","&fcy;":"","&female;":"","&ffilig;":"","&fflig;":"","&ffllig;":"","&ffr;":"","&filig;":"","&fjlig;":"fj","&flat;":"","&fllig;":"","&fltns;":"","&fnof;":"","&fopf;":"","&forall;":"","&fork;":"","&forkv;":"","&fpartint;":"","&frac12":"","&frac12;":"","&frac13;":"","&frac14":"","&frac14;":"","&frac15;":"","&frac16;":"","&frac18;":"","&frac23;":"","&frac25;":"","&frac34":"","&frac34;":"","&frac35;":"","&frac38;":"","&frac45;":"","&frac56;":"","&frac58;":"","&frac78;":"","&frasl;":"","&frown;":"","&fscr;":"","&gE;":"","&gEl;":"","&gacute;":"","&gamma;":"","&gammad;":"","&gap;":"","&gbreve;":"","&gcirc;":"","&gcy;":"","&gdot;":"","&ge;":"","&gel;":"","&geq;":"","&geqq;":"","&geqslant;":"","&ges;":"","&gescc;":"","&gesdot;":"","&gesdoto;":"","&gesdotol;":"","&gesl;":"","&gesles;":"","&gfr;":"","&gg;":"","&ggg;":"","&gimel;":"","&gjcy;":"","&gl;":"","&glE;":"","&gla;":"","&glj;":"","&gnE;":"","&gnap;":"","&gnapprox;":"","&gne;":"","&gneq;":"","&gneqq;":"","&gnsim;":"","&gopf;":"","&grave;":"`","&gscr;":"","&gsim;":"","&gsime;":"","&gsiml;":"","&gt":">","&gt;":">","&gtcc;":"","&gtcir;":"","&gtdot;":"","&gtlPar;":"","&gtquest;":"","&gtrapprox;":"","&gtrarr;":"","&gtrdot;":"","&gtreqless;":"","&gtreqqless;":"","&gtrless;":"","&gtrsim;":"","&gvertneqq;":"","&gvnE;":"","&hArr;":"","&hairsp;":"","&half;":"","&hamilt;":"","&hardcy;":"","&harr;":"","&harrcir;":"","&harrw;":"","&hbar;":"","&hcirc;":"","&hearts;":"","&heartsuit;":"","&hellip;":"","&hercon;":"","&hfr;":"","&hksearow;":"","&hkswarow;":"","&hoarr;":"","&homtht;":"","&hookleftarrow;":"","&hookrightarrow;":"","&hopf;":"","&horbar;":"","&hscr;":"","&hslash;":"","&hstrok;":"","&hybull;":"","&hyphen;":"","&iacute":"","&iacute;":"","&ic;":"","&icirc":"","&icirc;":"","&icy;":"","&iecy;":"","&iexcl":"","&iexcl;":"","&iff;":"","&ifr;":"","&igrave":"","&igrave;":"","&ii;":"","&iiiint;":"","&iiint;":"","&iinfin;":"","&iiota;":"","&ijlig;":"","&imacr;":"","&image;":"","&imagline;":"","&imagpart;":"","&imath;":"","&imof;":"","&imped;":"","&in;":"","&incare;":"","&infin;":"","&infintie;":"","&inodot;":"","&int;":"","&intcal;":"","&integers;":"","&intercal;":"","&intlarhk;":"","&intprod;":"","&iocy;":"","&iogon;":"","&iopf;":"","&iota;":"","&iprod;":"","&iquest":"","&iquest;":"","&iscr;":"","&isin;":"","&isinE;":"","&isindot;":"","&isins;":"","&isinsv;":"","&isinv;":"","&it;":"","&itilde;":"","&iukcy;":"","&iuml":"","&iuml;":"","&jcirc;":"","&jcy;":"","&jfr;":"","&jmath;":"","&jopf;":"","&jscr;":"","&jsercy;":"","&jukcy;":"","&kappa;":"","&kappav;":"","&kcedil;":"","&kcy;":"","&kfr;":"","&kgreen;":"","&khcy;":"","&kjcy;":"","&kopf;":"","&kscr;":"","&lAarr;":"","&lArr;":"","&lAtail;":"","&lBarr;":"","&lE;":"","&lEg;":"","&lHar;":"","&lacute;":"","&laemptyv;":"","&lagran;":"","&lambda;":"","&lang;":"","&langd;":"","&langle;":"","&lap;":"","&laquo":"","&laquo;":"","&larr;":"","&larrb;":"","&larrbfs;":"","&larrfs;":"","&larrhk;":"","&larrlp;":"","&larrpl;":"","&larrsim;":"","&larrtl;":"","&lat;":"","&latail;":"","&late;":"","&lates;":"","&lbarr;":"","&lbbrk;":"","&lbrace;":"{","&lbrack;":"[","&lbrke;":"","&lbrksld;":"","&lbrkslu;":"","&lcaron;":"","&lcedil;":"","&lceil;":"","&lcub;":"{","&lcy;":"","&ldca;":"","&ldquo;":"","&ldquor;":"","&ldrdhar;":"","&ldrushar;":"","&ldsh;":"","&le;":"","&leftarrow;":"","&leftarrowtail;":"","&leftharpoondown;":"","&leftharpoonup;":"","&leftleftarrows;":"","&leftrightarrow;":"","&leftrightarrows;":"","&leftrightharpoons;":"","&leftrightsquigarrow;":"","&leftthreetimes;":"","&leg;":"","&leq;":"","&leqq;":"","&leqslant;":"","&les;":"","&lescc;":"","&lesdot;":"","&lesdoto;":"","&lesdotor;":"","&lesg;":"","&lesges;":"","&lessapprox;":"","&lessdot;":"","&lesseqgtr;":"","&lesseqqgtr;":"","&lessgtr;":"","&lesssim;":"","&lfisht;":"","&lfloor;":"","&lfr;":"","&lg;":"","&lgE;":"","&lhard;":"","&lharu;":"","&lharul;":"","&lhblk;":"","&ljcy;":"","&ll;":"","&llarr;":"","&llcorner;":"","&llhard;":"","&lltri;":"","&lmidot;":"","&lmoust;":"","&lmoustache;":"","&lnE;":"","&lnap;":"","&lnapprox;":"","&lne;":"","&lneq;":"","&lneqq;":"","&lnsim;":"","&loang;":"","&loarr;":"","&lobrk;":"","&longleftarrow;":"","&longleftrightarrow;":"","&longmapsto;":"","&longrightarrow;":"","&looparrowleft;":"","&looparrowright;":"","&lopar;":"","&lopf;":"","&loplus;":"","&lotimes;":"","&lowast;":"","&lowbar;":"_","&loz;":"","&lozenge;":"","&lozf;":"","&lpar;":"(","&lparlt;":"","&lrarr;":"","&lrcorner;":"","&lrhar;":"","&lrhard;":"","&lrm;":"","&lrtri;":"","&lsaquo;":"","&lscr;":"","&lsh;":"","&lsim;":"","&lsime;":"","&lsimg;":"","&lsqb;":"[","&lsquo;":"","&lsquor;":"","&lstrok;":"","&lt":"<","&lt;":"<","&ltcc;":"","&ltcir;":"","&ltdot;":"","&lthree;":"","&ltimes;":"","&ltlarr;":"","&ltquest;":"","&ltrPar;":"","&ltri;":"","&ltrie;":"","&ltrif;":"","&lurdshar;":"","&luruhar;":"","&lvertneqq;":"","&lvnE;":"","&mDDot;":"","&macr":"","&macr;":"","&male;":"","&malt;":"","&maltese;":"","&map;":"","&mapsto;":"","&mapstodown;":"","&mapstoleft;":"","&mapstoup;":"","&marker;":"","&mcomma;":"","&mcy;":"","&mdash;":"","&measuredangle;":"","&mfr;":"","&mho;":"","&micro":"","&micro;":"","&mid;":"","&midast;":"*","&midcir;":"","&middot":"","&middot;":"","&minus;":"","&minusb;":"","&minusd;":"","&minusdu;":"","&mlcp;":"","&mldr;":"","&mnplus;":"","&models;":"","&mopf;":"","&mp;":"","&mscr;":"","&mstpos;":"","&mu;":"","&multimap;":"","&mumap;":"","&nGg;":"","&nGt;":"","&nGtv;":"","&nLeftarrow;":"","&nLeftrightarrow;":"","&nLl;":"","&nLt;":"","&nLtv;":"","&nRightarrow;":"","&nVDash;":"","&nVdash;":"","&nabla;":"","&nacute;":"","&nang;":"","&nap;":"","&napE;":"","&napid;":"","&napos;":"","&napprox;":"","&natur;":"","&natural;":"","&naturals;":"","&nbsp":"","&nbsp;":"","&nbump;":"","&nbumpe;":"","&ncap;":"","&ncaron;":"","&ncedil;":"","&ncong;":"","&ncongdot;":"","&ncup;":"","&ncy;":"","&ndash;":"","&ne;":"","&neArr;":"","&nearhk;":"","&nearr;":"","&nearrow;":"","&nedot;":"","&nequiv;":"","&nesear;":"","&nesim;":"","&nexist;":"","&nexists;":"","&nfr;":"","&ngE;":"","&nge;":"","&ngeq;":"","&ngeqq;":"","&ngeqslant;":"","&nges;":"","&ngsim;":"","&ngt;":"","&ngtr;":"","&nhArr;":"","&nharr;":"","&nhpar;":"","&ni;":"","&nis;":"","&nisd;":"","&niv;":"","&njcy;":"","&nlArr;":"","&nlE;":"","&nlarr;":"","&nldr;":"","&nle;":"","&nleftarrow;":"","&nleftrightarrow;":"","&nleq;":"","&nleqq;":"","&nleqslant;":"","&nles;":"","&nless;":"","&nlsim;":"","&nlt;":"","&nltri;":"","&nltrie;":"","&nmid;":"","&nopf;":"","&not":"","&not;":"","&notin;":"","&notinE;":"","&notindot;":"","&notinva;":"","&notinvb;":"","&notinvc;":"","&notni;":"","&notniva;":"","&notnivb;":"","&notnivc;":"","&npar;":"","&nparallel;":"","&nparsl;":"","&npart;":"","&npolint;":"","&npr;":"","&nprcue;":"","&npre;":"","&nprec;":"","&npreceq;":"","&nrArr;":"","&nrarr;":"","&nrarrc;":"","&nrarrw;":"","&nrightarrow;":"","&nrtri;":"","&nrtrie;":"","&nsc;":"","&nsccue;":"","&nsce;":"","&nscr;":"","&nshortmid;":"","&nshortparallel;":"","&nsim;":"","&nsime;":"","&nsimeq;":"","&nsmid;":"","&nspar;":"","&nsqsube;":"","&nsqsupe;":"","&nsub;":"","&nsubE;":"","&nsube;":"","&nsubset;":"","&nsubseteq;":"","&nsubseteqq;":"","&nsucc;":"","&nsucceq;":"","&nsup;":"","&nsupE;":"","&nsupe;":"","&nsupset;":"","&nsupseteq;":"","&nsupseteqq;":"","&ntgl;":"","&ntilde":"","&ntilde;":"","&ntlg;":"","&ntriangleleft;":"","&ntrianglelefteq;":"","&ntriangleright;":"","&ntrianglerighteq;":"","&nu;":"","&num;":"#","&numero;":"","&numsp;":"","&nvDash;":"","&nvHarr;":"","&nvap;":"","&nvdash;":"","&nvge;":"","&nvgt;":">","&nvinfin;":"","&nvlArr;":"","&nvle;":"","&nvlt;":"<","&nvltrie;":"","&nvrArr;":"","&nvrtrie;":"","&nvsim;":"","&nwArr;":"","&nwarhk;":"","&nwarr;":"","&nwarrow;":"","&nwnear;":"","&oS;":"","&oacute":"","&oacute;":"","&oast;":"","&ocir;":"","&ocirc":"","&ocirc;":"","&ocy;":"","&odash;":"","&odblac;":"","&odiv;":"","&odot;":"","&odsold;":"","&oelig;":"","&ofcir;":"","&ofr;":"","&ogon;":"","&ograve":"","&ograve;":"","&ogt;":"","&ohbar;":"","&ohm;":"","&oint;":"","&olarr;":"","&olcir;":"","&olcross;":"","&oline;":"","&olt;":"","&omacr;":"","&omega;":"","&omicron;":"","&omid;":"","&ominus;":"","&oopf;":"","&opar;":"","&operp;":"","&oplus;":"","&or;":"","&orarr;":"","&ord;":"","&order;":"","&orderof;":"","&ordf":"","&ordf;":"","&ordm":"","&ordm;":"","&origof;":"","&oror;":"","&orslope;":"","&orv;":"","&oscr;":"","&oslash":"","&oslash;":"","&osol;":"","&otilde":"","&otilde;":"","&otimes;":"","&otimesas;":"","&ouml":"","&ouml;":"","&ovbar;":"","&par;":"","&para":"","&para;":"","&parallel;":"","&parsim;":"","&parsl;":"","&part;":"","&pcy;":"","&percnt;":"%","&period;":".","&permil;":"","&perp;":"","&pertenk;":"","&pfr;":"","&phi;":"","&phiv;":"","&phmmat;":"","&phone;":"","&pi;":"","&pitchfork;":"","&piv;":"","&planck;":"","&planckh;":"","&plankv;":"","&plus;":"+","&plusacir;":"","&plusb;":"","&pluscir;":"","&plusdo;":"","&plusdu;":"","&pluse;":"","&plusmn":"","&plusmn;":"","&plussim;":"","&plustwo;":"","&pm;":"","&pointint;":"","&popf;":"","&pound":"","&pound;":"","&pr;":"","&prE;":"","&prap;":"","&prcue;":"","&pre;":"","&prec;":"","&precapprox;":"","&preccurlyeq;":"","&preceq;":"","&precnapprox;":"","&precneqq;":"","&precnsim;":"","&precsim;":"","&prime;":"","&primes;":"","&prnE;":"","&prnap;":"","&prnsim;":"","&prod;":"","&profalar;":"","&profline;":"","&profsurf;":"","&prop;":"","&propto;":"","&prsim;":"","&prurel;":"","&pscr;":"","&psi;":"","&puncsp;":"","&qfr;":"","&qint;":"","&qopf;":"","&qprime;":"","&qscr;":"","&quaternions;":"","&quatint;":"","&quest;":"?","&questeq;":"","&quot":'"',"&quot;":'"',"&rAarr;":"","&rArr;":"","&rAtail;":"","&rBarr;":"","&rHar;":"","&race;":"","&racute;":"","&radic;":"","&raemptyv;":"","&rang;":"","&rangd;":"","&range;":"","&rangle;":"","&raquo":"","&raquo;":"","&rarr;":"","&rarrap;":"","&rarrb;":"","&rarrbfs;":"","&rarrc;":"","&rarrfs;":"","&rarrhk;":"","&rarrlp;":"","&rarrpl;":"","&rarrsim;":"","&rarrtl;":"","&rarrw;":"","&ratail;":"","&ratio;":"","&rationals;":"","&rbarr;":"","&rbbrk;":"","&rbrace;":"}","&rbrack;":"]","&rbrke;":"","&rbrksld;":"","&rbrkslu;":"","&rcaron;":"","&rcedil;":"","&rceil;":"","&rcub;":"}","&rcy;":"","&rdca;":"","&rdldhar;":"","&rdquo;":"","&rdquor;":"","&rdsh;":"","&real;":"","&realine;":"","&realpart;":"","&reals;":"","&rect;":"","&reg":"","&reg;":"","&rfisht;":"","&rfloor;":"","&rfr;":"","&rhard;":"","&rharu;":"","&rharul;":"","&rho;":"","&rhov;":"","&rightarrow;":"","&rightarrowtail;":"","&rightharpoondown;":"","&rightharpoonup;":"","&rightleftarrows;":"","&rightleftharpoons;":"","&rightrightarrows;":"","&rightsquigarrow;":"","&rightthreetimes;":"","&ring;":"","&risingdotseq;":"","&rlarr;":"","&rlhar;":"","&rlm;":"","&rmoust;":"","&rmoustache;":"","&rnmid;":"","&roang;":"","&roarr;":"","&robrk;":"","&ropar;":"","&ropf;":"","&roplus;":"","&rotimes;":"","&rpar;":")","&rpargt;":"","&rppolint;":"","&rrarr;":"","&rsaquo;":"","&rscr;":"","&rsh;":"","&rsqb;":"]","&rsquo;":"","&rsquor;":"","&rthree;":"","&rtimes;":"","&rtri;":"","&rtrie;":"","&rtrif;":"","&rtriltri;":"","&ruluhar;":"","&rx;":"","&sacute;":"","&sbquo;":"","&sc;":"","&scE;":"","&scap;":"","&scaron;":"","&sccue;":"","&sce;":"","&scedil;":"","&scirc;":"","&scnE;":"","&scnap;":"","&scnsim;":"","&scpolint;":"","&scsim;":"","&scy;":"","&sdot;":"","&sdotb;":"","&sdote;":"","&seArr;":"","&searhk;":"","&searr;":"","&searrow;":"","&sect":"","&sect;":"","&semi;":";","&seswar;":"","&setminus;":"","&setmn;":"","&sext;":"","&sfr;":"","&sfrown;":"","&sharp;":"","&shchcy;":"","&shcy;":"","&shortmid;":"","&shortparallel;":"","&shy":"","&shy;":"","&sigma;":"","&sigmaf;":"","&sigmav;":"","&sim;":"","&simdot;":"","&sime;":"","&simeq;":"","&simg;":"","&simgE;":"","&siml;":"","&simlE;":"","&simne;":"","&simplus;":"","&simrarr;":"","&slarr;":"","&smallsetminus;":"","&smashp;":"","&smeparsl;":"","&smid;":"","&smile;":"","&smt;":"","&smte;":"","&smtes;":"","&softcy;":"","&sol;":"/","&solb;":"","&solbar;":"","&sopf;":"","&spades;":"","&spadesuit;":"","&spar;":"","&sqcap;":"","&sqcaps;":"","&sqcup;":"","&sqcups;":"","&sqsub;":"","&sqsube;":"","&sqsubset;":"","&sqsubseteq;":"","&sqsup;":"","&sqsupe;":"","&sqsupset;":"","&sqsupseteq;":"","&squ;":"","&square;":"","&squarf;":"","&squf;":"","&srarr;":"","&sscr;":"","&ssetmn;":"","&ssmile;":"","&sstarf;":"","&star;":"","&starf;":"","&straightepsilon;":"","&straightphi;":"","&strns;":"","&sub;":"","&subE;":"","&subdot;":"","&sube;":"","&subedot;":"","&submult;":"","&subnE;":"","&subne;":"","&subplus;":"","&subrarr;":"","&subset;":"","&subseteq;":"","&subseteqq;":"","&subsetneq;":"","&subsetneqq;":"","&subsim;":"","&subsub;":"","&subsup;":"","&succ;":"","&succapprox;":"","&succcurlyeq;":"","&succeq;":"","&succnapprox;":"","&succneqq;":"","&succnsim;":"","&succsim;":"","&sum;":"","&sung;":"","&sup1":"","&sup1;":"","&sup2":"","&sup2;":"","&sup3":"","&sup3;":"","&sup;":"","&supE;":"","&supdot;":"","&supdsub;":"","&supe;":"","&supedot;":"","&suphsol;":"","&suphsub;":"","&suplarr;":"","&supmult;":"","&supnE;":"","&supne;":"","&supplus;":"","&supset;":"","&supseteq;":"","&supseteqq;":"","&supsetneq;":"","&supsetneqq;":"","&supsim;":"","&supsub;":"","&supsup;":"","&swArr;":"","&swarhk;":"","&swarr;":"","&swarrow;":"","&swnwar;":"","&szlig":"","&szlig;":"","&target;":"","&tau;":"","&tbrk;":"","&tcaron;":"","&tcedil;":"","&tcy;":"","&tdot;":"","&telrec;":"","&tfr;":"","&there4;":"","&therefore;":"","&theta;":"","&thetasym;":"","&thetav;":"","&thickapprox;":"","&thicksim;":"","&thinsp;":"","&thkap;":"","&thksim;":"","&thorn":"","&thorn;":"","&tilde;":"","&times":"","&times;":"","&timesb;":"","&timesbar;":"","&timesd;":"","&tint;":"","&toea;":"","&top;":"","&topbot;":"","&topcir;":"","&topf;":"","&topfork;":"","&tosa;":"","&tprime;":"","&trade;":"","&triangle;":"","&triangledown;":"","&triangleleft;":"","&trianglelefteq;":"","&triangleq;":"","&triangleright;":"","&trianglerighteq;":"","&tridot;":"","&trie;":"","&triminus;":"","&triplus;":"","&trisb;":"","&tritime;":"","&trpezium;":"","&tscr;":"","&tscy;":"","&tshcy;":"","&tstrok;":"","&twixt;":"","&twoheadleftarrow;":"","&twoheadrightarrow;":"","&uArr;":"","&uHar;":"","&uacute":"","&uacute;":"","&uarr;":"","&ubrcy;":"","&ubreve;":"","&ucirc":"","&ucirc;":"","&ucy;":"","&udarr;":"","&udblac;":"","&udhar;":"","&ufisht;":"","&ufr;":"","&ugrave":"","&ugrave;":"","&uharl;":"","&uharr;":"","&uhblk;":"","&ulcorn;":"","&ulcorner;":"","&ulcrop;":"","&ultri;":"","&umacr;":"","&uml":"","&uml;":"","&uogon;":"","&uopf;":"","&uparrow;":"","&updownarrow;":"","&upharpoonleft;":"","&upharpoonright;":"","&uplus;":"","&upsi;":"","&upsih;":"","&upsilon;":"","&upuparrows;":"","&urcorn;":"","&urcorner;":"","&urcrop;":"","&uring;":"","&urtri;":"","&uscr;":"","&utdot;":"","&utilde;":"","&utri;":"","&utrif;":"","&uuarr;":"","&uuml":"","&uuml;":"","&uwangle;":"","&vArr;":"","&vBar;":"","&vBarv;":"","&vDash;":"","&vangrt;":"","&varepsilon;":"","&varkappa;":"","&varnothing;":"","&varphi;":"","&varpi;":"","&varpropto;":"","&varr;":"","&varrho;":"","&varsigma;":"","&varsubsetneq;":"","&varsubsetneqq;":"","&varsupsetneq;":"","&varsupsetneqq;":"","&vartheta;":"","&vartriangleleft;":"","&vartriangleright;":"","&vcy;":"","&vdash;":"","&vee;":"","&veebar;":"","&veeeq;":"","&vellip;":"","&verbar;":"|","&vert;":"|","&vfr;":"","&vltri;":"","&vnsub;":"","&vnsup;":"","&vopf;":"","&vprop;":"","&vrtri;":"","&vscr;":"","&vsubnE;":"","&vsubne;":"","&vsupnE;":"","&vsupne;":"","&vzigzag;":"","&wcirc;":"","&wedbar;":"","&wedge;":"","&wedgeq;":"","&weierp;":"","&wfr;":"","&wopf;":"","&wp;":"","&wr;":"","&wreath;":"","&wscr;":"","&xcap;":"","&xcirc;":"","&xcup;":"","&xdtri;":"","&xfr;":"","&xhArr;":"","&xharr;":"","&xi;":"","&xlArr;":"","&xlarr;":"","&xmap;":"","&xnis;":"","&xodot;":"","&xopf;":"","&xoplus;":"","&xotime;":"","&xrArr;":"","&xrarr;":"","&xscr;":"","&xsqcup;":"","&xuplus;":"","&xutri;":"","&xvee;":"","&xwedge;":"","&yacute":"","&yacute;":"","&yacy;":"","&ycirc;":"","&ycy;":"","&yen":"","&yen;":"","&yfr;":"","&yicy;":"","&yopf;":"","&yscr;":"","&yucy;":"","&yuml":"","&yuml;":"","&zacute;":"","&zcaron;":"","&zcy;":"","&zdot;":"","&zeetrf;":"","&zeta;":"","&zfr;":"","&zhcy;":"","&zigrarr;":"","&zopf;":"","&zscr;":"","&zwj;":"","&zwnj;":""},characters:{"":"&AElig;","&":"&amp;","":"&Aacute;","":"&Abreve;","":"&Acirc;","":"&Acy;","":"&Afr;","":"&Agrave;","":"&Alpha;","":"&Amacr;","":"&And;","":"&Aogon;","":"&Aopf;","":"&af;","":"&angst;","":"&Ascr;","":"&coloneq;","":"&Atilde;","":"&Auml;","":"&ssetmn;","":"&Barv;","":"&doublebarwedge;","":"&Bcy;","":"&because;","":"&bernou;","":"&Beta;","":"&Bfr;","":"&Bopf;","":"&breve;","":"&bump;","":"&CHcy;","":"&copy;","":"&Cacute;","":"&Cap;","":"&DD;","":"&Cfr;","":"&Ccaron;","":"&Ccedil;","":"&Ccirc;","":"&Cconint;","":"&Cdot;","":"&cedil;","":"&middot;","":"&Chi;","":"&odot;","":"&ominus;","":"&oplus;","":"&otimes;","":"&cwconint;","":"&rdquor;","":"&rsquor;","":"&Proportion;","":"&Colone;","":"&equiv;","":"&DoubleContourIntegral;","":"&oint;","":"&complexes;","":"&coprod;","":"&awconint;","":"&Cross;","":"&Cscr;","":"&Cup;","":"&asympeq;","":"&DDotrahd;","":"&DJcy;","":"&DScy;","":"&DZcy;","":"&ddagger;","":"&Darr;","":"&DoubleLeftTee;","":"&Dcaron;","":"&Dcy;","":"&nabla;","":"&Delta;","":"&Dfr;","":"&acute;","":"&dot;","":"&dblac;","`":"&grave;","":"&tilde;","":"&diamond;","":"&dd;","":"&Dopf;","":"&uml;","":"&DotDot;","":"&esdot;","":"&dArr;","":"&lArr;","":"&iff;","":"&xlArr;","":"&xhArr;","":"&xrArr;","":"&rArr;","":"&vDash;","":"&uArr;","":"&vArr;","":"&spar;","":"&downarrow;","":"&DownArrowBar;","":"&duarr;","":"&DownBreve;","":"&DownLeftRightVector;","":"&DownLeftTeeVector;","":"&lhard;","":"&DownLeftVectorBar;","":"&DownRightTeeVector;","":"&rightharpoondown;","":"&DownRightVectorBar;","":"&top;","":"&mapstodown;","":"&Dscr;","":"&Dstrok;","":"&ENG;","":"&ETH;","":"&Eacute;","":"&Ecaron;","":"&Ecirc;","":"&Ecy;","":"&Edot;","":"&Efr;","":"&Egrave;","":"&isinv;","":"&Emacr;","":"&EmptySmallSquare;","":"&EmptyVerySmallSquare;","":"&Eogon;","":"&Eopf;","":"&Epsilon;","":"&Equal;","":"&esim;","":"&rlhar;","":"&expectation;","":"&Esim;","":"&Eta;","":"&Euml;","":"&exist;","":"&exponentiale;","":"&Fcy;","":"&Ffr;","":"&FilledSmallSquare;","":"&squf;","":"&Fopf;","":"&forall;","":"&Fscr;","":"&GJcy;",">":"&gt;","":"&Gamma;","":"&Gammad;","":"&Gbreve;","":"&Gcedil;","":"&Gcirc;","":"&Gcy;","":"&Gdot;","":"&Gfr;","":"&ggg;","":"&Gopf;","":"&geq;","":"&gtreqless;","":"&geqq;","":"&GreaterGreater;","":"&gtrless;","":"&ges;","":"&gtrsim;","":"&Gscr;","":"&gg;","":"&HARDcy;","":"&caron;","^":"&Hat;","":"&Hcirc;","":"&Poincareplane;","":"&hamilt;","":"&quaternions;","":"&boxh;","":"&Hstrok;","":"&bumpeq;","":"&IEcy;","":"&IJlig;","":"&IOcy;","":"&Iacute;","":"&Icirc;","":"&Icy;","":"&Idot;","":"&imagpart;","":"&Igrave;","":"&Imacr;","":"&ii;","":"&Int;","":"&int;","":"&xcap;","":"&ic;","":"&it;","":"&Iogon;","":"&Iopf;","":"&Iota;","":"&imagline;","":"&Itilde;","":"&Iukcy;","":"&Iuml;","":"&Jcirc;","":"&Jcy;","":"&Jfr;","":"&Jopf;","":"&Jscr;","":"&Jsercy;","":"&Jukcy;","":"&KHcy;","":"&KJcy;","":"&Kappa;","":"&Kcedil;","":"&Kcy;","":"&Kfr;","":"&Kopf;","":"&Kscr;","":"&LJcy;","<":"&lt;","":"&Lacute;","":"&Lambda;","":"&Lang;","":"&lagran;","":"&twoheadleftarrow;","":"&Lcaron;","":"&Lcedil;","":"&Lcy;","":"&langle;","":"&slarr;","":"&larrb;","":"&lrarr;","":"&lceil;","":"&lobrk;","":"&LeftDownTeeVector;","":"&downharpoonleft;","":"&LeftDownVectorBar;","":"&lfloor;","":"&leftrightarrow;","":"&LeftRightVector;","":"&dashv;","":"&mapstoleft;","":"&LeftTeeVector;","":"&vltri;","":"&LeftTriangleBar;","":"&trianglelefteq;","":"&LeftUpDownVector;","":"&LeftUpTeeVector;","":"&upharpoonleft;","":"&LeftUpVectorBar;","":"&lharu;","":"&LeftVectorBar;","":"&lesseqgtr;","":"&leqq;","":"&lg;","":"&LessLess;","":"&les;","":"&lsim;","":"&Lfr;","":"&Ll;","":"&lAarr;","":"&Lmidot;","":"&xlarr;","":"&xharr;","":"&xrarr;","":"&Lopf;","":"&swarrow;","":"&searrow;","":"&lsh;","":"&Lstrok;","":"&ll;","":"&Map;","":"&Mcy;","":"&MediumSpace;","":"&phmmat;","":"&Mfr;","":"&mp;","":"&Mopf;","":"&Mu;","":"&NJcy;","":"&Nacute;","":"&Ncaron;","":"&Ncedil;","":"&Ncy;","":"&ZeroWidthSpace;","\n":"&NewLine;","":"&Nfr;","":"&NoBreak;","":"&nbsp;","":"&naturals;","":"&Not;","":"&nequiv;","":"&NotCupCap;","":"&nspar;","":"&notinva;","":"&ne;","":"&nesim;","":"&nexists;","":"&ngtr;","":"&ngeq;","":"&ngeqq;","":"&nGtv;","":"&ntgl;","":"&nges;","":"&ngsim;","":"&nbump;","":"&nbumpe;","":"&ntriangleleft;","":"&NotLeftTriangleBar;","":"&ntrianglelefteq;","":"&nlt;","":"&nleq;","":"&ntlg;","":"&nLtv;","":"&nles;","":"&nlsim;","":"&NotNestedGreaterGreater;","":"&NotNestedLessLess;","":"&nprec;","":"&npreceq;","":"&nprcue;","":"&notniva;","":"&ntriangleright;","":"&NotRightTriangleBar;","":"&ntrianglerighteq;","":"&NotSquareSubset;","":"&nsqsube;","":"&NotSquareSuperset;","":"&nsqsupe;","":"&vnsub;","":"&nsubseteq;","":"&nsucc;","":"&nsucceq;","":"&nsccue;","":"&NotSucceedsTilde;","":"&vnsup;","":"&nsupseteq;","":"&nsim;","":"&nsimeq;","":"&ncong;","":"&napprox;","":"&nsmid;","":"&Nscr;","":"&Ntilde;","":"&Nu;","":"&OElig;","":"&Oacute;","":"&Ocirc;","":"&Ocy;","":"&Odblac;","":"&Ofr;","":"&Ograve;","":"&Omacr;","":"&ohm;","":"&Omicron;","":"&Oopf;","":"&ldquo;","":"&lsquo;","":"&Or;","":"&Oscr;","":"&Oslash;","":"&Otilde;","":"&Otimes;","":"&Ouml;","":"&oline;","":"&OverBrace;","":"&tbrk;","":"&OverParenthesis;","":"&part;","":"&Pcy;","":"&Pfr;","":"&Phi;","":"&Pi;","":"&pm;","":"&primes;","":"&Pr;","":"&prec;","":"&preceq;","":"&preccurlyeq;","":"&prsim;","":"&Prime;","":"&prod;","":"&vprop;","":"&Pscr;","":"&Psi;",'"':"&quot;","":"&Qfr;","":"&rationals;","":"&Qscr;","":"&drbkarow;","":"&reg;","":"&Racute;","":"&Rang;","":"&twoheadrightarrow;","":"&Rarrtl;","":"&Rcaron;","":"&Rcedil;","":"&Rcy;","":"&realpart;","":"&niv;","":"&lrhar;","":"&duhar;","":"&Rho;","":"&rangle;","":"&srarr;","":"&rarrb;","":"&rlarr;","":"&rceil;","":"&robrk;","":"&RightDownTeeVector;","":"&downharpoonright;","":"&RightDownVectorBar;","":"&rfloor;","":"&vdash;","":"&mapsto;","":"&RightTeeVector;","":"&vrtri;","":"&RightTriangleBar;","":"&trianglerighteq;","":"&RightUpDownVector;","":"&RightUpTeeVector;","":"&upharpoonright;","":"&RightUpVectorBar;","":"&rightharpoonup;","":"&RightVectorBar;","":"&reals;","":"&RoundImplies;","":"&rAarr;","":"&realine;","":"&rsh;","":"&RuleDelayed;","":"&SHCHcy;","":"&SHcy;","":"&SOFTcy;","":"&Sacute;","":"&Sc;","":"&Scaron;","":"&Scedil;","":"&Scirc;","":"&Scy;","":"&Sfr;","":"&uparrow;","":"&Sigma;","":"&compfn;","":"&Sopf;","":"&radic;","":"&square;","":"&sqcap;","":"&sqsubset;","":"&sqsubseteq;","":"&sqsupset;","":"&sqsupseteq;","":"&sqcup;","":"&Sscr;","":"&sstarf;","":"&Subset;","":"&subseteq;","":"&succ;","":"&succeq;","":"&succcurlyeq;","":"&succsim;","":"&sum;","":"&Supset;","":"&supset;","":"&supseteq;","":"&THORN;","":"&trade;","":"&TSHcy;","":"&TScy;","\t":"&Tab;","":"&Tau;","":"&Tcaron;","":"&Tcedil;","":"&Tcy;","":"&Tfr;","":"&therefore;","":"&Theta;","":"&ThickSpace;","":"&thinsp;","":"&thksim;","":"&simeq;","":"&cong;","":"&thkap;","":"&Topf;","":"&tdot;","":"&Tscr;","":"&Tstrok;","":"&Uacute;","":"&Uarr;","":"&Uarrocir;","":"&Ubrcy;","":"&Ubreve;","":"&Ucirc;","":"&Ucy;","":"&Udblac;","":"&Ufr;","":"&Ugrave;","":"&Umacr;",_:"&lowbar;","":"&UnderBrace;","":"&bbrk;","":"&UnderParenthesis;","":"&xcup;","":"&uplus;","":"&Uogon;","":"&Uopf;","":"&UpArrowBar;","":"&udarr;","":"&varr;","":"&udhar;","":"&perp;","":"&mapstoup;","":"&nwarrow;","":"&nearrow;","":"&upsih;","":"&Upsilon;","":"&Uring;","":"&Uscr;","":"&Utilde;","":"&Uuml;","":"&VDash;","":"&Vbar;","":"&Vcy;","":"&Vdash;","":"&Vdashl;","":"&xvee;","":"&Vert;","":"&smid;","|":"&vert;","":"&VerticalSeparator;","":"&wreath;","":"&hairsp;","":"&Vfr;","":"&Vopf;","":"&Vscr;","":"&Vvdash;","":"&Wcirc;","":"&xwedge;","":"&Wfr;","":"&Wopf;","":"&Wscr;","":"&Xfr;","":"&Xi;","":"&Xopf;","":"&Xscr;","":"&YAcy;","":"&YIcy;","":"&YUcy;","":"&Yacute;","":"&Ycirc;","":"&Ycy;","":"&Yfr;","":"&Yopf;","":"&Yscr;","":"&Yuml;","":"&ZHcy;","":"&Zacute;","":"&Zcaron;","":"&Zcy;","":"&Zdot;","":"&Zeta;","":"&zeetrf;","":"&integers;","":"&Zscr;","":"&aacute;","":"&abreve;","":"&mstpos;","":"&acE;","":"&acd;","":"&acirc;","":"&acy;","":"&aelig;","":"&afr;","":"&agrave;","":"&aleph;","":"&alpha;","":"&amacr;","":"&amalg;","":"&wedge;","":"&andand;","":"&andd;","":"&andslope;","":"&andv;","":"&angle;","":"&ange;","":"&measuredangle;","":"&angmsdaa;","":"&angmsdab;","":"&angmsdac;","":"&angmsdad;","":"&angmsdae;","":"&angmsdaf;","":"&angmsdag;","":"&angmsdah;","":"&angrt;","":"&angrtvb;","":"&angrtvbd;","":"&angsph;","":"&angzarr;","":"&aogon;","":"&aopf;","":"&apE;","":"&apacir;","":"&approxeq;","":"&apid;","'":"&apos;","":"&aring;","":"&ascr;","*":"&midast;","":"&atilde;","":"&auml;","":"&awint;","":"&bNot;","":"&bcong;","":"&bepsi;","":"&bprime;","":"&bsim;","":"&bsime;","":"&barvee;","":"&barwedge;","":"&bbrktbrk;","":"&bcy;","":"&ldquor;","":"&bemptyv;","":"&beta;","":"&beth;","":"&twixt;","":"&bfr;","":"&xcirc;","":"&xodot;","":"&xoplus;","":"&xotime;","":"&xsqcup;","":"&starf;","":"&xdtri;","":"&xutri;","":"&xuplus;","":"&rbarr;","":"&lozf;","":"&utrif;","":"&dtrif;","":"&ltrif;","":"&rtrif;","":"&blank;","":"&blk12;","":"&blk14;","":"&blk34;","":"&block;","=":"&bne;","":"&bnequiv;","":"&bnot;","":"&bopf;","":"&bowtie;","":"&boxDL;","":"&boxDR;","":"&boxDl;","":"&boxDr;","":"&boxH;","":"&boxHD;","":"&boxHU;","":"&boxHd;","":"&boxHu;","":"&boxUL;","":"&boxUR;","":"&boxUl;","":"&boxUr;","":"&boxV;","":"&boxVH;","":"&boxVL;","":"&boxVR;","":"&boxVh;","":"&boxVl;","":"&boxVr;","":"&boxbox;","":"&boxdL;","":"&boxdR;","":"&boxdl;","":"&boxdr;","":"&boxhD;","":"&boxhU;","":"&boxhd;","":"&boxhu;","":"&minusb;","":"&plusb;","":"&timesb;","":"&boxuL;","":"&boxuR;","":"&boxul;","":"&boxur;","":"&boxv;","":"&boxvH;","":"&boxvL;","":"&boxvR;","":"&boxvh;","":"&boxvl;","":"&boxvr;","":"&brvbar;","":"&bscr;","":"&bsemi;","\\":"&bsol;","":"&bsolb;","":"&bsolhsub;","":"&bullet;","":"&bumpE;","":"&cacute;","":"&cap;","":"&capand;","":"&capbrcup;","":"&capcap;","":"&capcup;","":"&capdot;","":"&caps;","":"&caret;","":"&ccaps;","":"&ccaron;","":"&ccedil;","":"&ccirc;","":"&ccups;","":"&ccupssm;","":"&cdot;","":"&cemptyv;","":"&cent;","":"&cfr;","":"&chcy;","":"&checkmark;","":"&chi;","":"&cir;","":"&cirE;","":"&circ;","":"&cire;","":"&olarr;","":"&orarr;","":"&oS;","":"&oast;","":"&ocir;","":"&odash;","":"&cirfnint;","":"&cirmid;","":"&cirscir;","":"&clubsuit;",":":"&colon;",",":"&comma;","@":"&commat;","":"&complement;","":"&congdot;","":"&copf;","":"&copysr;","":"&crarr;","":"&cross;","":"&cscr;","":"&csub;","":"&csube;","":"&csup;","":"&csupe;","":"&ctdot;","":"&cudarrl;","":"&cudarrr;","":"&curlyeqprec;","":"&curlyeqsucc;","":"&curvearrowleft;","":"&cularrp;","":"&cup;","":"&cupbrcap;","":"&cupcap;","":"&cupcup;","":"&cupdot;","":"&cupor;","":"&cups;","":"&curvearrowright;","":"&curarrm;","":"&cuvee;","":"&cuwed;","":"&curren;","":"&cwint;","":"&cylcty;","":"&dHar;","":"&dagger;","":"&daleth;","":"&hyphen;","":"&rBarr;","":"&dcaron;","":"&dcy;","":"&downdownarrows;","":"&eDDot;","":"&deg;","":"&delta;","":"&demptyv;","":"&dfisht;","":"&dfr;","":"&diams;","":"&gammad;","":"&disin;","":"&divide;","":"&divonx;","":"&djcy;","":"&llcorner;","":"&dlcrop;",$:"&dollar;","":"&dopf;","":"&eDot;","":"&minusd;","":"&plusdo;","":"&sdotb;","":"&lrcorner;","":"&drcrop;","":"&dscr;","":"&dscy;","":"&dsol;","":"&dstrok;","":"&dtdot;","":"&triangledown;","":"&dwangle;","":"&dzcy;","":"&dzigrarr;","":"&eacute;","":"&easter;","":"&ecaron;","":"&eqcirc;","":"&ecirc;","":"&eqcolon;","":"&ecy;","":"&edot;","":"&fallingdotseq;","":"&efr;","":"&eg;","":"&egrave;","":"&eqslantgtr;","":"&egsdot;","":"&el;","":"&elinters;","":"&ell;","":"&eqslantless;","":"&elsdot;","":"&emacr;","":"&varnothing;","":"&emsp13;","":"&emsp14;","":"&emsp;","":"&eng;","":"&ensp;","":"&eogon;","":"&eopf;","":"&epar;","":"&eparsl;","":"&eplus;","":"&epsilon;","":"&varepsilon;","=":"&equals;","":"&questeq;","":"&equivDD;","":"&eqvparsl;","":"&risingdotseq;","":"&erarr;","":"&escr;","":"&eta;","":"&eth;","":"&euml;","":"&euro;","!":"&excl;","":"&fcy;","":"&female;","":"&ffilig;","":"&fflig;","":"&ffllig;","":"&ffr;","":"&filig;",fj:"&fjlig;","":"&flat;","":"&fllig;","":"&fltns;","":"&fnof;","":"&fopf;","":"&pitchfork;","":"&forkv;","":"&fpartint;","":"&half;","":"&frac13;","":"&frac14;","":"&frac15;","":"&frac16;","":"&frac18;","":"&frac23;","":"&frac25;","":"&frac34;","":"&frac35;","":"&frac38;","":"&frac45;","":"&frac56;","":"&frac58;","":"&frac78;","":"&frasl;","":"&sfrown;","":"&fscr;","":"&gtreqqless;","":"&gacute;","":"&gamma;","":"&gtrapprox;","":"&gbreve;","":"&gcirc;","":"&gcy;","":"&gdot;","":"&gescc;","":"&gesdot;","":"&gesdoto;","":"&gesdotol;","":"&gesl;","":"&gesles;","":"&gfr;","":"&gimel;","":"&gjcy;","":"&glE;","":"&gla;","":"&glj;","":"&gneqq;","":"&gnapprox;","":"&gneq;","":"&gnsim;","":"&gopf;","":"&gscr;","":"&gsime;","":"&gsiml;","":"&gtcc;","":"&gtcir;","":"&gtrdot;","":"&gtlPar;","":"&gtquest;","":"&gtrarr;","":"&gvnE;","":"&hardcy;","":"&harrcir;","":"&leftrightsquigarrow;","":"&plankv;","":"&hcirc;","":"&heartsuit;","":"&mldr;","":"&hercon;","":"&hfr;","":"&searhk;","":"&swarhk;","":"&hoarr;","":"&homtht;","":"&larrhk;","":"&rarrhk;","":"&hopf;","":"&horbar;","":"&hscr;","":"&hstrok;","":"&hybull;","":"&iacute;","":"&icirc;","":"&icy;","":"&iecy;","":"&iexcl;","":"&ifr;","":"&igrave;","":"&qint;","":"&tint;","":"&iinfin;","":"&iiota;","":"&ijlig;","":"&imacr;","":"&inodot;","":"&imof;","":"&imped;","":"&incare;","":"&infin;","":"&infintie;","":"&intercal;","":"&intlarhk;","":"&iprod;","":"&iocy;","":"&iogon;","":"&iopf;","":"&iota;","":"&iquest;","":"&iscr;","":"&isinE;","":"&isindot;","":"&isins;","":"&isinsv;","":"&itilde;","":"&iukcy;","":"&iuml;","":"&jcirc;","":"&jcy;","":"&jfr;","":"&jmath;","":"&jopf;","":"&jscr;","":"&jsercy;","":"&jukcy;","":"&kappa;","":"&varkappa;","":"&kcedil;","":"&kcy;","":"&kfr;","":"&kgreen;","":"&khcy;","":"&kjcy;","":"&kopf;","":"&kscr;","":"&lAtail;","":"&lBarr;","":"&lesseqqgtr;","":"&lHar;","":"&lacute;","":"&laemptyv;","":"&lambda;","":"&langd;","":"&lessapprox;","":"&laquo;","":"&larrbfs;","":"&larrfs;","":"&looparrowleft;","":"&larrpl;","":"&larrsim;","":"&leftarrowtail;","":"&lat;","":"&latail;","":"&late;","":"&lates;","":"&lbarr;","":"&lbbrk;","{":"&lcub;","[":"&lsqb;","":"&lbrke;","":"&lbrksld;","":"&lbrkslu;","":"&lcaron;","":"&lcedil;","":"&lcy;","":"&ldca;","":"&ldrdhar;","":"&ldrushar;","":"&ldsh;","":"&leq;","":"&llarr;","":"&lthree;","":"&lescc;","":"&lesdot;","":"&lesdoto;","":"&lesdotor;","":"&lesg;","":"&lesges;","":"&ltdot;","":"&lfisht;","":"&lfr;","":"&lgE;","":"&lharul;","":"&lhblk;","":"&ljcy;","":"&llhard;","":"&lltri;","":"&lmidot;","":"&lmoustache;","":"&lneqq;","":"&lnapprox;","":"&lneq;","":"&lnsim;","":"&loang;","":"&loarr;","":"&xmap;","":"&rarrlp;","":"&lopar;","":"&lopf;","":"&loplus;","":"&lotimes;","":"&lowast;","":"&lozenge;","(":"&lpar;","":"&lparlt;","":"&lrhard;","":"&lrm;","":"&lrtri;","":"&lsaquo;","":"&lscr;","":"&lsime;","":"&lsimg;","":"&sbquo;","":"&lstrok;","":"&ltcc;","":"&ltcir;","":"&ltimes;","":"&ltlarr;","":"&ltquest;","":"&ltrPar;","":"&triangleleft;","":"&lurdshar;","":"&luruhar;","":"&lvnE;","":"&mDDot;","":"&strns;","":"&male;","":"&maltese;","":"&marker;","":"&mcomma;","":"&mcy;","":"&mdash;","":"&mfr;","":"&mho;","":"&micro;","":"&midcir;","":"&minus;","":"&minusdu;","":"&mlcp;","":"&models;","":"&mopf;","":"&mscr;","":"&mu;","":"&mumap;","":"&nGg;","":"&nGt;","":"&nlArr;","":"&nhArr;","":"&nLl;","":"&nLt;","":"&nrArr;","":"&nVDash;","":"&nVdash;","":"&nacute;","":"&nang;","":"&napE;","":"&napid;","":"&napos;","":"&natural;","":"&ncap;","":"&ncaron;","":"&ncedil;","":"&ncongdot;","":"&ncup;","":"&ncy;","":"&ndash;","":"&neArr;","":"&nearhk;","":"&nedot;","":"&toea;","":"&nfr;","":"&nleftrightarrow;","":"&nhpar;","":"&nis;","":"&nisd;","":"&njcy;","":"&nleqq;","":"&nleftarrow;","":"&nldr;","":"&nopf;","":"&not;","":"&notinE;","":"&notindot;","":"&notinvb;","":"&notinvc;","":"&notnivb;","":"&notnivc;","":"&nparsl;","":"&npart;","":"&npolint;","":"&nrightarrow;","":"&nrarrc;","":"&nrarrw;","":"&nscr;","":"&nsub;","":"&nsubseteqq;","":"&nsup;","":"&nsupseteqq;","":"&ntilde;","":"&nu;","#":"&num;","":"&numero;","":"&numsp;","":"&nvDash;","":"&nvHarr;","":"&nvap;","":"&nvdash;","":"&nvge;",">":"&nvgt;","":"&nvinfin;","":"&nvlArr;","":"&nvle;","<":"&nvlt;","":"&nvltrie;","":"&nvrArr;","":"&nvrtrie;","":"&nvsim;","":"&nwArr;","":"&nwarhk;","":"&nwnear;","":"&oacute;","":"&ocirc;","":"&ocy;","":"&odblac;","":"&odiv;","":"&odsold;","":"&oelig;","":"&ofcir;","":"&ofr;","":"&ogon;","":"&ograve;","":"&ogt;","":"&ohbar;","":"&olcir;","":"&olcross;","":"&olt;","":"&omacr;","":"&omega;","":"&omicron;","":"&omid;","":"&oopf;","":"&opar;","":"&operp;","":"&vee;","":"&ord;","":"&oscr;","":"&ordf;","":"&ordm;","":"&origof;","":"&oror;","":"&orslope;","":"&orv;","":"&oslash;","":"&osol;","":"&otilde;","":"&otimesas;","":"&ouml;","":"&ovbar;","":"&para;","":"&parsim;","":"&parsl;","":"&pcy;","%":"&percnt;",".":"&period;","":"&permil;","":"&pertenk;","":"&pfr;","":"&phi;","":"&varphi;","":"&phone;","":"&pi;","":"&varpi;","":"&planckh;","+":"&plus;","":"&plusacir;","":"&pluscir;","":"&plusdu;","":"&pluse;","":"&plussim;","":"&plustwo;","":"&pointint;","":"&popf;","":"&pound;","":"&prE;","":"&precapprox;","":"&prnap;","":"&prnE;","":"&prnsim;","":"&prime;","":"&profalar;","":"&profline;","":"&profsurf;","":"&prurel;","":"&pscr;","":"&psi;","":"&puncsp;","":"&qfr;","":"&qopf;","":"&qprime;","":"&qscr;","":"&quatint;","?":"&quest;","":"&rAtail;","":"&rHar;","":"&race;","":"&racute;","":"&raemptyv;","":"&rangd;","":"&range;","":"&raquo;","":"&rarrap;","":"&rarrbfs;","":"&rarrc;","":"&rarrfs;","":"&rarrpl;","":"&rarrsim;","":"&rightarrowtail;","":"&rightsquigarrow;","":"&ratail;","":"&ratio;","":"&rbbrk;","}":"&rcub;","]":"&rsqb;","":"&rbrke;","":"&rbrksld;","":"&rbrkslu;","":"&rcaron;","":"&rcedil;","":"&rcy;","":"&rdca;","":"&rdldhar;","":"&rdsh;","":"&rect;","":"&rfisht;","":"&rfr;","":"&rharul;","":"&rho;","":"&varrho;","":"&rrarr;","":"&rthree;","":"&ring;","":"&rlm;","":"&rmoustache;","":"&rnmid;","":"&roang;","":"&roarr;","":"&ropar;","":"&ropf;","":"&roplus;","":"&rotimes;",")":"&rpar;","":"&rpargt;","":"&rppolint;","":"&rsaquo;","":"&rscr;","":"&rtimes;","":"&triangleright;","":"&rtriltri;","":"&ruluhar;","":"&rx;","":"&sacute;","":"&scE;","":"&succapprox;","":"&scaron;","":"&scedil;","":"&scirc;","":"&succneqq;","":"&succnapprox;","":"&succnsim;","":"&scpolint;","":"&scy;","":"&sdot;","":"&sdote;","":"&seArr;","":"&sect;",";":"&semi;","":"&tosa;","":"&sext;","":"&sfr;","":"&sharp;","":"&shchcy;","":"&shcy;","":"&shy;","":"&sigma;","":"&varsigma;","":"&simdot;","":"&simg;","":"&simgE;","":"&siml;","":"&simlE;","":"&simne;","":"&simplus;","":"&simrarr;","":"&smashp;","":"&smeparsl;","":"&ssmile;","":"&smt;","":"&smte;","":"&smtes;","":"&softcy;","/":"&sol;","":"&solb;","":"&solbar;","":"&sopf;","":"&spadesuit;","":"&sqcaps;","":"&sqcups;","":"&sscr;","":"&star;","":"&subset;","":"&subseteqq;","":"&subdot;","":"&subedot;","":"&submult;","":"&subsetneqq;","":"&subsetneq;","":"&subplus;","":"&subrarr;","":"&subsim;","":"&subsub;","":"&subsup;","":"&sung;","":"&sup1;","":"&sup2;","":"&sup3;","":"&supseteqq;","":"&supdot;","":"&supdsub;","":"&supedot;","":"&suphsol;","":"&suphsub;","":"&suplarr;","":"&supmult;","":"&supsetneqq;","":"&supsetneq;","":"&supplus;","":"&supsim;","":"&supsub;","":"&supsup;","":"&swArr;","":"&swnwar;","":"&szlig;","":"&target;","":"&tau;","":"&tcaron;","":"&tcedil;","":"&tcy;","":"&telrec;","":"&tfr;","":"&theta;","":"&vartheta;","":"&thorn;","":"&times;","":"&timesbar;","":"&timesd;","":"&topbot;","":"&topcir;","":"&topf;","":"&topfork;","":"&tprime;","":"&utri;","":"&trie;","":"&tridot;","":"&triminus;","":"&triplus;","":"&trisb;","":"&tritime;","":"&trpezium;","":"&tscr;","":"&tscy;","":"&tshcy;","":"&tstrok;","":"&uHar;","":"&uacute;","":"&ubrcy;","":"&ubreve;","":"&ucirc;","":"&ucy;","":"&udblac;","":"&ufisht;","":"&ufr;","":"&ugrave;","":"&uhblk;","":"&ulcorner;","":"&ulcrop;","":"&ultri;","":"&umacr;","":"&uogon;","":"&uopf;","":"&upsilon;","":"&uuarr;","":"&urcorner;","":"&urcrop;","":"&uring;","":"&urtri;","":"&uscr;","":"&utdot;","":"&utilde;","":"&uuml;","":"&uwangle;","":"&vBar;","":"&vBarv;","":"&vangrt;","":"&vsubne;","":"&vsubnE;","":"&vsupne;","":"&vsupnE;","":"&vcy;","":"&veebar;","":"&veeeq;","":"&vellip;","":"&vfr;","":"&vopf;","":"&vscr;","":"&vzigzag;","":"&wcirc;","":"&wedbar;","":"&wedgeq;","":"&wp;","":"&wfr;","":"&wopf;","":"&wscr;","":"&xfr;","":"&xi;","":"&xnis;","":"&xopf;","":"&xscr;","":"&yacute;","":"&yacy;","":"&ycirc;","":"&ycy;","":"&yen;","":"&yfr;","":"&yicy;","":"&yopf;","":"&yscr;","":"&yucy;","":"&yuml;","":"&zacute;","":"&zcaron;","":"&zcy;","":"&zdot;","":"&zeta;","":"&zfr;","":"&zhcy;","":"&zigrarr;","":"&zopf;","":"&zscr;","":"&zwj;","":"&zwnj;"}}};

	var numericUnicodeMap = {};

	Object.defineProperty(numericUnicodeMap,"__esModule",{value:true});numericUnicodeMap.numericUnicodeMap={0:65533,128:8364,130:8218,131:402,132:8222,133:8230,134:8224,135:8225,136:710,137:8240,138:352,139:8249,140:338,142:381,145:8216,146:8217,147:8220,148:8221,149:8226,150:8211,151:8212,152:732,153:8482,154:353,155:8250,156:339,158:382,159:376};

	var surrogatePairs = {};

	Object.defineProperty(surrogatePairs,"__esModule",{value:true});surrogatePairs.fromCodePoint=String.fromCodePoint||function(astralCodePoint){return String.fromCharCode(Math.floor((astralCodePoint-65536)/1024)+55296,(astralCodePoint-65536)%1024+56320)};surrogatePairs.getCodePoint=String.prototype.codePointAt?function(input,position){return input.codePointAt(position)}:function(input,position){return (input.charCodeAt(position)-55296)*1024+input.charCodeAt(position+1)-56320+65536};surrogatePairs.highSurrogateFrom=55296;surrogatePairs.highSurrogateTo=56319;

	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(lib$1, "__esModule", { value: true });
	var named_references_1 = namedReferences;
	var numeric_unicode_map_1 = numericUnicodeMap;
	var surrogate_pairs_1 = surrogatePairs;
	var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });
	var encodeRegExps = {
	    specialChars: /[<>'"&]/g,
	    nonAscii: /(?:[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
	    nonAsciiPrintable: /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
	    extensive: /(?:[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
	};
	var defaultEncodeOptions = {
	    mode: 'specialChars',
	    level: 'all',
	    numeric: 'decimal'
	};
	/** Encodes all the necessary (specified by `level`) characters in the text */
	function encode(text, _a) {
	    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;
	    if (!text) {
	        return '';
	    }
	    var encodeRegExp = encodeRegExps[mode];
	    var references = allNamedReferences[level].characters;
	    var isHex = numeric === 'hexadecimal';
	    encodeRegExp.lastIndex = 0;
	    var _b = encodeRegExp.exec(text);
	    var _c;
	    if (_b) {
	        _c = '';
	        var _d = 0;
	        do {
	            if (_d !== _b.index) {
	                _c += text.substring(_d, _b.index);
	            }
	            var _e = _b[0];
	            var result_1 = references[_e];
	            if (!result_1) {
	                var code_1 = _e.length > 1 ? surrogate_pairs_1.getCodePoint(_e, 0) : _e.charCodeAt(0);
	                result_1 = (isHex ? '&#x' + code_1.toString(16) : '&#' + code_1) + ';';
	            }
	            _c += result_1;
	            _d = _b.index + _e.length;
	        } while ((_b = encodeRegExp.exec(text)));
	        if (_d !== text.length) {
	            _c += text.substring(_d);
	        }
	    }
	    else {
	        _c =
	            text;
	    }
	    return _c;
	}
	lib$1.encode = encode;
	var defaultDecodeOptions = {
	    scope: 'body',
	    level: 'all'
	};
	var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
	var attribute$1 = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
	var baseDecodeRegExps = {
	    xml: {
	        strict: strict,
	        attribute: attribute$1,
	        body: named_references_1.bodyRegExps.xml
	    },
	    html4: {
	        strict: strict,
	        attribute: attribute$1,
	        body: named_references_1.bodyRegExps.html4
	    },
	    html5: {
	        strict: strict,
	        attribute: attribute$1,
	        body: named_references_1.bodyRegExps.html5
	    }
	};
	var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
	var fromCharCode = String.fromCharCode;
	var outOfBoundsChar = fromCharCode(65533);
	var defaultDecodeEntityOptions = {
	    level: 'all'
	};
	/** Decodes a single entity */
	function decodeEntity(entity, _a) {
	    var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level, level = _b === void 0 ? 'all' : _b;
	    if (!entity) {
	        return '';
	    }
	    var _b = entity;
	    entity[entity.length - 1];
	    {
	        var decodeResultByReference_1 = allNamedReferences[level].entities[entity];
	        if (decodeResultByReference_1) {
	            _b = decodeResultByReference_1;
	        }
	        else if (entity[0] === '&' && entity[1] === '#') {
	            var decodeSecondChar_1 = entity[2];
	            var decodeCode_1 = decodeSecondChar_1 == 'x' || decodeSecondChar_1 == 'X'
	                ? parseInt(entity.substr(3), 16)
	                : parseInt(entity.substr(2));
	            _b =
	                decodeCode_1 >= 0x10ffff
	                    ? outOfBoundsChar
	                    : decodeCode_1 > 65535
	                        ? surrogate_pairs_1.fromCodePoint(decodeCode_1)
	                        : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_1] || decodeCode_1);
	        }
	    }
	    return _b;
	}
	lib$1.decodeEntity = decodeEntity;
	/** Decodes all entities in the text */
	function decode(text, _a) {
	    var decodeSecondChar_1 = _a === void 0 ? defaultDecodeOptions : _a, decodeCode_1 = decodeSecondChar_1.level, level = decodeCode_1 === void 0 ? 'all' : decodeCode_1, _b = decodeSecondChar_1.scope, scope = _b === void 0 ? level === 'xml' ? 'strict' : 'body' : _b;
	    if (!text) {
	        return '';
	    }
	    var decodeRegExp = decodeRegExps[level][scope];
	    var references = allNamedReferences[level].entities;
	    var isAttribute = scope === 'attribute';
	    var isStrict = scope === 'strict';
	    decodeRegExp.lastIndex = 0;
	    var replaceMatch_1 = decodeRegExp.exec(text);
	    var replaceResult_1;
	    if (replaceMatch_1) {
	        replaceResult_1 = '';
	        var replaceLastIndex_1 = 0;
	        do {
	            if (replaceLastIndex_1 !== replaceMatch_1.index) {
	                replaceResult_1 += text.substring(replaceLastIndex_1, replaceMatch_1.index);
	            }
	            var replaceInput_1 = replaceMatch_1[0];
	            var decodeResult_1 = replaceInput_1;
	            var decodeEntityLastChar_2 = replaceInput_1[replaceInput_1.length - 1];
	            if (isAttribute
	                && decodeEntityLastChar_2 === '=') {
	                decodeResult_1 = replaceInput_1;
	            }
	            else if (isStrict
	                && decodeEntityLastChar_2 !== ';') {
	                decodeResult_1 = replaceInput_1;
	            }
	            else {
	                var decodeResultByReference_2 = references[replaceInput_1];
	                if (decodeResultByReference_2) {
	                    decodeResult_1 = decodeResultByReference_2;
	                }
	                else if (replaceInput_1[0] === '&' && replaceInput_1[1] === '#') {
	                    var decodeSecondChar_2 = replaceInput_1[2];
	                    var decodeCode_2 = decodeSecondChar_2 == 'x' || decodeSecondChar_2 == 'X'
	                        ? parseInt(replaceInput_1.substr(3), 16)
	                        : parseInt(replaceInput_1.substr(2));
	                    decodeResult_1 =
	                        decodeCode_2 >= 0x10ffff
	                            ? outOfBoundsChar
	                            : decodeCode_2 > 65535
	                                ? surrogate_pairs_1.fromCodePoint(decodeCode_2)
	                                : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_2] || decodeCode_2);
	                }
	            }
	            replaceResult_1 += decodeResult_1;
	            replaceLastIndex_1 = replaceMatch_1.index + replaceInput_1.length;
	        } while ((replaceMatch_1 = decodeRegExp.exec(text)));
	        if (replaceLastIndex_1 !== text.length) {
	            replaceResult_1 += text.substring(replaceLastIndex_1);
	        }
	    }
	    else {
	        replaceResult_1 =
	            text;
	    }
	    return replaceResult_1;
	}
	var decode_1 = lib$1.decode = decode;

	const { checkText,emojiMap } = smile2emoji;

	function t(str) {
	    return {type: 'text', value: decode_1(checkText(str),{level: 'html5'})};
	}

	var own$5 = {}.hasOwnProperty;

	/**
	 * @callback Handler
	 * @param {...unknown} value
	 * @return {unknown}
	 *
	 * @typedef {Record<string, Handler>} Handlers
	 *
	 * @typedef {Object} Options
	 * @property {Handler} [unknown]
	 * @property {Handler} [invalid]
	 * @property {Handlers} [handlers]
	 */

	/**
	 * Handle values based on a property.
	 *
	 * @param {string} key
	 * @param {Options} [options]
	 */
	function zwitch(key, options) {
	  var settings = options || {};

	  /**
	   * Handle one value.
	   * Based on the bound `key`, a respective handler will be called.
	   * If `value` is not an object, or doesnt have a `key` property, the special
	   * invalid handler will be called.
	   * If `value` has an unknown `key`, the special unknown handler will be
	   * called.
	   *
	   * All arguments, and the context object, are passed through to the handler,
	   * and its result is returned.
	   *
	   * @param {...unknown} [value]
	   * @this {unknown}
	   * @returns {unknown}
	   * @property {Handler} invalid
	   * @property {Handler} unknown
	   * @property {Handlers} handlers
	   */
	  function one(value) {
	    var fn = one.invalid;
	    var handlers = one.handlers;

	    if (value && own$5.call(value, key)) {
	      fn = own$5.call(handlers, value[key]) ? handlers[value[key]] : one.unknown;
	    }

	    if (fn) {
	      return fn.apply(this, arguments)
	    }
	  }

	  one.handlers = settings.handlers || {};
	  one.invalid = settings.invalid;
	  one.unknown = settings.unknown;

	  return one
	}

	const rtlRange = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC';
	const ltrRange =
	  'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' +
	  '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' +
	  '\uFE00-\uFE6F\uFEFD-\uFFFF';

	/* eslint-disable no-misleading-character-class */
	const rtl = new RegExp('^[^' + ltrRange + ']*[' + rtlRange + ']');
	const ltr = new RegExp('^[^' + rtlRange + ']*[' + ltrRange + ']');
	/* eslint-enable no-misleading-character-class */

	/**
	 * Detect the direction of text: left-to-right, right-to-left, or neutral
	 *
	 * @param {string} value
	 * @returns {'rtl'|'ltr'|'neutral'}
	 */
	function direction(value) {
	  const source = String(value || '');
	  return rtl.test(source) ? 'rtl' : ltr.test(source) ? 'ltr' : 'neutral'
	}

	/**
	 * @typedef {import('unist').Node} Node
	 * @typedef {import('unist').Parent} Parent
	 * @typedef {import('hast').Element} Element
	 *
	 * @typedef {string} TagName
	 * @typedef {null|undefined|TagName|TestFunctionAnything|Array.<TagName|TestFunctionAnything>} Test
	 */

	/**
	 * @template {Element} T
	 * @typedef {null|undefined|T['tagName']|TestFunctionPredicate<T>|Array.<T['tagName']|TestFunctionPredicate<T>>} PredicateTest
	 */

	/**
	 * Check if an element passes a test
	 *
	 * @callback TestFunctionAnything
	 * @param {Element} element
	 * @param {number|null|undefined} [index]
	 * @param {Parent|null|undefined} [parent]
	 * @returns {boolean|void}
	 */

	/**
	 * Check if an element passes a certain node test
	 *
	 * @template {Element} X
	 * @callback TestFunctionPredicate
	 * @param {Element} element
	 * @param {number|null|undefined} [index]
	 * @param {Parent|null|undefined} [parent]
	 * @returns {element is X}
	 */

	/**
	 * Check if a node is an element and passes a certain node test
	 *
	 * @callback AssertAnything
	 * @param {unknown} [node]
	 * @param {number|null|undefined} [index]
	 * @param {Parent|null|undefined} [parent]
	 * @returns {boolean}
	 */

	/**
	 * Check if a node is an element and passes a certain node test
	 *
	 * @template {Element} Y
	 * @callback AssertPredicate
	 * @param {unknown} [node]
	 * @param {number|null|undefined} [index]
	 * @param {Parent|null|undefined} [parent]
	 * @returns {node is Y}
	 */

	// Check if `node` is an `element` and whether it passes the given test.
	const isElement =
	  /**
	   * Check if a node is an element and passes a test.
	   * When a `parent` node is known the `index` of node should also be given.
	   *
	   * @type {(
	   *   (() => false) &
	   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
	   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
	   * )}
	   */
	  (
	    /**
	     * Check if a node passes a test.
	     * When a `parent` node is known the `index` of node should also be given.
	     *
	     * @param {unknown} [node] Node to check
	     * @param {Test} [test] When nullish, checks if `node` is a `Node`.
	     * When `string`, works like passing `function (node) {return node.type === test}`.
	     * When `function` checks if function passed the node is true.
	     * When `array`, checks any one of the subtests pass.
	     * @param {number} [index] Position of `node` in `parent`
	     * @param {Parent} [parent] Parent of `node`
	     * @param {unknown} [context] Context object to invoke `test` with
	     * @returns {boolean} Whether test passed and `node` is an `Element` (object with `type` set to `element` and `tagName` set to a non-empty string).
	     */
	    // eslint-disable-next-line max-params
	    function (node, test, index, parent, context) {
	      const check = convertElement(test);

	      if (
	        index !== undefined &&
	        index !== null &&
	        (typeof index !== 'number' ||
	          index < 0 ||
	          index === Number.POSITIVE_INFINITY)
	      ) {
	        throw new Error('Expected positive finite index for child node')
	      }

	      if (
	        parent !== undefined &&
	        parent !== null &&
	        (!parent.type || !parent.children)
	      ) {
	        throw new Error('Expected parent node')
	      }

	      // @ts-expect-error Looks like a node.
	      if (!node || !node.type || typeof node.type !== 'string') {
	        return false
	      }

	      if (
	        (parent === undefined || parent === null) !==
	        (index === undefined || index === null)
	      ) {
	        throw new Error('Expected both parent and index')
	      }

	      return check.call(context, node, index, parent)
	    }
	  );

	const convertElement =
	  /**
	   * @type {(
	   *   (<T extends Element>(test: T['tagName']|TestFunctionPredicate<T>) => AssertPredicate<T>) &
	   *   ((test?: Test) => AssertAnything)
	   * )}
	   */
	  (
	    /**
	     * Generate an assertion from a check.
	     * @param {Test} [test]
	     * When nullish, checks if `node` is a `Node`.
	     * When `string`, works like passing `function (node) {return node.type === test}`.
	     * When `function` checks if function passed the node is true.
	     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
	     * When `array`, checks any one of the subtests pass.
	     * @returns {AssertAnything}
	     */
	    function (test) {
	      if (test === undefined || test === null) {
	        return element$2
	      }

	      if (typeof test === 'string') {
	        return tagNameFactory(test)
	      }

	      if (typeof test === 'object') {
	        return anyFactory$1(test)
	      }

	      if (typeof test === 'function') {
	        return castFactory$1(test)
	      }

	      throw new Error('Expected function, string, or array as test')
	    }
	  );

	/**
	 * @param {Array.<TagName|TestFunctionAnything>} tests
	 * @returns {AssertAnything}
	 */
	function anyFactory$1(tests) {
	  /** @type {Array.<AssertAnything>} */
	  const checks = [];
	  let index = -1;

	  while (++index < tests.length) {
	    checks[index] = convertElement(tests[index]);
	  }

	  return castFactory$1(any)

	  /**
	   * @this {unknown}
	   * @param {unknown[]} parameters
	   * @returns {boolean}
	   */
	  function any(...parameters) {
	    let index = -1;

	    while (++index < checks.length) {
	      if (checks[index].call(this, ...parameters)) {
	        return true
	      }
	    }

	    return false
	  }
	}

	/**
	 * Utility to convert a string into a function which checks a given nodes tag
	 * name for said string.
	 *
	 * @param {TagName} check
	 * @returns {AssertAnything}
	 */
	function tagNameFactory(check) {
	  return tagName

	  /**
	   * @param {unknown} node
	   * @returns {boolean}
	   */
	  function tagName(node) {
	    return element$2(node) && node.tagName === check
	  }
	}

	/**
	 * @param {TestFunctionAnything} check
	 * @returns {AssertAnything}
	 */
	function castFactory$1(check) {
	  return assertion

	  /**
	   * @this {unknown}
	   * @param {unknown} node
	   * @param {Array.<unknown>} parameters
	   * @returns {boolean}
	   */
	  function assertion(node, ...parameters) {
	    // @ts-expect-error: fine.
	    return element$2(node) && Boolean(check.call(this, node, ...parameters))
	  }
	}

	/**
	 * Utility to return true if this is an element.
	 * @param {unknown} node
	 * @returns {node is Element}
	 */
	function element$2(node) {
	  return Boolean(
	    node &&
	      typeof node === 'object' &&
	      // @ts-expect-error Looks like a node.
	      node.type === 'element' &&
	      // @ts-expect-error Looks like an element.
	      typeof node.tagName === 'string'
	  )
	}

	/**
	 * @fileoverview
	 *   Get the plain-text value of a hast node.
	 * @longdescription
	 *   ## Use
	 *
	 *   ```js
	 *   import {h} from 'hastscript'
	 *   import {toString} from 'hast-util-to-string'
	 *
	 *   toString(h('p', 'Alpha'))
	 *   //=> 'Alpha'
	 *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))
	 *   //=> 'Bold and italic.'
	 *   ```
	 *
	 *   ## API
	 *
	 *   ### `toString(node)`
	 *
	 *   Transform a node to a string.
	 */

	/**
	 * @typedef {import('hast').Root} Root
	 * @typedef {import('hast').Element} Element
	 * @typedef {Root|Root['children'][number]} Node
	 */

	/**
	 * Get the plain-text value of a hast node.
	 *
	 * @param {Node} node
	 * @returns {string}
	 */
	function toString$1(node) {
	  // The concatenation of data of all the Text node descendants of the context
	  // object, in tree order.
	  if ('children' in node) {
	    return all$1(node)
	  }

	  // Context objects data.
	  return 'value' in node ? node.value : ''
	}

	/**
	 * @param {Node} node
	 * @returns {string}
	 */
	function one$1(node) {
	  if (node.type === 'text') {
	    return node.value
	  }

	  return 'children' in node ? all$1(node) : ''
	}

	/**
	 * @param {Root|Element} node
	 * @returns {string}
	 */
	function all$1(node) {
	  let index = -1;
	  /** @type {string[]} */
	  const result = [];

	  while (++index < node.children.length) {
	    result[index] = one$1(node.children[index]);
	  }

	  return result.join('')
	}

	/**
	 * @typedef {import('unist').Node} Node
	 * @typedef {import('unist').Parent} Parent
	 *
	 * @typedef {string} Type
	 * @typedef {Object<string, unknown>} Props
	 *
	 * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test
	 */

	const convert =
	  /**
	   * @type {(
	   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &
	   *   ((test?: Test) => AssertAnything)
	   * )}
	   */
	  (
	    /**
	     * Generate an assertion from a check.
	     * @param {Test} [test]
	     * When nullish, checks if `node` is a `Node`.
	     * When `string`, works like passing `function (node) {return node.type === test}`.
	     * When `function` checks if function passed the node is true.
	     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
	     * When `array`, checks any one of the subtests pass.
	     * @returns {AssertAnything}
	     */
	    function (test) {
	      if (test === undefined || test === null) {
	        return ok
	      }

	      if (typeof test === 'string') {
	        return typeFactory(test)
	      }

	      if (typeof test === 'object') {
	        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
	      }

	      if (typeof test === 'function') {
	        return castFactory(test)
	      }

	      throw new Error('Expected function, string, or object as test')
	    }
	  );
	/**
	 * @param {Array.<Type|Props|TestFunctionAnything>} tests
	 * @returns {AssertAnything}
	 */
	function anyFactory(tests) {
	  /** @type {Array.<AssertAnything>} */
	  const checks = [];
	  let index = -1;

	  while (++index < tests.length) {
	    checks[index] = convert(tests[index]);
	  }

	  return castFactory(any)

	  /**
	   * @this {unknown}
	   * @param {unknown[]} parameters
	   * @returns {boolean}
	   */
	  function any(...parameters) {
	    let index = -1;

	    while (++index < checks.length) {
	      if (checks[index].call(this, ...parameters)) return true
	    }

	    return false
	  }
	}

	/**
	 * Utility to assert each property in `test` is represented in `node`, and each
	 * values are strictly equal.
	 *
	 * @param {Props} check
	 * @returns {AssertAnything}
	 */
	function propsFactory(check) {
	  return castFactory(all)

	  /**
	   * @param {Node} node
	   * @returns {boolean}
	   */
	  function all(node) {
	    /** @type {string} */
	    let key;

	    for (key in check) {
	      // @ts-expect-error: hush, it sure works as an index.
	      if (node[key] !== check[key]) return false
	    }

	    return true
	  }
	}

	/**
	 * Utility to convert a string into a function which checks a given nodes type
	 * for said string.
	 *
	 * @param {Type} check
	 * @returns {AssertAnything}
	 */
	function typeFactory(check) {
	  return castFactory(type)

	  /**
	   * @param {Node} node
	   */
	  function type(node) {
	    return node && node.type === check
	  }
	}

	/**
	 * Utility to convert a string into a function which checks a given nodes type
	 * for said string.
	 * @param {TestFunctionAnything} check
	 * @returns {AssertAnything}
	 */
	function castFactory(check) {
	  return assertion

	  /**
	   * @this {unknown}
	   * @param {Array.<unknown>} parameters
	   * @returns {boolean}
	   */
	  function assertion(...parameters) {
	    // @ts-expect-error: spreading is fine.
	    return Boolean(check.call(this, ...parameters))
	  }
	}

	// Utility to return true.
	function ok() {
	  return true
	}

	/**
	 * @param {string} d
	 * @returns {string}
	 */
	function color(d) {
	  return '\u001B[33m' + d + '\u001B[39m'
	}

	/**
	 * @typedef {import('unist').Node} Node
	 * @typedef {import('unist').Parent} Parent
	 * @typedef {import('unist-util-is').Test} Test
	 * @typedef {import('./complex-types.js').Action} Action
	 * @typedef {import('./complex-types.js').Index} Index
	 * @typedef {import('./complex-types.js').ActionTuple} ActionTuple
	 * @typedef {import('./complex-types.js').VisitorResult} VisitorResult
	 * @typedef {import('./complex-types.js').Visitor} Visitor
	 */

	/**
	 * Continue traversing as normal
	 */
	const CONTINUE = true;
	/**
	 * Do not traverse this nodes children
	 */
	const SKIP = 'skip';
	/**
	 * Stop traversing immediately
	 */
	const EXIT = false;

	/**
	 * Visit children of tree which pass test.
	 *
	 * @param tree
	 *   Tree to walk
	 * @param [test]
	 *   `unist-util-is`-compatible test
	 * @param visitor
	 *   Function called for nodes that pass `test`.
	 * @param [reverse=false]
	 *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).
	 */
	const visitParents =
	  /**
	   * @type {(
	   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &
	   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)
	   * )}
	   */
	  (
	    /**
	     * @param {Node} tree
	     * @param {Test} test
	     * @param {import('./complex-types.js').Visitor<Node>} visitor
	     * @param {boolean} [reverse=false]
	     */
	    function (tree, test, visitor, reverse) {
	      if (typeof test === 'function' && typeof visitor !== 'function') {
	        reverse = visitor;
	        // @ts-expect-error no visitor given, so `visitor` is test.
	        visitor = test;
	        test = null;
	      }

	      const is = convert(test);
	      const step = reverse ? -1 : 1;

	      factory(tree, null, [])();

	      /**
	       * @param {Node} node
	       * @param {number?} index
	       * @param {Array<Parent>} parents
	       */
	      function factory(node, index, parents) {
	        /** @type {Record<string, unknown>} */
	        // @ts-expect-error: hush
	        const value = typeof node === 'object' && node !== null ? node : {};
	        /** @type {string|undefined} */
	        let name;

	        if (typeof value.type === 'string') {
	          name =
	            typeof value.tagName === 'string'
	              ? value.tagName
	              : typeof value.name === 'string'
	              ? value.name
	              : undefined;

	          Object.defineProperty(visit, 'name', {
	            value:
	              'node (' +
	              color(value.type + (name ? '<' + name + '>' : '')) +
	              ')'
	          });
	        }

	        return visit

	        function visit() {
	          /** @type {ActionTuple} */
	          let result = [];
	          /** @type {ActionTuple} */
	          let subresult;
	          /** @type {number} */
	          let offset;
	          /** @type {Array<Parent>} */
	          let grandparents;

	          if (!test || is(node, index, parents[parents.length - 1] || null)) {
	            result = toResult(visitor(node, parents));

	            if (result[0] === EXIT) {
	              return result
	            }
	          }

	          // @ts-expect-error looks like a parent.
	          if (node.children && result[0] !== SKIP) {
	            // @ts-expect-error looks like a parent.
	            offset = (reverse ? node.children.length : -1) + step;
	            // @ts-expect-error looks like a parent.
	            grandparents = parents.concat(node);

	            // @ts-expect-error looks like a parent.
	            while (offset > -1 && offset < node.children.length) {
	              // @ts-expect-error looks like a parent.
	              subresult = factory(node.children[offset], offset, grandparents)();

	              if (subresult[0] === EXIT) {
	                return subresult
	              }

	              offset =
	                typeof subresult[1] === 'number' ? subresult[1] : offset + step;
	            }
	          }

	          return result
	        }
	      }
	    }
	  );

	/**
	 * @param {VisitorResult} value
	 * @returns {ActionTuple}
	 */
	function toResult(value) {
	  if (Array.isArray(value)) {
	    return value
	  }

	  if (typeof value === 'number') {
	    return [CONTINUE, value]
	  }

	  return [value]
	}

	/**
	 * @typedef {import('unist').Node} Node
	 * @typedef {import('unist').Parent} Parent
	 * @typedef {import('unist-util-is').Test} Test
	 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
	 * @typedef {import('./complex-types.js').Visitor} Visitor
	 */

	/**
	 * Visit children of tree which pass test.
	 *
	 * @param tree
	 *   Tree to walk
	 * @param [test]
	 *   `unist-util-is`-compatible test
	 * @param visitor
	 *   Function called for nodes that pass `test`.
	 * @param reverse
	 *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).
	 */
	const visit =
	  /**
	   * @type {(
	   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &
	   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)
	   * )}
	   */
	  (
	    /**
	     * @param {Node} tree
	     * @param {Test} test
	     * @param {import('./complex-types.js').Visitor} visitor
	     * @param {boolean} [reverse]
	     */
	    function (tree, test, visitor, reverse) {
	      if (typeof test === 'function' && typeof visitor !== 'function') {
	        reverse = visitor;
	        visitor = test;
	        test = null;
	      }

	      visitParents(tree, test, overload, reverse);

	      /**
	       * @param {Node} node
	       * @param {Array<Parent>} parents
	       */
	      function overload(node, parents) {
	        const parent = parents[parents.length - 1];
	        return visitor(
	          node,
	          parent ? parent.children.indexOf(node) : null,
	          parent
	        )
	      }
	    }
	  );

	/**
	 * @typedef {import('./types.js').Node} Node
	 * @typedef {import('./types.js').Element} Element
	 * @typedef {import('./types.js').Parent} Parent
	 * @typedef {import('hast-util-is-element').AssertPredicate<Element>} IsElement
	 */

	/**
	 * @param {Node} node
	 * @returns {node is Parent}
	 */
	function parent(node) {
	  // @ts-expect-error: hush.
	  return Array.isArray(node.children)
	}

	/** @type {IsElement} */
	// @ts-expect-error it works.
	const element$1 = convertElement();

	/**
	 * @typedef {import('./types.js').SelectState} SelectState
	 * @typedef {import('./types.js').HastNode} HastNode
	 * @typedef {import('./types.js').ElementChild} ElementChild
	 * @typedef {import('./types.js').Direction} Direction
	 * @typedef {import('unist-util-visit/complex-types').Visitor<ElementChild>} Visitor
	 */

	/**
	 * @param {SelectState} state
	 * @param {HastNode} node
	 * @returns {() => void}
	 */
	// eslint-disable-next-line complexity
	function enterState(state, node) {
	  const schema = state.schema;
	  const language = state.language;
	  const currentDirection = state.direction;
	  const editableOrEditingHost = state.editableOrEditingHost;
	  /** @type {Direction|undefined} */
	  let dirInferred;
	  /** @type {boolean|undefined} */
	  let found;

	  if (element$1(node) && node.properties) {
	    const lang = node.properties.xmlLang || node.properties.lang;
	    const type = node.properties.type || 'text';
	    const dir = dirProperty(node);

	    if (lang !== undefined && lang !== null) {
	      state.language = String(lang);
	      found = true;
	    }

	    if (schema && schema.space === 'html') {
	      if (node.properties.contentEditable === 'true') {
	        state.editableOrEditingHost = true;
	        found = true;
	      }

	      if (isElement(node, 'svg')) {
	        state.schema = svg;
	        found = true;
	      }

	      // See: <https://html.spec.whatwg.org/#the-directionality>.
	      // Explicit `[dir=rtl]`.
	      if (dir === 'rtl') {
	        dirInferred = dir;
	      } else if (
	        // Explicit `[dir=ltr]`.
	        dir === 'ltr' ||
	        // HTML with an invalid or no `[dir]`.
	        (dir !== 'auto' && isElement(node, 'html')) ||
	        // `input[type=tel]` with an invalid or no `[dir]`.
	        (dir !== 'auto' && isElement(node, 'input') && type === 'tel')
	      ) {
	        dirInferred = 'ltr';
	        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.
	      } else if (dir === 'auto' || isElement(node, 'bdi')) {
	        if (isElement(node, 'textarea')) {
	          // Check contents of `<textarea>`.
	          dirInferred = dirBidi(toString$1(node));
	        } else if (
	          isElement(node, 'input') &&
	          (type === 'email' ||
	            type === 'search' ||
	            type === 'tel' ||
	            type === 'text')
	        ) {
	          // Check value of `<input>`.
	          // @ts-expect-error something is `never` in types but this is needed.
	          dirInferred = node.properties.value
	            ? // @ts-expect-error Assume string
	              dirBidi(node.properties.value)
	            : 'ltr';
	        } else {
	          // Check text nodes in `node`.
	          visit(node, inferDirectionality);
	        }
	      }

	      if (dirInferred) {
	        state.direction = dirInferred;
	        found = true;
	      }
	    }
	    // Turn off editing mode in non-HTML spaces.
	    else if (state.editableOrEditingHost) {
	      state.editableOrEditingHost = false;
	      found = true;
	    }
	  }

	  return found ? reset : noop$1

	  function reset() {
	    state.schema = schema;
	    state.language = language;
	    state.direction = currentDirection;
	    state.editableOrEditingHost = editableOrEditingHost;
	  }

	  /** @type {Visitor} */
	  function inferDirectionality(child) {
	    if (child.type === 'text') {
	      dirInferred = dirBidi(child.value);
	      return dirInferred ? EXIT : null
	    }

	    if (
	      child !== node &&
	      (isElement(child, ['bdi', 'script', 'style', 'textare']) ||
	        dirProperty(child))
	    ) {
	      return SKIP
	    }
	  }
	}

	/**
	 * @param {string} value
	 * @returns {Direction|undefined}
	 */
	function dirBidi(value) {
	  const result = direction(value);
	  return result === 'neutral' ? undefined : result
	}

	/**
	 * @param {ElementChild} node
	 * @returns {Direction|undefined}
	 */
	function dirProperty(node) {
	  const value =
	    element$1(node) && node.properties && typeof node.properties.dir === 'string'
	      ? node.properties.dir.toLowerCase()
	      : undefined;

	  return value === 'auto' || value === 'ltr' || value === 'rtl'
	    ? value
	    : undefined
	}

	function noop$1() {}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').Node} Node
	 * @typedef {import('./types.js').Element} Element
	 * @typedef {import('./types.js').Parent} Parent
	 * @typedef {import('./types.js').SelectState} SelectState
	 * @typedef {import('./types.js').SelectIterator} SelectIterator
	 * @typedef {import('./types.js').Handler} Handler
	 */

	const own$4 = {}.hasOwnProperty;

	const handle$2 = zwitch('nestingOperator', {
	  // @ts-expect-error: hush.
	  unknown: unknownNesting,
	  // @ts-expect-error: hush.
	  invalid: topScan, // `undefined` is the top query selector.
	  handlers: {
	    // @ts-expect-error: hush.
	    null: descendant, // `null` is the descendant combinator.
	    // @ts-expect-error: hush.
	    '>': child,
	    // @ts-expect-error: hush.
	    '+': adjacentSibling,
	    // @ts-expect-error: hush.
	    '~': generalSibling
	  }
	});

	/** @type {Handler} */
	function nest(query, node, index, parent, state) {
	  handle$2(query, node, index, parent, state);
	}

	// Shouldnt be called, parser gives correct data.
	/* c8 ignore next 6 */
	/**
	 * @param {{[x: string]: unknown, type: string}} query
	 */
	function unknownNesting(query) {
	  throw new Error('Unexpected nesting `' + query.nestingOperator + '`')
	}

	/** @type {Handler} */
	function topScan(query, node, index, parent, state) {
	  // Shouldnt happen.
	  /* c8 ignore next 3 */
	  if (parent || index === null) {
	    throw new Error('topScan is supposed to be called from the root node')
	  }

	  // Shouldnt happen.
	  /* c8 ignore next 3 */
	  if (!state.iterator) {
	    throw new Error('Expected `iterator`')
	  }

	  state.iterator(query, node, index, parent, state);
	  if (!state.shallow) descendant(query, node, index, parent, state);
	}

	/** @type {Handler} */
	function descendant(query, node, index, parent, state) {
	  const previous = state.iterator;

	  state.iterator = iterator;
	  child(query, node, index, parent, state);

	  /** @type {SelectIterator} */
	  function iterator(query, node, index, parent, state) {
	    // Shouldnt happen.
	    /* c8 ignore next 3 */
	    if (!previous) {
	      throw new Error('Expected `iterator`')
	    }

	    state.iterator = previous;
	    previous(query, node, index, parent, state);
	    state.iterator = iterator;

	    if (state.one && state.found) return

	    child(query, node, index, parent, state);
	  }
	}

	/** @type {Handler} */
	function child(query, node, _1, _2, state) {
	  if (!parent(node)) return
	  if (node.children.length === 0) return
	  indexedSearch(query, node, state);
	}

	/** @type {Handler} */
	function adjacentSibling(query, _, index, parent, state) {
	  // Shouldnt happen.
	  /* c8 ignore next */
	  if (!parent || index === null) return
	  indexedSearch(query, parent, state, index + 1, true);
	}

	/** @type {Handler} */
	function generalSibling(query, _, index, parent, state) {
	  // Shouldnt happen.
	  /* c8 ignore next */
	  if (!parent || index === null) return
	  indexedSearch(query, parent, state, index + 1);
	}

	/**
	 * Handles `typeIndex` and `typeCount` properties for every walker.
	 *
	 * @param {Rule} query
	 * @param {Parent} parent
	 * @param {SelectState} state
	 * @param {number} [from=0]
	 * @param {boolean} [firstElementOnly=false]
	 */
	function indexedSearch(query, parent, state, from, firstElementOnly) {
	  const handle = state.index ? delay : add;
	  const children = parent.children;
	  let elements = 0;
	  let index = -1;
	  /** @type {Record<string, number>} */
	  const types = {};
	  /** @type {Array<Function>} */
	  const delayed = [];

	  // Start looking at `from`
	  if (from === undefined || from === null) from = 0;

	  // Exit if there are no further nodes.
	  if (from >= children.length) return

	  // If we need to index for types, do so for all elements before `from`.
	  if (state.index) {
	    while (++index < from) {
	      const child = children[index];
	      if (element$1(child)) count(child.tagName);
	    }
	  }

	  index = from - 1;

	  while (++index < children.length) {
	    const child = children[index];
	    // Only check elements.
	    // Check either all elements, or only check the first sibling
	    if (element$1(child)) {
	      handle(child, index);

	      // Stop if were looking for one node and its already found.
	      if (state.one && state.found) return
	      if (firstElementOnly) break
	    }
	  }

	  if (state.index) {
	    index = -1;

	    while (++index < delayed.length) {
	      delayed[index]();
	      if (state.one && state.found) return
	    }
	  }

	  /**
	   * @param {Element} node
	   * @param {number} childIndex
	   */
	  function delay(node, childIndex) {
	    const elementsBefore = elements;
	    const elementsByTypeBefore = own$4.call(types, node.tagName)
	      ? types[node.tagName]
	      : 0;

	    count(node.tagName);

	    delayed.push(fn);

	    function fn() {
	      // Before counting further elements:
	      state.elementIndex = elementsBefore;
	      state.typeIndex = elementsByTypeBefore;

	      // After counting all elements.
	      state.elementCount = elements;
	      state.typeCount = types[node.tagName];

	      add(node, childIndex);
	    }
	  }

	  /**
	   * @param {Element} node
	   * @param {number} childIndex
	   */
	  function add(node, childIndex) {
	    const exit = enterState(state, node);

	    // Shouldnt happen.
	    /* c8 ignore next 3 */
	    if (!state.iterator) {
	      throw new Error('Expected `iterator`')
	    }

	    state.iterator(query, node, childIndex, parent, state);
	    exit();
	  }

	  /**
	   * @param {string} name
	   */
	  function count(name) {
	    if (!own$4.call(types, name)) types[name] = 0;
	    elements++;
	    types[name]++;
	  }
	}

	/**
	 * See <https://tools.ietf.org/html/rfc4647#section-3.1>
	 * for more information on the algorithms.
	 */

	/**
	 * @typedef {string} Tag
	 * @typedef {Array<Tag>} Tags
	 * @typedef {string} Range
	 * @typedef {Array<Range>} Ranges
	 *
	 * @callback Check
	 * @param {Tag} tag
	 * @param {Range} range
	 * @returns {boolean}
	 *
	 * @typedef {FilterOrLookup<true>} Filter
	 * @typedef {FilterOrLookup<false>} Lookup
	 */

	/**
	 * @template {boolean} IsFilter
	 * @callback FilterOrLookup
	 * @param {Tag|Tags} tags
	 * @param {Range|Ranges} [ranges='*']
	 * @returns {IsFilter extends true ? Tags : Tag|undefined}
	 */

	/**
	 * Factory to perform a filter or a lookup.
	 * This factory creates a function that accepts a list of tags and a list of
	 * ranges, and contains logic to exit early for lookups.
	 * `check` just has to deal with one tag and one range.
	 * This match function iterates over ranges, and for each range,
	 * iterates over tags.  That way, earlier ranges matching any tag have
	 * precedence over later ranges.
	 *
	 * @template {boolean} IsFilter
	 * @param {Check} check
	 * @param {IsFilter} filter
	 * @returns {FilterOrLookup<IsFilter>}
	 */
	function factory(check, filter) {
	  return function (tags, ranges) {
	    let left = cast(tags, 'tag');
	    const right = cast(
	      ranges === null || ranges === undefined ? '*' : ranges,
	      'range'
	    );
	    /** @type {Tags} */
	    const matches = [];
	    let rightIndex = -1;

	    while (++rightIndex < right.length) {
	      const range = right[rightIndex].toLowerCase();

	      // Ignore wildcards in lookup mode.
	      if (!filter && range === '*') continue

	      let leftIndex = -1;
	      /** @type {Tags} */
	      const next = [];

	      while (++leftIndex < left.length) {
	        if (check(left[leftIndex].toLowerCase(), range)) {
	          // Exit if this is a lookup and we have a match.
	          if (!filter) {
	            return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (
	              left[leftIndex]
	            )
	          }

	          matches.push(left[leftIndex]);
	        } else {
	          next.push(left[leftIndex]);
	        }
	      }

	      left = next;
	    }

	    // If this is a filter, return the list.  If its a lookup, we didnt find
	    // a match, so return `undefined`.
	    return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (
	      filter ? matches : undefined
	    )
	  }
	}

	/**
	 * Extended Filtering (Section 3.3.2) matches a language priority list
	 * consisting of extended language ranges (Section 2.2) to sets of language
	 * tags.
	 */
	const extendedFilter = factory(function (tag, range) {
	  // 3.3.2.1
	  const left = tag.split('-');
	  const right = range.split('-');
	  let leftIndex = 0;
	  let rightIndex = 0;

	  // 3.3.2.2
	  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {
	    return false
	  }

	  leftIndex++;
	  rightIndex++;

	  // 3.3.2.3
	  while (rightIndex < right.length) {
	    // 3.3.2.3.A
	    if (right[rightIndex] === '*') {
	      rightIndex++;
	      continue
	    }

	    // 3.3.2.3.B
	    if (!left[leftIndex]) return false

	    // 3.3.2.3.C
	    if (left[leftIndex] === right[rightIndex]) {
	      leftIndex++;
	      rightIndex++;
	      continue
	    }

	    // 3.3.2.3.D
	    if (left[leftIndex].length === 1) return false

	    // 3.3.2.3.E
	    leftIndex++;
	  }

	  // 3.3.2.4
	  return true
	}, true);

	/**
	 * Validate tags or ranges, and cast them to arrays.
	 *
	 * @param {string|Array<string>} values
	 * @param {string} name
	 * @returns {Array<string>}
	 */
	function cast(values, name) {
	  const value = values && typeof values === 'string' ? [values] : values;

	  if (!value || typeof value !== 'object' || !('length' in value)) {
	    throw new Error(
	      'Invalid ' + name + ' `' + value + '`, expected non-empty string'
	    )
	  }

	  return value
	}

	var own$3 = {}.hasOwnProperty;

	/**
	 * Check if `node` has a set `name` property.
	 *
	 * @param {unknown} node
	 * @param {string} name
	 * @returns {boolean}
	 */
	function hasProperty(node, name) {
	  /** @type {unknown} */
	  var value =
	    name &&
	    node &&
	    typeof node === 'object' &&
	    // @ts-ignore Looks like a node.
	    node.type === 'element' &&
	    // @ts-ignore Looks like an element.
	    node.properties &&
	    // @ts-ignore Looks like an element.
	    own$3.call(node.properties, name) &&
	    // @ts-ignore Looks like an element.
	    node.properties[name];

	  return value !== null && value !== undefined && value !== false
	}

	/**
	 * @param {unknown} thing
	 * @returns {boolean}
	 */
	function whitespace$1(thing) {
	  /** @type {string} */
	  var value =
	    // @ts-ignore looks like a node.
	    thing && typeof thing === 'object' && thing.type === 'text'
	      ? // @ts-ignore looks like a text.
	        thing.value || ''
	      : thing;

	  // HTML whitespace expression.
	  // See <https://html.spec.whatwg.org/#space-character>.
	  return typeof value === 'string' && value.replace(/[ \t\n\f\r]/g, '') === ''
	}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').RulePseudo} RulePseudo
	 * @typedef {import('./types.js').RulePseudoNth} RulePseudoNth
	 * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector
	 * @typedef {import('./types.js').Parent} Parent
	 * @typedef {import('./types.js').Selector} Selector
	 * @typedef {import('./types.js').Selectors} Selectors
	 * @typedef {import('./types.js').SelectState} SelectState
	 * @typedef {import('./types.js').Element} Element
	 * @typedef {import('./types.js').ElementChild} ElementChild
	 */

	const handle$1 = zwitch('name', {
	  // @ts-expect-error: hush.
	  unknown: unknownPseudo,
	  invalid: invalidPseudo,
	  handlers: {
	    // @ts-expect-error: hush.
	    any: matches$1,
	    // @ts-expect-error: hush.
	    'any-link': anyLink,
	    // @ts-expect-error: hush.
	    blank,
	    // @ts-expect-error: hush.
	    checked,
	    // @ts-expect-error: hush.
	    dir,
	    // @ts-expect-error: hush.
	    disabled,
	    // @ts-expect-error: hush.
	    empty: empty$2,
	    // @ts-expect-error: hush.
	    enabled,
	    // @ts-expect-error: hush.
	    'first-child': firstChild,
	    // @ts-expect-error: hush.
	    'first-of-type': firstOfType,
	    // @ts-expect-error: hush.
	    has,
	    // @ts-expect-error: hush.
	    lang,
	    // @ts-expect-error: hush.
	    'last-child': lastChild,
	    // @ts-expect-error: hush.
	    'last-of-type': lastOfType,
	    // @ts-expect-error: hush.
	    matches: matches$1,
	    // @ts-expect-error: hush.
	    not: not$1,
	    // @ts-expect-error: hush.
	    'nth-child': nthChild,
	    // @ts-expect-error: hush.
	    'nth-last-child': nthLastChild,
	    // @ts-expect-error: hush.
	    'nth-of-type': nthOfType,
	    // @ts-expect-error: hush.
	    'nth-last-of-type': nthLastOfType,
	    // @ts-expect-error: hush.
	    'only-child': onlyChild,
	    // @ts-expect-error: hush.
	    'only-of-type': onlyOfType,
	    // @ts-expect-error: hush.
	    optional,
	    // @ts-expect-error: hush.
	    'read-only': readOnly,
	    // @ts-expect-error: hush.
	    'read-write': readWrite,
	    // @ts-expect-error: hush.
	    required,
	    // @ts-expect-error: hush.
	    root,
	    // @ts-expect-error: hush.
	    scope
	  }
	});

	pseudo.needsIndex = [
	  'first-child',
	  'first-of-type',
	  'last-child',
	  'last-of-type',
	  'nth-child',
	  'nth-last-child',
	  'nth-of-type',
	  'nth-last-of-type',
	  'only-child',
	  'only-of-type'
	];

	/**
	 * @param {Rule} query
	 * @param {Element} element
	 * @param {number|null} index
	 * @param {Parent|null} parent
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function pseudo(query, element, index, parent, state) {
	  const pseudos = query.pseudos;
	  let offset = -1;

	  while (++offset < pseudos.length) {
	    if (!handle$1(pseudos[offset], element, index, parent, state)) return false
	  }

	  return true
	}

	/**
	 * @param {RulePseudoSelector} query
	 * @param {Element} element
	 * @param {number|null} _1
	 * @param {Parent|null} _2
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function matches$1(query, element, _1, _2, state) {
	  const shallow = state.shallow;
	  const one = state.one;

	  state.shallow = true;
	  state.one = true;

	  const result = any(query.value, element, state)[0] === element;

	  state.shallow = shallow;
	  state.one = one;

	  return result
	}

	/**
	 * @param {RulePseudoSelector} query
	 * @param {Element} element
	 * @param {number|null} index
	 * @param {Parent|null} parent
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function not$1(query, element, index, parent, state) {
	  return !matches$1(query, element, index, parent, state)
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function anyLink(_, element) {
	  return (
	    isElement(element, ['a', 'area', 'link']) && hasProperty(element, 'href')
	  )
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function checked(_, element) {
	  if (isElement(element, ['input', 'menuitem'])) {
	    return Boolean(
	      element.properties &&
	        (element.properties.type === 'checkbox' ||
	          element.properties.type === 'radio') &&
	        hasProperty(element, 'checked')
	    )
	  }

	  if (isElement(element, 'option')) {
	    return hasProperty(element, 'selected')
	  }

	  return false
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function dir(query, _1, _2, _3, state) {
	  return state.direction === query.value
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function disabled(_, element) {
	  return (
	    isElement(element, [
	      'button',
	      'input',
	      'select',
	      'textarea',
	      'optgroup',
	      'option',
	      'menuitem',
	      'fieldset'
	    ]) && hasProperty(element, 'disabled')
	  )
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function enabled(query, element) {
	  return !disabled(query, element)
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function required(_, element) {
	  return (
	    isElement(element, ['input', 'textarea', 'select']) &&
	    hasProperty(element, 'required')
	  )
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function optional(query, element) {
	  return !required(query, element)
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @param {number|null} _1
	 * @param {Parent|null} _2
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function readWrite(_, element, _1, _2, state) {
	  return isElement(element, ['input', 'textarea'])
	    ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled')
	    : Boolean(state.editableOrEditingHost)
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} element
	 * @param {number|null} index
	 * @param {Parent|null} parent
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function readOnly(query, element, index, parent, state) {
	  return !readWrite(query, element, index, parent, state)
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @param {number|null} _1
	 * @param {Parent|null} parent
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function root(_, element, _1, parent, state) {
	  return Boolean(
	    (!parent || parent.type === 'root') &&
	      state.schema &&
	      (state.schema.space === 'html' || state.schema.space === 'svg') &&
	      isElement(element, ['html', 'svg'])
	  )
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @param {number|null} _1
	 * @param {Parent|null} _2
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function scope(_, element, _1, _2, state) {
	  return Boolean(
	    isElement(element) &&
	      state.scopeElements &&
	      state.scopeElements.includes(element)
	  )
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function empty$2(_, element) {
	  return !someChildren(element, check)

	  /**
	   * @param {ElementChild} child
	   * @returns {boolean}
	   */
	  function check(child) {
	    return child.type === 'element' || child.type === 'text'
	  }
	}

	/**
	 * @param {RulePseudo} _
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function blank(_, element) {
	  return !someChildren(element, check)

	  /**
	   * @param {ElementChild} child
	   * @returns {boolean}
	   */
	  function check(child) {
	    return (
	      child.type === 'element' || (child.type === 'text' && !whitespace$1(child))
	    )
	  }
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function firstChild(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return state.elementIndex === 0
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function lang(query, _1, _2, _3, state) {
	  return (
	    state.language !== '' &&
	    state.language !== undefined &&
	    state.language !== null &&
	    // @ts-expect-error never `selectors`.
	    extendedFilter(state.language, parse$3(query.value)).length > 0
	  )
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function lastChild(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return Boolean(
	    state.elementCount && state.elementIndex === state.elementCount - 1
	  )
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function onlyChild(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return state.elementCount === 1
	}

	/**
	 * @param {RulePseudoNth} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function nthChild(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return (
	    typeof state.elementIndex === 'number' && query.value(state.elementIndex)
	  )
	}

	/**
	 * @param {RulePseudoNth} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function nthLastChild(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return Boolean(
	    typeof state.elementCount === 'number' &&
	      typeof state.elementIndex === 'number' &&
	      query.value(state.elementCount - state.elementIndex - 1)
	  )
	}

	/**
	 * @param {RulePseudoNth} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function nthOfType(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return typeof state.typeIndex === 'number' && query.value(state.typeIndex)
	}

	/**
	 * @param {RulePseudoNth} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function nthLastOfType(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return (
	    typeof state.typeCount === 'number' &&
	    typeof state.typeIndex === 'number' &&
	    query.value(state.typeCount - 1 - state.typeIndex)
	  )
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function firstOfType(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return state.typeIndex === 0
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function lastOfType(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return (
	    typeof state.typeIndex === 'number' &&
	    typeof state.typeCount === 'number' &&
	    state.typeIndex === state.typeCount - 1
	  )
	}

	/**
	 * @param {RulePseudo} query
	 * @param {Element} _1
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function onlyOfType(query, _1, _2, _3, state) {
	  assertDeep(state, query);
	  return state.typeCount === 1
	}

	/**
	 * @param {Element} element
	 * @param {(child: ElementChild) => boolean} check
	 * @returns {boolean}
	 */
	function someChildren(element, check) {
	  const children = element.children;
	  let index = -1;

	  while (++index < children.length) {
	    if (check(children[index])) return true
	  }

	  return false
	}

	// Shouldnt be called, parser gives correct data.
	/* c8 ignore next 3 */
	function invalidPseudo() {
	  throw new Error('Invalid pseudo-selector')
	}

	/**
	 * @param {RulePseudo} query
	 */
	function unknownPseudo(query) {
	  if (query.name) {
	    throw new Error('Unknown pseudo-selector `' + query.name + '`')
	  }

	  throw new Error('Unexpected pseudo-element or empty pseudo-class')
	}

	/**
	 * @param {SelectState} state
	 * @param {RulePseudo|RulePseudoNth} query
	 */
	function assertDeep(state, query) {
	  if (state.shallow) {
	    throw new Error('Cannot use `:' + query.name + '` without parent')
	  }
	}

	/**
	 * @param {RulePseudoSelector} query
	 * @param {Element} element
	 * @param {number|null} _2
	 * @param {Parent|null} _3
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function has(query, element, _2, _3, state) {
	  const shallow = state.shallow;
	  const one = state.one;
	  const scopeElements = state.scopeElements;
	  const value = appendScope(query.value);

	  state.shallow = false;
	  state.one = true;
	  state.scopeElements = [element];

	  const result = any(value, element, state).length > 0;

	  state.shallow = shallow;
	  state.one = one;
	  state.scopeElements = scopeElements;

	  return result
	}

	/**
	 * @param {Selector} value
	 * @returns {Selectors}
	 */
	function appendScope(value) {
	  /** @type {Selectors} */
	  const selector =
	    value.type === 'ruleSet' ? {type: 'selectors', selectors: [value]} : value;
	  let index = -1;

	  while (++index < selector.selectors.length) {
	    const rule = selector.selectors[index].rule;
	    rule.nestingOperator = null;

	    if (
	      !rule.pseudos ||
	      rule.pseudos.length !== 1 ||
	      rule.pseudos[0].name !== 'scope'
	    ) {
	      selector.selectors[index] = {
	        type: 'ruleSet',
	        // @ts-expect-error pseudos are fine w/ just a name!
	        rule: {type: 'rule', rule, pseudos: [{name: 'scope'}]}
	      };
	    }
	  }

	  return selector
	}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').RuleAttr} RuleAttr
	 * @typedef {import('./types.js').Element} Element
	 * @typedef {import('./types.js').Schema} Schema
	 * @typedef {import('./types.js').Info} Info
	 * @typedef {import('./types.js').PropertyValue} PropertyValue
	 */

	const handle = zwitch('operator', {
	  // @ts-expect-error: hush.
	  unknown: unknownOperator,
	  // @ts-expect-error: hush.
	  invalid: exists,
	  handlers: {
	    // @ts-expect-error: hush.
	    '=': exact,
	    // @ts-expect-error: hush.
	    '~=': spaceSeparatedList,
	    // @ts-expect-error: hush.
	    '|=': exactOrPrefix,
	    // @ts-expect-error: hush.
	    '^=': begins,
	    // @ts-expect-error: hush.
	    '$=': ends,
	    // @ts-expect-error: hush.
	    '*=': contains
	  }
	});

	/**
	 * @param {Rule} query
	 * @param {Element} element
	 * @param {Schema} schema
	 * @returns {boolean}
	 */
	function attribute(query, element, schema) {
	  const attrs = query.attrs;
	  let index = -1;

	  while (++index < attrs.length) {
	    if (!handle(attrs[index], element, find(schema, attrs[index].name))) {
	      return false
	    }
	  }

	  return true
	}

	/**
	 * `[attr]`
	 *
	 * @param {RuleAttr} _
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function exists(_, element, info) {
	  return hasProperty(element, info.property)
	}

	/**
	 * `[attr=value]`
	 *
	 * @param {RuleAttr} query
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function exact(query, element, info) {
	  return Boolean(
	    hasProperty(element, info.property) &&
	      element.properties &&
	      normalizeValue(element.properties[info.property], info) === query.value
	  )
	}

	/**
	 * `[attr~=value]`
	 *
	 * @param {RuleAttr} query
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function spaceSeparatedList(query, element, info) {
	  const value = element.properties && element.properties[info.property];

	  return (
	    // If this is a comma-separated list, and the query is contained in it, return
	    // true.
	    (!info.commaSeparated &&
	      value &&
	      typeof value === 'object' &&
	      query.value &&
	      value.includes(query.value)) ||
	    // For all other values (including comma-separated lists), return whether this
	    // is an exact match.
	    (hasProperty(element, info.property) &&
	      normalizeValue(value, info) === query.value)
	  )
	}

	/**
	 * `[attr|=value]`
	 *
	 * @param {RuleAttr} query
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function exactOrPrefix(query, element, info) {
	  const value = normalizeValue(
	    element.properties && element.properties[info.property],
	    info
	  );

	  return Boolean(
	    hasProperty(element, info.property) &&
	      query.value &&
	      (value === query.value ||
	        (value.slice(0, query.value.length) === query.value &&
	          value.charAt(query.value.length) === '-'))
	  )
	}

	/**
	 * `[attr^=value]`
	 *
	 * @param {RuleAttr} query
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function begins(query, element, info) {
	  return Boolean(
	    hasProperty(element, info.property) &&
	      element.properties &&
	      query.value &&
	      normalizeValue(element.properties[info.property], info).slice(
	        0,
	        query.value.length
	      ) === query.value
	  )
	}

	/**
	 * `[attr$=value]`
	 *
	 * @param {RuleAttr} query
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function ends(query, element, info) {
	  return Boolean(
	    hasProperty(element, info.property) &&
	      element.properties &&
	      query.value &&
	      normalizeValue(element.properties[info.property], info).slice(
	        -query.value.length
	      ) === query.value
	  )
	}

	/**
	 * `[attr*=value]`
	 *
	 * @param {RuleAttr} query
	 * @param {Element} element
	 * @param {Info} info
	 * @returns {boolean}
	 */
	function contains(query, element, info) {
	  return Boolean(
	    hasProperty(element, info.property) &&
	      element.properties &&
	      query.value &&
	      normalizeValue(element.properties[info.property], info).includes(
	        query.value
	      )
	  )
	}

	// Shouldnt be called, Parser throws an error instead.
	/**
	 * @param {RuleAttr} query
	 * @returns {boolean}
	 */
	/* c8 ignore next 3 */
	function unknownOperator(query) {
	  throw new Error('Unknown operator `' + query.operator + '`')
	}

	/**
	 * Stringify a hast value back to its HTML form.
	 *
	 * @param {PropertyValue} value
	 * @param {Info} info
	 * @returns {string}
	 */
	function normalizeValue(value, info) {
	  if (typeof value === 'boolean') {
	    return info.attribute
	  }

	  if (Array.isArray(value)) {
	    return (info.commaSeparated ? stringify : stringify$1)(value)
	  }

	  return String(value)
	}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').Element} Element
	 */

	/**
	 * @param {Rule} query
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function className(query, element) {
	  /** @type {Array<string>} */
	  // @ts-expect-error Assume array.
	  const value = element.properties.className || [];
	  let index = -1;

	  if (query.classNames) {
	    while (++index < query.classNames.length) {
	      if (!value.includes(query.classNames[index])) return false
	    }
	  }

	  return true
	}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').Element} Element
	 */

	/**
	 * @param {Rule} query
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function id(query, element) {
	  return Boolean(element.properties && element.properties.id === query.id)
	}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').Element} Element
	 */

	/**
	 * @param {Rule} query
	 * @param {Element} element
	 * @returns {boolean}
	 */
	function name(query, element) {
	  return query.tagName === '*' || query.tagName === element.tagName
	}

	/**
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').HastNode} HastNode
	 * @typedef {import('./types.js').Element} Element
	 * @typedef {import('./types.js').Parent} Parent
	 * @typedef {import('./types.js').SelectState} SelectState
	 * @typedef {import('hast-util-is-element').AssertPredicate<Element>} IsElement
	 */

	/**
	 * @param {Rule} query
	 * @param {HastNode} node
	 * @param {number|null} index
	 * @param {Parent|null} parent
	 * @param {SelectState} state
	 * @returns {boolean}
	 */
	function test(query, node, index, parent, state) {
	  return Boolean(
	    element$1(node) &&
	      state.schema &&
	      (!query.tagName || name(query, node)) &&
	      (!query.classNames || className(query, node)) &&
	      (!query.id || id(query, node)) &&
	      (!query.attrs || attribute(query, node, state.schema)) &&
	      (!query.pseudos || pseudo(query, node, index, parent, state))
	  )
	}

	/**
	 * @typedef {import('hast').Element} Element
	 * @typedef {import('./types.js').Selectors} Selectors
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').RuleSet} RuleSet
	 * @typedef {import('./types.js').HastNode} HastNode
	 * @typedef {import('./types.js').SelectIterator} SelectIterator
	 * @typedef {import('./types.js').SelectState} SelectState
	 */

	const type = zwitch('type', {
	  // @ts-expect-error: hush.
	  unknown: unknownType,
	  invalid: invalidType,
	  // @ts-expect-error: hush.
	  handlers: {selectors: selectors$1, ruleSet: ruleSet$1, rule: rule$1}
	});

	/**
	 * @param {Selectors|RuleSet|Rule} query
	 * @param {HastNode|undefined} node
	 * @param {SelectState} state
	 * @returns {Array<Element>}
	 */
	function any(query, node, state) {
	  // @ts-expect-error zwitch types are off.
	  return query && node ? type(query, node, state) : []
	}

	/**
	 * @param {Selectors} query
	 * @param {HastNode} node
	 * @param {SelectState} state
	 * @returns {Array<Element>}
	 */
	function selectors$1(query, node, state) {
	  const collector = new Collector(state.one);
	  let index = -1;

	  while (++index < query.selectors.length) {
	    collector.collectAll(ruleSet$1(query.selectors[index], node, state));
	  }

	  return collector.result
	}

	/**
	 * @param {RuleSet} query
	 * @param {HastNode} node
	 * @param {SelectState} state
	 * @returns {Array<Element>}
	 */
	function ruleSet$1(query, node, state) {
	  return rule$1(query.rule, node, state)
	}

	/**
	 * @param {Rule} query
	 * @param {HastNode} tree
	 * @param {SelectState} state
	 * @returns {Array<Element>}
	 */
	function rule$1(query, tree, state) {
	  const collector = new Collector(state.one);

	  if (state.shallow && query.rule) {
	    throw new Error('Expected selector without nesting')
	  }

	  nest(
	    query,
	    tree,
	    0,
	    null,
	    configure(query, {
	      schema: state.space === 'svg' ? svg : html$2,
	      language: undefined,
	      direction: 'ltr',
	      editableOrEditingHost: false,
	      // @ts-expect-error assume elements.
	      scopeElements: tree.type === 'root' ? tree.children : [tree],
	      iterator,
	      one: state.one,
	      shallow: state.shallow
	    })
	  );

	  return collector.result

	  /** @type {SelectIterator} */
	  function iterator(query, node, index, parent, state) {
	    const exit = enterState(state, node);

	    if (test(query, node, index, parent, state)) {
	      if (query.rule) {
	        nest(query.rule, node, index, parent, configure(query.rule, state));
	      } else {
	        // @ts-expect-error `test` also asserts `node is Element`
	        collector.collect(node);
	        state.found = true;
	      }
	    }

	    exit();
	  }

	  /**
	   * @template {SelectState} S
	   * @param {Rule} query
	   * @param {S} state
	   * @returns {S}
	   */
	  function configure(query, state) {
	    const pseudos = query.pseudos || [];
	    let index = -1;

	    while (++index < pseudos.length) {
	      if (pseudo.needsIndex.includes(pseudos[index].name)) {
	        state.index = true;
	        break
	      }
	    }

	    return state
	  }
	}

	// Shouldnt be called, all data is handled.
	/* c8 ignore next 6 */
	/**
	 * @param {{[x: string]: unknown, type: string}} query
	 */
	function unknownType(query) {
	  throw new Error('Unknown type `' + query.type + '`')
	}

	// Shouldnt be called, parser gives correct data.
	/* c8 ignore next 3 */
	function invalidType() {
	  throw new Error('Invalid type')
	}

	class Collector {
	  /**
	   * @param {boolean|undefined} [one]
	   */
	  constructor(one) {
	    /** @type {Array<Element>} */
	    this.result = [];
	    /** @type {boolean|undefined} */
	    this.one = one;
	    /** @type {boolean} */
	    this.found = false;
	  }

	  /**
	   * Append nodes to array, filtering out duplicates.
	   *
	   * @param {Array<Element>} elements
	   */
	  collectAll(elements) {
	    let index = -1;

	    while (++index < elements.length) {
	      this.collect(elements[index]);
	    }
	  }

	  /**
	   * Append one node.
	   *
	   * @param {Element} element
	   */
	  collect(element) {
	    if (this.one) {
	      // Shouldnt happen, safeguards performance problems.
	      /* c8 ignore next */
	      if (this.found) return
	      this.found = true;
	    }

	    if (!this.result.includes(element)) this.result.push(element);
	  }
	}

	var lib = {};

	var parserContext = {};

	var utils = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		function isIdentStart(c) {
		    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c === '-') || (c === '_');
		}
		exports.isIdentStart = isIdentStart;
		function isIdent(c) {
		    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '-' || c === '_';
		}
		exports.isIdent = isIdent;
		function isHex(c) {
		    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');
		}
		exports.isHex = isHex;
		function escapeIdentifier(s) {
		    var len = s.length;
		    var result = '';
		    var i = 0;
		    while (i < len) {
		        var chr = s.charAt(i);
		        if (exports.identSpecialChars[chr]) {
		            result += '\\' + chr;
		        }
		        else {
		            if (!(chr === '_' || chr === '-' ||
		                (chr >= 'A' && chr <= 'Z') ||
		                (chr >= 'a' && chr <= 'z') ||
		                (i !== 0 && chr >= '0' && chr <= '9'))) {
		                var charCode = chr.charCodeAt(0);
		                if ((charCode & 0xF800) === 0xD800) {
		                    var extraCharCode = s.charCodeAt(i++);
		                    if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) {
		                        throw Error('UCS-2(decode): illegal sequence');
		                    }
		                    charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;
		                }
		                result += '\\' + charCode.toString(16) + ' ';
		            }
		            else {
		                result += chr;
		            }
		        }
		        i++;
		    }
		    return result;
		}
		exports.escapeIdentifier = escapeIdentifier;
		function escapeStr(s) {
		    var len = s.length;
		    var result = '';
		    var i = 0;
		    var replacement;
		    while (i < len) {
		        var chr = s.charAt(i);
		        if (chr === '"') {
		            chr = '\\"';
		        }
		        else if (chr === '\\') {
		            chr = '\\\\';
		        }
		        else if ((replacement = exports.strReplacementsRev[chr]) !== undefined) {
		            chr = replacement;
		        }
		        result += chr;
		        i++;
		    }
		    return "\"" + result + "\"";
		}
		exports.escapeStr = escapeStr;
		exports.identSpecialChars = {
		    '!': true,
		    '"': true,
		    '#': true,
		    '$': true,
		    '%': true,
		    '&': true,
		    '\'': true,
		    '(': true,
		    ')': true,
		    '*': true,
		    '+': true,
		    ',': true,
		    '.': true,
		    '/': true,
		    ';': true,
		    '<': true,
		    '=': true,
		    '>': true,
		    '?': true,
		    '@': true,
		    '[': true,
		    '\\': true,
		    ']': true,
		    '^': true,
		    '`': true,
		    '{': true,
		    '|': true,
		    '}': true,
		    '~': true
		};
		exports.strReplacementsRev = {
		    '\n': '\\n',
		    '\r': '\\r',
		    '\t': '\\t',
		    '\f': '\\f',
		    '\v': '\\v'
		};
		exports.singleQuoteEscapeChars = {
		    n: '\n',
		    r: '\r',
		    t: '\t',
		    f: '\f',
		    '\\': '\\',
		    '\'': '\''
		};
		exports.doubleQuotesEscapeChars = {
		    n: '\n',
		    r: '\r',
		    t: '\t',
		    f: '\f',
		    '\\': '\\',
		    '"': '"'
		};
	} (utils));

	Object.defineProperty(parserContext, "__esModule", { value: true });
	var utils_1$1 = utils;
	function parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {
	    var l = str.length;
	    var chr = '';
	    function getStr(quote, escapeTable) {
	        var result = '';
	        pos++;
	        chr = str.charAt(pos);
	        while (pos < l) {
	            if (chr === quote) {
	                pos++;
	                return result;
	            }
	            else if (chr === '\\') {
	                pos++;
	                chr = str.charAt(pos);
	                var esc = void 0;
	                if (chr === quote) {
	                    result += quote;
	                }
	                else if ((esc = escapeTable[chr]) !== undefined) {
	                    result += esc;
	                }
	                else if (utils_1$1.isHex(chr)) {
	                    var hex = chr;
	                    pos++;
	                    chr = str.charAt(pos);
	                    while (utils_1$1.isHex(chr)) {
	                        hex += chr;
	                        pos++;
	                        chr = str.charAt(pos);
	                    }
	                    if (chr === ' ') {
	                        pos++;
	                        chr = str.charAt(pos);
	                    }
	                    result += String.fromCharCode(parseInt(hex, 16));
	                    continue;
	                }
	                else {
	                    result += chr;
	                }
	            }
	            else {
	                result += chr;
	            }
	            pos++;
	            chr = str.charAt(pos);
	        }
	        return result;
	    }
	    function getIdent() {
	        var result = '';
	        chr = str.charAt(pos);
	        while (pos < l) {
	            if (utils_1$1.isIdent(chr)) {
	                result += chr;
	            }
	            else if (chr === '\\') {
	                pos++;
	                if (pos >= l) {
	                    throw Error('Expected symbol but end of file reached.');
	                }
	                chr = str.charAt(pos);
	                if (utils_1$1.identSpecialChars[chr]) {
	                    result += chr;
	                }
	                else if (utils_1$1.isHex(chr)) {
	                    var hex = chr;
	                    pos++;
	                    chr = str.charAt(pos);
	                    while (utils_1$1.isHex(chr)) {
	                        hex += chr;
	                        pos++;
	                        chr = str.charAt(pos);
	                    }
	                    if (chr === ' ') {
	                        pos++;
	                        chr = str.charAt(pos);
	                    }
	                    result += String.fromCharCode(parseInt(hex, 16));
	                    continue;
	                }
	                else {
	                    result += chr;
	                }
	            }
	            else {
	                return result;
	            }
	            pos++;
	            chr = str.charAt(pos);
	        }
	        return result;
	    }
	    function skipWhitespace() {
	        chr = str.charAt(pos);
	        var result = false;
	        while (chr === ' ' || chr === "\t" || chr === "\n" || chr === "\r" || chr === "\f") {
	            result = true;
	            pos++;
	            chr = str.charAt(pos);
	        }
	        return result;
	    }
	    function parse() {
	        var res = parseSelector();
	        if (pos < l) {
	            throw Error('Rule expected but "' + str.charAt(pos) + '" found.');
	        }
	        return res;
	    }
	    function parseSelector() {
	        var selector = parseSingleSelector();
	        if (!selector) {
	            return null;
	        }
	        var res = selector;
	        chr = str.charAt(pos);
	        while (chr === ',') {
	            pos++;
	            skipWhitespace();
	            if (res.type !== 'selectors') {
	                res = {
	                    type: 'selectors',
	                    selectors: [selector]
	                };
	            }
	            selector = parseSingleSelector();
	            if (!selector) {
	                throw Error('Rule expected after ",".');
	            }
	            res.selectors.push(selector);
	        }
	        return res;
	    }
	    function parseSingleSelector() {
	        skipWhitespace();
	        var selector = {
	            type: 'ruleSet'
	        };
	        var rule = parseRule();
	        if (!rule) {
	            return null;
	        }
	        var currentRule = selector;
	        while (rule) {
	            rule.type = 'rule';
	            currentRule.rule = rule;
	            currentRule = rule;
	            skipWhitespace();
	            chr = str.charAt(pos);
	            if (pos >= l || chr === ',' || chr === ')') {
	                break;
	            }
	            if (ruleNestingOperators[chr]) {
	                var op = chr;
	                pos++;
	                skipWhitespace();
	                rule = parseRule();
	                if (!rule) {
	                    throw Error('Rule expected after "' + op + '".');
	                }
	                rule.nestingOperator = op;
	            }
	            else {
	                rule = parseRule();
	                if (rule) {
	                    rule.nestingOperator = null;
	                }
	            }
	        }
	        return selector;
	    }
	    // @ts-ignore no-overlap
	    function parseRule() {
	        var rule = null;
	        while (pos < l) {
	            chr = str.charAt(pos);
	            if (chr === '*') {
	                pos++;
	                (rule = rule || {}).tagName = '*';
	            }
	            else if (utils_1$1.isIdentStart(chr) || chr === '\\') {
	                (rule = rule || {}).tagName = getIdent();
	            }
	            else if (chr === '.') {
	                pos++;
	                rule = rule || {};
	                (rule.classNames = rule.classNames || []).push(getIdent());
	            }
	            else if (chr === '#') {
	                pos++;
	                (rule = rule || {}).id = getIdent();
	            }
	            else if (chr === '[') {
	                pos++;
	                skipWhitespace();
	                var attr = {
	                    name: getIdent()
	                };
	                skipWhitespace();
	                // @ts-ignore
	                if (chr === ']') {
	                    pos++;
	                }
	                else {
	                    var operator = '';
	                    if (attrEqualityMods[chr]) {
	                        operator = chr;
	                        pos++;
	                        chr = str.charAt(pos);
	                    }
	                    if (pos >= l) {
	                        throw Error('Expected "=" but end of file reached.');
	                    }
	                    if (chr !== '=') {
	                        throw Error('Expected "=" but "' + chr + '" found.');
	                    }
	                    attr.operator = operator + '=';
	                    pos++;
	                    skipWhitespace();
	                    var attrValue = '';
	                    attr.valueType = 'string';
	                    // @ts-ignore
	                    if (chr === '"') {
	                        attrValue = getStr('"', utils_1$1.doubleQuotesEscapeChars);
	                        // @ts-ignore
	                    }
	                    else if (chr === '\'') {
	                        attrValue = getStr('\'', utils_1$1.singleQuoteEscapeChars);
	                        // @ts-ignore
	                    }
	                    else if (substitutesEnabled && chr === '$') {
	                        pos++;
	                        attrValue = getIdent();
	                        attr.valueType = 'substitute';
	                    }
	                    else {
	                        while (pos < l) {
	                            if (chr === ']') {
	                                break;
	                            }
	                            attrValue += chr;
	                            pos++;
	                            chr = str.charAt(pos);
	                        }
	                        attrValue = attrValue.trim();
	                    }
	                    skipWhitespace();
	                    if (pos >= l) {
	                        throw Error('Expected "]" but end of file reached.');
	                    }
	                    if (chr !== ']') {
	                        throw Error('Expected "]" but "' + chr + '" found.');
	                    }
	                    pos++;
	                    attr.value = attrValue;
	                }
	                rule = rule || {};
	                (rule.attrs = rule.attrs || []).push(attr);
	            }
	            else if (chr === ':') {
	                pos++;
	                var pseudoName = getIdent();
	                var pseudo = {
	                    name: pseudoName
	                };
	                // @ts-ignore
	                if (chr === '(') {
	                    pos++;
	                    var value = '';
	                    skipWhitespace();
	                    if (pseudos[pseudoName] === 'selector') {
	                        pseudo.valueType = 'selector';
	                        value = parseSelector();
	                    }
	                    else {
	                        pseudo.valueType = pseudos[pseudoName] || 'string';
	                        // @ts-ignore
	                        if (chr === '"') {
	                            value = getStr('"', utils_1$1.doubleQuotesEscapeChars);
	                            // @ts-ignore
	                        }
	                        else if (chr === '\'') {
	                            value = getStr('\'', utils_1$1.singleQuoteEscapeChars);
	                            // @ts-ignore
	                        }
	                        else if (substitutesEnabled && chr === '$') {
	                            pos++;
	                            value = getIdent();
	                            pseudo.valueType = 'substitute';
	                        }
	                        else {
	                            while (pos < l) {
	                                if (chr === ')') {
	                                    break;
	                                }
	                                value += chr;
	                                pos++;
	                                chr = str.charAt(pos);
	                            }
	                            value = value.trim();
	                        }
	                        skipWhitespace();
	                    }
	                    if (pos >= l) {
	                        throw Error('Expected ")" but end of file reached.');
	                    }
	                    if (chr !== ')') {
	                        throw Error('Expected ")" but "' + chr + '" found.');
	                    }
	                    pos++;
	                    pseudo.value = value;
	                }
	                rule = rule || {};
	                (rule.pseudos = rule.pseudos || []).push(pseudo);
	            }
	            else {
	                break;
	            }
	        }
	        return rule;
	    }
	    return parse();
	}
	parserContext.parseCssSelector = parseCssSelector;

	var render = {};

	Object.defineProperty(render, "__esModule", { value: true });
	var utils_1 = utils;
	function renderEntity(entity) {
	    var res = '';
	    switch (entity.type) {
	        case 'ruleSet':
	            var currentEntity = entity.rule;
	            var parts = [];
	            while (currentEntity) {
	                if (currentEntity.nestingOperator) {
	                    parts.push(currentEntity.nestingOperator);
	                }
	                parts.push(renderEntity(currentEntity));
	                currentEntity = currentEntity.rule;
	            }
	            res = parts.join(' ');
	            break;
	        case 'selectors':
	            res = entity.selectors.map(renderEntity).join(', ');
	            break;
	        case 'rule':
	            if (entity.tagName) {
	                if (entity.tagName === '*') {
	                    res = '*';
	                }
	                else {
	                    res = utils_1.escapeIdentifier(entity.tagName);
	                }
	            }
	            if (entity.id) {
	                res += "#" + utils_1.escapeIdentifier(entity.id);
	            }
	            if (entity.classNames) {
	                res += entity.classNames.map(function (cn) {
	                    return "." + (utils_1.escapeIdentifier(cn));
	                }).join('');
	            }
	            if (entity.attrs) {
	                res += entity.attrs.map(function (attr) {
	                    if ('operator' in attr) {
	                        if (attr.valueType === 'substitute') {
	                            return "[" + utils_1.escapeIdentifier(attr.name) + attr.operator + "$" + attr.value + "]";
	                        }
	                        else {
	                            return "[" + utils_1.escapeIdentifier(attr.name) + attr.operator + utils_1.escapeStr(attr.value) + "]";
	                        }
	                    }
	                    else {
	                        return "[" + utils_1.escapeIdentifier(attr.name) + "]";
	                    }
	                }).join('');
	            }
	            if (entity.pseudos) {
	                res += entity.pseudos.map(function (pseudo) {
	                    if (pseudo.valueType) {
	                        if (pseudo.valueType === 'selector') {
	                            return ":" + utils_1.escapeIdentifier(pseudo.name) + "(" + renderEntity(pseudo.value) + ")";
	                        }
	                        else if (pseudo.valueType === 'substitute') {
	                            return ":" + utils_1.escapeIdentifier(pseudo.name) + "($" + pseudo.value + ")";
	                        }
	                        else if (pseudo.valueType === 'numeric') {
	                            return ":" + utils_1.escapeIdentifier(pseudo.name) + "(" + pseudo.value + ")";
	                        }
	                        else {
	                            return (":" + utils_1.escapeIdentifier(pseudo.name) +
	                                "(" + utils_1.escapeIdentifier(pseudo.value) + ")");
	                        }
	                    }
	                    else {
	                        return ":" + utils_1.escapeIdentifier(pseudo.name);
	                    }
	                }).join('');
	            }
	            break;
	        default:
	            throw Error('Unknown entity type: "' + entity.type + '".');
	    }
	    return res;
	}
	render.renderEntity = renderEntity;

	Object.defineProperty(lib, "__esModule", { value: true });
	var parser_context_1 = parserContext;
	var render_1 = render;
	var CssSelectorParser = /** @class */ (function () {
	    function CssSelectorParser() {
	        this.pseudos = {};
	        this.attrEqualityMods = {};
	        this.ruleNestingOperators = {};
	        this.substitutesEnabled = false;
	    }
	    CssSelectorParser.prototype.registerSelectorPseudos = function () {
	        var pseudos = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            pseudos[_i] = arguments[_i];
	        }
	        for (var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++) {
	            var pseudo = pseudos_1[_a];
	            this.pseudos[pseudo] = 'selector';
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.unregisterSelectorPseudos = function () {
	        var pseudos = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            pseudos[_i] = arguments[_i];
	        }
	        for (var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++) {
	            var pseudo = pseudos_2[_a];
	            delete this.pseudos[pseudo];
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.registerNumericPseudos = function () {
	        var pseudos = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            pseudos[_i] = arguments[_i];
	        }
	        for (var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++) {
	            var pseudo = pseudos_3[_a];
	            this.pseudos[pseudo] = 'numeric';
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.unregisterNumericPseudos = function () {
	        var pseudos = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            pseudos[_i] = arguments[_i];
	        }
	        for (var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++) {
	            var pseudo = pseudos_4[_a];
	            delete this.pseudos[pseudo];
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.registerNestingOperators = function () {
	        var operators = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operators[_i] = arguments[_i];
	        }
	        for (var _a = 0, operators_1 = operators; _a < operators_1.length; _a++) {
	            var operator = operators_1[_a];
	            this.ruleNestingOperators[operator] = true;
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.unregisterNestingOperators = function () {
	        var operators = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operators[_i] = arguments[_i];
	        }
	        for (var _a = 0, operators_2 = operators; _a < operators_2.length; _a++) {
	            var operator = operators_2[_a];
	            delete this.ruleNestingOperators[operator];
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.registerAttrEqualityMods = function () {
	        var mods = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            mods[_i] = arguments[_i];
	        }
	        for (var _a = 0, mods_1 = mods; _a < mods_1.length; _a++) {
	            var mod = mods_1[_a];
	            this.attrEqualityMods[mod] = true;
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.unregisterAttrEqualityMods = function () {
	        var mods = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            mods[_i] = arguments[_i];
	        }
	        for (var _a = 0, mods_2 = mods; _a < mods_2.length; _a++) {
	            var mod = mods_2[_a];
	            delete this.attrEqualityMods[mod];
	        }
	        return this;
	    };
	    CssSelectorParser.prototype.enableSubstitutes = function () {
	        this.substitutesEnabled = true;
	        return this;
	    };
	    CssSelectorParser.prototype.disableSubstitutes = function () {
	        this.substitutesEnabled = false;
	        return this;
	    };
	    CssSelectorParser.prototype.parse = function (str) {
	        return parser_context_1.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
	    };
	    CssSelectorParser.prototype.render = function (path) {
	        return render_1.renderEntity(path).trim();
	    };
	    return CssSelectorParser;
	}());
	var CssSelectorParser_1 = lib.CssSelectorParser = CssSelectorParser;

	// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
	// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
	const whitespace = new Set([9, 10, 12, 13, 32]);
	const ZERO = "0".charCodeAt(0);
	const NINE = "9".charCodeAt(0);
	/**
	 * Parses an expression.
	 *
	 * @throws An `Error` if parsing fails.
	 * @returns An array containing the integer step size and the integer offset of the nth rule.
	 * @example nthCheck.parse("2n+3"); // returns [2, 3]
	 */
	function parse$2(formula) {
	    formula = formula.trim().toLowerCase();
	    if (formula === "even") {
	        return [2, 0];
	    }
	    else if (formula === "odd") {
	        return [2, 1];
	    }
	    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
	    let idx = 0;
	    let a = 0;
	    let sign = readSign();
	    let number = readNumber();
	    if (idx < formula.length && formula.charAt(idx) === "n") {
	        idx++;
	        a = sign * (number !== null && number !== void 0 ? number : 1);
	        skipWhitespace();
	        if (idx < formula.length) {
	            sign = readSign();
	            skipWhitespace();
	            number = readNumber();
	        }
	        else {
	            sign = number = 0;
	        }
	    }
	    // Throw if there is anything else
	    if (number === null || idx < formula.length) {
	        throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
	    }
	    return [a, sign * number];
	    function readSign() {
	        if (formula.charAt(idx) === "-") {
	            idx++;
	            return -1;
	        }
	        if (formula.charAt(idx) === "+") {
	            idx++;
	        }
	        return 1;
	    }
	    function readNumber() {
	        const start = idx;
	        let value = 0;
	        while (idx < formula.length &&
	            formula.charCodeAt(idx) >= ZERO &&
	            formula.charCodeAt(idx) <= NINE) {
	            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
	            idx++;
	        }
	        // Return `null` if we didn't read anything.
	        return idx === start ? null : value;
	    }
	    function skipWhitespace() {
	        while (idx < formula.length &&
	            whitespace.has(formula.charCodeAt(idx))) {
	            idx++;
	        }
	    }
	}

	var boolbase = {
		trueFunc: function trueFunc(){
			return true;
		},
		falseFunc: function falseFunc(){
			return false;
		}
	};

	/**
	 * Returns a function that checks if an elements index matches the given rule
	 * highly optimized to return the fastest solution.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A highly optimized function that returns whether an index matches the nth-check.
	 * @example
	 *
	 * ```js
	 * const check = nthCheck.compile([2, 3]);
	 *
	 * check(0); // `false`
	 * check(1); // `false`
	 * check(2); // `true`
	 * check(3); // `false`
	 * check(4); // `true`
	 * check(5); // `false`
	 * check(6); // `true`
	 * ```
	 */
	function compile$1(parsed) {
	    const a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    const b = parsed[1] - 1;
	    /*
	     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
	     * Besides, the specification states that no elements are
	     * matched when `a` and `b` are 0.
	     *
	     * `b < 0` here as we subtracted 1 from `b` above.
	     */
	    if (b < 0 && a <= 0)
	        return boolbase.falseFunc;
	    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
	    if (a === -1)
	        return (index) => index <= b;
	    if (a === 0)
	        return (index) => index === b;
	    // When `b <= 0` and `a === 1`, they match any element.
	    if (a === 1)
	        return b < 0 ? boolbase.trueFunc : (index) => index >= b;
	    /*
	     * Otherwise, modulo can be used to check if there is a match.
	     *
	     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
	     */
	    const absA = Math.abs(a);
	    // Get `b mod a`, + a if this is negative.
	    const bMod = ((b % absA) + absA) % absA;
	    return a > 1
	        ? (index) => index >= b && index % absA === bMod
	        : (index) => index <= b && index % absA === bMod;
	}

	/**
	 * Parses and compiles a formula to a highly optimized function.
	 * Combination of {@link parse} and {@link compile}.
	 *
	 * If the formula doesn't match any elements,
	 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
	 * Otherwise, a function accepting an _index_ is returned, which returns
	 * whether or not the passed _index_ matches the formula.
	 *
	 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
	 *
	 * @param formula The formula to compile.
	 * @example
	 * const check = nthCheck("2n+3");
	 *
	 * check(0); // `false`
	 * check(1); // `false`
	 * check(2); // `true`
	 * check(3); // `false`
	 * check(4); // `true`
	 * check(5); // `false`
	 * check(6); // `true`
	 */
	function nthCheck$1(formula) {
	    return compile$1(parse$2(formula));
	}

	/**
	 * @typedef {import('./types.js').Selector} Selector
	 * @typedef {import('./types.js').Selectors} Selectors
	 * @typedef {import('./types.js').RuleSet} RuleSet
	 * @typedef {import('./types.js').Rule} Rule
	 * @typedef {import('./types.js').RulePseudo} RulePseudo
	 * @typedef {import('./types.js').RulePseudoNth} RulePseudoNth
	 */

	/** @type {import('nth-check').default} */
	// @ts-expect-error
	const nthCheck = nthCheck$1.default || nthCheck$1;

	const nth = new Set([
	  'nth-child',
	  'nth-last-child',
	  'nth-of-type',
	  'nth-last-of-type'
	]);

	const parser = new CssSelectorParser_1();

	// @ts-expect-error: hush.
	const compile = zwitch('type', {handlers: {selectors, ruleSet, rule}});

	parser.registerAttrEqualityMods('~', '|', '^', '$', '*');
	parser.registerSelectorPseudos('any', 'matches', 'not', 'has');
	parser.registerNestingOperators('>', '+', '~');

	/**
	 * @param {string} selector
	 * @returns {Selector}
	 */
	function parse$1(selector) {
	  if (typeof selector !== 'string') {
	    throw new TypeError('Expected `string` as selector, not `' + selector + '`')
	  }

	  // @ts-expect-error types are wrong.
	  return compile(parser.parse(selector))
	}

	/**
	 * @param {Selectors} query
	 * @returns {Selectors}
	 */
	function selectors(query) {
	  let index = -1;

	  while (++index < query.selectors.length) {
	    compile(query.selectors[index]);
	  }

	  return query
	}

	/**
	 * @param {RuleSet} query
	 * @returns {Rule}
	 */
	function ruleSet(query) {
	  return rule(query.rule)
	}

	/**
	 * @param {Rule} query
	 * @returns {Rule}
	 */
	function rule(query) {
	  const pseudos = query.pseudos || [];
	  let index = -1;

	  while (++index < pseudos.length) {
	    const pseudo = pseudos[index];

	    if (nth.has(pseudo.name)) {
	      // @ts-expect-error Patch a non-primitive type.
	      pseudo.value = nthCheck(pseudo.value);
	      // @ts-expect-error Patch a non-primitive type.
	      pseudo.valueType = 'function';
	    }
	  }

	  compile(query.rule);

	  return query
	}

	/**
	 * @typedef {import('./lib/types.js').Element} Element
	 * @typedef {import('./lib/types.js').HastNode} HastNode
	 * @typedef {import('./lib/types.js').Space} Space
	 */

	/**
	 * @param {string} selector
	 * @param {HastNode} [node]
	 * @param {Space} [space]
	 * @returns {boolean}
	 */
	function matches(selector, node, space) {
	  return Boolean(
	    any(parse$1(selector), node, {space, one: true, shallow: true})[0]
	  )
	}

	/**
	 * @param {string} selector
	 * @param {HastNode} [node]
	 * @param {Space} [space]
	 * @returns {Element|null}
	 */
	function select(selector, node, space) {
	  return any(parse$1(selector), node, {space, one: true})[0] || null
	}

	/**
	 * @param {string} selector
	 * @param {HastNode} [node]
	 * @param {Space} [space]
	 * @returns {Array<Element>}
	 */
	function selectAll(selector, node, space) {
	  return any(parse$1(selector), node, {space})
	}

	// This file was generated. Do not modify manually!
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

	// This file was generated. Do not modify manually!
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];

	// This file was generated. Do not modify manually!
	var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

	// This file was generated. Do not modify manually!
	var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

	// These are a run-length and offset encoded representation of the

	// Reserved word lists for various dialects of the language

	var reservedWords = {
	  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	  5: "class enum extends super const export import",
	  6: "enum",
	  strict: "implements interface let package private protected public static yield",
	  strictBind: "eval arguments"
	};

	// And the keywords

	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

	var keywords$1 = {
	  5: ecma5AndLessKeywords,
	  "5module": ecma5AndLessKeywords + " export import",
	  6: ecma5AndLessKeywords + " const class extends export import super"
	};

	var keywordRelationalOperator = /^in(stanceof)?$/;

	// ## Character categories

	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 0x10000;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) { return false }
	    pos += set[i + 1];
	    if (pos >= code) { return true }
	  }
	}

	// Test whether a given character code starts an identifier.

	function isIdentifierStart(code, astral) {
	  if (code < 65) { return code === 36 }
	  if (code < 91) { return true }
	  if (code < 97) { return code === 95 }
	  if (code < 123) { return true }
	  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
	  if (astral === false) { return false }
	  return isInAstralSet(code, astralIdentifierStartCodes)
	}

	// Test whether a given character is part of an identifier.

	function isIdentifierChar(code, astral) {
	  if (code < 48) { return code === 36 }
	  if (code < 58) { return true }
	  if (code < 65) { return false }
	  if (code < 91) { return true }
	  if (code < 97) { return code === 95 }
	  if (code < 123) { return true }
	  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
	  if (astral === false) { return false }
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
	}

	// ## Token types

	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.

	// All token type variables start with an underscore, to make them
	// easy to recognize.

	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// The `startsExpr` property is used to check if the token ends a
	// `yield` expression. It is set on all token types that either can
	// directly start an expression (like a quotation mark) or can
	// continue an expression (like the body of a string).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.

	var TokenType = function TokenType(label, conf) {
	  if ( conf === void 0 ) conf = {};

	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};

	function binop(name, prec) {
	  return new TokenType(name, {beforeExpr: true, binop: prec})
	}
	var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

	// Map keyword names to token types.

	var keywords = {};

	// Succinct definitions of keyword token types
	function kw(name, options) {
	  if ( options === void 0 ) options = {};

	  options.keyword = name;
	  return keywords[name] = new TokenType(name, options)
	}

	var types$1 = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  privateId: new TokenType("privateId", startsExpr),
	  eof: new TokenType("eof"),

	  // Punctuation token types.
	  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  questionDot: new TokenType("?."),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  invalidTemplate: new TokenType("invalidTemplate"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.

	  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
	  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
	  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
	  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=/===/!==", 6),
	  relational: binop("</>/<=/>=", 7),
	  bitShift: binop("<</>>/>>>", 8),
	  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10),
	  starstar: new TokenType("**", {beforeExpr: true}),
	  coalesce: binop("??", 1),

	  // Keyword token types.
	  _break: kw("break"),
	  _case: kw("case", beforeExpr),
	  _catch: kw("catch"),
	  _continue: kw("continue"),
	  _debugger: kw("debugger"),
	  _default: kw("default", beforeExpr),
	  _do: kw("do", {isLoop: true, beforeExpr: true}),
	  _else: kw("else", beforeExpr),
	  _finally: kw("finally"),
	  _for: kw("for", {isLoop: true}),
	  _function: kw("function", startsExpr),
	  _if: kw("if"),
	  _return: kw("return", beforeExpr),
	  _switch: kw("switch"),
	  _throw: kw("throw", beforeExpr),
	  _try: kw("try"),
	  _var: kw("var"),
	  _const: kw("const"),
	  _while: kw("while", {isLoop: true}),
	  _with: kw("with"),
	  _new: kw("new", {beforeExpr: true, startsExpr: true}),
	  _this: kw("this", startsExpr),
	  _super: kw("super", startsExpr),
	  _class: kw("class", startsExpr),
	  _extends: kw("extends", beforeExpr),
	  _export: kw("export"),
	  _import: kw("import", startsExpr),
	  _null: kw("null", startsExpr),
	  _true: kw("true", startsExpr),
	  _false: kw("false", startsExpr),
	  _in: kw("in", {beforeExpr: true, binop: 7}),
	  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
	  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
	  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
	  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
	};

	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.

	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	var lineBreakG = new RegExp(lineBreak.source, "g");

	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
	}

	function nextLineBreak(code, from, end) {
	  if ( end === void 0 ) end = code.length;

	  for (var i = from; i < end; i++) {
	    var next = code.charCodeAt(i);
	    if (isNewLine(next))
	      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
	  }
	  return -1
	}

	var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

	var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

	var ref = Object.prototype;
	var hasOwnProperty = ref.hasOwnProperty;
	var toString = ref.toString;

	var hasOwn = Object.hasOwn || (function (obj, propName) { return (
	  hasOwnProperty.call(obj, propName)
	); });

	var isArray = Array.isArray || (function (obj) { return (
	  toString.call(obj) === "[object Array]"
	); });

	function wordsRegexp(words) {
	  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
	}

	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 0xFFFF) { return String.fromCharCode(code) }
	  code -= 0x10000;
	  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
	}

	var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.

	var Position = function Position(line, col) {
	  this.line = line;
	  this.column = col;
	};

	Position.prototype.offset = function offset (n) {
	  return new Position(this.line, this.column + n)
	};

	var SourceLocation = function SourceLocation(p, start, end) {
	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) { this.source = p.sourceFile; }
	};

	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.

	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    var nextBreak = nextLineBreak(input, cur, offset);
	    if (nextBreak < 0) { return new Position(line, offset - cur) }
	    ++line;
	    cur = nextBreak;
	  }
	}

	// A second argument must be given to configure the parser process.
	// These options are recognized (only `ecmaVersion` is required):

	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
	  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
	  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
	  // (the latest version the library supports). This influences
	  // support for strict mode, the set of reserved words, and support
	  // for new syntax features.
	  ecmaVersion: null,
	  // `sourceType` indicates the mode the code should be parsed in.
	  // Can be either `"script"` or `"module"`. This influences global
	  // strict mode and parsing of `import` and `export` declarations.
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // the position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are only enforced if ecmaVersion >= 5.
	  // Set `allowReserved` to a boolean value to explicitly turn this on
	  // an off. When this option has the value "never", reserved words
	  // and keywords can also not be used as property names.
	  allowReserved: null,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program, and an import.meta expression
	  // in a script isn't considered an error.
	  allowImportExportEverywhere: false,
	  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
	  // When enabled, await identifiers are allowed to appear at the top-level scope,
	  // but they are still not allowed in non-async functions.
	  allowAwaitOutsideFunction: null,
	  // When enabled, super identifiers are not constrained to
	  // appearing in methods and do not raise an error when they appear elsewhere.
	  allowSuperOutsideMethod: null,
	  // When enabled, hashbang directive in the beginning of file is
	  // allowed and treated as a line comment. Enabled by default when
	  // `ecmaVersion` >= 2023.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokens returned from `tokenizer().getToken()`. Note
	  // that you are not allowed to call the parser from the
	  // callbackthat will corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callbackthat will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false
	};

	// Interpret and default an options object

	var warnedAboutEcmaVersion = false;

	function getOptions(opts) {
	  var options = {};

	  for (var opt in defaultOptions)
	    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

	  if (options.ecmaVersion === "latest") {
	    options.ecmaVersion = 1e8;
	  } else if (options.ecmaVersion == null) {
	    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
	      warnedAboutEcmaVersion = true;
	      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
	    }
	    options.ecmaVersion = 11;
	  } else if (options.ecmaVersion >= 2015) {
	    options.ecmaVersion -= 2009;
	  }

	  if (options.allowReserved == null)
	    { options.allowReserved = options.ecmaVersion < 5; }

	  if (opts.allowHashBang == null)
	    { options.allowHashBang = options.ecmaVersion >= 14; }

	  if (isArray(options.onToken)) {
	    var tokens = options.onToken;
	    options.onToken = function (token) { return tokens.push(token); };
	  }
	  if (isArray(options.onComment))
	    { options.onComment = pushComment(options, options.onComment); }

	  return options
	}

	function pushComment(options, array) {
	  return function(block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? "Block" : "Line",
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations)
	      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
	    if (options.ranges)
	      { comment.range = [start, end]; }
	    array.push(comment);
	  }
	}

	// Each scope gets a bitset that may contain these flags
	var
	    SCOPE_TOP = 1,
	    SCOPE_FUNCTION = 2,
	    SCOPE_ASYNC = 4,
	    SCOPE_GENERATOR = 8,
	    SCOPE_ARROW = 16,
	    SCOPE_SIMPLE_CATCH = 32,
	    SCOPE_SUPER = 64,
	    SCOPE_DIRECT_SUPER = 128,
	    SCOPE_CLASS_STATIC_BLOCK = 256,
	    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

	function functionFlags(async, generator) {
	  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
	}

	// Used in checkLVal* and declareName to determine the type of a binding
	var
	    BIND_NONE = 0, // Not a binding
	    BIND_VAR = 1, // Var-style binding
	    BIND_LEXICAL = 2, // Let- or const-style binding
	    BIND_FUNCTION = 3, // Function declaration
	    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
	    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

	var Parser = function Parser(options, input, startPos) {
	  this.options = options = getOptions(options);
	  this.sourceFile = options.sourceFile;
	  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
	  var reserved = "";
	  if (options.allowReserved !== true) {
	    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
	    if (options.sourceType === "module") { reserved += " await"; }
	  }
	  this.reservedWords = wordsRegexp(reserved);
	  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	  this.reservedWordsStrict = wordsRegexp(reservedStrict);
	  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
	  this.input = String(input);

	  // Used to signal to callers of `readWord1` whether the word
	  // contained any escape sequences. This is needed because words with
	  // escape sequences must not be interpreted as keywords.
	  this.containsEsc = false;

	  // Set up token state

	  // The current position of the tokenizer in the input.
	  if (startPos) {
	    this.pos = startPos;
	    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
	    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	  } else {
	    this.pos = this.lineStart = 0;
	    this.curLine = 1;
	  }

	  // Properties of the current token:
	  // Its type
	  this.type = types$1.eof;
	  // For tokens that include more information than their type, the value
	  this.value = null;
	  // Its start and end offset
	  this.start = this.end = this.pos;
	  // And, if locations are used, the {line, column} object
	  // corresponding to those offsets
	  this.startLoc = this.endLoc = this.curPosition();

	  // Position information for the previous token
	  this.lastTokEndLoc = this.lastTokStartLoc = null;
	  this.lastTokStart = this.lastTokEnd = this.pos;

	  // The context stack is used to superficially track syntactic
	  // context to predict whether a regular expression is allowed in a
	  // given position.
	  this.context = this.initialContext();
	  this.exprAllowed = true;

	  // Figure out if it's a module code.
	  this.inModule = options.sourceType === "module";
	  this.strict = this.inModule || this.strictDirective(this.pos);

	  // Used to signify the start of a potential arrow function
	  this.potentialArrowAt = -1;
	  this.potentialArrowInForAwait = false;

	  // Positions to delayed-check that yield/await does not exist in default parameters.
	  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
	  // Labels in scope.
	  this.labels = [];
	  // Thus-far undefined exports.
	  this.undefinedExports = Object.create(null);

	  // If enabled, skip leading hashbang line.
	  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
	    { this.skipLineComment(2); }

	  // Scope tracking for duplicate variable names (see scope.js)
	  this.scopeStack = [];
	  this.enterScope(SCOPE_TOP);

	  // For RegExp validation
	  this.regexpState = null;

	  // The stack of private names.
	  // Each element has two properties: 'declared' and 'used'.
	  // When it exited from the outermost class definition, all used private names must be declared.
	  this.privateNameStack = [];
	};

	var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

	Parser.prototype.parse = function parse () {
	  var node = this.options.program || this.startNode();
	  this.nextToken();
	  return this.parseTopLevel(node)
	};

	prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

	prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

	prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

	prototypeAccessors.canAwait.get = function () {
	  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
	    var scope = this.scopeStack[i];
	    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
	    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
	  }
	  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
	};

	prototypeAccessors.allowSuper.get = function () {
	  var ref = this.currentThisScope();
	    var flags = ref.flags;
	    var inClassFieldInit = ref.inClassFieldInit;
	  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
	};

	prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

	prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

	prototypeAccessors.allowNewDotTarget.get = function () {
	  var ref = this.currentThisScope();
	    var flags = ref.flags;
	    var inClassFieldInit = ref.inClassFieldInit;
	  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
	};

	prototypeAccessors.inClassStaticBlock.get = function () {
	  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
	};

	Parser.extend = function extend () {
	    var plugins = [], len = arguments.length;
	    while ( len-- ) plugins[ len ] = arguments[ len ];

	  var cls = this;
	  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
	  return cls
	};

	Parser.parse = function parse (input, options) {
	  return new this(options, input).parse()
	};

	Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
	  var parser = new this(options, input, pos);
	  parser.nextToken();
	  return parser.parseExpression()
	};

	Parser.tokenizer = function tokenizer (input, options) {
	  return new this(options, input)
	};

	Object.defineProperties( Parser.prototype, prototypeAccessors );

	var pp$9 = Parser.prototype;

	// ## Parser utilities

	var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
	pp$9.strictDirective = function(start) {
	  if (this.options.ecmaVersion < 5) { return false }
	  for (;;) {
	    // Try to find string literal.
	    skipWhiteSpace.lastIndex = start;
	    start += skipWhiteSpace.exec(this.input)[0].length;
	    var match = literal.exec(this.input.slice(start));
	    if (!match) { return false }
	    if ((match[1] || match[2]) === "use strict") {
	      skipWhiteSpace.lastIndex = start + match[0].length;
	      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
	      var next = this.input.charAt(end);
	      return next === ";" || next === "}" ||
	        (lineBreak.test(spaceAfter[0]) &&
	         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
	    }
	    start += match[0].length;

	    // Skip semicolon, if any.
	    skipWhiteSpace.lastIndex = start;
	    start += skipWhiteSpace.exec(this.input)[0].length;
	    if (this.input[start] === ";")
	      { start++; }
	  }
	};

	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.

	pp$9.eat = function(type) {
	  if (this.type === type) {
	    this.next();
	    return true
	  } else {
	    return false
	  }
	};

	// Tests whether parsed token is a contextual keyword.

	pp$9.isContextual = function(name) {
	  return this.type === types$1.name && this.value === name && !this.containsEsc
	};

	// Consumes contextual keyword if possible.

	pp$9.eatContextual = function(name) {
	  if (!this.isContextual(name)) { return false }
	  this.next();
	  return true
	};

	// Asserts that following token is given contextual keyword.

	pp$9.expectContextual = function(name) {
	  if (!this.eatContextual(name)) { this.unexpected(); }
	};

	// Test whether a semicolon can be inserted at the current position.

	pp$9.canInsertSemicolon = function() {
	  return this.type === types$1.eof ||
	    this.type === types$1.braceR ||
	    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	};

	pp$9.insertSemicolon = function() {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon)
	      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
	    return true
	  }
	};

	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.

	pp$9.semicolon = function() {
	  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
	};

	pp$9.afterTrailingComma = function(tokType, notNext) {
	  if (this.type === tokType) {
	    if (this.options.onTrailingComma)
	      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
	    if (!notNext)
	      { this.next(); }
	    return true
	  }
	};

	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.

	pp$9.expect = function(type) {
	  this.eat(type) || this.unexpected();
	};

	// Raise an unexpected token error.

	pp$9.unexpected = function(pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};

	var DestructuringErrors = function DestructuringErrors() {
	  this.shorthandAssign =
	  this.trailingComma =
	  this.parenthesizedAssign =
	  this.parenthesizedBind =
	  this.doubleProto =
	    -1;
	};

	pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	  if (!refDestructuringErrors) { return }
	  if (refDestructuringErrors.trailingComma > -1)
	    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
	  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
	};

	pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	  if (!refDestructuringErrors) { return false }
	  var shorthandAssign = refDestructuringErrors.shorthandAssign;
	  var doubleProto = refDestructuringErrors.doubleProto;
	  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
	  if (shorthandAssign >= 0)
	    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
	  if (doubleProto >= 0)
	    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
	};

	pp$9.checkYieldAwaitInDefaultParams = function() {
	  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
	    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
	  if (this.awaitPos)
	    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
	};

	pp$9.isSimpleAssignTarget = function(expr) {
	  if (expr.type === "ParenthesizedExpression")
	    { return this.isSimpleAssignTarget(expr.expression) }
	  return expr.type === "Identifier" || expr.type === "MemberExpression"
	};

	var pp$8 = Parser.prototype;

	// ### Statement parsing

	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.

	pp$8.parseTopLevel = function(node) {
	  var exports = Object.create(null);
	  if (!node.body) { node.body = []; }
	  while (this.type !== types$1.eof) {
	    var stmt = this.parseStatement(null, true, exports);
	    node.body.push(stmt);
	  }
	  if (this.inModule)
	    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
	      {
	        var name = list[i];

	        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
	      } }
	  this.adaptDirectivePrologue(node.body);
	  this.next();
	  node.sourceType = this.options.sourceType;
	  return this.finishNode(node, "Program")
	};

	var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

	pp$8.isLet = function(context) {
	  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
	  skipWhiteSpace.lastIndex = this.pos;
	  var skip = skipWhiteSpace.exec(this.input);
	  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	  // For ambiguous cases, determine if a LexicalDeclaration (or only a
	  // Statement) is allowed here. If context is not empty then only a Statement
	  // is allowed. However, `let [` is an explicit negative lookahead for
	  // ExpressionStatement, so special-case it first.
	  if (nextCh === 91 || nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '[', '/', astral
	  if (context) { return false }

	  if (nextCh === 123) { return true } // '{'
	  if (isIdentifierStart(nextCh, true)) {
	    var pos = next + 1;
	    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
	    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
	    var ident = this.input.slice(next, pos);
	    if (!keywordRelationalOperator.test(ident)) { return true }
	  }
	  return false
	};

	// check 'async [no LineTerminator here] function'
	// - 'async /*foo*/ function' is OK.
	// - 'async /*\n*/ function' is invalid.
	pp$8.isAsyncFunction = function() {
	  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
	    { return false }

	  skipWhiteSpace.lastIndex = this.pos;
	  var skip = skipWhiteSpace.exec(this.input);
	  var next = this.pos + skip[0].length, after;
	  return !lineBreak.test(this.input.slice(this.pos, next)) &&
	    this.input.slice(next, next + 8) === "function" &&
	    (next + 8 === this.input.length ||
	     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
	};

	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.

	pp$8.parseStatement = function(context, topLevel, exports) {
	  var starttype = this.type, node = this.startNode(), kind;

	  if (this.isLet(context)) {
	    starttype = types$1._var;
	    kind = "let";
	  }

	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.

	  switch (starttype) {
	  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
	  case types$1._debugger: return this.parseDebuggerStatement(node)
	  case types$1._do: return this.parseDoStatement(node)
	  case types$1._for: return this.parseForStatement(node)
	  case types$1._function:
	    // Function as sole body of either an if statement or a labeled statement
	    // works, but not when it is part of a labeled statement that is the sole
	    // body of an if statement.
	    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
	    return this.parseFunctionStatement(node, false, !context)
	  case types$1._class:
	    if (context) { this.unexpected(); }
	    return this.parseClass(node, true)
	  case types$1._if: return this.parseIfStatement(node)
	  case types$1._return: return this.parseReturnStatement(node)
	  case types$1._switch: return this.parseSwitchStatement(node)
	  case types$1._throw: return this.parseThrowStatement(node)
	  case types$1._try: return this.parseTryStatement(node)
	  case types$1._const: case types$1._var:
	    kind = kind || this.value;
	    if (context && kind !== "var") { this.unexpected(); }
	    return this.parseVarStatement(node, kind)
	  case types$1._while: return this.parseWhileStatement(node)
	  case types$1._with: return this.parseWithStatement(node)
	  case types$1.braceL: return this.parseBlock(true, node)
	  case types$1.semi: return this.parseEmptyStatement(node)
	  case types$1._export:
	  case types$1._import:
	    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
	      skipWhiteSpace.lastIndex = this.pos;
	      var skip = skipWhiteSpace.exec(this.input);
	      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	      if (nextCh === 40 || nextCh === 46) // '(' or '.'
	        { return this.parseExpressionStatement(node, this.parseExpression()) }
	    }

	    if (!this.options.allowImportExportEverywhere) {
	      if (!topLevel)
	        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
	      if (!this.inModule)
	        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
	    }
	    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	  default:
	    if (this.isAsyncFunction()) {
	      if (context) { this.unexpected(); }
	      this.next();
	      return this.parseFunctionStatement(node, true, !context)
	    }

	    var maybeName = this.value, expr = this.parseExpression();
	    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
	      { return this.parseLabeledStatement(node, maybeName, expr, context) }
	    else { return this.parseExpressionStatement(node, expr) }
	  }
	};

	pp$8.parseBreakContinueStatement = function(node, keyword) {
	  var isBreak = keyword === "break";
	  this.next();
	  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
	  else if (this.type !== types$1.name) { this.unexpected(); }
	  else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }

	  // Verify that there is an actual destination to break or
	  // continue to.
	  var i = 0;
	  for (; i < this.labels.length; ++i) {
	    var lab = this.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
	      if (node.label && isBreak) { break }
	    }
	  }
	  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
	};

	pp$8.parseDebuggerStatement = function(node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement")
	};

	pp$8.parseDoStatement = function(node) {
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement("do");
	  this.labels.pop();
	  this.expect(types$1._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6)
	    { this.eat(types$1.semi); }
	  else
	    { this.semicolon(); }
	  return this.finishNode(node, "DoWhileStatement")
	};

	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.

	pp$8.parseForStatement = function(node) {
	  this.next();
	  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
	  this.labels.push(loopLabel);
	  this.enterScope(0);
	  this.expect(types$1.parenL);
	  if (this.type === types$1.semi) {
	    if (awaitAt > -1) { this.unexpected(awaitAt); }
	    return this.parseFor(node, null)
	  }
	  var isLet = this.isLet();
	  if (this.type === types$1._var || this.type === types$1._const || isLet) {
	    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
	    this.next();
	    this.parseVar(init$1, true, kind);
	    this.finishNode(init$1, "VariableDeclaration");
	    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
	      if (this.options.ecmaVersion >= 9) {
	        if (this.type === types$1._in) {
	          if (awaitAt > -1) { this.unexpected(awaitAt); }
	        } else { node.await = awaitAt > -1; }
	      }
	      return this.parseForIn(node, init$1)
	    }
	    if (awaitAt > -1) { this.unexpected(awaitAt); }
	    return this.parseFor(node, init$1)
	  }
	  var startsWithLet = this.isContextual("let"), isForOf = false;
	  var refDestructuringErrors = new DestructuringErrors;
	  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
	  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	    if (this.options.ecmaVersion >= 9) {
	      if (this.type === types$1._in) {
	        if (awaitAt > -1) { this.unexpected(awaitAt); }
	      } else { node.await = awaitAt > -1; }
	    }
	    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
	    this.toAssignable(init, false, refDestructuringErrors);
	    this.checkLValPattern(init);
	    return this.parseForIn(node, init)
	  } else {
	    this.checkExpressionErrors(refDestructuringErrors, true);
	  }
	  if (awaitAt > -1) { this.unexpected(awaitAt); }
	  return this.parseFor(node, init)
	};

	pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
	  this.next();
	  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
	};

	pp$8.parseIfStatement = function(node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  // allow function declarations in branches, but only in non-strict mode
	  node.consequent = this.parseStatement("if");
	  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
	  return this.finishNode(node, "IfStatement")
	};

	pp$8.parseReturnStatement = function(node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
	    { this.raise(this.start, "'return' outside of function"); }
	  this.next();

	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.

	  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
	  else { node.argument = this.parseExpression(); this.semicolon(); }
	  return this.finishNode(node, "ReturnStatement")
	};

	pp$8.parseSwitchStatement = function(node) {
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(types$1.braceL);
	  this.labels.push(switchLabel);
	  this.enterScope(0);

	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.

	  var cur;
	  for (var sawDefault = false; this.type !== types$1.braceR;) {
	    if (this.type === types$1._case || this.type === types$1._default) {
	      var isCase = this.type === types$1._case;
	      if (cur) { this.finishNode(cur, "SwitchCase"); }
	      node.cases.push(cur = this.startNode());
	      cur.consequent = [];
	      this.next();
	      if (isCase) {
	        cur.test = this.parseExpression();
	      } else {
	        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
	        sawDefault = true;
	        cur.test = null;
	      }
	      this.expect(types$1.colon);
	    } else {
	      if (!cur) { this.unexpected(); }
	      cur.consequent.push(this.parseStatement(null));
	    }
	  }
	  this.exitScope();
	  if (cur) { this.finishNode(cur, "SwitchCase"); }
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement")
	};

	pp$8.parseThrowStatement = function(node) {
	  this.next();
	  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
	    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement")
	};

	// Reused empty array added for node fields that are always empty.

	var empty$1 = [];

	pp$8.parseTryStatement = function(node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === types$1._catch) {
	    var clause = this.startNode();
	    this.next();
	    if (this.eat(types$1.parenL)) {
	      clause.param = this.parseBindingAtom();
	      var simple = clause.param.type === "Identifier";
	      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
	      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
	      this.expect(types$1.parenR);
	    } else {
	      if (this.options.ecmaVersion < 10) { this.unexpected(); }
	      clause.param = null;
	      this.enterScope(0);
	    }
	    clause.body = this.parseBlock(false);
	    this.exitScope();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer)
	    { this.raise(node.start, "Missing catch or finally clause"); }
	  return this.finishNode(node, "TryStatement")
	};

	pp$8.parseVarStatement = function(node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration")
	};

	pp$8.parseWhileStatement = function(node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement("while");
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement")
	};

	pp$8.parseWithStatement = function(node) {
	  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement("with");
	  return this.finishNode(node, "WithStatement")
	};

	pp$8.parseEmptyStatement = function(node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement")
	};

	pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
	  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
	    {
	    var label = list[i$1];

	    if (label.name === maybeName)
	      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  } }
	  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
	  for (var i = this.labels.length - 1; i >= 0; i--) {
	    var label$1 = this.labels[i];
	    if (label$1.statementStart === node.start) {
	      // Update information about previous labels on this node
	      label$1.statementStart = this.start;
	      label$1.kind = kind;
	    } else { break }
	  }
	  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
	  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement")
	};

	pp$8.parseExpressionStatement = function(node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement")
	};

	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).

	pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
	  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
	  if ( node === void 0 ) node = this.startNode();

	  node.body = [];
	  this.expect(types$1.braceL);
	  if (createNewLexicalScope) { this.enterScope(0); }
	  while (this.type !== types$1.braceR) {
	    var stmt = this.parseStatement(null);
	    node.body.push(stmt);
	  }
	  if (exitStrict) { this.strict = false; }
	  this.next();
	  if (createNewLexicalScope) { this.exitScope(); }
	  return this.finishNode(node, "BlockStatement")
	};

	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.

	pp$8.parseFor = function(node, init) {
	  node.init = init;
	  this.expect(types$1.semi);
	  node.test = this.type === types$1.semi ? null : this.parseExpression();
	  this.expect(types$1.semi);
	  node.update = this.type === types$1.parenR ? null : this.parseExpression();
	  this.expect(types$1.parenR);
	  node.body = this.parseStatement("for");
	  this.exitScope();
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement")
	};

	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.

	pp$8.parseForIn = function(node, init) {
	  var isForIn = this.type === types$1._in;
	  this.next();

	  if (
	    init.type === "VariableDeclaration" &&
	    init.declarations[0].init != null &&
	    (
	      !isForIn ||
	      this.options.ecmaVersion < 8 ||
	      this.strict ||
	      init.kind !== "var" ||
	      init.declarations[0].id.type !== "Identifier"
	    )
	  ) {
	    this.raise(
	      init.start,
	      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
	    );
	  }
	  node.left = init;
	  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
	  this.expect(types$1.parenR);
	  node.body = this.parseStatement("for");
	  this.exitScope();
	  this.labels.pop();
	  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
	};

	// Parse a list of variable declarations.

	pp$8.parseVar = function(node, isFor, kind) {
	  node.declarations = [];
	  node.kind = kind;
	  for (;;) {
	    var decl = this.startNode();
	    this.parseVarId(decl, kind);
	    if (this.eat(types$1.eq)) {
	      decl.init = this.parseMaybeAssign(isFor);
	    } else if (kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
	      this.unexpected();
	    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
	      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	    if (!this.eat(types$1.comma)) { break }
	  }
	  return node
	};

	pp$8.parseVarId = function(decl, kind) {
	  decl.id = this.parseBindingAtom();
	  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
	};

	var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

	// Parse a function declaration or literal (depending on the
	// `statement & FUNC_STATEMENT`).

	// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
	pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
	    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
	      { this.unexpected(); }
	    node.generator = this.eat(types$1.star);
	  }
	  if (this.options.ecmaVersion >= 8)
	    { node.async = !!isAsync; }

	  if (statement & FUNC_STATEMENT) {
	    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
	    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
	      // If it is a regular function declaration in sloppy mode, then it is
	      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
	      // mode depends on properties of the current scope (see
	      // treatFunctionsAsVar).
	      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
	  }

	  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	  this.yieldPos = 0;
	  this.awaitPos = 0;
	  this.awaitIdentPos = 0;
	  this.enterScope(functionFlags(node.async, node.generator));

	  if (!(statement & FUNC_STATEMENT))
	    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

	  this.yieldPos = oldYieldPos;
	  this.awaitPos = oldAwaitPos;
	  this.awaitIdentPos = oldAwaitIdentPos;
	  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
	};

	pp$8.parseFunctionParams = function(node) {
	  this.expect(types$1.parenL);
	  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	  this.checkYieldAwaitInDefaultParams();
	};

	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).

	pp$8.parseClass = function(node, isStatement) {
	  this.next();

	  // ecma-262 14.6 Class Definitions
	  // A class definition is always strict mode code.
	  var oldStrict = this.strict;
	  this.strict = true;

	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var privateNameMap = this.enterClassBody();
	  var classBody = this.startNode();
	  var hadConstructor = false;
	  classBody.body = [];
	  this.expect(types$1.braceL);
	  while (this.type !== types$1.braceR) {
	    var element = this.parseClassElement(node.superClass !== null);
	    if (element) {
	      classBody.body.push(element);
	      if (element.type === "MethodDefinition" && element.kind === "constructor") {
	        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
	        hadConstructor = true;
	      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
	        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
	      }
	    }
	  }
	  this.strict = oldStrict;
	  this.next();
	  node.body = this.finishNode(classBody, "ClassBody");
	  this.exitClassBody();
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
	};

	pp$8.parseClassElement = function(constructorAllowsSuper) {
	  if (this.eat(types$1.semi)) { return null }

	  var ecmaVersion = this.options.ecmaVersion;
	  var node = this.startNode();
	  var keyName = "";
	  var isGenerator = false;
	  var isAsync = false;
	  var kind = "method";
	  var isStatic = false;

	  if (this.eatContextual("static")) {
	    // Parse static init block
	    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
	      this.parseClassStaticBlock(node);
	      return node
	    }
	    if (this.isClassElementNameStart() || this.type === types$1.star) {
	      isStatic = true;
	    } else {
	      keyName = "static";
	    }
	  }
	  node.static = isStatic;
	  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
	    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
	      isAsync = true;
	    } else {
	      keyName = "async";
	    }
	  }
	  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
	    isGenerator = true;
	  }
	  if (!keyName && !isAsync && !isGenerator) {
	    var lastValue = this.value;
	    if (this.eatContextual("get") || this.eatContextual("set")) {
	      if (this.isClassElementNameStart()) {
	        kind = lastValue;
	      } else {
	        keyName = lastValue;
	      }
	    }
	  }

	  // Parse element name
	  if (keyName) {
	    // 'async', 'get', 'set', or 'static' were not a keyword contextually.
	    // The last token is any of those. Make it the element name.
	    node.computed = false;
	    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
	    node.key.name = keyName;
	    this.finishNode(node.key, "Identifier");
	  } else {
	    this.parseClassElementName(node);
	  }

	  // Parse element value
	  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
	    var isConstructor = !node.static && checkKeyName(node, "constructor");
	    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
	    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
	    if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
	    node.kind = isConstructor ? "constructor" : kind;
	    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
	  } else {
	    this.parseClassField(node);
	  }

	  return node
	};

	pp$8.isClassElementNameStart = function() {
	  return (
	    this.type === types$1.name ||
	    this.type === types$1.privateId ||
	    this.type === types$1.num ||
	    this.type === types$1.string ||
	    this.type === types$1.bracketL ||
	    this.type.keyword
	  )
	};

	pp$8.parseClassElementName = function(element) {
	  if (this.type === types$1.privateId) {
	    if (this.value === "constructor") {
	      this.raise(this.start, "Classes can't have an element named '#constructor'");
	    }
	    element.computed = false;
	    element.key = this.parsePrivateIdent();
	  } else {
	    this.parsePropertyName(element);
	  }
	};

	pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
	  // Check key and flags
	  var key = method.key;
	  if (method.kind === "constructor") {
	    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
	    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
	  } else if (method.static && checkKeyName(method, "prototype")) {
	    this.raise(key.start, "Classes may not have a static property named prototype");
	  }

	  // Parse value
	  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

	  // Check value
	  if (method.kind === "get" && value.params.length !== 0)
	    { this.raiseRecoverable(value.start, "getter should have no params"); }
	  if (method.kind === "set" && value.params.length !== 1)
	    { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
	  if (method.kind === "set" && value.params[0].type === "RestElement")
	    { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

	  return this.finishNode(method, "MethodDefinition")
	};

	pp$8.parseClassField = function(field) {
	  if (checkKeyName(field, "constructor")) {
	    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
	  } else if (field.static && checkKeyName(field, "prototype")) {
	    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
	  }

	  if (this.eat(types$1.eq)) {
	    // To raise SyntaxError if 'arguments' exists in the initializer.
	    var scope = this.currentThisScope();
	    var inClassFieldInit = scope.inClassFieldInit;
	    scope.inClassFieldInit = true;
	    field.value = this.parseMaybeAssign();
	    scope.inClassFieldInit = inClassFieldInit;
	  } else {
	    field.value = null;
	  }
	  this.semicolon();

	  return this.finishNode(field, "PropertyDefinition")
	};

	pp$8.parseClassStaticBlock = function(node) {
	  node.body = [];

	  var oldLabels = this.labels;
	  this.labels = [];
	  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
	  while (this.type !== types$1.braceR) {
	    var stmt = this.parseStatement(null);
	    node.body.push(stmt);
	  }
	  this.next();
	  this.exitScope();
	  this.labels = oldLabels;

	  return this.finishNode(node, "StaticBlock")
	};

	pp$8.parseClassId = function(node, isStatement) {
	  if (this.type === types$1.name) {
	    node.id = this.parseIdent();
	    if (isStatement)
	      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
	  } else {
	    if (isStatement === true)
	      { this.unexpected(); }
	    node.id = null;
	  }
	};

	pp$8.parseClassSuper = function(node) {
	  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
	};

	pp$8.enterClassBody = function() {
	  var element = {declared: Object.create(null), used: []};
	  this.privateNameStack.push(element);
	  return element.declared
	};

	pp$8.exitClassBody = function() {
	  var ref = this.privateNameStack.pop();
	  var declared = ref.declared;
	  var used = ref.used;
	  var len = this.privateNameStack.length;
	  var parent = len === 0 ? null : this.privateNameStack[len - 1];
	  for (var i = 0; i < used.length; ++i) {
	    var id = used[i];
	    if (!hasOwn(declared, id.name)) {
	      if (parent) {
	        parent.used.push(id);
	      } else {
	        this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
	      }
	    }
	  }
	};

	function isPrivateNameConflicted(privateNameMap, element) {
	  var name = element.key.name;
	  var curr = privateNameMap[name];

	  var next = "true";
	  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
	    next = (element.static ? "s" : "i") + element.kind;
	  }

	  // `class { get #a(){}; static set #a(_){} }` is also conflict.
	  if (
	    curr === "iget" && next === "iset" ||
	    curr === "iset" && next === "iget" ||
	    curr === "sget" && next === "sset" ||
	    curr === "sset" && next === "sget"
	  ) {
	    privateNameMap[name] = "true";
	    return false
	  } else if (!curr) {
	    privateNameMap[name] = next;
	    return false
	  } else {
	    return true
	  }
	}

	function checkKeyName(node, name) {
	  var computed = node.computed;
	  var key = node.key;
	  return !computed && (
	    key.type === "Identifier" && key.name === name ||
	    key.type === "Literal" && key.value === name
	  )
	}

	// Parses module export declaration.

	pp$8.parseExport = function(node, exports) {
	  this.next();
	  // export * from '...'
	  if (this.eat(types$1.star)) {
	    if (this.options.ecmaVersion >= 11) {
	      if (this.eatContextual("as")) {
	        node.exported = this.parseModuleExportName();
	        this.checkExport(exports, node.exported, this.lastTokStart);
	      } else {
	        node.exported = null;
	      }
	    }
	    this.expectContextual("from");
	    if (this.type !== types$1.string) { this.unexpected(); }
	    node.source = this.parseExprAtom();
	    this.semicolon();
	    return this.finishNode(node, "ExportAllDeclaration")
	  }
	  if (this.eat(types$1._default)) { // export default ...
	    this.checkExport(exports, "default", this.lastTokStart);
	    var isAsync;
	    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
	      var fNode = this.startNode();
	      this.next();
	      if (isAsync) { this.next(); }
	      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
	    } else if (this.type === types$1._class) {
	      var cNode = this.startNode();
	      node.declaration = this.parseClass(cNode, "nullableID");
	    } else {
	      node.declaration = this.parseMaybeAssign();
	      this.semicolon();
	    }
	    return this.finishNode(node, "ExportDefaultDeclaration")
	  }
	  // export var|const|let|function|class ...
	  if (this.shouldParseExportStatement()) {
	    node.declaration = this.parseStatement(null);
	    if (node.declaration.type === "VariableDeclaration")
	      { this.checkVariableExport(exports, node.declaration.declarations); }
	    else
	      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
	    node.specifiers = [];
	    node.source = null;
	  } else { // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers(exports);
	    if (this.eatContextual("from")) {
	      if (this.type !== types$1.string) { this.unexpected(); }
	      node.source = this.parseExprAtom();
	    } else {
	      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
	        // check for keywords used as local names
	        var spec = list[i];

	        this.checkUnreserved(spec.local);
	        // check if export is defined
	        this.checkLocalExport(spec.local);

	        if (spec.local.type === "Literal") {
	          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
	        }
	      }

	      node.source = null;
	    }
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration")
	};

	pp$8.checkExport = function(exports, name, pos) {
	  if (!exports) { return }
	  if (typeof name !== "string")
	    { name = name.type === "Identifier" ? name.name : name.value; }
	  if (hasOwn(exports, name))
	    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
	  exports[name] = true;
	};

	pp$8.checkPatternExport = function(exports, pat) {
	  var type = pat.type;
	  if (type === "Identifier")
	    { this.checkExport(exports, pat, pat.start); }
	  else if (type === "ObjectPattern")
	    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
	      {
	        var prop = list[i];

	        this.checkPatternExport(exports, prop);
	      } }
	  else if (type === "ArrayPattern")
	    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
	      var elt = list$1[i$1];

	        if (elt) { this.checkPatternExport(exports, elt); }
	    } }
	  else if (type === "Property")
	    { this.checkPatternExport(exports, pat.value); }
	  else if (type === "AssignmentPattern")
	    { this.checkPatternExport(exports, pat.left); }
	  else if (type === "RestElement")
	    { this.checkPatternExport(exports, pat.argument); }
	  else if (type === "ParenthesizedExpression")
	    { this.checkPatternExport(exports, pat.expression); }
	};

	pp$8.checkVariableExport = function(exports, decls) {
	  if (!exports) { return }
	  for (var i = 0, list = decls; i < list.length; i += 1)
	    {
	    var decl = list[i];

	    this.checkPatternExport(exports, decl.id);
	  }
	};

	pp$8.shouldParseExportStatement = function() {
	  return this.type.keyword === "var" ||
	    this.type.keyword === "const" ||
	    this.type.keyword === "class" ||
	    this.type.keyword === "function" ||
	    this.isLet() ||
	    this.isAsyncFunction()
	};

	// Parses a comma-separated list of module exports.

	pp$8.parseExportSpecifiers = function(exports) {
	  var nodes = [], first = true;
	  // export { x, y as z } [from '...']
	  this.expect(types$1.braceL);
	  while (!this.eat(types$1.braceR)) {
	    if (!first) {
	      this.expect(types$1.comma);
	      if (this.afterTrailingComma(types$1.braceR)) { break }
	    } else { first = false; }

	    var node = this.startNode();
	    node.local = this.parseModuleExportName();
	    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
	    this.checkExport(
	      exports,
	      node.exported,
	      node.exported.start
	    );
	    nodes.push(this.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes
	};

	// Parses import declaration.

	pp$8.parseImport = function(node) {
	  this.next();
	  // import '...'
	  if (this.type === types$1.string) {
	    node.specifiers = empty$1;
	    node.source = this.parseExprAtom();
	  } else {
	    node.specifiers = this.parseImportSpecifiers();
	    this.expectContextual("from");
	    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration")
	};

	// Parses a comma-separated list of module imports.

	pp$8.parseImportSpecifiers = function() {
	  var nodes = [], first = true;
	  if (this.type === types$1.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var node = this.startNode();
	    node.local = this.parseIdent();
	    this.checkLValSimple(node.local, BIND_LEXICAL);
	    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	    if (!this.eat(types$1.comma)) { return nodes }
	  }
	  if (this.type === types$1.star) {
	    var node$1 = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    node$1.local = this.parseIdent();
	    this.checkLValSimple(node$1.local, BIND_LEXICAL);
	    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
	    return nodes
	  }
	  this.expect(types$1.braceL);
	  while (!this.eat(types$1.braceR)) {
	    if (!first) {
	      this.expect(types$1.comma);
	      if (this.afterTrailingComma(types$1.braceR)) { break }
	    } else { first = false; }

	    var node$2 = this.startNode();
	    node$2.imported = this.parseModuleExportName();
	    if (this.eatContextual("as")) {
	      node$2.local = this.parseIdent();
	    } else {
	      this.checkUnreserved(node$2.imported);
	      node$2.local = node$2.imported;
	    }
	    this.checkLValSimple(node$2.local, BIND_LEXICAL);
	    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
	  }
	  return nodes
	};

	pp$8.parseModuleExportName = function() {
	  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
	    var stringLiteral = this.parseLiteral(this.value);
	    if (loneSurrogate.test(stringLiteral.value)) {
	      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
	    }
	    return stringLiteral
	  }
	  return this.parseIdent(true)
	};

	// Set `ExpressionStatement#directive` property for directive prologues.
	pp$8.adaptDirectivePrologue = function(statements) {
	  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
	    statements[i].directive = statements[i].expression.raw.slice(1, -1);
	  }
	};
	pp$8.isDirectiveCandidate = function(statement) {
	  return (
	    this.options.ecmaVersion >= 5 &&
	    statement.type === "ExpressionStatement" &&
	    statement.expression.type === "Literal" &&
	    typeof statement.expression.value === "string" &&
	    // Reject parenthesized strings.
	    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
	  )
	};

	var pp$7 = Parser.prototype;

	// Convert existing expression atom to assignable pattern
	// if possible.

	pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	    case "Identifier":
	      if (this.inAsync && node.name === "await")
	        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
	      break

	    case "ObjectPattern":
	    case "ArrayPattern":
	    case "AssignmentPattern":
	    case "RestElement":
	      break

	    case "ObjectExpression":
	      node.type = "ObjectPattern";
	      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
	      for (var i = 0, list = node.properties; i < list.length; i += 1) {
	        var prop = list[i];

	      this.toAssignable(prop, isBinding);
	        // Early error:
	        //   AssignmentRestProperty[Yield, Await] :
	        //     `...` DestructuringAssignmentTarget[Yield, Await]
	        //
	        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
	        if (
	          prop.type === "RestElement" &&
	          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
	        ) {
	          this.raise(prop.argument.start, "Unexpected token");
	        }
	      }
	      break

	    case "Property":
	      // AssignmentProperty has type === "Property"
	      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
	      this.toAssignable(node.value, isBinding);
	      break

	    case "ArrayExpression":
	      node.type = "ArrayPattern";
	      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
	      this.toAssignableList(node.elements, isBinding);
	      break

	    case "SpreadElement":
	      node.type = "RestElement";
	      this.toAssignable(node.argument, isBinding);
	      if (node.argument.type === "AssignmentPattern")
	        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
	      break

	    case "AssignmentExpression":
	      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
	      node.type = "AssignmentPattern";
	      delete node.operator;
	      this.toAssignable(node.left, isBinding);
	      break

	    case "ParenthesizedExpression":
	      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
	      break

	    case "ChainExpression":
	      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
	      break

	    case "MemberExpression":
	      if (!isBinding) { break }

	    default:
	      this.raise(node.start, "Assigning to rvalue");
	    }
	  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
	  return node
	};

	// Convert list of expression atoms to binding list.

	pp$7.toAssignableList = function(exprList, isBinding) {
	  var end = exprList.length;
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) { this.toAssignable(elt, isBinding); }
	  }
	  if (end) {
	    var last = exprList[end - 1];
	    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
	      { this.unexpected(last.argument.start); }
	  }
	  return exprList
	};

	// Parses spread element.

	pp$7.parseSpread = function(refDestructuringErrors) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	  return this.finishNode(node, "SpreadElement")
	};

	pp$7.parseRestBinding = function() {
	  var node = this.startNode();
	  this.next();

	  // RestElement inside of a function parameter must be an identifier
	  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
	    { this.unexpected(); }

	  node.argument = this.parseBindingAtom();

	  return this.finishNode(node, "RestElement")
	};

	// Parses lvalue (assignable) atom.

	pp$7.parseBindingAtom = function() {
	  if (this.options.ecmaVersion >= 6) {
	    switch (this.type) {
	    case types$1.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(types$1.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern")

	    case types$1.braceL:
	      return this.parseObj(true)
	    }
	  }
	  return this.parseIdent()
	};

	pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
	  var elts = [], first = true;
	  while (!this.eat(close)) {
	    if (first) { first = false; }
	    else { this.expect(types$1.comma); }
	    if (allowEmpty && this.type === types$1.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
	      break
	    } else if (this.type === types$1.ellipsis) {
	      var rest = this.parseRestBinding();
	      this.parseBindingListItem(rest);
	      elts.push(rest);
	      if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
	      this.expect(close);
	      break
	    } else {
	      var elem = this.parseMaybeDefault(this.start, this.startLoc);
	      this.parseBindingListItem(elem);
	      elts.push(elem);
	    }
	  }
	  return elts
	};

	pp$7.parseBindingListItem = function(param) {
	  return param
	};

	// Parses assignment pattern around given atom if possible.

	pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
	  left = left || this.parseBindingAtom();
	  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern")
	};

	// The following three functions all verify that a node is an lvalue 
	// something that can be bound, or assigned to. In order to do so, they perform
	// a variety of checks:
	//
	// - Check that none of the bound/assigned-to identifiers are reserved words.
	// - Record name declarations for bindings in the appropriate scope.
	// - Check duplicate argument names, if checkClashes is set.
	//
	// If a complex binding pattern is encountered (e.g., object and array
	// destructuring), the entire pattern is recursively checked.
	//
	// There are three versions of checkLVal*() appropriate for different
	// circumstances:
	//
	// - checkLValSimple() shall be used if the syntactic construct supports
	//   nothing other than identifiers and member expressions. Parenthesized
	//   expressions are also correctly handled. This is generally appropriate for
	//   constructs for which the spec says
	//
	//   > It is a Syntax Error if AssignmentTargetType of [the production] is not
	//   > simple.
	//
	//   It is also appropriate for checking if an identifier is valid and not
	//   defined elsewhere, like import declarations or function/class identifiers.
	//
	//   Examples where this is used include:
	//     a += ;
	//     import a from '';
	//   where a is the node to be checked.
	//
	// - checkLValPattern() shall be used if the syntactic construct supports
	//   anything checkLValSimple() supports, as well as object and array
	//   destructuring patterns. This is generally appropriate for constructs for
	//   which the spec says
	//
	//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
	//   > an ArrayLiteral and AssignmentTargetType of [the production] is not
	//   > simple.
	//
	//   Examples where this is used include:
	//     (a = );
	//     const a = ;
	//     try {  } catch (a) {  }
	//   where a is the node to be checked.
	//
	// - checkLValInnerPattern() shall be used if the syntactic construct supports
	//   anything checkLValPattern() supports, as well as default assignment
	//   patterns, rest elements, and other constructs that may appear within an
	//   object or array destructuring pattern.
	//
	//   As a special case, function parameters also use checkLValInnerPattern(),
	//   as they also support defaults and rest constructs.
	//
	// These functions deliberately support both assignment and binding constructs,
	// as the logic for both is exceedingly similar. If the node is the target of
	// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
	// should be set to the appropriate BIND_* constant, like BIND_VAR or
	// BIND_LEXICAL.
	//
	// If the function is called with a non-BIND_NONE bindingType, then
	// additionally a checkClashes object may be specified to allow checking for
	// duplicate argument names. checkClashes is ignored if the provided construct
	// is an assignment (i.e., bindingType is BIND_NONE).

	pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
	  if ( bindingType === void 0 ) bindingType = BIND_NONE;

	  var isBind = bindingType !== BIND_NONE;

	  switch (expr.type) {
	  case "Identifier":
	    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
	      { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
	    if (isBind) {
	      if (bindingType === BIND_LEXICAL && expr.name === "let")
	        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
	      if (checkClashes) {
	        if (hasOwn(checkClashes, expr.name))
	          { this.raiseRecoverable(expr.start, "Argument name clash"); }
	        checkClashes[expr.name] = true;
	      }
	      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
	    }
	    break

	  case "ChainExpression":
	    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
	    break

	  case "MemberExpression":
	    if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
	    break

	  case "ParenthesizedExpression":
	    if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
	    return this.checkLValSimple(expr.expression, bindingType, checkClashes)

	  default:
	    this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
	  }
	};

	pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
	  if ( bindingType === void 0 ) bindingType = BIND_NONE;

	  switch (expr.type) {
	  case "ObjectPattern":
	    for (var i = 0, list = expr.properties; i < list.length; i += 1) {
	      var prop = list[i];

	    this.checkLValInnerPattern(prop, bindingType, checkClashes);
	    }
	    break

	  case "ArrayPattern":
	    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
	      var elem = list$1[i$1];

	    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
	    }
	    break

	  default:
	    this.checkLValSimple(expr, bindingType, checkClashes);
	  }
	};

	pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
	  if ( bindingType === void 0 ) bindingType = BIND_NONE;

	  switch (expr.type) {
	  case "Property":
	    // AssignmentProperty has type === "Property"
	    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
	    break

	  case "AssignmentPattern":
	    this.checkLValPattern(expr.left, bindingType, checkClashes);
	    break

	  case "RestElement":
	    this.checkLValPattern(expr.argument, bindingType, checkClashes);
	    break

	  default:
	    this.checkLValPattern(expr, bindingType, checkClashes);
	  }
	};

	// The algorithm used to determine whether a regexp can appear at a

	var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
	  this.token = token;
	  this.isExpr = !!isExpr;
	  this.preserveSpace = !!preserveSpace;
	  this.override = override;
	  this.generator = !!generator;
	};

	var types = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", false),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
	  f_stat: new TokContext("function", false),
	  f_expr: new TokContext("function", true),
	  f_expr_gen: new TokContext("function", true, false, null, true),
	  f_gen: new TokContext("function", false, false, null, true)
	};

	var pp$6 = Parser.prototype;

	pp$6.initialContext = function() {
	  return [types.b_stat]
	};

	pp$6.curContext = function() {
	  return this.context[this.context.length - 1]
	};

	pp$6.braceIsBlock = function(prevType) {
	  var parent = this.curContext();
	  if (parent === types.f_expr || parent === types.f_stat)
	    { return true }
	  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
	    { return !parent.isExpr }

	  // The check for `tt.name && exprAllowed` detects whether we are
	  // after a `yield` or `of` construct. See the `updateContext` for
	  // `tt.name`.
	  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
	    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
	  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
	    { return true }
	  if (prevType === types$1.braceL)
	    { return parent === types.b_stat }
	  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
	    { return false }
	  return !this.exprAllowed
	};

	pp$6.inGeneratorContext = function() {
	  for (var i = this.context.length - 1; i >= 1; i--) {
	    var context = this.context[i];
	    if (context.token === "function")
	      { return context.generator }
	  }
	  return false
	};

	pp$6.updateContext = function(prevType) {
	  var update, type = this.type;
	  if (type.keyword && prevType === types$1.dot)
	    { this.exprAllowed = false; }
	  else if (update = type.updateContext)
	    { update.call(this, prevType); }
	  else
	    { this.exprAllowed = type.beforeExpr; }
	};

	// Used to handle egde cases when token context could not be inferred correctly during tokenization phase

	pp$6.overrideContext = function(tokenCtx) {
	  if (this.curContext() !== tokenCtx) {
	    this.context[this.context.length - 1] = tokenCtx;
	  }
	};

	// Token-specific context update code

	types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
	  if (this.context.length === 1) {
	    this.exprAllowed = true;
	    return
	  }
	  var out = this.context.pop();
	  if (out === types.b_stat && this.curContext().token === "function") {
	    out = this.context.pop();
	  }
	  this.exprAllowed = !out.isExpr;
	};

	types$1.braceL.updateContext = function(prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	  this.exprAllowed = true;
	};

	types$1.dollarBraceL.updateContext = function() {
	  this.context.push(types.b_tmpl);
	  this.exprAllowed = true;
	};

	types$1.parenL.updateContext = function(prevType) {
	  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
	  this.context.push(statementParens ? types.p_stat : types.p_expr);
	  this.exprAllowed = true;
	};

	types$1.incDec.updateContext = function() {
	  // tokExprAllowed stays unchanged
	};

	types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
	  if (prevType.beforeExpr && prevType !== types$1._else &&
	      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
	      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
	      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
	    { this.context.push(types.f_expr); }
	  else
	    { this.context.push(types.f_stat); }
	  this.exprAllowed = false;
	};

	types$1.backQuote.updateContext = function() {
	  if (this.curContext() === types.q_tmpl)
	    { this.context.pop(); }
	  else
	    { this.context.push(types.q_tmpl); }
	  this.exprAllowed = false;
	};

	types$1.star.updateContext = function(prevType) {
	  if (prevType === types$1._function) {
	    var index = this.context.length - 1;
	    if (this.context[index] === types.f_expr)
	      { this.context[index] = types.f_expr_gen; }
	    else
	      { this.context[index] = types.f_gen; }
	  }
	  this.exprAllowed = true;
	};

	types$1.name.updateContext = function(prevType) {
	  var allowed = false;
	  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
	    if (this.value === "of" && !this.exprAllowed ||
	        this.value === "yield" && this.inGeneratorContext())
	      { allowed = true; }
	  }
	  this.exprAllowed = allowed;
	};

	// A recursive descent parser operates by defining functions for all

	var pp$5 = Parser.prototype;

	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash 
	// either with each other or with an init property  and in
	// strict mode, init properties are also not allowed to be repeated.

	pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
	    { return }
	  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
	    { return }
	  var key = prop.key;
	  var name;
	  switch (key.type) {
	  case "Identifier": name = key.name; break
	  case "Literal": name = String(key.value); break
	  default: return
	  }
	  var kind = prop.kind;
	  if (this.options.ecmaVersion >= 6) {
	    if (name === "__proto__" && kind === "init") {
	      if (propHash.proto) {
	        if (refDestructuringErrors) {
	          if (refDestructuringErrors.doubleProto < 0) {
	            refDestructuringErrors.doubleProto = key.start;
	          }
	        } else {
	          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
	        }
	      }
	      propHash.proto = true;
	    }
	    return
	  }
	  name = "$" + name;
	  var other = propHash[name];
	  if (other) {
	    var redefinition;
	    if (kind === "init") {
	      redefinition = this.strict && other.init || other.get || other.set;
	    } else {
	      redefinition = other.init || other[kind];
	    }
	    if (redefinition)
	      { this.raiseRecoverable(key.start, "Redefinition of property"); }
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};

	// ### Expression parsing

	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.

	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).

	pp$5.parseExpression = function(forInit, refDestructuringErrors) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
	  if (this.type === types$1.comma) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.expressions = [expr];
	    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
	    return this.finishNode(node, "SequenceExpression")
	  }
	  return expr
	};

	// Parse an assignment expression. This includes applications of
	// operators like `+=`.

	pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
	  if (this.isContextual("yield")) {
	    if (this.inGenerator) { return this.parseYield(forInit) }
	    // The tokenizer will assume an expression is allowed after
	    // `yield`, but this isn't that kind of yield
	    else { this.exprAllowed = false; }
	  }

	  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
	  if (refDestructuringErrors) {
	    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
	    oldTrailingComma = refDestructuringErrors.trailingComma;
	    oldDoubleProto = refDestructuringErrors.doubleProto;
	    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	  } else {
	    refDestructuringErrors = new DestructuringErrors;
	    ownDestructuringErrors = true;
	  }

	  var startPos = this.start, startLoc = this.startLoc;
	  if (this.type === types$1.parenL || this.type === types$1.name) {
	    this.potentialArrowAt = this.start;
	    this.potentialArrowInForAwait = forInit === "await";
	  }
	  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
	  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
	  if (this.type.isAssign) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    if (this.type === types$1.eq)
	      { left = this.toAssignable(left, false, refDestructuringErrors); }
	    if (!ownDestructuringErrors) {
	      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
	    }
	    if (refDestructuringErrors.shorthandAssign >= left.start)
	      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
	    if (this.type === types$1.eq)
	      { this.checkLValPattern(left); }
	    else
	      { this.checkLValSimple(left); }
	    node.left = left;
	    this.next();
	    node.right = this.parseMaybeAssign(forInit);
	    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
	    return this.finishNode(node, "AssignmentExpression")
	  } else {
	    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
	  }
	  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
	  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
	  return left
	};

	// Parse a ternary conditional (`?:`) operator.

	pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseExprOps(forInit, refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
	  if (this.eat(types$1.question)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(types$1.colon);
	    node.alternate = this.parseMaybeAssign(forInit);
	    return this.finishNode(node, "ConditionalExpression")
	  }
	  return expr
	};

	// Start the precedence parser.

	pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
	  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
	  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
	};

	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.

	pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
	  var prec = this.type.binop;
	  if (prec != null && (!forInit || this.type !== types$1._in)) {
	    if (prec > minPrec) {
	      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
	      var coalesce = this.type === types$1.coalesce;
	      if (coalesce) {
	        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
	        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
	        prec = types$1.logicalAND.binop;
	      }
	      var op = this.value;
	      this.next();
	      var startPos = this.start, startLoc = this.startLoc;
	      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
	      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
	      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
	        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
	      }
	      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
	    }
	  }
	  return left
	};

	pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.operator = op;
	  node.right = right;
	  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
	};

	// Parse unary operators, both prefix and postfix.

	pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
	  var startPos = this.start, startLoc = this.startLoc, expr;
	  if (this.isContextual("await") && this.canAwait) {
	    expr = this.parseAwait(forInit);
	    sawUnary = true;
	  } else if (this.type.prefix) {
	    var node = this.startNode(), update = this.type === types$1.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary(null, true, update, forInit);
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    if (update) { this.checkLValSimple(node.argument); }
	    else if (this.strict && node.operator === "delete" &&
	             node.argument.type === "Identifier")
	      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
	    else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
	      { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
	    else { sawUnary = true; }
	    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  } else if (!sawUnary && this.type === types$1.privateId) {
	    if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
	    expr = this.parsePrivateIdent();
	    // only could be private fields in 'in', such as #x in obj
	    if (this.type !== types$1._in) { this.unexpected(); }
	  } else {
	    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
	    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
	    while (this.type.postfix && !this.canInsertSemicolon()) {
	      var node$1 = this.startNodeAt(startPos, startLoc);
	      node$1.operator = this.value;
	      node$1.prefix = false;
	      node$1.argument = expr;
	      this.checkLValSimple(expr);
	      this.next();
	      expr = this.finishNode(node$1, "UpdateExpression");
	    }
	  }

	  if (!incDec && this.eat(types$1.starstar)) {
	    if (sawUnary)
	      { this.unexpected(this.lastTokStart); }
	    else
	      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
	  } else {
	    return expr
	  }
	};

	function isPrivateFieldAccess(node) {
	  return (
	    node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
	    node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
	  )
	}

	// Parse call, dot, and `[]`-subscript expressions.

	pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
	  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
	    { return expr }
	  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
	  if (refDestructuringErrors && result.type === "MemberExpression") {
	    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
	    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
	    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
	  }
	  return result
	};

	pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
	  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
	      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
	      this.potentialArrowAt === base.start;
	  var optionalChained = false;

	  while (true) {
	    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

	    if (element.optional) { optionalChained = true; }
	    if (element === base || element.type === "ArrowFunctionExpression") {
	      if (optionalChained) {
	        var chainNode = this.startNodeAt(startPos, startLoc);
	        chainNode.expression = element;
	        element = this.finishNode(chainNode, "ChainExpression");
	      }
	      return element
	    }

	    base = element;
	  }
	};

	pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
	  var optionalSupported = this.options.ecmaVersion >= 11;
	  var optional = optionalSupported && this.eat(types$1.questionDot);
	  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

	  var computed = this.eat(types$1.bracketL);
	  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.object = base;
	    if (computed) {
	      node.property = this.parseExpression();
	      this.expect(types$1.bracketR);
	    } else if (this.type === types$1.privateId && base.type !== "Super") {
	      node.property = this.parsePrivateIdent();
	    } else {
	      node.property = this.parseIdent(this.options.allowReserved !== "never");
	    }
	    node.computed = !!computed;
	    if (optionalSupported) {
	      node.optional = optional;
	    }
	    base = this.finishNode(node, "MemberExpression");
	  } else if (!noCalls && this.eat(types$1.parenL)) {
	    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	    this.yieldPos = 0;
	    this.awaitPos = 0;
	    this.awaitIdentPos = 0;
	    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
	    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
	      this.checkPatternErrors(refDestructuringErrors, false);
	      this.checkYieldAwaitInDefaultParams();
	      if (this.awaitIdentPos > 0)
	        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
	      this.yieldPos = oldYieldPos;
	      this.awaitPos = oldAwaitPos;
	      this.awaitIdentPos = oldAwaitIdentPos;
	      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
	    }
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    this.yieldPos = oldYieldPos || this.yieldPos;
	    this.awaitPos = oldAwaitPos || this.awaitPos;
	    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
	    var node$1 = this.startNodeAt(startPos, startLoc);
	    node$1.callee = base;
	    node$1.arguments = exprList;
	    if (optionalSupported) {
	      node$1.optional = optional;
	    }
	    base = this.finishNode(node$1, "CallExpression");
	  } else if (this.type === types$1.backQuote) {
	    if (optional || optionalChained) {
	      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
	    }
	    var node$2 = this.startNodeAt(startPos, startLoc);
	    node$2.tag = base;
	    node$2.quasi = this.parseTemplate({isTagged: true});
	    base = this.finishNode(node$2, "TaggedTemplateExpression");
	  }
	  return base
	};

	// Parse an atomic expression  either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.

	pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
	  // If a division operator appears in an expression position, the
	  // tokenizer got confused, and we force it to read a regexp instead.
	  if (this.type === types$1.slash) { this.readRegexp(); }

	  var node, canBeArrow = this.potentialArrowAt === this.start;
	  switch (this.type) {
	  case types$1._super:
	    if (!this.allowSuper)
	      { this.raise(this.start, "'super' keyword outside a method"); }
	    node = this.startNode();
	    this.next();
	    if (this.type === types$1.parenL && !this.allowDirectSuper)
	      { this.raise(node.start, "super() call outside constructor of a subclass"); }
	    // The `super` keyword can appear at below:
	    // SuperProperty:
	    //     super [ Expression ]
	    //     super . IdentifierName
	    // SuperCall:
	    //     super ( Arguments )
	    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
	      { this.unexpected(); }
	    return this.finishNode(node, "Super")

	  case types$1._this:
	    node = this.startNode();
	    this.next();
	    return this.finishNode(node, "ThisExpression")

	  case types$1.name:
	    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
	    var id = this.parseIdent(false);
	    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
	      this.overrideContext(types.f_expr);
	      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
	    }
	    if (canBeArrow && !this.canInsertSemicolon()) {
	      if (this.eat(types$1.arrow))
	        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
	      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
	          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
	        id = this.parseIdent(false);
	        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
	          { this.unexpected(); }
	        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
	      }
	    }
	    return id

	  case types$1.regexp:
	    var value = this.value;
	    node = this.parseLiteral(value.value);
	    node.regex = {pattern: value.pattern, flags: value.flags};
	    return node

	  case types$1.num: case types$1.string:
	    return this.parseLiteral(this.value)

	  case types$1._null: case types$1._true: case types$1._false:
	    node = this.startNode();
	    node.value = this.type === types$1._null ? null : this.type === types$1._true;
	    node.raw = this.type.keyword;
	    this.next();
	    return this.finishNode(node, "Literal")

	  case types$1.parenL:
	    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
	    if (refDestructuringErrors) {
	      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
	        { refDestructuringErrors.parenthesizedAssign = start; }
	      if (refDestructuringErrors.parenthesizedBind < 0)
	        { refDestructuringErrors.parenthesizedBind = start; }
	    }
	    return expr

	  case types$1.bracketL:
	    node = this.startNode();
	    this.next();
	    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
	    return this.finishNode(node, "ArrayExpression")

	  case types$1.braceL:
	    this.overrideContext(types.b_expr);
	    return this.parseObj(false, refDestructuringErrors)

	  case types$1._function:
	    node = this.startNode();
	    this.next();
	    return this.parseFunction(node, 0)

	  case types$1._class:
	    return this.parseClass(this.startNode(), false)

	  case types$1._new:
	    return this.parseNew()

	  case types$1.backQuote:
	    return this.parseTemplate()

	  case types$1._import:
	    if (this.options.ecmaVersion >= 11) {
	      return this.parseExprImport()
	    } else {
	      return this.unexpected()
	    }

	  default:
	    this.unexpected();
	  }
	};

	pp$5.parseExprImport = function() {
	  var node = this.startNode();

	  // Consume `import` as an identifier for `import.meta`.
	  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
	  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
	  var meta = this.parseIdent(true);

	  switch (this.type) {
	  case types$1.parenL:
	    return this.parseDynamicImport(node)
	  case types$1.dot:
	    node.meta = meta;
	    return this.parseImportMeta(node)
	  default:
	    this.unexpected();
	  }
	};

	pp$5.parseDynamicImport = function(node) {
	  this.next(); // skip `(`

	  // Parse node.source.
	  node.source = this.parseMaybeAssign();

	  // Verify ending.
	  if (!this.eat(types$1.parenR)) {
	    var errorPos = this.start;
	    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
	      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
	    } else {
	      this.unexpected(errorPos);
	    }
	  }

	  return this.finishNode(node, "ImportExpression")
	};

	pp$5.parseImportMeta = function(node) {
	  this.next(); // skip `.`

	  var containsEsc = this.containsEsc;
	  node.property = this.parseIdent(true);

	  if (node.property.name !== "meta")
	    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
	  if (containsEsc)
	    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
	  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
	    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

	  return this.finishNode(node, "MetaProperty")
	};

	pp$5.parseLiteral = function(value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
	  this.next();
	  return this.finishNode(node, "Literal")
	};

	pp$5.parseParenExpression = function() {
	  this.expect(types$1.parenL);
	  var val = this.parseExpression();
	  this.expect(types$1.parenR);
	  return val
	};

	pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
	  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();

	    var innerStartPos = this.start, innerStartLoc = this.startLoc;
	    var exprList = [], first = true, lastIsComma = false;
	    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
	    this.yieldPos = 0;
	    this.awaitPos = 0;
	    // Do not save awaitIdentPos to allow checking awaits nested in parameters
	    while (this.type !== types$1.parenR) {
	      first ? first = false : this.expect(types$1.comma);
	      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
	        lastIsComma = true;
	        break
	      } else if (this.type === types$1.ellipsis) {
	        spreadStart = this.start;
	        exprList.push(this.parseParenItem(this.parseRestBinding()));
	        if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
	        break
	      } else {
	        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
	      }
	    }
	    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
	    this.expect(types$1.parenR);

	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
	      this.checkPatternErrors(refDestructuringErrors, false);
	      this.checkYieldAwaitInDefaultParams();
	      this.yieldPos = oldYieldPos;
	      this.awaitPos = oldAwaitPos;
	      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
	    }

	    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
	    if (spreadStart) { this.unexpected(spreadStart); }
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    this.yieldPos = oldYieldPos || this.yieldPos;
	    this.awaitPos = oldAwaitPos || this.awaitPos;

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }

	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(startPos, startLoc);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression")
	  } else {
	    return val
	  }
	};

	pp$5.parseParenItem = function(item) {
	  return item
	};

	pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
	  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
	};

	// New's precedence is slightly tricky. It must allow its argument to
	// be a `[]` or dot subscript expression, but not a call  at least,
	// not without wrapping it in parentheses. Thus, it uses the noCalls
	// argument to parseSubscripts to prevent it from consuming the
	// argument list.

	var empty = [];

	pp$5.parseNew = function() {
	  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
	    node.meta = meta;
	    var containsEsc = this.containsEsc;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target")
	      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
	    if (containsEsc)
	      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
	    if (!this.allowNewDotTarget)
	      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
	    return this.finishNode(node, "MetaProperty")
	  }
	  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
	  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
	  if (isImport && node.callee.type === "ImportExpression") {
	    this.raise(startPos, "Cannot use new with import()");
	  }
	  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
	  else { node.arguments = empty; }
	  return this.finishNode(node, "NewExpression")
	};

	// Parse template expression.

	pp$5.parseTemplateElement = function(ref) {
	  var isTagged = ref.isTagged;

	  var elem = this.startNode();
	  if (this.type === types$1.invalidTemplate) {
	    if (!isTagged) {
	      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
	    }
	    elem.value = {
	      raw: this.value,
	      cooked: null
	    };
	  } else {
	    elem.value = {
	      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
	      cooked: this.value
	    };
	  }
	  this.next();
	  elem.tail = this.type === types$1.backQuote;
	  return this.finishNode(elem, "TemplateElement")
	};

	pp$5.parseTemplate = function(ref) {
	  if ( ref === void 0 ) ref = {};
	  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement({isTagged: isTagged});
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
	    this.expect(types$1.dollarBraceL);
	    node.expressions.push(this.parseExpression());
	    this.expect(types$1.braceR);
	    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral")
	};

	pp$5.isAsyncProp = function(prop) {
	  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
	    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
	    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	};

	// Parse an object literal or binding pattern.

	pp$5.parseObj = function(isPattern, refDestructuringErrors) {
	  var node = this.startNode(), first = true, propHash = {};
	  node.properties = [];
	  this.next();
	  while (!this.eat(types$1.braceR)) {
	    if (!first) {
	      this.expect(types$1.comma);
	      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
	    } else { first = false; }

	    var prop = this.parseProperty(isPattern, refDestructuringErrors);
	    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
	    node.properties.push(prop);
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
	};

	pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
	  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
	  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
	    if (isPattern) {
	      prop.argument = this.parseIdent(false);
	      if (this.type === types$1.comma) {
	        this.raise(this.start, "Comma is not permitted after the rest element");
	      }
	      return this.finishNode(prop, "RestElement")
	    }
	    // Parse argument.
	    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	    // To disallow trailing comma via `this.toAssignable()`.
	    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
	      refDestructuringErrors.trailingComma = this.start;
	    }
	    // Finish
	    return this.finishNode(prop, "SpreadElement")
	  }
	  if (this.options.ecmaVersion >= 6) {
	    prop.method = false;
	    prop.shorthand = false;
	    if (isPattern || refDestructuringErrors) {
	      startPos = this.start;
	      startLoc = this.startLoc;
	    }
	    if (!isPattern)
	      { isGenerator = this.eat(types$1.star); }
	  }
	  var containsEsc = this.containsEsc;
	  this.parsePropertyName(prop);
	  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
	    isAsync = true;
	    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
	    this.parsePropertyName(prop, refDestructuringErrors);
	  } else {
	    isAsync = false;
	  }
	  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
	  return this.finishNode(prop, "Property")
	};

	pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
	  if ((isGenerator || isAsync) && this.type === types$1.colon)
	    { this.unexpected(); }

	  if (this.eat(types$1.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
	    if (isPattern) { this.unexpected(); }
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator, isAsync);
	  } else if (!isPattern && !containsEsc &&
	             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
	             (prop.key.name === "get" || prop.key.name === "set") &&
	             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
	    if (isGenerator || isAsync) { this.unexpected(); }
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	    var paramCount = prop.kind === "get" ? 0 : 1;
	    if (prop.value.params.length !== paramCount) {
	      var start = prop.value.start;
	      if (prop.kind === "get")
	        { this.raiseRecoverable(start, "getter should have no params"); }
	      else
	        { this.raiseRecoverable(start, "setter should have exactly one param"); }
	    } else {
	      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
	        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
	    }
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    if (isGenerator || isAsync) { this.unexpected(); }
	    this.checkUnreserved(prop.key);
	    if (prop.key.name === "await" && !this.awaitIdentPos)
	      { this.awaitIdentPos = startPos; }
	    prop.kind = "init";
	    if (isPattern) {
	      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
	    } else if (this.type === types$1.eq && refDestructuringErrors) {
	      if (refDestructuringErrors.shorthandAssign < 0)
	        { refDestructuringErrors.shorthandAssign = this.start; }
	      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
	    } else {
	      prop.value = this.copyNode(prop.key);
	    }
	    prop.shorthand = true;
	  } else { this.unexpected(); }
	};

	pp$5.parsePropertyName = function(prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(types$1.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(types$1.bracketR);
	      return prop.key
	    } else {
	      prop.computed = false;
	    }
	  }
	  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
	};

	// Initialize empty function node.

	pp$5.initFunction = function(node) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
	  if (this.options.ecmaVersion >= 8) { node.async = false; }
	};

	// Parse object or class method.

	pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
	  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6)
	    { node.generator = isGenerator; }
	  if (this.options.ecmaVersion >= 8)
	    { node.async = !!isAsync; }

	  this.yieldPos = 0;
	  this.awaitPos = 0;
	  this.awaitIdentPos = 0;
	  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

	  this.expect(types$1.parenL);
	  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	  this.checkYieldAwaitInDefaultParams();
	  this.parseFunctionBody(node, false, true, false);

	  this.yieldPos = oldYieldPos;
	  this.awaitPos = oldAwaitPos;
	  this.awaitIdentPos = oldAwaitIdentPos;
	  return this.finishNode(node, "FunctionExpression")
	};

	// Parse arrow function expression with given parameters.

	pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
	  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

	  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

	  this.yieldPos = 0;
	  this.awaitPos = 0;
	  this.awaitIdentPos = 0;

	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true, false, forInit);

	  this.yieldPos = oldYieldPos;
	  this.awaitPos = oldAwaitPos;
	  this.awaitIdentPos = oldAwaitIdentPos;
	  return this.finishNode(node, "ArrowFunctionExpression")
	};

	// Parse function body and check parameters.

	pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
	  var isExpression = isArrowFunction && this.type !== types$1.braceL;
	  var oldStrict = this.strict, useStrict = false;

	  if (isExpression) {
	    node.body = this.parseMaybeAssign(forInit);
	    node.expression = true;
	    this.checkParams(node, false);
	  } else {
	    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
	    if (!oldStrict || nonSimple) {
	      useStrict = this.strictDirective(this.end);
	      // If this is a strict mode function, verify that argument names
	      // are not repeated, and it does not try to bind the words `eval`
	      // or `arguments`.
	      if (useStrict && nonSimple)
	        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
	    }
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldLabels = this.labels;
	    this.labels = [];
	    if (useStrict) { this.strict = true; }

	    // Add the params to varDeclaredNames to ensure that an error is thrown
	    // if a let/const declaration in the function clashes with one of the params.
	    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
	    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
	    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
	    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
	    node.expression = false;
	    this.adaptDirectivePrologue(node.body.body);
	    this.labels = oldLabels;
	  }
	  this.exitScope();
	};

	pp$5.isSimpleParamList = function(params) {
	  for (var i = 0, list = params; i < list.length; i += 1)
	    {
	    var param = list[i];

	    if (param.type !== "Identifier") { return false
	  } }
	  return true
	};

	// Checks function params for various disallowed patterns such as using "eval"
	// or "arguments" and duplicate parameters.

	pp$5.checkParams = function(node, allowDuplicates) {
	  var nameHash = Object.create(null);
	  for (var i = 0, list = node.params; i < list.length; i += 1)
	    {
	    var param = list[i];

	    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
	  }
	};

	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).

	pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	  var elts = [], first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this.expect(types$1.comma);
	      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
	    } else { first = false; }

	    var elt = (void 0);
	    if (allowEmpty && this.type === types$1.comma)
	      { elt = null; }
	    else if (this.type === types$1.ellipsis) {
	      elt = this.parseSpread(refDestructuringErrors);
	      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
	        { refDestructuringErrors.trailingComma = this.start; }
	    } else {
	      elt = this.parseMaybeAssign(false, refDestructuringErrors);
	    }
	    elts.push(elt);
	  }
	  return elts
	};

	pp$5.checkUnreserved = function(ref) {
	  var start = ref.start;
	  var end = ref.end;
	  var name = ref.name;

	  if (this.inGenerator && name === "yield")
	    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
	  if (this.inAsync && name === "await")
	    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
	  if (this.currentThisScope().inClassFieldInit && name === "arguments")
	    { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
	  if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
	    { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
	  if (this.keywords.test(name))
	    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
	  if (this.options.ecmaVersion < 6 &&
	    this.input.slice(start, end).indexOf("\\") !== -1) { return }
	  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
	  if (re.test(name)) {
	    if (!this.inAsync && name === "await")
	      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
	    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
	  }
	};

	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.

	pp$5.parseIdent = function(liberal, isBinding) {
	  var node = this.startNode();
	  if (this.type === types$1.name) {
	    node.name = this.value;
	  } else if (this.type.keyword) {
	    node.name = this.type.keyword;

	    // To fix https://github.com/acornjs/acorn/issues/575
	    // `class` and `function` keywords push new context into this.context.
	    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
	    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
	    if ((node.name === "class" || node.name === "function") &&
	        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
	      this.context.pop();
	    }
	  } else {
	    this.unexpected();
	  }
	  this.next(!!liberal);
	  this.finishNode(node, "Identifier");
	  if (!liberal) {
	    this.checkUnreserved(node);
	    if (node.name === "await" && !this.awaitIdentPos)
	      { this.awaitIdentPos = node.start; }
	  }
	  return node
	};

	pp$5.parsePrivateIdent = function() {
	  var node = this.startNode();
	  if (this.type === types$1.privateId) {
	    node.name = this.value;
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  this.finishNode(node, "PrivateIdentifier");

	  // For validating existence
	  if (this.privateNameStack.length === 0) {
	    this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
	  } else {
	    this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
	  }

	  return node
	};

	// Parses yield expression inside generator.

	pp$5.parseYield = function(forInit) {
	  if (!this.yieldPos) { this.yieldPos = this.start; }

	  var node = this.startNode();
	  this.next();
	  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(types$1.star);
	    node.argument = this.parseMaybeAssign(forInit);
	  }
	  return this.finishNode(node, "YieldExpression")
	};

	pp$5.parseAwait = function(forInit) {
	  if (!this.awaitPos) { this.awaitPos = this.start; }

	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeUnary(null, true, false, forInit);
	  return this.finishNode(node, "AwaitExpression")
	};

	var pp$4 = Parser.prototype;

	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.

	pp$4.raise = function(pos, message) {
	  var loc = getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
	  throw err
	};

	pp$4.raiseRecoverable = pp$4.raise;

	pp$4.curPosition = function() {
	  if (this.options.locations) {
	    return new Position(this.curLine, this.pos - this.lineStart)
	  }
	};

	var pp$3 = Parser.prototype;

	var Scope = function Scope(flags) {
	  this.flags = flags;
	  // A list of var-declared names in the current lexical scope
	  this.var = [];
	  // A list of lexically-declared names in the current lexical scope
	  this.lexical = [];
	  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
	  this.functions = [];
	  // A switch to disallow the identifier reference 'arguments'
	  this.inClassFieldInit = false;
	};

	// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

	pp$3.enterScope = function(flags) {
	  this.scopeStack.push(new Scope(flags));
	};

	pp$3.exitScope = function() {
	  this.scopeStack.pop();
	};

	// The spec says:
	// > At the top level of a function, or script, function declarations are
	// > treated like var declarations rather than like lexical declarations.
	pp$3.treatFunctionsAsVarInScope = function(scope) {
	  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
	};

	pp$3.declareName = function(name, bindingType, pos) {
	  var redeclared = false;
	  if (bindingType === BIND_LEXICAL) {
	    var scope = this.currentScope();
	    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
	    scope.lexical.push(name);
	    if (this.inModule && (scope.flags & SCOPE_TOP))
	      { delete this.undefinedExports[name]; }
	  } else if (bindingType === BIND_SIMPLE_CATCH) {
	    var scope$1 = this.currentScope();
	    scope$1.lexical.push(name);
	  } else if (bindingType === BIND_FUNCTION) {
	    var scope$2 = this.currentScope();
	    if (this.treatFunctionsAsVar)
	      { redeclared = scope$2.lexical.indexOf(name) > -1; }
	    else
	      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
	    scope$2.functions.push(name);
	  } else {
	    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
	      var scope$3 = this.scopeStack[i];
	      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
	          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
	        redeclared = true;
	        break
	      }
	      scope$3.var.push(name);
	      if (this.inModule && (scope$3.flags & SCOPE_TOP))
	        { delete this.undefinedExports[name]; }
	      if (scope$3.flags & SCOPE_VAR) { break }
	    }
	  }
	  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
	};

	pp$3.checkLocalExport = function(id) {
	  // scope.functions must be empty as Module code is always strict.
	  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
	      this.scopeStack[0].var.indexOf(id.name) === -1) {
	    this.undefinedExports[id.name] = id;
	  }
	};

	pp$3.currentScope = function() {
	  return this.scopeStack[this.scopeStack.length - 1]
	};

	pp$3.currentVarScope = function() {
	  for (var i = this.scopeStack.length - 1;; i--) {
	    var scope = this.scopeStack[i];
	    if (scope.flags & SCOPE_VAR) { return scope }
	  }
	};

	// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
	pp$3.currentThisScope = function() {
	  for (var i = this.scopeStack.length - 1;; i--) {
	    var scope = this.scopeStack[i];
	    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
	  }
	};

	var Node = function Node(parser, pos, loc) {
	  this.type = "";
	  this.start = pos;
	  this.end = 0;
	  if (parser.options.locations)
	    { this.loc = new SourceLocation(parser, loc); }
	  if (parser.options.directSourceFile)
	    { this.sourceFile = parser.options.directSourceFile; }
	  if (parser.options.ranges)
	    { this.range = [pos, 0]; }
	};

	// Start an AST node, attaching a start offset.

	var pp$2 = Parser.prototype;

	pp$2.startNode = function() {
	  return new Node(this, this.start, this.startLoc)
	};

	pp$2.startNodeAt = function(pos, loc) {
	  return new Node(this, pos, loc)
	};

	// Finish an AST node, adding `type` and `end` properties.

	function finishNodeAt(node, type, pos, loc) {
	  node.type = type;
	  node.end = pos;
	  if (this.options.locations)
	    { node.loc.end = loc; }
	  if (this.options.ranges)
	    { node.range[1] = pos; }
	  return node
	}

	pp$2.finishNode = function(node, type) {
	  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
	};

	// Finish node at given position

	pp$2.finishNodeAt = function(node, type, pos, loc) {
	  return finishNodeAt.call(this, node, type, pos, loc)
	};

	pp$2.copyNode = function(node) {
	  var newNode = new Node(this, node.start, this.startLoc);
	  for (var prop in node) { newNode[prop] = node[prop]; }
	  return newNode
	};

	// This file contains Unicode properties extracted from the ECMAScript
	// specification. The lists are extracted like so:
	// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

	// #table-binary-unicode-properties
	var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
	var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
	var ecma11BinaryProperties = ecma10BinaryProperties;
	var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
	var ecma13BinaryProperties = ecma12BinaryProperties;
	var unicodeBinaryProperties = {
	  9: ecma9BinaryProperties,
	  10: ecma10BinaryProperties,
	  11: ecma11BinaryProperties,
	  12: ecma12BinaryProperties,
	  13: ecma13BinaryProperties
	};

	// #table-unicode-general-category-values
	var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

	// #table-unicode-script-values
	var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
	var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
	var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
	var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
	var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
	var unicodeScriptValues = {
	  9: ecma9ScriptValues,
	  10: ecma10ScriptValues,
	  11: ecma11ScriptValues,
	  12: ecma12ScriptValues,
	  13: ecma13ScriptValues
	};

	var data = {};
	function buildUnicodeData(ecmaVersion) {
	  var d = data[ecmaVersion] = {
	    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
	    nonBinary: {
	      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
	      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
	    }
	  };
	  d.nonBinary.Script_Extensions = d.nonBinary.Script;

	  d.nonBinary.gc = d.nonBinary.General_Category;
	  d.nonBinary.sc = d.nonBinary.Script;
	  d.nonBinary.scx = d.nonBinary.Script_Extensions;
	}

	for (var i$1 = 0, list = [9, 10, 11, 12, 13]; i$1 < list.length; i$1 += 1) {
	  var ecmaVersion = list[i$1];

	  buildUnicodeData(ecmaVersion);
	}

	var pp$1 = Parser.prototype;

	var RegExpValidationState = function RegExpValidationState(parser) {
	  this.parser = parser;
	  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
	  this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
	  this.source = "";
	  this.flags = "";
	  this.start = 0;
	  this.switchU = false;
	  this.switchN = false;
	  this.pos = 0;
	  this.lastIntValue = 0;
	  this.lastStringValue = "";
	  this.lastAssertionIsQuantifiable = false;
	  this.numCapturingParens = 0;
	  this.maxBackReference = 0;
	  this.groupNames = [];
	  this.backReferenceNames = [];
	};

	RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
	  var unicode = flags.indexOf("u") !== -1;
	  this.start = start | 0;
	  this.source = pattern + "";
	  this.flags = flags;
	  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
	  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
	};

	RegExpValidationState.prototype.raise = function raise (message) {
	  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
	};

	// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
	// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
	RegExpValidationState.prototype.at = function at (i, forceU) {
	    if ( forceU === void 0 ) forceU = false;

	  var s = this.source;
	  var l = s.length;
	  if (i >= l) {
	    return -1
	  }
	  var c = s.charCodeAt(i);
	  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
	    return c
	  }
	  var next = s.charCodeAt(i + 1);
	  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
	};

	RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
	    if ( forceU === void 0 ) forceU = false;

	  var s = this.source;
	  var l = s.length;
	  if (i >= l) {
	    return l
	  }
	  var c = s.charCodeAt(i), next;
	  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
	      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
	    return i + 1
	  }
	  return i + 2
	};

	RegExpValidationState.prototype.current = function current (forceU) {
	    if ( forceU === void 0 ) forceU = false;

	  return this.at(this.pos, forceU)
	};

	RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
	    if ( forceU === void 0 ) forceU = false;

	  return this.at(this.nextIndex(this.pos, forceU), forceU)
	};

	RegExpValidationState.prototype.advance = function advance (forceU) {
	    if ( forceU === void 0 ) forceU = false;

	  this.pos = this.nextIndex(this.pos, forceU);
	};

	RegExpValidationState.prototype.eat = function eat (ch, forceU) {
	    if ( forceU === void 0 ) forceU = false;

	  if (this.current(forceU) === ch) {
	    this.advance(forceU);
	    return true
	  }
	  return false
	};

	/**
	 * Validate the flags part of a given RegExpLiteral.
	 *
	 * @param {RegExpValidationState} state The state to validate RegExp.
	 * @returns {void}
	 */
	pp$1.validateRegExpFlags = function(state) {
	  var validFlags = state.validFlags;
	  var flags = state.flags;

	  for (var i = 0; i < flags.length; i++) {
	    var flag = flags.charAt(i);
	    if (validFlags.indexOf(flag) === -1) {
	      this.raise(state.start, "Invalid regular expression flag");
	    }
	    if (flags.indexOf(flag, i + 1) > -1) {
	      this.raise(state.start, "Duplicate regular expression flag");
	    }
	  }
	};

	/**
	 * Validate the pattern part of a given RegExpLiteral.
	 *
	 * @param {RegExpValidationState} state The state to validate RegExp.
	 * @returns {void}
	 */
	pp$1.validateRegExpPattern = function(state) {
	  this.regexp_pattern(state);

	  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
	  // parsing contains a |GroupName|, reparse with the goal symbol
	  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
	  // exception if _P_ did not conform to the grammar, if any elements of _P_
	  // were not matched by the parse, or if any Early Error conditions exist.
	  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
	    state.switchN = true;
	    this.regexp_pattern(state);
	  }
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
	pp$1.regexp_pattern = function(state) {
	  state.pos = 0;
	  state.lastIntValue = 0;
	  state.lastStringValue = "";
	  state.lastAssertionIsQuantifiable = false;
	  state.numCapturingParens = 0;
	  state.maxBackReference = 0;
	  state.groupNames.length = 0;
	  state.backReferenceNames.length = 0;

	  this.regexp_disjunction(state);

	  if (state.pos !== state.source.length) {
	    // Make the same messages as V8.
	    if (state.eat(0x29 /* ) */)) {
	      state.raise("Unmatched ')'");
	    }
	    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
	      state.raise("Lone quantifier brackets");
	    }
	  }
	  if (state.maxBackReference > state.numCapturingParens) {
	    state.raise("Invalid escape");
	  }
	  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
	    var name = list[i];

	    if (state.groupNames.indexOf(name) === -1) {
	      state.raise("Invalid named capture referenced");
	    }
	  }
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
	pp$1.regexp_disjunction = function(state) {
	  this.regexp_alternative(state);
	  while (state.eat(0x7C /* | */)) {
	    this.regexp_alternative(state);
	  }

	  // Make the same message as V8.
	  if (this.regexp_eatQuantifier(state, true)) {
	    state.raise("Nothing to repeat");
	  }
	  if (state.eat(0x7B /* { */)) {
	    state.raise("Lone quantifier brackets");
	  }
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
	pp$1.regexp_alternative = function(state) {
	  while (state.pos < state.source.length && this.regexp_eatTerm(state))
	    { }
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
	pp$1.regexp_eatTerm = function(state) {
	  if (this.regexp_eatAssertion(state)) {
	    // Handle `QuantifiableAssertion Quantifier` alternative.
	    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
	    // is a QuantifiableAssertion.
	    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
	      // Make the same message as V8.
	      if (state.switchU) {
	        state.raise("Invalid quantifier");
	      }
	    }
	    return true
	  }

	  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
	    this.regexp_eatQuantifier(state);
	    return true
	  }

	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
	pp$1.regexp_eatAssertion = function(state) {
	  var start = state.pos;
	  state.lastAssertionIsQuantifiable = false;

	  // ^, $
	  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
	    return true
	  }

	  // \b \B
	  if (state.eat(0x5C /* \ */)) {
	    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
	      return true
	    }
	    state.pos = start;
	  }

	  // Lookahead / Lookbehind
	  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
	    var lookbehind = false;
	    if (this.options.ecmaVersion >= 9) {
	      lookbehind = state.eat(0x3C /* < */);
	    }
	    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
	      this.regexp_disjunction(state);
	      if (!state.eat(0x29 /* ) */)) {
	        state.raise("Unterminated group");
	      }
	      state.lastAssertionIsQuantifiable = !lookbehind;
	      return true
	    }
	  }

	  state.pos = start;
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
	pp$1.regexp_eatQuantifier = function(state, noError) {
	  if ( noError === void 0 ) noError = false;

	  if (this.regexp_eatQuantifierPrefix(state, noError)) {
	    state.eat(0x3F /* ? */);
	    return true
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
	pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
	  return (
	    state.eat(0x2A /* * */) ||
	    state.eat(0x2B /* + */) ||
	    state.eat(0x3F /* ? */) ||
	    this.regexp_eatBracedQuantifier(state, noError)
	  )
	};
	pp$1.regexp_eatBracedQuantifier = function(state, noError) {
	  var start = state.pos;
	  if (state.eat(0x7B /* { */)) {
	    var min = 0, max = -1;
	    if (this.regexp_eatDecimalDigits(state)) {
	      min = state.lastIntValue;
	      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
	        max = state.lastIntValue;
	      }
	      if (state.eat(0x7D /* } */)) {
	        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
	        if (max !== -1 && max < min && !noError) {
	          state.raise("numbers out of order in {} quantifier");
	        }
	        return true
	      }
	    }
	    if (state.switchU && !noError) {
	      state.raise("Incomplete quantifier");
	    }
	    state.pos = start;
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
	pp$1.regexp_eatAtom = function(state) {
	  return (
	    this.regexp_eatPatternCharacters(state) ||
	    state.eat(0x2E /* . */) ||
	    this.regexp_eatReverseSolidusAtomEscape(state) ||
	    this.regexp_eatCharacterClass(state) ||
	    this.regexp_eatUncapturingGroup(state) ||
	    this.regexp_eatCapturingGroup(state)
	  )
	};
	pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
	  var start = state.pos;
	  if (state.eat(0x5C /* \ */)) {
	    if (this.regexp_eatAtomEscape(state)) {
	      return true
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$1.regexp_eatUncapturingGroup = function(state) {
	  var start = state.pos;
	  if (state.eat(0x28 /* ( */)) {
	    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
	      this.regexp_disjunction(state);
	      if (state.eat(0x29 /* ) */)) {
	        return true
	      }
	      state.raise("Unterminated group");
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$1.regexp_eatCapturingGroup = function(state) {
	  if (state.eat(0x28 /* ( */)) {
	    if (this.options.ecmaVersion >= 9) {
	      this.regexp_groupSpecifier(state);
	    } else if (state.current() === 0x3F /* ? */) {
	      state.raise("Invalid group");
	    }
	    this.regexp_disjunction(state);
	    if (state.eat(0x29 /* ) */)) {
	      state.numCapturingParens += 1;
	      return true
	    }
	    state.raise("Unterminated group");
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
	pp$1.regexp_eatExtendedAtom = function(state) {
	  return (
	    state.eat(0x2E /* . */) ||
	    this.regexp_eatReverseSolidusAtomEscape(state) ||
	    this.regexp_eatCharacterClass(state) ||
	    this.regexp_eatUncapturingGroup(state) ||
	    this.regexp_eatCapturingGroup(state) ||
	    this.regexp_eatInvalidBracedQuantifier(state) ||
	    this.regexp_eatExtendedPatternCharacter(state)
	  )
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
	pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
	  if (this.regexp_eatBracedQuantifier(state, true)) {
	    state.raise("Nothing to repeat");
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
	pp$1.regexp_eatSyntaxCharacter = function(state) {
	  var ch = state.current();
	  if (isSyntaxCharacter(ch)) {
	    state.lastIntValue = ch;
	    state.advance();
	    return true
	  }
	  return false
	};
	function isSyntaxCharacter(ch) {
	  return (
	    ch === 0x24 /* $ */ ||
	    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
	    ch === 0x2E /* . */ ||
	    ch === 0x3F /* ? */ ||
	    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
	    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
	  )
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
	// But eat eager.
	pp$1.regexp_eatPatternCharacters = function(state) {
	  var start = state.pos;
	  var ch = 0;
	  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
	    state.advance();
	  }
	  return state.pos !== start
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
	pp$1.regexp_eatExtendedPatternCharacter = function(state) {
	  var ch = state.current();
	  if (
	    ch !== -1 &&
	    ch !== 0x24 /* $ */ &&
	    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
	    ch !== 0x2E /* . */ &&
	    ch !== 0x3F /* ? */ &&
	    ch !== 0x5B /* [ */ &&
	    ch !== 0x5E /* ^ */ &&
	    ch !== 0x7C /* | */
	  ) {
	    state.advance();
	    return true
	  }
	  return false
	};

	// GroupSpecifier ::
	//   [empty]
	//   `?` GroupName
	pp$1.regexp_groupSpecifier = function(state) {
	  if (state.eat(0x3F /* ? */)) {
	    if (this.regexp_eatGroupName(state)) {
	      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
	        state.raise("Duplicate capture group name");
	      }
	      state.groupNames.push(state.lastStringValue);
	      return
	    }
	    state.raise("Invalid group");
	  }
	};

	// GroupName ::
	//   `<` RegExpIdentifierName `>`
	// Note: this updates `state.lastStringValue` property with the eaten name.
	pp$1.regexp_eatGroupName = function(state) {
	  state.lastStringValue = "";
	  if (state.eat(0x3C /* < */)) {
	    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
	      return true
	    }
	    state.raise("Invalid capture group name");
	  }
	  return false
	};

	// RegExpIdentifierName ::
	//   RegExpIdentifierStart
	//   RegExpIdentifierName RegExpIdentifierPart
	// Note: this updates `state.lastStringValue` property with the eaten name.
	pp$1.regexp_eatRegExpIdentifierName = function(state) {
	  state.lastStringValue = "";
	  if (this.regexp_eatRegExpIdentifierStart(state)) {
	    state.lastStringValue += codePointToString(state.lastIntValue);
	    while (this.regexp_eatRegExpIdentifierPart(state)) {
	      state.lastStringValue += codePointToString(state.lastIntValue);
	    }
	    return true
	  }
	  return false
	};

	// RegExpIdentifierStart ::
	//   UnicodeIDStart
	//   `$`
	//   `_`
	//   `\` RegExpUnicodeEscapeSequence[+U]
	pp$1.regexp_eatRegExpIdentifierStart = function(state) {
	  var start = state.pos;
	  var forceU = this.options.ecmaVersion >= 11;
	  var ch = state.current(forceU);
	  state.advance(forceU);

	  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
	    ch = state.lastIntValue;
	  }
	  if (isRegExpIdentifierStart(ch)) {
	    state.lastIntValue = ch;
	    return true
	  }

	  state.pos = start;
	  return false
	};
	function isRegExpIdentifierStart(ch) {
	  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
	}

	// RegExpIdentifierPart ::
	//   UnicodeIDContinue
	//   `$`
	//   `_`
	//   `\` RegExpUnicodeEscapeSequence[+U]
	//   <ZWNJ>
	//   <ZWJ>
	pp$1.regexp_eatRegExpIdentifierPart = function(state) {
	  var start = state.pos;
	  var forceU = this.options.ecmaVersion >= 11;
	  var ch = state.current(forceU);
	  state.advance(forceU);

	  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
	    ch = state.lastIntValue;
	  }
	  if (isRegExpIdentifierPart(ch)) {
	    state.lastIntValue = ch;
	    return true
	  }

	  state.pos = start;
	  return false
	};
	function isRegExpIdentifierPart(ch) {
	  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
	pp$1.regexp_eatAtomEscape = function(state) {
	  if (
	    this.regexp_eatBackReference(state) ||
	    this.regexp_eatCharacterClassEscape(state) ||
	    this.regexp_eatCharacterEscape(state) ||
	    (state.switchN && this.regexp_eatKGroupName(state))
	  ) {
	    return true
	  }
	  if (state.switchU) {
	    // Make the same message as V8.
	    if (state.current() === 0x63 /* c */) {
	      state.raise("Invalid unicode escape");
	    }
	    state.raise("Invalid escape");
	  }
	  return false
	};
	pp$1.regexp_eatBackReference = function(state) {
	  var start = state.pos;
	  if (this.regexp_eatDecimalEscape(state)) {
	    var n = state.lastIntValue;
	    if (state.switchU) {
	      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
	      if (n > state.maxBackReference) {
	        state.maxBackReference = n;
	      }
	      return true
	    }
	    if (n <= state.numCapturingParens) {
	      return true
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$1.regexp_eatKGroupName = function(state) {
	  if (state.eat(0x6B /* k */)) {
	    if (this.regexp_eatGroupName(state)) {
	      state.backReferenceNames.push(state.lastStringValue);
	      return true
	    }
	    state.raise("Invalid named reference");
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
	pp$1.regexp_eatCharacterEscape = function(state) {
	  return (
	    this.regexp_eatControlEscape(state) ||
	    this.regexp_eatCControlLetter(state) ||
	    this.regexp_eatZero(state) ||
	    this.regexp_eatHexEscapeSequence(state) ||
	    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
	    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
	    this.regexp_eatIdentityEscape(state)
	  )
	};
	pp$1.regexp_eatCControlLetter = function(state) {
	  var start = state.pos;
	  if (state.eat(0x63 /* c */)) {
	    if (this.regexp_eatControlLetter(state)) {
	      return true
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$1.regexp_eatZero = function(state) {
	  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
	    state.lastIntValue = 0;
	    state.advance();
	    return true
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
	pp$1.regexp_eatControlEscape = function(state) {
	  var ch = state.current();
	  if (ch === 0x74 /* t */) {
	    state.lastIntValue = 0x09; /* \t */
	    state.advance();
	    return true
	  }
	  if (ch === 0x6E /* n */) {
	    state.lastIntValue = 0x0A; /* \n */
	    state.advance();
	    return true
	  }
	  if (ch === 0x76 /* v */) {
	    state.lastIntValue = 0x0B; /* \v */
	    state.advance();
	    return true
	  }
	  if (ch === 0x66 /* f */) {
	    state.lastIntValue = 0x0C; /* \f */
	    state.advance();
	    return true
	  }
	  if (ch === 0x72 /* r */) {
	    state.lastIntValue = 0x0D; /* \r */
	    state.advance();
	    return true
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
	pp$1.regexp_eatControlLetter = function(state) {
	  var ch = state.current();
	  if (isControlLetter(ch)) {
	    state.lastIntValue = ch % 0x20;
	    state.advance();
	    return true
	  }
	  return false
	};
	function isControlLetter(ch) {
	  return (
	    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
	    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
	  )
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
	pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
	  if ( forceU === void 0 ) forceU = false;

	  var start = state.pos;
	  var switchU = forceU || state.switchU;

	  if (state.eat(0x75 /* u */)) {
	    if (this.regexp_eatFixedHexDigits(state, 4)) {
	      var lead = state.lastIntValue;
	      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
	        var leadSurrogateEnd = state.pos;
	        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
	          var trail = state.lastIntValue;
	          if (trail >= 0xDC00 && trail <= 0xDFFF) {
	            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	            return true
	          }
	        }
	        state.pos = leadSurrogateEnd;
	        state.lastIntValue = lead;
	      }
	      return true
	    }
	    if (
	      switchU &&
	      state.eat(0x7B /* { */) &&
	      this.regexp_eatHexDigits(state) &&
	      state.eat(0x7D /* } */) &&
	      isValidUnicode(state.lastIntValue)
	    ) {
	      return true
	    }
	    if (switchU) {
	      state.raise("Invalid unicode escape");
	    }
	    state.pos = start;
	  }

	  return false
	};
	function isValidUnicode(ch) {
	  return ch >= 0 && ch <= 0x10FFFF
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
	pp$1.regexp_eatIdentityEscape = function(state) {
	  if (state.switchU) {
	    if (this.regexp_eatSyntaxCharacter(state)) {
	      return true
	    }
	    if (state.eat(0x2F /* / */)) {
	      state.lastIntValue = 0x2F; /* / */
	      return true
	    }
	    return false
	  }

	  var ch = state.current();
	  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
	    state.lastIntValue = ch;
	    state.advance();
	    return true
	  }

	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
	pp$1.regexp_eatDecimalEscape = function(state) {
	  state.lastIntValue = 0;
	  var ch = state.current();
	  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
	    do {
	      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
	      state.advance();
	    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
	    return true
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
	pp$1.regexp_eatCharacterClassEscape = function(state) {
	  var ch = state.current();

	  if (isCharacterClassEscape(ch)) {
	    state.lastIntValue = -1;
	    state.advance();
	    return true
	  }

	  if (
	    state.switchU &&
	    this.options.ecmaVersion >= 9 &&
	    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
	  ) {
	    state.lastIntValue = -1;
	    state.advance();
	    if (
	      state.eat(0x7B /* { */) &&
	      this.regexp_eatUnicodePropertyValueExpression(state) &&
	      state.eat(0x7D /* } */)
	    ) {
	      return true
	    }
	    state.raise("Invalid property name");
	  }

	  return false
	};
	function isCharacterClassEscape(ch) {
	  return (
	    ch === 0x64 /* d */ ||
	    ch === 0x44 /* D */ ||
	    ch === 0x73 /* s */ ||
	    ch === 0x53 /* S */ ||
	    ch === 0x77 /* w */ ||
	    ch === 0x57 /* W */
	  )
	}

	// UnicodePropertyValueExpression ::
	//   UnicodePropertyName `=` UnicodePropertyValue
	//   LoneUnicodePropertyNameOrValue
	pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
	  var start = state.pos;

	  // UnicodePropertyName `=` UnicodePropertyValue
	  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
	    var name = state.lastStringValue;
	    if (this.regexp_eatUnicodePropertyValue(state)) {
	      var value = state.lastStringValue;
	      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
	      return true
	    }
	  }
	  state.pos = start;

	  // LoneUnicodePropertyNameOrValue
	  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
	    var nameOrValue = state.lastStringValue;
	    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	    return true
	  }
	  return false
	};
	pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	  if (!hasOwn(state.unicodeProperties.nonBinary, name))
	    { state.raise("Invalid property name"); }
	  if (!state.unicodeProperties.nonBinary[name].test(value))
	    { state.raise("Invalid property value"); }
	};
	pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	  if (!state.unicodeProperties.binary.test(nameOrValue))
	    { state.raise("Invalid property name"); }
	};

	// UnicodePropertyName ::
	//   UnicodePropertyNameCharacters
	pp$1.regexp_eatUnicodePropertyName = function(state) {
	  var ch = 0;
	  state.lastStringValue = "";
	  while (isUnicodePropertyNameCharacter(ch = state.current())) {
	    state.lastStringValue += codePointToString(ch);
	    state.advance();
	  }
	  return state.lastStringValue !== ""
	};
	function isUnicodePropertyNameCharacter(ch) {
	  return isControlLetter(ch) || ch === 0x5F /* _ */
	}

	// UnicodePropertyValue ::
	//   UnicodePropertyValueCharacters
	pp$1.regexp_eatUnicodePropertyValue = function(state) {
	  var ch = 0;
	  state.lastStringValue = "";
	  while (isUnicodePropertyValueCharacter(ch = state.current())) {
	    state.lastStringValue += codePointToString(ch);
	    state.advance();
	  }
	  return state.lastStringValue !== ""
	};
	function isUnicodePropertyValueCharacter(ch) {
	  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
	}

	// LoneUnicodePropertyNameOrValue ::
	//   UnicodePropertyValueCharacters
	pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	  return this.regexp_eatUnicodePropertyValue(state)
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
	pp$1.regexp_eatCharacterClass = function(state) {
	  if (state.eat(0x5B /* [ */)) {
	    state.eat(0x5E /* ^ */);
	    this.regexp_classRanges(state);
	    if (state.eat(0x5D /* ] */)) {
	      return true
	    }
	    // Unreachable since it threw "unterminated regular expression" error before.
	    state.raise("Unterminated character class");
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
	// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
	// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
	pp$1.regexp_classRanges = function(state) {
	  while (this.regexp_eatClassAtom(state)) {
	    var left = state.lastIntValue;
	    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
	      var right = state.lastIntValue;
	      if (state.switchU && (left === -1 || right === -1)) {
	        state.raise("Invalid character class");
	      }
	      if (left !== -1 && right !== -1 && left > right) {
	        state.raise("Range out of order in character class");
	      }
	    }
	  }
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
	// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
	pp$1.regexp_eatClassAtom = function(state) {
	  var start = state.pos;

	  if (state.eat(0x5C /* \ */)) {
	    if (this.regexp_eatClassEscape(state)) {
	      return true
	    }
	    if (state.switchU) {
	      // Make the same message as V8.
	      var ch$1 = state.current();
	      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
	        state.raise("Invalid class escape");
	      }
	      state.raise("Invalid escape");
	    }
	    state.pos = start;
	  }

	  var ch = state.current();
	  if (ch !== 0x5D /* ] */) {
	    state.lastIntValue = ch;
	    state.advance();
	    return true
	  }

	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
	pp$1.regexp_eatClassEscape = function(state) {
	  var start = state.pos;

	  if (state.eat(0x62 /* b */)) {
	    state.lastIntValue = 0x08; /* <BS> */
	    return true
	  }

	  if (state.switchU && state.eat(0x2D /* - */)) {
	    state.lastIntValue = 0x2D; /* - */
	    return true
	  }

	  if (!state.switchU && state.eat(0x63 /* c */)) {
	    if (this.regexp_eatClassControlLetter(state)) {
	      return true
	    }
	    state.pos = start;
	  }

	  return (
	    this.regexp_eatCharacterClassEscape(state) ||
	    this.regexp_eatCharacterEscape(state)
	  )
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
	pp$1.regexp_eatClassControlLetter = function(state) {
	  var ch = state.current();
	  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
	    state.lastIntValue = ch % 0x20;
	    state.advance();
	    return true
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
	pp$1.regexp_eatHexEscapeSequence = function(state) {
	  var start = state.pos;
	  if (state.eat(0x78 /* x */)) {
	    if (this.regexp_eatFixedHexDigits(state, 2)) {
	      return true
	    }
	    if (state.switchU) {
	      state.raise("Invalid escape");
	    }
	    state.pos = start;
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
	pp$1.regexp_eatDecimalDigits = function(state) {
	  var start = state.pos;
	  var ch = 0;
	  state.lastIntValue = 0;
	  while (isDecimalDigit(ch = state.current())) {
	    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
	    state.advance();
	  }
	  return state.pos !== start
	};
	function isDecimalDigit(ch) {
	  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
	pp$1.regexp_eatHexDigits = function(state) {
	  var start = state.pos;
	  var ch = 0;
	  state.lastIntValue = 0;
	  while (isHexDigit(ch = state.current())) {
	    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
	    state.advance();
	  }
	  return state.pos !== start
	};
	function isHexDigit(ch) {
	  return (
	    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
	    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
	    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
	  )
	}
	function hexToInt(ch) {
	  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
	    return 10 + (ch - 0x41 /* A */)
	  }
	  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
	    return 10 + (ch - 0x61 /* a */)
	  }
	  return ch - 0x30 /* 0 */
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
	// Allows only 0-377(octal) i.e. 0-255(decimal).
	pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
	  if (this.regexp_eatOctalDigit(state)) {
	    var n1 = state.lastIntValue;
	    if (this.regexp_eatOctalDigit(state)) {
	      var n2 = state.lastIntValue;
	      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
	        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
	      } else {
	        state.lastIntValue = n1 * 8 + n2;
	      }
	    } else {
	      state.lastIntValue = n1;
	    }
	    return true
	  }
	  return false
	};

	// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
	pp$1.regexp_eatOctalDigit = function(state) {
	  var ch = state.current();
	  if (isOctalDigit(ch)) {
	    state.lastIntValue = ch - 0x30; /* 0 */
	    state.advance();
	    return true
	  }
	  state.lastIntValue = 0;
	  return false
	};
	function isOctalDigit(ch) {
	  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
	}

	// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
	// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
	// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
	pp$1.regexp_eatFixedHexDigits = function(state, length) {
	  var start = state.pos;
	  state.lastIntValue = 0;
	  for (var i = 0; i < length; ++i) {
	    var ch = state.current();
	    if (!isHexDigit(ch)) {
	      state.pos = start;
	      return false
	    }
	    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
	    state.advance();
	  }
	  return true
	};

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.

	var Token = function Token(p) {
	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations)
	    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
	  if (p.options.ranges)
	    { this.range = [p.start, p.end]; }
	};

	// ## Tokenizer

	var pp = Parser.prototype;

	// Move to the next token

	pp.next = function(ignoreEscapeSequenceInKeyword) {
	  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
	    { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
	  if (this.options.onToken)
	    { this.options.onToken(new Token(this)); }

	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};

	pp.getToken = function() {
	  this.next();
	  return new Token(this)
	};

	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined")
	  { pp[Symbol.iterator] = function() {
	    var this$1$1 = this;

	    return {
	      next: function () {
	        var token = this$1$1.getToken();
	        return {
	          done: token.type === types$1.eof,
	          value: token
	        }
	      }
	    }
	  }; }

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).

	// Read a single token, updating the parser object's token-related
	// properties.

	pp.nextToken = function() {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

	  this.start = this.pos;
	  if (this.options.locations) { this.startLoc = this.curPosition(); }
	  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

	  if (curContext.override) { return curContext.override(this) }
	  else { this.readToken(this.fullCharCodeAtPos()); }
	};

	pp.readToken = function(code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
	    { return this.readWord() }

	  return this.getTokenFromCode(code)
	};

	pp.fullCharCodeAtPos = function() {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 0xd7ff || code >= 0xdc00) { return code }
	  var next = this.input.charCodeAt(this.pos + 1);
	  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
	};

	pp.skipBlockComment = function() {
	  var startLoc = this.options.onComment && this.curPosition();
	  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
	  this.pos = end + 2;
	  if (this.options.locations) {
	    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
	      ++this.curLine;
	      pos = this.lineStart = nextBreak;
	    }
	  }
	  if (this.options.onComment)
	    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
	                           startLoc, this.curPosition()); }
	};

	pp.skipLineComment = function(startSkip) {
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && !isNewLine(ch)) {
	    ch = this.input.charCodeAt(++this.pos);
	  }
	  if (this.options.onComment)
	    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
	                           startLoc, this.curPosition()); }
	};

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.

	pp.skipSpace = function() {
	  loop: while (this.pos < this.input.length) {
	    var ch = this.input.charCodeAt(this.pos);
	    switch (ch) {
	    case 32: case 160: // ' '
	      ++this.pos;
	      break
	    case 13:
	      if (this.input.charCodeAt(this.pos + 1) === 10) {
	        ++this.pos;
	      }
	    case 10: case 8232: case 8233:
	      ++this.pos;
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      break
	    case 47: // '/'
	      switch (this.input.charCodeAt(this.pos + 1)) {
	      case 42: // '*'
	        this.skipBlockComment();
	        break
	      case 47:
	        this.skipLineComment(2);
	        break
	      default:
	        break loop
	      }
	      break
	    default:
	      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	        ++this.pos;
	      } else {
	        break loop
	      }
	    }
	  }
	};

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.

	pp.finishToken = function(type, val) {
	  this.end = this.pos;
	  if (this.options.locations) { this.endLoc = this.curPosition(); }
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;

	  this.updateContext(prevType);
	};

	// ### Token reading

	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp.readToken_dot = function() {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) { return this.readNumber(true) }
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(types$1.ellipsis)
	  } else {
	    ++this.pos;
	    return this.finishToken(types$1.dot)
	  }
	};

	pp.readToken_slash = function() { // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
	  if (next === 61) { return this.finishOp(types$1.assign, 2) }
	  return this.finishOp(types$1.slash, 1)
	};

	pp.readToken_mult_modulo_exp = function(code) { // '%*'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  var tokentype = code === 42 ? types$1.star : types$1.modulo;

	  // exponentiation operator ** and **=
	  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
	    ++size;
	    tokentype = types$1.starstar;
	    next = this.input.charCodeAt(this.pos + 2);
	  }

	  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
	  return this.finishOp(tokentype, size)
	};

	pp.readToken_pipe_amp = function(code) { // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (this.options.ecmaVersion >= 12) {
	      var next2 = this.input.charCodeAt(this.pos + 2);
	      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
	    }
	    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
	  }
	  if (next === 61) { return this.finishOp(types$1.assign, 2) }
	  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
	};

	pp.readToken_caret = function() { // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) { return this.finishOp(types$1.assign, 2) }
	  return this.finishOp(types$1.bitwiseXOR, 1)
	};

	pp.readToken_plus_min = function(code) { // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
	        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken()
	    }
	    return this.finishOp(types$1.incDec, 2)
	  }
	  if (next === 61) { return this.finishOp(types$1.assign, 2) }
	  return this.finishOp(types$1.plusMin, 1)
	};

	pp.readToken_lt_gt = function(code) { // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
	    return this.finishOp(types$1.bitShift, size)
	  }
	  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
	      this.input.charCodeAt(this.pos + 3) === 45) {
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken()
	  }
	  if (next === 61) { size = 2; }
	  return this.finishOp(types$1.relational, size)
	};

	pp.readToken_eq_excl = function(code) { // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
	    this.pos += 2;
	    return this.finishToken(types$1.arrow)
	  }
	  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
	};

	pp.readToken_question = function() { // '?'
	  var ecmaVersion = this.options.ecmaVersion;
	  if (ecmaVersion >= 11) {
	    var next = this.input.charCodeAt(this.pos + 1);
	    if (next === 46) {
	      var next2 = this.input.charCodeAt(this.pos + 2);
	      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
	    }
	    if (next === 63) {
	      if (ecmaVersion >= 12) {
	        var next2$1 = this.input.charCodeAt(this.pos + 2);
	        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
	      }
	      return this.finishOp(types$1.coalesce, 2)
	    }
	  }
	  return this.finishOp(types$1.question, 1)
	};

	pp.readToken_numberSign = function() { // '#'
	  var ecmaVersion = this.options.ecmaVersion;
	  var code = 35; // '#'
	  if (ecmaVersion >= 13) {
	    ++this.pos;
	    code = this.fullCharCodeAtPos();
	    if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
	      return this.finishToken(types$1.privateId, this.readWord1())
	    }
	  }

	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};

	pp.getTokenFromCode = function(code) {
	  switch (code) {
	  // The interpretation of a dot depends on whether it is followed
	  // by a digit or another two dots.
	  case 46: // '.'
	    return this.readToken_dot()

	  // Punctuation tokens.
	  case 40: ++this.pos; return this.finishToken(types$1.parenL)
	  case 41: ++this.pos; return this.finishToken(types$1.parenR)
	  case 59: ++this.pos; return this.finishToken(types$1.semi)
	  case 44: ++this.pos; return this.finishToken(types$1.comma)
	  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
	  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
	  case 123: ++this.pos; return this.finishToken(types$1.braceL)
	  case 125: ++this.pos; return this.finishToken(types$1.braceR)
	  case 58: ++this.pos; return this.finishToken(types$1.colon)

	  case 96: // '`'
	    if (this.options.ecmaVersion < 6) { break }
	    ++this.pos;
	    return this.finishToken(types$1.backQuote)

	  case 48: // '0'
	    var next = this.input.charCodeAt(this.pos + 1);
	    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
	    if (this.options.ecmaVersion >= 6) {
	      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
	      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
	    }

	  // Anything else beginning with a digit is an integer, octal
	  // number, or float.
	  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
	    return this.readNumber(false)

	  // Quotes produce strings.
	  case 34: case 39: // '"', "'"
	    return this.readString(code)

	  // Operators are parsed inline in tiny state machines. '=' (61) is
	  // often referred to. `finishOp` simply skips the amount of
	  // characters it is given as second argument, and returns a token
	  // of the type given by its first argument.
	  case 47: // '/'
	    return this.readToken_slash()

	  case 37: case 42: // '%*'
	    return this.readToken_mult_modulo_exp(code)

	  case 124: case 38: // '|&'
	    return this.readToken_pipe_amp(code)

	  case 94: // '^'
	    return this.readToken_caret()

	  case 43: case 45: // '+-'
	    return this.readToken_plus_min(code)

	  case 60: case 62: // '<>'
	    return this.readToken_lt_gt(code)

	  case 61: case 33: // '=!'
	    return this.readToken_eq_excl(code)

	  case 63: // '?'
	    return this.readToken_question()

	  case 126: // '~'
	    return this.finishOp(types$1.prefix, 1)

	  case 35: // '#'
	    return this.readToken_numberSign()
	  }

	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};

	pp.finishOp = function(type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str)
	};

	pp.readRegexp = function() {
	  var escaped, inClass, start = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
	    var ch = this.input.charAt(this.pos);
	    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
	    if (!escaped) {
	      if (ch === "[") { inClass = true; }
	      else if (ch === "]" && inClass) { inClass = false; }
	      else if (ch === "/" && !inClass) { break }
	      escaped = ch === "\\";
	    } else { escaped = false; }
	    ++this.pos;
	  }
	  var pattern = this.input.slice(start, this.pos);
	  ++this.pos;
	  var flagsStart = this.pos;
	  var flags = this.readWord1();
	  if (this.containsEsc) { this.unexpected(flagsStart); }

	  // Validate pattern
	  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	  state.reset(start, pattern, flags);
	  this.validateRegExpFlags(state);
	  this.validateRegExpPattern(state);

	  // Create Literal#value property value.
	  var value = null;
	  try {
	    value = new RegExp(pattern, flags);
	  } catch (e) {
	    // ESTree requires null if it failed to instantiate RegExp object.
	    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
	  }

	  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
	};

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.

	pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
	  // `len` is used for character escape sequences. In that case, disallow separators.
	  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

	  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
	  // and isn't fraction part nor exponent part. In that case, if the first digit
	  // is zero then disallow separators.
	  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

	  var start = this.pos, total = 0, lastCode = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
	    var code = this.input.charCodeAt(this.pos), val = (void 0);

	    if (allowSeparators && code === 95) {
	      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
	      if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
	      if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
	      lastCode = code;
	      continue
	    }

	    if (code >= 97) { val = code - 97 + 10; } // a
	    else if (code >= 65) { val = code - 65 + 10; } // A
	    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
	    else { val = Infinity; }
	    if (val >= radix) { break }
	    lastCode = code;
	    total = total * radix + val;
	  }

	  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
	  if (this.pos === start || len != null && this.pos - start !== len) { return null }

	  return total
	};

	function stringToNumber(str, isLegacyOctalNumericLiteral) {
	  if (isLegacyOctalNumericLiteral) {
	    return parseInt(str, 8)
	  }

	  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
	  return parseFloat(str.replace(/_/g, ""))
	}

	function stringToBigInt(str) {
	  if (typeof BigInt !== "function") {
	    return null
	  }

	  // `BigInt(value)` throws syntax error if the string contains numeric separators.
	  return BigInt(str.replace(/_/g, ""))
	}

	pp.readRadixNumber = function(radix) {
	  var start = this.pos;
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
	  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
	    val = stringToBigInt(this.input.slice(start, this.pos));
	    ++this.pos;
	  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
	  return this.finishToken(types$1.num, val)
	};

	// Read an integer, octal integer, or floating-point number.

	pp.readNumber = function(startsWithDot) {
	  var start = this.pos;
	  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
	  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	  if (octal && this.strict) { this.raise(start, "Invalid number"); }
	  var next = this.input.charCodeAt(this.pos);
	  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
	    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
	    ++this.pos;
	    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
	    return this.finishToken(types$1.num, val$1)
	  }
	  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
	  if (next === 46 && !octal) { // '.'
	    ++this.pos;
	    this.readInt(10);
	    next = this.input.charCodeAt(this.pos);
	  }
	  if ((next === 69 || next === 101) && !octal) { // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) { ++this.pos; } // '+-'
	    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
	  }
	  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

	  var val = stringToNumber(this.input.slice(start, this.pos), octal);
	  return this.finishToken(types$1.num, val)
	};

	// Read a string value, interpreting backslash-escapes.

	pp.readCodePoint = function() {
	  var ch = this.input.charCodeAt(this.pos), code;

	  if (ch === 123) { // '{'
	    if (this.options.ecmaVersion < 6) { this.unexpected(); }
	    var codePos = ++this.pos;
	    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
	    ++this.pos;
	    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code
	};

	pp.readString = function(quote) {
	  var out = "", chunkStart = ++this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === quote) { break }
	    if (ch === 92) { // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(false);
	      chunkStart = this.pos;
	    } else if (ch === 0x2028 || ch === 0x2029) {
	      if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
	      ++this.pos;
	      if (this.options.locations) {
	        this.curLine++;
	        this.lineStart = this.pos;
	      }
	    } else {
	      if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
	      ++this.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(types$1.string, out)
	};

	// Reads template string tokens.

	var INVALID_TEMPLATE_ESCAPE_ERROR = {};

	pp.tryReadTemplateToken = function() {
	  this.inTemplateElement = true;
	  try {
	    this.readTmplToken();
	  } catch (err) {
	    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
	      this.readInvalidTemplateToken();
	    } else {
	      throw err
	    }
	  }

	  this.inTemplateElement = false;
	};

	pp.invalidStringToken = function(position, message) {
	  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
	    throw INVALID_TEMPLATE_ESCAPE_ERROR
	  } else {
	    this.raise(position, message);
	  }
	};

	pp.readTmplToken = function() {
	  var out = "", chunkStart = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
	      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
	        if (ch === 36) {
	          this.pos += 2;
	          return this.finishToken(types$1.dollarBraceL)
	        } else {
	          ++this.pos;
	          return this.finishToken(types$1.backQuote)
	        }
	      }
	      out += this.input.slice(chunkStart, this.pos);
	      return this.finishToken(types$1.template, out)
	    }
	    if (ch === 92) { // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(true);
	      chunkStart = this.pos;
	    } else if (isNewLine(ch)) {
	      out += this.input.slice(chunkStart, this.pos);
	      ++this.pos;
	      switch (ch) {
	      case 13:
	        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
	      case 10:
	        out += "\n";
	        break
	      default:
	        out += String.fromCharCode(ch);
	        break
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      chunkStart = this.pos;
	    } else {
	      ++this.pos;
	    }
	  }
	};

	// Reads a template token to search for the end, without validating any escape sequences
	pp.readInvalidTemplateToken = function() {
	  for (; this.pos < this.input.length; this.pos++) {
	    switch (this.input[this.pos]) {
	    case "\\":
	      ++this.pos;
	      break

	    case "$":
	      if (this.input[this.pos + 1] !== "{") {
	        break
	      }

	    // falls through
	    case "`":
	      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

	    // no default
	    }
	  }
	  this.raise(this.start, "Unterminated template");
	};

	// Used to read escaped characters

	pp.readEscapedChar = function(inTemplate) {
	  var ch = this.input.charCodeAt(++this.pos);
	  ++this.pos;
	  switch (ch) {
	  case 110: return "\n" // 'n' -> '\n'
	  case 114: return "\r" // 'r' -> '\r'
	  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
	  case 117: return codePointToString(this.readCodePoint()) // 'u'
	  case 116: return "\t" // 't' -> '\t'
	  case 98: return "\b" // 'b' -> '\b'
	  case 118: return "\u000b" // 'v' -> '\u000b'
	  case 102: return "\f" // 'f' -> '\f'
	  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
	  case 10: // ' \n'
	    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
	    return ""
	  case 56:
	  case 57:
	    if (this.strict) {
	      this.invalidStringToken(
	        this.pos - 1,
	        "Invalid escape sequence"
	      );
	    }
	    if (inTemplate) {
	      var codePos = this.pos - 1;

	      this.invalidStringToken(
	        codePos,
	        "Invalid escape sequence in template string"
	      );

	      return null
	    }
	  default:
	    if (ch >= 48 && ch <= 55) {
	      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
	      var octal = parseInt(octalStr, 8);
	      if (octal > 255) {
	        octalStr = octalStr.slice(0, -1);
	        octal = parseInt(octalStr, 8);
	      }
	      this.pos += octalStr.length - 1;
	      ch = this.input.charCodeAt(this.pos);
	      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
	        this.invalidStringToken(
	          this.pos - 1 - octalStr.length,
	          inTemplate
	            ? "Octal literal in template string"
	            : "Octal literal in strict mode"
	        );
	      }
	      return String.fromCharCode(octal)
	    }
	    if (isNewLine(ch)) {
	      // Unicode new line characters after \ get removed from output in both
	      // template literals and strings
	      return ""
	    }
	    return String.fromCharCode(ch)
	  }
	};

	// Used to read character escape sequences ('\x', '\u', '\U').

	pp.readHexChar = function(len) {
	  var codePos = this.pos;
	  var n = this.readInt(16, len);
	  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
	  return n
	};

	// Read an identifier, and return it as a string. Sets `this.containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.

	pp.readWord1 = function() {
	  this.containsEsc = false;
	  var word = "", first = true, chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this.fullCharCodeAtPos();
	    if (isIdentifierChar(ch, astral)) {
	      this.pos += ch <= 0xffff ? 1 : 2;
	    } else if (ch === 92) { // "\"
	      this.containsEsc = true;
	      word += this.input.slice(chunkStart, this.pos);
	      var escStart = this.pos;
	      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
	        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
	      ++this.pos;
	      var esc = this.readCodePoint();
	      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
	        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
	      word += codePointToString(esc);
	      chunkStart = this.pos;
	    } else {
	      break
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos)
	};

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.

	pp.readWord = function() {
	  var word = this.readWord1();
	  var type = types$1.name;
	  if (this.keywords.test(word)) {
	    type = keywords[word];
	  }
	  return this.finishToken(type, word)
	};

	// Acorn is a tiny, fast JavaScript parser written in JavaScript.

	var version = "8.8.1";

	Parser.acorn = {
	  Parser: Parser,
	  version: version,
	  defaultOptions: defaultOptions,
	  Position: Position,
	  SourceLocation: SourceLocation,
	  getLineInfo: getLineInfo,
	  Node: Node,
	  TokenType: TokenType,
	  tokTypes: types$1,
	  keywordTypes: keywords,
	  TokContext: TokContext,
	  tokContexts: types,
	  isIdentifierChar: isIdentifierChar,
	  isIdentifierStart: isIdentifierStart,
	  Token: Token,
	  isNewLine: isNewLine,
	  lineBreak: lineBreak,
	  lineBreakG: lineBreakG,
	  nonASCIIwhitespace: nonASCIIwhitespace
	};

	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

	function parse(input, options) {
	  return Parser.parse(input, options)
	}

	function strToJs(str,throwOnInvalid = false) {

	    try {
	        const node = parse('[' + str + ']', {ecmaVersion: 2020});

	        // this is the simplest case that doesn't need to be wrapped
	        // TODO: detect more cases
	        if (node.body[0].expression.elements[0].type == 'Literal') {
	            return `[${str}]`
	        } else {
	            return `(()=>{try{return [${str}]}catch(e){return [${qouted(str)}]}})()`
	        }
	    } catch (e) {
	        if (throwOnInvalid) {
	            throw e
	        } else {
	            return `[${qouted(str)}]`
	        }
	    }
	}

	/**
	 * Finite State Machine generation utilities
	 */

	/**
	 * Define a basic state machine state. j is the list of character transitions,
	 * jr is the list of regex-match transitions, jd is the default state to
	 * transition to t is the accepting token type, if any. If this is the terminal
	 * state, then it does not emit a token.
	 * @param {string|class} token to emit
	 */
	function State(token) {
	  this.j = {}; // IMPLEMENTATION 1
	  // this.j = []; // IMPLEMENTATION 2

	  this.jr = [];
	  this.jd = null;
	  this.t = token;
	}
	/**
	 * Take the transition from this state to the next one on the given input.
	 * If this state does not exist deterministically, will create it.
	 *
	 * @param {string} input character or token to transition on
	 * @param {string|class} [token] token or multi-token to emit when reaching
	 * this state
	 */

	State.prototype = {
	  /**
	   * @param {State} state
	   */
	  accepts: function accepts() {
	    return !!this.t;
	  },

	  /**
	   * Short for "take transition", this is a method for building/working with
	   * state machines.
	   *
	   * If a state already exists for the given input, returns it.
	   *
	   * If a token is specified, that state will emit that token when reached by
	   * the linkify engine.
	   *
	   * If no state exists, it will be initialized with some default transitions
	   * that resemble existing default transitions.
	   *
	   * If a state is given for the second argument, that state will be
	   * transitioned to on the given input regardless of what that input
	   * previously did.
	   *
	   * @param {string} input character or token to transition on
	   * @param {Token|State} tokenOrState transition to a matching state
	   * @returns State taken after the given input
	   */
	  tt: function tt(input, tokenOrState) {
	    if (tokenOrState && tokenOrState.j) {
	      // State, default a basic transition
	      this.j[input] = tokenOrState;
	      return tokenOrState;
	    } // See if there's a direct state transition (not regex or default)


	    var token = tokenOrState;
	    var nextState = this.j[input];

	    if (nextState) {
	      if (token) {
	        nextState.t = token;
	      } // overrwites previous token


	      return nextState;
	    } // Create a new state for this input


	    nextState = makeState(); // Take the transition using the usual default mechanisms

	    var templateState = takeT(this, input);

	    if (templateState) {
	      // Some default state transition, make a prime state based on this one
	      Object.assign(nextState.j, templateState.j);
	      nextState.jr.append(templateState.jr);
	      nextState.jr = templateState.jd;
	      nextState.t = token || templateState.t;
	    } else {
	      nextState.t = token;
	    }

	    this.j[input] = nextState;
	    return nextState;
	  }
	};
	/**
	 * Utility function to create state without using new keyword (reduced file size
	 * when minified)
	 */

	var makeState = function makeState() {
	  return new State();
	};
	/**
	 * Similar to previous except it is an accepting state that emits a token
	 * @param {Token} token
	 */

	var makeAcceptingState = function makeAcceptingState(token) {
	  return new State(token);
	};
	/**
	 * Create a transition from startState to nextState via the given character
	 * @param {State} startState transition from thie starting state
	 * @param {Token} input via this input character or other concrete token type
	 * @param {State} nextState to this next state
	 */

	var makeT = function makeT(startState, input, nextState) {
	  // IMPLEMENTATION 1: Add to object (fast)
	  if (!startState.j[input]) {
	    startState.j[input] = nextState;
	  } // IMPLEMENTATION 2: Add to array (slower)
	  // startState.j.push([input, nextState]);

	};
	/**
	 *
	 * @param {State} startState stransition from this starting state
	 * @param {RegExp} regex Regular expression to match on input
	 * @param {State} nextState transition to this next state if there's are regex match
	 */

	var makeRegexT = function makeRegexT(startState, regex, nextState) {
	  startState.jr.push([regex, nextState]);
	};
	/**
	 * Follow the transition from the given character to the next state
	 * @param {State} state
	 * @param {Token} input character or other concrete token type to transition
	 * @returns {?State} the next state, if any
	 */

	var takeT = function takeT(state, input) {
	  // IMPLEMENTATION 1: Object key lookup (faster)
	  var nextState = state.j[input];

	  if (nextState) {
	    return nextState;
	  } // IMPLEMENTATION 2: List lookup (slower)
	  // Loop through all the state transitions and see if there's a match
	  // for (let i = 0; i < state.j.length; i++) {
	  //	const val = state.j[i][0];
	  //	const nextState = state.j[i][1];
	  // 	if (input === val) { return nextState; }
	  // }


	  for (var i = 0; i < state.jr.length; i++) {
	    var regex = state.jr[i][0];
	    var _nextState = state.jr[i][1];

	    if (regex.test(input)) {
	      return _nextState;
	    }
	  } // Nowhere left to jump! Return default, if any


	  return state.jd;
	};
	/**
	 * Similar to makeT, but takes a list of characters that all transition to the
	 * same nextState startState
	 * @param {State} startState
	 * @param {Array} chars
	 * @param {State} nextState
	 */

	var makeMultiT = function makeMultiT(startState, chars, nextState) {
	  for (var i = 0; i < chars.length; i++) {
	    makeT(startState, chars[i], nextState);
	  }
	};
	/**
	 * Set up a list of multiple transitions at once. transitions is a list of
	 * tuples, where the first element is the transitions character and the second
	 * is the state to transition to
	 * @param {State} startState
	 * @param {Array} transitions
	 */

	var makeBatchT = function makeBatchT(startState, transitions) {
	  for (var i = 0; i < transitions.length; i++) {
	    var input = transitions[i][0];
	    var nextState = transitions[i][1];
	    makeT(startState, input, nextState);
	  }
	};
	/**
	 * For state machines that transition on characters only; given a non-empty
	 * target string, generates states (if required) for each consecutive substring
	 * of characters starting from the beginning of the string. The final state will
	 * have a special value, as specified in options. All other "in between"
	 * substrings will have a default end state.
	 *
	 * This turns the state machine into a Trie-like data structure (rather than a
	 * intelligently-designed DFA).
	 * @param {State} state
	 * @param {string} str
	 * @param {Token} endStateFactory
	 * @param {Token} defaultStateFactory
	 */

	var makeChainT = function makeChainT(state, str, endState, defaultStateFactory) {
	  var i = 0,
	      len = str.length,
	      nextState; // Find the next state without a jump to the next character

	  while (i < len && (nextState = state.j[str[i]])) {
	    state = nextState;
	    i++;
	  }

	  if (i >= len) {
	    return [];
	  } // no new tokens were added


	  while (i < len - 1) {
	    nextState = defaultStateFactory();
	    makeT(state, str[i], nextState);
	    state = nextState;
	    i++;
	  }

	  makeT(state, str[len - 1], endState);
	};

	/******************************************************************************
		Text Tokens
		Tokens composed of strings
	******************************************************************************/
	// A valid web domain token
	var DOMAIN = 'DOMAIN';
	var LOCALHOST = 'LOCALHOST'; // special case of domain
	// Valid top-level domain (see tlds.js)

	var TLD = 'TLD'; // Any sequence of digits 0-9

	var NUM = 'NUM'; // A web URL protocol. Supported types include
	// - `http:`
	// - `https:`
	// - `ftp:`
	// - `ftps:`
	// - user-defined custom protocols

	var PROTOCOL = 'PROTOCOL'; // Start of the email URI protocol

	var MAILTO = 'MAILTO'; // mailto:
	// Any number of consecutive whitespace characters that are not newline

	var WS = 'WS'; // New line (unix style)

	var NL = 'NL'; // \n
	// Opening/closing bracket classes

	var OPENBRACE = 'OPENBRACE'; // {

	var OPENBRACKET = 'OPENBRACKET'; // [

	var OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <

	var OPENPAREN = 'OPENPAREN'; // (

	var CLOSEBRACE = 'CLOSEBRACE'; // }

	var CLOSEBRACKET = 'CLOSEBRACKET'; // ]

	var CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >

	var CLOSEPAREN = 'CLOSEPAREN'; // )
	// Various symbols

	var AMPERSAND = 'AMPERSAND'; // &

	var APOSTROPHE = 'APOSTROPHE'; // '

	var ASTERISK = 'ASTERISK'; // *

	var AT = 'AT'; // @

	var BACKSLASH = 'BACKSLASH'; // \

	var BACKTICK = 'BACKTICK'; // `

	var CARET = 'CARET'; // ^

	var COLON = 'COLON'; // :

	var COMMA = 'COMMA'; // ,

	var DOLLAR = 'DOLLAR'; // $

	var DOT = 'DOT'; // .

	var EQUALS = 'EQUALS'; // =

	var EXCLAMATION = 'EXCLAMATION'; // !

	var HYPHEN = 'HYPHEN'; // -

	var PERCENT = 'PERCENT'; // %

	var PIPE = 'PIPE'; // |

	var PLUS = 'PLUS'; // +

	var POUND = 'POUND'; // #

	var QUERY = 'QUERY'; // ?

	var QUOTE = 'QUOTE'; // "

	var SEMI = 'SEMI'; // ;

	var SLASH = 'SLASH'; // /

	var TILDE = 'TILDE'; // ~

	var UNDERSCORE = 'UNDERSCORE'; // _
	// Default token - anything that is not one of the above

	var SYM = 'SYM';

	var text$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DOMAIN: DOMAIN,
		LOCALHOST: LOCALHOST,
		TLD: TLD,
		NUM: NUM,
		PROTOCOL: PROTOCOL,
		MAILTO: MAILTO,
		WS: WS,
		NL: NL,
		OPENBRACE: OPENBRACE,
		OPENBRACKET: OPENBRACKET,
		OPENANGLEBRACKET: OPENANGLEBRACKET,
		OPENPAREN: OPENPAREN,
		CLOSEBRACE: CLOSEBRACE,
		CLOSEBRACKET: CLOSEBRACKET,
		CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,
		CLOSEPAREN: CLOSEPAREN,
		AMPERSAND: AMPERSAND,
		APOSTROPHE: APOSTROPHE,
		ASTERISK: ASTERISK,
		AT: AT,
		BACKSLASH: BACKSLASH,
		BACKTICK: BACKTICK,
		CARET: CARET,
		COLON: COLON,
		COMMA: COMMA,
		DOLLAR: DOLLAR,
		DOT: DOT,
		EQUALS: EQUALS,
		EXCLAMATION: EXCLAMATION,
		HYPHEN: HYPHEN,
		PERCENT: PERCENT,
		PIPE: PIPE,
		PLUS: PLUS,
		POUND: POUND,
		QUERY: QUERY,
		QUOTE: QUOTE,
		SEMI: SEMI,
		SLASH: SLASH,
		TILDE: TILDE,
		UNDERSCORE: UNDERSCORE,
		SYM: SYM
	});

	// NOTE: punycode versions of IDNs are not included here because these will not
	// be as commonly used without the http prefix anyway and linkify will already
	// force-encode those.
	// To be updated with the values in this list
	// http://data.iana.org/TLD/tlds-alpha-by-domain.txt
	// Version 2021022800, Last Updated Sun Feb 28 07:07:01 2021 UTC
	var tlds = 'aaa \
aarp \
abarth \
abb \
abbott \
abbvie \
abc \
able \
abogado \
abudhabi \
ac \
academy \
accenture \
accountant \
accountants \
aco \
actor \
ad \
adac \
ads \
adult \
ae \
aeg \
aero \
aetna \
af \
afamilycompany \
afl \
africa \
ag \
agakhan \
agency \
ai \
aig \
airbus \
airforce \
airtel \
akdn \
al \
alfaromeo \
alibaba \
alipay \
allfinanz \
allstate \
ally \
alsace \
alstom \
am \
amazon \
americanexpress \
americanfamily \
amex \
amfam \
amica \
amsterdam \
analytics \
android \
anquan \
anz \
ao \
aol \
apartments \
app \
apple \
aq \
aquarelle \
ar \
arab \
aramco \
archi \
army \
arpa \
art \
arte \
as \
asda \
asia \
associates \
at \
athleta \
attorney \
au \
auction \
audi \
audible \
audio \
auspost \
author \
auto \
autos \
avianca \
aw \
aws \
ax \
axa \
az \
azure \
ba \
baby \
baidu \
banamex \
bananarepublic \
band \
bank \
bar \
barcelona \
barclaycard \
barclays \
barefoot \
bargains \
baseball \
basketball \
bauhaus \
bayern \
bb \
bbc \
bbt \
bbva \
bcg \
bcn \
bd \
be \
beats \
beauty \
beer \
bentley \
berlin \
best \
bestbuy \
bet \
bf \
bg \
bh \
bharti \
bi \
bible \
bid \
bike \
bing \
bingo \
bio \
biz \
bj \
black \
blackfriday \
blockbuster \
blog \
bloomberg \
blue \
bm \
bms \
bmw \
bn \
bnpparibas \
bo \
boats \
boehringer \
bofa \
bom \
bond \
boo \
book \
booking \
bosch \
bostik \
boston \
bot \
boutique \
box \
br \
bradesco \
bridgestone \
broadway \
broker \
brother \
brussels \
bs \
bt \
budapest \
bugatti \
build \
builders \
business \
buy \
buzz \
bv \
bw \
by \
bz \
bzh \
ca \
cab \
cafe \
cal \
call \
calvinklein \
cam \
camera \
camp \
cancerresearch \
canon \
capetown \
capital \
capitalone \
car \
caravan \
cards \
care \
career \
careers \
cars \
casa \
case \
cash \
casino \
cat \
catering \
catholic \
cba \
cbn \
cbre \
cbs \
cc \
cd \
center \
ceo \
cern \
cf \
cfa \
cfd \
cg \
ch \
chanel \
channel \
charity \
chase \
chat \
cheap \
chintai \
christmas \
chrome \
church \
ci \
cipriani \
circle \
cisco \
citadel \
citi \
citic \
city \
cityeats \
ck \
cl \
claims \
cleaning \
click \
clinic \
clinique \
clothing \
cloud \
club \
clubmed \
cm \
cn \
co \
coach \
codes \
coffee \
college \
cologne \
com \
comcast \
commbank \
community \
company \
compare \
computer \
comsec \
condos \
construction \
consulting \
contact \
contractors \
cooking \
cookingchannel \
cool \
coop \
corsica \
country \
coupon \
coupons \
courses \
cpa \
cr \
credit \
creditcard \
creditunion \
cricket \
crown \
crs \
cruise \
cruises \
csc \
cu \
cuisinella \
cv \
cw \
cx \
cy \
cymru \
cyou \
cz \
dabur \
dad \
dance \
data \
date \
dating \
datsun \
day \
dclk \
dds \
de \
deal \
dealer \
deals \
degree \
delivery \
dell \
deloitte \
delta \
democrat \
dental \
dentist \
desi \
design \
dev \
dhl \
diamonds \
diet \
digital \
direct \
directory \
discount \
discover \
dish \
diy \
dj \
dk \
dm \
dnp \
do \
docs \
doctor \
dog \
domains \
dot \
download \
drive \
dtv \
dubai \
duck \
dunlop \
dupont \
durban \
dvag \
dvr \
dz \
earth \
eat \
ec \
eco \
edeka \
edu \
education \
ee \
eg \
email \
emerck \
energy \
engineer \
engineering \
enterprises \
epson \
equipment \
er \
ericsson \
erni \
es \
esq \
estate \
et \
etisalat \
eu \
eurovision \
eus \
events \
exchange \
expert \
exposed \
express \
extraspace \
fage \
fail \
fairwinds \
faith \
family \
fan \
fans \
farm \
farmers \
fashion \
fast \
fedex \
feedback \
ferrari \
ferrero \
fi \
fiat \
fidelity \
fido \
film \
final \
finance \
financial \
fire \
firestone \
firmdale \
fish \
fishing \
fit \
fitness \
fj \
fk \
flickr \
flights \
flir \
florist \
flowers \
fly \
fm \
fo \
foo \
food \
foodnetwork \
football \
ford \
forex \
forsale \
forum \
foundation \
fox \
fr \
free \
fresenius \
frl \
frogans \
frontdoor \
frontier \
ftr \
fujitsu \
fujixerox \
fun \
fund \
furniture \
futbol \
fyi \
ga \
gal \
gallery \
gallo \
gallup \
game \
games \
gap \
garden \
gay \
gb \
gbiz \
gd \
gdn \
ge \
gea \
gent \
genting \
george \
gf \
gg \
ggee \
gh \
gi \
gift \
gifts \
gives \
giving \
gl \
glade \
glass \
gle \
global \
globo \
gm \
gmail \
gmbh \
gmo \
gmx \
gn \
godaddy \
gold \
goldpoint \
golf \
goo \
goodyear \
goog \
google \
gop \
got \
gov \
gp \
gq \
gr \
grainger \
graphics \
gratis \
green \
gripe \
grocery \
group \
gs \
gt \
gu \
guardian \
gucci \
guge \
guide \
guitars \
guru \
gw \
gy \
hair \
hamburg \
hangout \
haus \
hbo \
hdfc \
hdfcbank \
health \
healthcare \
help \
helsinki \
here \
hermes \
hgtv \
hiphop \
hisamitsu \
hitachi \
hiv \
hk \
hkt \
hm \
hn \
hockey \
holdings \
holiday \
homedepot \
homegoods \
homes \
homesense \
honda \
horse \
hospital \
host \
hosting \
hot \
hoteles \
hotels \
hotmail \
house \
how \
hr \
hsbc \
ht \
hu \
hughes \
hyatt \
hyundai \
ibm \
icbc \
ice \
icu \
id \
ie \
ieee \
ifm \
ikano \
il \
im \
imamat \
imdb \
immo \
immobilien \
in \
inc \
industries \
infiniti \
info \
ing \
ink \
institute \
insurance \
insure \
int \
international \
intuit \
investments \
io \
ipiranga \
iq \
ir \
irish \
is \
ismaili \
ist \
istanbul \
it \
itau \
itv \
iveco \
jaguar \
java \
jcb \
je \
jeep \
jetzt \
jewelry \
jio \
jll \
jm \
jmp \
jnj \
jo \
jobs \
joburg \
jot \
joy \
jp \
jpmorgan \
jprs \
juegos \
juniper \
kaufen \
kddi \
ke \
kerryhotels \
kerrylogistics \
kerryproperties \
kfh \
kg \
kh \
ki \
kia \
kim \
kinder \
kindle \
kitchen \
kiwi \
km \
kn \
koeln \
komatsu \
kosher \
kp \
kpmg \
kpn \
kr \
krd \
kred \
kuokgroup \
kw \
ky \
kyoto \
kz \
la \
lacaixa \
lamborghini \
lamer \
lancaster \
lancia \
land \
landrover \
lanxess \
lasalle \
lat \
latino \
latrobe \
law \
lawyer \
lb \
lc \
lds \
lease \
leclerc \
lefrak \
legal \
lego \
lexus \
lgbt \
li \
lidl \
life \
lifeinsurance \
lifestyle \
lighting \
like \
lilly \
limited \
limo \
lincoln \
linde \
link \
lipsy \
live \
living \
lixil \
lk \
llc \
llp \
loan \
loans \
locker \
locus \
loft \
lol \
london \
lotte \
lotto \
love \
lpl \
lplfinancial \
lr \
ls \
lt \
ltd \
ltda \
lu \
lundbeck \
luxe \
luxury \
lv \
ly \
ma \
macys \
madrid \
maif \
maison \
makeup \
man \
management \
mango \
map \
market \
marketing \
markets \
marriott \
marshalls \
maserati \
mattel \
mba \
mc \
mckinsey \
md \
me \
med \
media \
meet \
melbourne \
meme \
memorial \
men \
menu \
merckmsd \
mg \
mh \
miami \
microsoft \
mil \
mini \
mint \
mit \
mitsubishi \
mk \
ml \
mlb \
mls \
mm \
mma \
mn \
mo \
mobi \
mobile \
moda \
moe \
moi \
mom \
monash \
money \
monster \
mormon \
mortgage \
moscow \
moto \
motorcycles \
mov \
movie \
mp \
mq \
mr \
ms \
msd \
mt \
mtn \
mtr \
mu \
museum \
mutual \
mv \
mw \
mx \
my \
mz \
na \
nab \
nagoya \
name \
nationwide \
natura \
navy \
nba \
nc \
ne \
nec \
net \
netbank \
netflix \
network \
neustar \
new \
news \
next \
nextdirect \
nexus \
nf \
nfl \
ng \
ngo \
nhk \
ni \
nico \
nike \
nikon \
ninja \
nissan \
nissay \
nl \
no \
nokia \
northwesternmutual \
norton \
now \
nowruz \
nowtv \
np \
nr \
nra \
nrw \
ntt \
nu \
nyc \
nz \
obi \
observer \
off \
office \
okinawa \
olayan \
olayangroup \
oldnavy \
ollo \
om \
omega \
one \
ong \
onl \
online \
onyourside \
ooo \
open \
oracle \
orange \
org \
organic \
origins \
osaka \
otsuka \
ott \
ovh \
pa \
page \
panasonic \
paris \
pars \
partners \
parts \
party \
passagens \
pay \
pccw \
pe \
pet \
pf \
pfizer \
pg \
ph \
pharmacy \
phd \
philips \
phone \
photo \
photography \
photos \
physio \
pics \
pictet \
pictures \
pid \
pin \
ping \
pink \
pioneer \
pizza \
pk \
pl \
place \
play \
playstation \
plumbing \
plus \
pm \
pn \
pnc \
pohl \
poker \
politie \
porn \
post \
pr \
pramerica \
praxi \
press \
prime \
pro \
prod \
productions \
prof \
progressive \
promo \
properties \
property \
protection \
pru \
prudential \
ps \
pt \
pub \
pw \
pwc \
py \
qa \
qpon \
quebec \
quest \
qvc \
racing \
radio \
raid \
re \
read \
realestate \
realtor \
realty \
recipes \
red \
redstone \
redumbrella \
rehab \
reise \
reisen \
reit \
reliance \
ren \
rent \
rentals \
repair \
report \
republican \
rest \
restaurant \
review \
reviews \
rexroth \
rich \
richardli \
ricoh \
ril \
rio \
rip \
rmit \
ro \
rocher \
rocks \
rodeo \
rogers \
room \
rs \
rsvp \
ru \
rugby \
ruhr \
run \
rw \
rwe \
ryukyu \
sa \
saarland \
safe \
safety \
sakura \
sale \
salon \
samsclub \
samsung \
sandvik \
sandvikcoromant \
sanofi \
sap \
sarl \
sas \
save \
saxo \
sb \
sbi \
sbs \
sc \
sca \
scb \
schaeffler \
schmidt \
scholarships \
school \
schule \
schwarz \
science \
scjohnson \
scot \
sd \
se \
search \
seat \
secure \
security \
seek \
select \
sener \
services \
ses \
seven \
sew \
sex \
sexy \
sfr \
sg \
sh \
shangrila \
sharp \
shaw \
shell \
shia \
shiksha \
shoes \
shop \
shopping \
shouji \
show \
showtime \
si \
silk \
sina \
singles \
site \
sj \
sk \
ski \
skin \
sky \
skype \
sl \
sling \
sm \
smart \
smile \
sn \
sncf \
so \
soccer \
social \
softbank \
software \
sohu \
solar \
solutions \
song \
sony \
soy \
spa \
space \
sport \
spot \
spreadbetting \
sr \
srl \
ss \
st \
stada \
staples \
star \
statebank \
statefarm \
stc \
stcgroup \
stockholm \
storage \
store \
stream \
studio \
study \
style \
su \
sucks \
supplies \
supply \
support \
surf \
surgery \
suzuki \
sv \
swatch \
swiftcover \
swiss \
sx \
sy \
sydney \
systems \
sz \
tab \
taipei \
talk \
taobao \
target \
tatamotors \
tatar \
tattoo \
tax \
taxi \
tc \
tci \
td \
tdk \
team \
tech \
technology \
tel \
temasek \
tennis \
teva \
tf \
tg \
th \
thd \
theater \
theatre \
tiaa \
tickets \
tienda \
tiffany \
tips \
tires \
tirol \
tj \
tjmaxx \
tjx \
tk \
tkmaxx \
tl \
tm \
tmall \
tn \
to \
today \
tokyo \
tools \
top \
toray \
toshiba \
total \
tours \
town \
toyota \
toys \
tr \
trade \
trading \
training \
travel \
travelchannel \
travelers \
travelersinsurance \
trust \
trv \
tt \
tube \
tui \
tunes \
tushu \
tv \
tvs \
tw \
tz \
ua \
ubank \
ubs \
ug \
uk \
unicom \
university \
uno \
uol \
ups \
us \
uy \
uz \
va \
vacations \
vana \
vanguard \
vc \
ve \
vegas \
ventures \
verisign \
versicherung \
vet \
vg \
vi \
viajes \
video \
vig \
viking \
villas \
vin \
vip \
virgin \
visa \
vision \
viva \
vivo \
vlaanderen \
vn \
vodka \
volkswagen \
volvo \
vote \
voting \
voto \
voyage \
vu \
vuelos \
wales \
walmart \
walter \
wang \
wanggou \
watch \
watches \
weather \
weatherchannel \
webcam \
weber \
website \
wed \
wedding \
weibo \
weir \
wf \
whoswho \
wien \
wiki \
williamhill \
win \
windows \
wine \
winners \
wme \
wolterskluwer \
woodside \
work \
works \
world \
wow \
ws \
wtc \
wtf \
xbox \
xerox \
xfinity \
xihuan \
xin \
xxx \
xyz \
yachts \
yahoo \
yamaxun \
yandex \
ye \
yodobashi \
yoga \
yokohama \
you \
youtube \
yt \
yun \
za \
zappos \
zara \
zero \
zip \
zm \
zone \
zuerich \
zw \
vermgensberater-ctb \
vermgensberatung-pwb \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
 \
'.split(' ');

	/**
		The scanner provides an interface that takes a string of text as input, and
		outputs an array of tokens instances that can be used for easy URL parsing.

		@module linkify
		@submodule scanner
		@main scanner
	*/

	var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/; // Any Unicode character with letter data type

	var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/; // Any Unicode emoji character

	var EMOJI_VARIATION = /\uFE0F/; // Variation selector, follows heart and others

	var DIGIT = /\d/;
	var SPACE = /\s/;
	/**
	 * Initialize the scanner character-based state machine for the given start state
	 * @return {State} scanner starting state
	 */

	function init$2() {
	  var customProtocols = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  // Frequently used states
	  var S_START = makeState();
	  var S_NUM = makeAcceptingState(NUM);
	  var S_DOMAIN = makeAcceptingState(DOMAIN);
	  var S_DOMAIN_HYPHEN = makeState(); // domain followed by 1 or more hyphen characters

	  var S_WS = makeAcceptingState(WS);
	  var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]]; // Create a state which emits a domain token

	  var makeDomainState = function makeDomainState() {
	    var state = makeAcceptingState(DOMAIN);
	    state.j = {
	      '-': S_DOMAIN_HYPHEN
	    };
	    state.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
	    return state;
	  }; // Create a state which does not emit a domain state but the usual alphanumeric
	  // transitions are domains


	  var makeNearDomainState = function makeNearDomainState(token) {
	    var state = makeDomainState();
	    state.t = token;
	    return state;
	  }; // States for special URL symbols that accept immediately after start


	  makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ['{', makeAcceptingState(OPENBRACE)], ['[', makeAcceptingState(OPENBRACKET)], ['<', makeAcceptingState(OPENANGLEBRACKET)], ['(', makeAcceptingState(OPENPAREN)], ['}', makeAcceptingState(CLOSEBRACE)], [']', makeAcceptingState(CLOSEBRACKET)], ['>', makeAcceptingState(CLOSEANGLEBRACKET)], [')', makeAcceptingState(CLOSEPAREN)], ['&', makeAcceptingState(AMPERSAND)], ['*', makeAcceptingState(ASTERISK)], ['@', makeAcceptingState(AT)], ['`', makeAcceptingState(BACKTICK)], ['^', makeAcceptingState(CARET)], [':', makeAcceptingState(COLON)], [',', makeAcceptingState(COMMA)], ['$', makeAcceptingState(DOLLAR)], ['.', makeAcceptingState(DOT)], ['=', makeAcceptingState(EQUALS)], ['!', makeAcceptingState(EXCLAMATION)], ['-', makeAcceptingState(HYPHEN)], ['%', makeAcceptingState(PERCENT)], ['|', makeAcceptingState(PIPE)], ['+', makeAcceptingState(PLUS)], ['#', makeAcceptingState(POUND)], ['?', makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ['/', makeAcceptingState(SLASH)], [';', makeAcceptingState(SEMI)], ['~', makeAcceptingState(TILDE)], ['_', makeAcceptingState(UNDERSCORE)], ['\\', makeAcceptingState(BACKSLASH)]]); // Whitespace jumps
	  // Tokens of only non-newline whitespace are arbitrarily long

	  makeT(S_START, '\n', makeAcceptingState(NL));
	  makeRegexT(S_START, SPACE, S_WS); // If any whitespace except newline, more whitespace!

	  makeT(S_WS, '\n', makeState()); // non-accepting state

	  makeRegexT(S_WS, SPACE, S_WS); // Generates states for top-level domains
	  // Note that this is most accurate when tlds are in alphabetical order

	  for (var i = 0; i < tlds.length; i++) {
	    makeChainT(S_START, tlds[i], makeNearDomainState(TLD), makeDomainState);
	  } // Collect the states generated by different protocls


	  var S_PROTOCOL_FILE = makeDomainState();
	  var S_PROTOCOL_FTP = makeDomainState();
	  var S_PROTOCOL_HTTP = makeDomainState();
	  var S_MAILTO = makeDomainState();
	  makeChainT(S_START, 'file', S_PROTOCOL_FILE, makeDomainState);
	  makeChainT(S_START, 'ftp', S_PROTOCOL_FTP, makeDomainState);
	  makeChainT(S_START, 'http', S_PROTOCOL_HTTP, makeDomainState);
	  makeChainT(S_START, 'mailto', S_MAILTO, makeDomainState); // Protocol states

	  var S_PROTOCOL_SECURE = makeDomainState();
	  var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL); // Full protocol ends with COLON

	  var S_FULL_MAILTO = makeAcceptingState(MAILTO); // Mailto ends with COLON
	  // Secure protocols (end with 's')

	  makeT(S_PROTOCOL_FTP, 's', S_PROTOCOL_SECURE);
	  makeT(S_PROTOCOL_FTP, ':', S_FULL_PROTOCOL);
	  makeT(S_PROTOCOL_HTTP, 's', S_PROTOCOL_SECURE);
	  makeT(S_PROTOCOL_HTTP, ':', S_FULL_PROTOCOL); // Become protocol tokens after a COLON

	  makeT(S_PROTOCOL_FILE, ':', S_FULL_PROTOCOL);
	  makeT(S_PROTOCOL_SECURE, ':', S_FULL_PROTOCOL);
	  makeT(S_MAILTO, ':', S_FULL_MAILTO); // Register custom protocols

	  var S_CUSTOM_PROTOCOL = makeDomainState();

	  for (var _i = 0; _i < customProtocols.length; _i++) {
	    makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
	  }

	  makeT(S_CUSTOM_PROTOCOL, ':', S_FULL_PROTOCOL); // Localhost

	  makeChainT(S_START, 'localhost', makeNearDomainState(LOCALHOST), makeDomainState); // Everything else
	  // DOMAINs make more DOMAINs
	  // Number and character transitions

	  makeRegexT(S_START, DIGIT, S_NUM);
	  makeRegexT(S_START, LETTER, S_DOMAIN);
	  makeRegexT(S_START, EMOJI, S_DOMAIN);
	  makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
	  makeRegexT(S_NUM, DIGIT, S_NUM);
	  makeRegexT(S_NUM, LETTER, S_DOMAIN); // number becomes DOMAIN

	  makeRegexT(S_NUM, EMOJI, S_DOMAIN); // number becomes DOMAIN

	  makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN); // number becomes DOMAIN

	  makeT(S_NUM, '-', S_DOMAIN_HYPHEN); // Default domain transitions

	  makeT(S_DOMAIN, '-', S_DOMAIN_HYPHEN);
	  makeT(S_DOMAIN_HYPHEN, '-', S_DOMAIN_HYPHEN);
	  makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
	  makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
	  makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
	  makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
	  makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
	  makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
	  makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
	  makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN); // Set default transition for start state (some symbol)

	  S_START.jd = makeAcceptingState(SYM);
	  return S_START;
	}
	/**
		Given a string, returns an array of TOKEN instances representing the
		composition of that string.

		@method run
		@param {State} start scanner starting state
		@param {string} str input string to scan
		@return {{t: string, v: string, s: number, l: number}[]} list of tokens, each with a type and value
	*/

	function run$1(start, str) {
	  // State machine is not case sensitive, so input is tokenized in lowercased
	  // form (still returns the regular case though) Uses selective `toLowerCase`
	  // is used because lowercasing the entire string causes the length and
	  // character position to vary in some non-English strings with V8-based
	  // runtimes.
	  var iterable = stringToArray(str.replace(/[A-Z]/g, function (c) {
	    return c.toLowerCase();
	  }));
	  var charCount = iterable.length; // <= len if there are emojis, etc

	  var tokens = []; // return value
	  // cursor through the string itself, accounting for characters that have
	  // width with length 2 such as emojis

	  var cursor = 0; // Cursor through the array-representation of the string

	  var charCursor = 0; // Tokenize the string

	  while (charCursor < charCount) {
	    var state = start;
	    var nextState = null;
	    var tokenLength = 0;
	    var latestAccepting = null;
	    var sinceAccepts = -1;
	    var charsSinceAccepts = -1;

	    while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
	      state = nextState; // Keep track of the latest accepting state

	      if (state.accepts()) {
	        sinceAccepts = 0;
	        charsSinceAccepts = 0;
	        latestAccepting = state;
	      } else if (sinceAccepts >= 0) {
	        sinceAccepts += iterable[charCursor].length;
	        charsSinceAccepts++;
	      }

	      tokenLength += iterable[charCursor].length;
	      cursor += iterable[charCursor].length;
	      charCursor++;
	    } // Roll back to the latest accepting state


	    cursor -= sinceAccepts;
	    charCursor -= charsSinceAccepts;
	    tokenLength -= sinceAccepts; // No more jumps, just make a new token from the last accepting one
	    // TODO: If possible, don't output v, instead output range where values ocur

	    tokens.push({
	      t: latestAccepting.t,
	      // token type/name
	      v: str.substr(cursor - tokenLength, tokenLength),
	      // string value
	      s: cursor - tokenLength,
	      // start index
	      e: cursor // end index (excluding)

	    });
	  }

	  return tokens;
	}
	/**
	 * Convert a String to an Array of characters, taking into account that some
	 * characters like emojis take up two string indexes.
	 *
	 * Adapted from core-js (MIT license)
	 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
	 *
	 * @function stringToArray
	 * @param {string} str
	 * @returns {string[]}
	 */

	function stringToArray(str) {
	  var result = [];
	  var len = str.length;
	  var index = 0;

	  while (index < len) {
	    var first = str.charCodeAt(index);
	    var second = void 0;
	    var char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character
	    : str.slice(index, index + 2); // two-index characters

	    result.push(char);
	    index += char.length;
	  }

	  return result;
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	/**
	 * @property {string} defaultProtocol
	 * @property {{[string]: (event) => void}]} [events]
	 */
	var defaults$1 = {
	  defaultProtocol: 'http',
	  events: null,
	  format: noop,
	  formatHref: noop,
	  nl2br: false,
	  tagName: 'a',
	  target: null,
	  rel: null,
	  validate: true,
	  truncate: 0,
	  className: null,
	  attributes: null,
	  ignoreTags: []
	};
	/**
	 * @class Options
	 * @param {Object} [opts] Set option properties besides the defaults
	 */

	function Options(opts) {
	  opts = opts || {};
	  this.defaultProtocol = 'defaultProtocol' in opts ? opts.defaultProtocol : defaults$1.defaultProtocol;
	  this.events = 'events' in opts ? opts.events : defaults$1.events;
	  this.format = 'format' in opts ? opts.format : defaults$1.format;
	  this.formatHref = 'formatHref' in opts ? opts.formatHref : defaults$1.formatHref;
	  this.nl2br = 'nl2br' in opts ? opts.nl2br : defaults$1.nl2br;
	  this.tagName = 'tagName' in opts ? opts.tagName : defaults$1.tagName;
	  this.target = 'target' in opts ? opts.target : defaults$1.target;
	  this.rel = 'rel' in opts ? opts.rel : defaults$1.rel;
	  this.validate = 'validate' in opts ? opts.validate : defaults$1.validate;
	  this.truncate = 'truncate' in opts ? opts.truncate : defaults$1.truncate;
	  this.className = 'className' in opts ? opts.className : defaults$1.className;
	  this.attributes = opts.attributes || defaults$1.attributes;
	  this.ignoreTags = []; // Make all tags names upper case

	  var ignoredTags = 'ignoreTags' in opts ? opts.ignoreTags : defaults$1.ignoreTags;

	  for (var i = 0; i < ignoredTags.length; i++) {
	    this.ignoreTags.push(ignoredTags[i].toUpperCase());
	  }
	}
	Options.prototype = {
	  /**
	   * Given the token, return all options for how it should be displayed
	   */
	  resolve: function resolve(token) {
	    var href = token.toHref(this.defaultProtocol);
	    return {
	      formatted: this.get('format', token.toString(), token),
	      formattedHref: this.get('formatHref', href, token),
	      tagName: this.get('tagName', href, token),
	      className: this.get('className', href, token),
	      target: this.get('target', href, token),
	      rel: this.get('rel', href, token),
	      events: this.getObject('events', href, token),
	      attributes: this.getObject('attributes', href, token),
	      truncate: this.get('truncate', href, token)
	    };
	  },

	  /**
	   * Returns true or false based on whether a token should be displayed as a
	   * link based on the user options. By default,
	   */
	  check: function check(token) {
	    return this.get('validate', token.toString(), token);
	  },
	  // Private methods

	  /**
	   * Resolve an option's value based on the value of the option and the given
	   * params.
	   * @param {string} key Name of option to use
	   * @param operator will be passed to the target option if it's method
	   * @param {MultiToken} token The token from linkify.tokenize
	   */
	  get: function get(key, operator, token) {
	    var option = this[key];

	    if (!option) {
	      return option;
	    }

	    var optionValue;

	    switch (_typeof(option)) {
	      case 'function':
	        return option(operator, token.t);

	      case 'object':
	        optionValue = token.t in option ? option[token.t] : defaults$1[key];
	        return typeof optionValue === 'function' ? optionValue(operator, token.t) : optionValue;
	    }

	    return option;
	  },
	  getObject: function getObject(key, operator, token) {
	    var option = this[key];
	    return typeof option === 'function' ? option(operator, token.t) : option;
	  }
	};

	function noop(val) {
	  return val;
	}

	/******************************************************************************
		Multi-Tokens
		Tokens composed of arrays of TextTokens
	******************************************************************************/

	function inherits(parent, child) {
	  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var extended = Object.create(parent.prototype);

	  for (var p in props) {
	    extended[p] = props[p];
	  }

	  extended.constructor = child;
	  child.prototype = extended;
	  return child;
	}
	/**
		Abstract class used for manufacturing tokens of text tokens. That is rather
		than the value for a token being a small string of text, it's value an array
		of text tokens.

		Used for grouping together URLs, emails, hashtags, and other potential
		creations.

		@class MultiToken
		@param {string} value
		@param {{t: string, v: string, s: number, e: number}[]} tokens
		@abstract
	*/


	function MultiToken() {}
	MultiToken.prototype = {
	  /**
	  	String representing the type for this token
	  	@property t
	  	@default 'token'
	  */
	  t: 'token',

	  /**
	  	Is this multitoken a link?
	  	@property isLink
	  	@default false
	  */
	  isLink: false,

	  /**
	  	Return the string this token represents.
	  	@method toString
	  	@return {string}
	  */
	  toString: function toString() {
	    return this.v;
	  },

	  /**
	  	What should the value for this token be in the `href` HTML attribute?
	  	Returns the `.toString` value by default.
	  		@method toHref
	  	@return {string}
	  */
	  toHref: function toHref() {
	    return this.toString();
	  },

	  /**
	   * The start index of this token in the original input string
	   * @returns {number}
	   */
	  startIndex: function startIndex() {
	    return this.tk[0].s;
	  },

	  /**
	   * The end index of this token in the original input string (up to this
	   * index but not including it)
	   * @returns {number}
	   */
	  endIndex: function endIndex() {
	    return this.tk[this.tk.length - 1].e;
	  },

	  /**
	  	Returns a hash of relevant values for this token, which includes keys
	  	* type - Kind of token ('url', 'email', etc.)
	  	* value - Original text
	  	* href - The value that should be added to the anchor tag's href
	  		attribute
	  		@method toObject
	  	@param {string} [protocol] `'http'` by default
	  */
	  toObject: function toObject() {
	    var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults$1.defaultProtocol;
	    return {
	      type: this.t,
	      value: this.v,
	      isLink: this.isLink,
	      href: this.toHref(protocol),
	      start: this.startIndex(),
	      end: this.endIndex()
	    };
	  }
	}; // Base token
	/**
	 * Create a new token that can be emitted by the parser state machine
	 * @param {string} type readable type of the token
	 * @param {object} props properties to assign or override, including isLink = true or false
	 * @returns {(value: string, tokens: {t: string, v: string, s: number, e: number}) => MultiToken} new token class
	 */

	function createTokenClass(type, props) {
	  function Token(value, tokens) {
	    this.t = type;
	    this.v = value;
	    this.tk = tokens;
	  }

	  inherits(MultiToken, Token, props);
	  return Token;
	}
	/**
		Represents an arbitrarily mailto email address with the prefix included
		@class MailtoEmail
		@extends MultiToken
	*/

	var MailtoEmail = createTokenClass('email', {
	  isLink: true
	});
	/**
		Represents a list of tokens making up a valid email address
		@class Email
		@extends MultiToken
	*/

	var Email = createTokenClass('email', {
	  isLink: true,
	  toHref: function toHref() {
	    return 'mailto:' + this.toString();
	  }
	});
	/**
		Represents some plain text
		@class Text
		@extends MultiToken
	*/

	var Text = createTokenClass('text');
	/**
		Multi-linebreak token - represents a line break
		@class Nl
		@extends MultiToken
	*/

	var Nl = createTokenClass('nl');
	/**
		Represents a list of text tokens making up a valid URL
		@class Url
		@extends MultiToken
	*/

	var Url = createTokenClass('url', {
	  isLink: true,

	  /**
	  	Lowercases relevant parts of the domain and adds the protocol if
	  	required. Note that this will not escape unsafe HTML characters in the
	  	URL.
	  		@method href
	  	@param {string} protocol
	  	@return {string}
	  */
	  toHref: function toHref() {
	    var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults$1.defaultProtocol;
	    var tokens = this.tk;
	    var hasProtocol = false;
	    var hasSlashSlash = false;
	    var result = [];
	    var i = 0; // Make the first part of the domain lowercase
	    // Lowercase protocol

	    while (tokens[i].t === PROTOCOL) {
	      hasProtocol = true;
	      result.push(tokens[i].v);
	      i++;
	    } // Skip slash-slash


	    while (tokens[i].t === SLASH) {
	      hasSlashSlash = true;
	      result.push(tokens[i].v);
	      i++;
	    } // Continue pushing characters


	    for (; i < tokens.length; i++) {
	      result.push(tokens[i].v);
	    }

	    result = result.join('');

	    if (!(hasProtocol || hasSlashSlash)) {
	      result = "".concat(protocol, "://").concat(result);
	    }

	    return result;
	  },
	  hasProtocol: function hasProtocol() {
	    return this.tk[0].t === PROTOCOL;
	  }
	});

	var multi = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MultiToken: MultiToken,
		Base: MultiToken,
		createTokenClass: createTokenClass,
		MailtoEmail: MailtoEmail,
		Email: Email,
		Text: Text,
		Nl: Nl,
		Url: Url
	});

	/**
		Not exactly parser, more like the second-stage scanner (although we can
		theoretically hotswap the code here with a real parser in the future... but
		for a little URL-finding utility abstract syntax trees may be a little
		overkill).

		URL format: http://en.wikipedia.org/wiki/URI_scheme
		Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
		reference)

		@module linkify
		@submodule parser
		@main run
	*/
	/**
	 * Generate the parser multi token-based state machine
	 * @returns {State} the starting state
	 */

	function init$1() {
	  // The universal starting state.
	  var S_START = makeState(); // Intermediate states for URLs. Note that domains that begin with a protocol
	  // are treated slighly differently from those that don't.

	  var S_PROTOCOL = makeState(); // e.g., 'http:'

	  var S_MAILTO = makeState(); // 'mailto:'

	  var S_PROTOCOL_SLASH = makeState(); // e.g., 'http:/''

	  var S_PROTOCOL_SLASH_SLASH = makeState(); // e.g.,'http://'

	  var S_DOMAIN = makeState(); // parsed string ends with a potential domain name (A)

	  var S_DOMAIN_DOT = makeState(); // (A) domain followed by DOT

	  var S_TLD = makeAcceptingState(Url); // (A) Simplest possible URL with no query string

	  var S_TLD_COLON = makeState(); // (A) URL followed by colon (potential port number here)

	  var S_TLD_PORT = makeAcceptingState(Url); // TLD followed by a port number

	  var S_URL = makeAcceptingState(Url); // Long URL with optional port and maybe query string

	  var S_URL_NON_ACCEPTING = makeState(); // URL followed by some symbols (will not be part of the final URL)

	  var S_URL_OPENBRACE = makeState(); // URL followed by {

	  var S_URL_OPENBRACKET = makeState(); // URL followed by [

	  var S_URL_OPENANGLEBRACKET = makeState(); // URL followed by <

	  var S_URL_OPENPAREN = makeState(); // URL followed by (

	  var S_URL_OPENBRACE_Q = makeAcceptingState(Url); // URL followed by { and some symbols that the URL can end it

	  var S_URL_OPENBRACKET_Q = makeAcceptingState(Url); // URL followed by [ and some symbols that the URL can end it

	  var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url); // URL followed by < and some symbols that the URL can end it

	  var S_URL_OPENPAREN_Q = makeAcceptingState(Url); // URL followed by ( and some symbols that the URL can end it

	  var S_URL_OPENBRACE_SYMS = makeState(); // S_URL_OPENBRACE_Q followed by some symbols it cannot end it

	  var S_URL_OPENBRACKET_SYMS = makeState(); // S_URL_OPENBRACKET_Q followed by some symbols it cannot end it

	  var S_URL_OPENANGLEBRACKET_SYMS = makeState(); // S_URL_OPENANGLEBRACKET_Q followed by some symbols it cannot end it

	  var S_URL_OPENPAREN_SYMS = makeState(); // S_URL_OPENPAREN_Q followed by some symbols it cannot end it

	  var S_EMAIL_DOMAIN = makeState(); // parsed string starts with local email info + @ with a potential domain name (C)

	  var S_EMAIL_DOMAIN_DOT = makeState(); // (C) domain followed by DOT

	  var S_EMAIL = makeAcceptingState(Email); // (C) Possible email address (could have more tlds)

	  var S_EMAIL_COLON = makeState(); // (C) URL followed by colon (potential port number here)

	  var S_EMAIL_PORT = makeAcceptingState(Email); // (C) Email address with a port

	  var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail); // Email that begins with the mailto prefix (D)

	  var S_MAILTO_EMAIL_NON_ACCEPTING = makeState(); // (D) Followed by some non-query string chars

	  var S_LOCALPART = makeState(); // Local part of the email address

	  var S_LOCALPART_AT = makeState(); // Local part of the email address plus @

	  var S_LOCALPART_DOT = makeState(); // Local part of the email address plus '.' (localpart cannot end in .)

	  var S_NL = makeAcceptingState(Nl); // single new line
	  // Make path from start to protocol (with '//')

	  makeT(S_START, NL, S_NL);
	  makeT(S_START, PROTOCOL, S_PROTOCOL);
	  makeT(S_START, MAILTO, S_MAILTO);
	  makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
	  makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH); // The very first potential domain name

	  makeT(S_START, TLD, S_DOMAIN);
	  makeT(S_START, DOMAIN, S_DOMAIN);
	  makeT(S_START, LOCALHOST, S_TLD);
	  makeT(S_START, NUM, S_DOMAIN); // Force URL for protocol followed by anything sane

	  makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
	  makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
	  makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
	  makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL); // Account for dots and hyphens
	  // hyphens are usually parts of domain names

	  makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
	  makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT); // Hyphen can jump back to a domain name
	  // After the first domain and a dot, we can find either a URL or another domain

	  makeT(S_DOMAIN_DOT, TLD, S_TLD);
	  makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
	  makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
	  makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
	  makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
	  makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
	  makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
	  makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN); // S_TLD accepts! But the URL could be longer, try to find a match greedily
	  // The `run` function should be able to "rollback" to the accepting state

	  makeT(S_TLD, DOT, S_DOMAIN_DOT);
	  makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT); // Become real URLs after `SLASH` or `COLON NUM SLASH`
	  // Here PSS and non-PSS converge

	  makeT(S_TLD, COLON, S_TLD_COLON);
	  makeT(S_TLD, SLASH, S_URL);
	  makeT(S_TLD_COLON, NUM, S_TLD_PORT);
	  makeT(S_TLD_PORT, SLASH, S_URL);
	  makeT(S_EMAIL, COLON, S_EMAIL_COLON);
	  makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT); // Types of characters the URL can definitely end in

	  var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE]; // Types of tokens that can follow a URL and be part of the query string
	  // but cannot be the very last characters
	  // Characters that cannot appear in the URL at all should be excluded

	  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI]; // These states are responsible primarily for determining whether or not to
	  // include the final round bracket.
	  // URL, followed by an opening bracket

	  makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
	  makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
	  makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
	  makeT(S_URL, OPENPAREN, S_URL_OPENPAREN); // URL with extra symbols at the end, followed by an opening bracket

	  makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
	  makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
	  makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
	  makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN); // Closing bracket component. This character WILL be included in the URL

	  makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
	  makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
	  makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
	  makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
	  makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
	  makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
	  makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
	  makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
	  makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
	  makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
	  makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
	  makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL); // URL that beings with an opening bracket, followed by a symbols.
	  // Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
	  // has a single opening bracket for some reason).

	  makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
	  makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
	  makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
	  makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
	  makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
	  makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
	  makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
	  makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS); // URL that begins with an opening bracket, followed by some symbols

	  makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
	  makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
	  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
	  makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
	  makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
	  makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
	  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
	  makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
	  makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
	  makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
	  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
	  makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
	  makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
	  makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
	  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
	  makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS); // Account for the query string

	  makeMultiT(S_URL, qsAccepting, S_URL);
	  makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
	  makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
	  makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING); // Email address-specific state definitions
	  // Note: We are not allowing '/' in email addresses since this would interfere
	  // with real URLs
	  // For addresses with the mailto prefix
	  // 'mailto:' followed by anything sane is a valid email

	  makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
	  makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
	  makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
	  makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL); // Greedily get more potential valid email values

	  makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
	  makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
	  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
	  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING); // For addresses without the mailto prefix
	  // Tokens allowed in the localpart of the email

	  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE]; // Some of the tokens in `localpartAccepting` are already accounted for here and
	  // will not be overwritten (don't worry)

	  makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
	  makeT(S_DOMAIN, AT, S_LOCALPART_AT);
	  makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
	  makeT(S_TLD, AT, S_LOCALPART_AT);
	  makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART); // Now in localpart of address
	  // TODO: IP addresses and what if the email starts with numbers?

	  makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
	  makeT(S_LOCALPART, AT, S_LOCALPART_AT); // close to an email address now

	  makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
	  makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
	  makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
	  makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
	  makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
	  makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL); // States following `@` defined above

	  return S_START;
	}
	/**
	 * Run the parser state machine on a list of scanned string-based tokens to
	 * create a list of multi tokens, each of which represents a URL, email address,
	 * plain text, etc.
	 *
	 * @param {State} start parser start state
	 * @param {string} input the original input used to generate the given tokens
	 * @param {{t: string, v: string, s: number, e: number}[]} tokens list of scanned tokens
	 * @returns {MultiToken[]}
	 */

	function run(start, input, tokens) {
	  var len = tokens.length;
	  var cursor = 0;
	  var multis = [];
	  var textTokens = [];

	  while (cursor < len) {
	    var state = start;
	    var secondState = null;
	    var nextState = null;
	    var multiLength = 0;
	    var latestAccepting = null;
	    var sinceAccepts = -1;

	    while (cursor < len && !(secondState = takeT(state, tokens[cursor].t))) {
	      // Starting tokens with nowhere to jump to.
	      // Consider these to be just plain text
	      textTokens.push(tokens[cursor++]);
	    }

	    while (cursor < len && (nextState = secondState || takeT(state, tokens[cursor].t))) {
	      // Get the next state
	      secondState = null;
	      state = nextState; // Keep track of the latest accepting state

	      if (state.accepts()) {
	        sinceAccepts = 0;
	        latestAccepting = state;
	      } else if (sinceAccepts >= 0) {
	        sinceAccepts++;
	      }

	      cursor++;
	      multiLength++;
	    }

	    if (sinceAccepts < 0) {
	      // No accepting state was found, part of a regular text token
	      // Add all the tokens we looked at to the text tokens array
	      for (var i = cursor - multiLength; i < cursor; i++) {
	        textTokens.push(tokens[i]);
	      }
	    } else {
	      // Accepting state!
	      // First close off the textTokens (if available)
	      if (textTokens.length > 0) {
	        multis.push(parserCreateMultiToken(Text, input, textTokens));
	        textTokens = [];
	      } // Roll back to the latest accepting state


	      cursor -= sinceAccepts;
	      multiLength -= sinceAccepts; // Create a new multitoken

	      var Multi = latestAccepting.t;
	      var subtokens = tokens.slice(cursor - multiLength, cursor);
	      multis.push(parserCreateMultiToken(Multi, input, subtokens));
	    }
	  } // Finally close off the textTokens (if available)


	  if (textTokens.length > 0) {
	    multis.push(parserCreateMultiToken(Text, input, textTokens));
	  }

	  return multis;
	}
	/**
	 * Utility function for instantiating a new multitoken with all the relevant
	 * fields during parsing.
	 * @param {Class<MultiToken>} Multi class to instantiate
	 * @param {string} input original input string
	 * @param {{t: string, v: string, s: number, e: number}[]} tokens consecutive tokens scanned from input string
	 * @returns {MultiToken}
	 */

	function parserCreateMultiToken(Multi, input, tokens) {
	  var startIdx = tokens[0].s;
	  var endIdx = tokens[tokens.length - 1].e;
	  var value = input.substr(startIdx, endIdx - startIdx);
	  return new Multi(value, tokens);
	}


	var INIT = {
	  scanner: null,
	  parser: null,
	  pluginQueue: [],
	  customProtocols: [],
	  initialized: false
	};
	/**
	 * Initialize the linkify state machine. Called automatically the first time
	 * linkify is called on a string, but may be called manually as well.
	 */

	function init() {
	  // Initialize state machines
	  INIT.scanner = {
	    start: init$2(INIT.customProtocols),
	    tokens: text$1
	  };
	  INIT.parser = {
	    start: init$1(),
	    tokens: multi
	  };
	  var utils = {
	    createTokenClass: createTokenClass
	  }; // Initialize plugins

	  for (var i = 0; i < INIT.pluginQueue.length; i++) {
	    INIT.pluginQueue[i][1]({
	      scanner: INIT.scanner,
	      parser: INIT.parser,
	      utils: utils
	    });
	  }

	  INIT.initialized = true;
	}
	/**
		Parse a string into tokens that represent linkable and non-linkable sub-components
		@param {string} str
		@return {MultiToken[]} tokens
	*/

	function tokenize(str) {
	  if (!INIT.initialized) {
	    init();
	  }

	  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
	}

	/**
		Convert strings of text into linkable HTML text
	*/

	function escapeText(text) {
	  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}

	function escapeAttr(href) {
	  return href.replace(/"/g, '&quot;');
	}

	function attributesToString(attributes) {
	  if (!attributes) {
	    return '';
	  }

	  var result = [];

	  for (var attr in attributes) {
	    var val = attributes[attr] + '';
	    result.push("".concat(attr, "=\"").concat(escapeAttr(val), "\""));
	  }

	  return result.join(' ');
	}
	/**
	 * Convert a plan text string to an HTML string with links. Expects that the
	 * given strings does not contain any HTML entities. Use the linkify-html
	 * interface if you need to parse HTML entities.
	 *
	 * @param {string} str string to linkify
	 * @param {object} [opts] overridable options
	 * @returns {string}
	 */


	function linkifyStr(str) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  opts = new Options(opts);
	  var tokens = tokenize(str);
	  var result = [];

	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];

	    if (token.t === 'nl' && opts.nl2br) {
	      result.push('<br>\n');
	      continue;
	    } else if (!token.isLink || !opts.check(token)) {
	      result.push(escapeText(token.toString()));
	      continue;
	    }

	    var _opts$resolve = opts.resolve(token),
	        formatted = _opts$resolve.formatted,
	        formattedHref = _opts$resolve.formattedHref,
	        tagName = _opts$resolve.tagName,
	        className = _opts$resolve.className,
	        target = _opts$resolve.target,
	        rel = _opts$resolve.rel,
	        attributes = _opts$resolve.attributes;

	    var link = ["<".concat(tagName, " href=\"").concat(escapeAttr(formattedHref), "\"")];

	    if (className) {
	      link.push(" class=\"".concat(escapeAttr(className), "\""));
	    }

	    if (target) {
	      link.push(" target=\"".concat(escapeAttr(target), "\""));
	    }

	    if (rel) {
	      link.push(" rel=\"".concat(escapeAttr(rel), "\""));
	    }

	    if (attributes) {
	      link.push(" ".concat(attributesToString(attributes)));
	    }

	    link.push(">".concat(escapeText(formatted), "</").concat(tagName, ">"));
	    result.push(link.join(''));
	  }

	  return result.join('');
	}

	if (!String.prototype.linkify) {
	  Object.defineProperty(String.prototype, 'linkify', {
	    writable: false,
	    value: function linkify(options) {
	      return linkifyStr(this, options);
	    }
	  });
	}

	const linkifyOptions = { defaultProtocol: 'https' };

	function url(s) {
	    s = s.replace(/\\\\/g,'\\');
	    const l = linkifyStr(s, linkifyOptions);
	    const m = l.match(/"([^"]+)"/);

	    if (m==null) {
	        return null
	    } else {
	        return m[1]
	    }
	}

	function internalLink(l) {
	    switch(l[0]) {
	        case '/':
	            return '/' + encodeURIComponent(l.substring(1).replace(/ +/g,"_").toLowerCase());
	        case '#':
	            return '#' + encodeURIComponent(l.substring(1).replace(/ +/g,"_").toLowerCase());
	        default:
	            return null
	    }
	}

	function strToLink(s) {
	    var parts = s.split("|", 2);
	    if (parts.length == 2 && parts[0].charAt(parts[0].length-1) == '\\') {
	        parts[0] = parts[0].substring(0,parts[0].length - 1) + '|' + parts[1];
	        parts.pop();
	    }
	    if (parts.length == 1) {
	        if (parts[0].trim() == '') {
	            return t(`[${s}]`)
	        }

	        let u = parts[0].trim().replace(/\\\]/g,']');

	        if (u[0] == '^') {
	            u = u.substring(1).trim();
	            return h('sup',{},[ h('a',{'footnote-u':u,'href': `#footnote-${u}`},[t(`TBD`)])])
	        } else {
	            const addr = parts[0].trim().replace(/\]/g,']');
	            const u = url(addr);
	            if (u==null) {
	                const il = internalLink(addr);
	                if (il == null) {
	                    return h('a',{'link-ref':addr.toLowerCase()},[t(addr)])
	                } else {
	                    return h('a',{'href':il},[t(il)])
	                }
	            } else {
	                return h('a',{'href':u},[t(u)])
	            }
	        }
	    } else {
	        const txt = parts[0].trim().replace(/\|/g,'|');
	        const addr = parts[1].trim().replace(/\]/g,']');
	        const u = url(addr);
	        if (u==null) {
	            const il = internalLink(addr);
	            if (il == null) {
	                return h('a',{'link-ref':addr.toLowerCase()},[t(txt)])
	            } else {
	                return h('a',{'href':il},[t(txt)])
	            }
	        } else {
	            return h('a',{'href':u},[t(txt)])
	        }
	    }
	}

	function lineToSxast(str) {

	    let root = h();

	    if (typeof str == 'string') {
	        process(root,str,0,'');
	    } else {
	        root.children.push(str);
	    }

	    function escapeChar(c) {
	        return c
	    }

	    function tagFor(c) {
	        switch (c) {
	            case '!':
	            case '*':
	                return "b";
	            case '~':
	            case '/':
	                return "i";
	            case '_':
	                return "u";
	            case '-':
	                return "del";
	            case '^':
	                return "sup";
	            case '`':
	                return "code";
	            case '$':
	                return "kbd";
	            default:
	                return c + "";
	        }
	    }


	    // function path(s) {
	    //     return '/' + encodeURIComponent(s.replace(/ +/g,"_").toLowerCase());
	    // }

	 
	    function process(parent,s,index,inChar) {
	        var a, b;
	        let str = '';

	        while (index < s.length) {
	            a = s.charAt(index++);
	            b = s.charAt(index);

	            // TODO: change from if statements that can fall into each other

	            if (a == '\\') {
	                if (b == '$') {
	                    str += '\\$';
	                    index++;
	                    continue;
	                }
	                let punc = /^[-!\"#$%&'()*+,-./:;<=>?@[\]^_`{|}~]$/;
	                if (b.match(punc)) {
	                    str += escapeChar(b);
	                    index++;
	                    continue;    
	                }
	            }

	            if (a == '[') {
	                let prev = a;
	                let curr;
	                for (let k = index; k < s.length; k++) {
	                    curr = s.charAt(k);
	                    if (curr == ']' && prev !='\\')	{
	                        parent.children.push(t(str));
	                        str = '';
	                        parent.children.push(strToLink(s.substring(index,k)));
	                        index = k + 1;
	                        if (index >= s.length) {
	                            parent.children.push(t(str));
	                            str = '';
	                            return index;// {i: index, str: strs};
	                        }
	                        a = s.charAt(index++);
	                        break;
	                    }
	                    prev = curr;
	                }
	            }
	            if (a == '@') {
	                const ch0 = /^[a-zA-Z]$/;
	                const chx = /^[a-zA-Z\d_]$/;
	                let user = '';
	                let k = index;
	                for (; k < s.length; k++) {
	                    let ch = s.charAt(k);
	                    if ((k==index && ch.match(ch0))
	                            || (ch.match(chx))) {
	                        user += ch;
	                    } else {
	                        break;
	                    }
	                }
	                if (user !== '') {
	                    index = k;
	                    a = s.charAt(index++);
	                    parent.children.push(t(str));
	                    str = '';
	                    parent.children.push(h('a',{'href':`/users/${user}`},[t(`@${user}`)]));
	                }
	            }
	            if (a == '$' && b == '{') {
	                let template = '';
	                index++;
	                while (index < s.length) {
	                    let ch = s.charAt(index);

	                    if (ch!='}') {
	                        template += ch;
	                    } else {
	                        try {
	                            strToJs(template,true);
	                            str += '${' + template + '}';
	                            template = null;
	                            index++;
	                            a = s.charAt(index++);
	                            b = s.charAt(index);
	                            break;
	                        } catch (e) {
	                            template += ch;
	                        }
	                    }
	                    index++;
	                }
	                if (index == s.length && template != null) {
	                    str += '\\${' + template;
	                    continue
	                }
	            }
	            if (a == '#') {
	                const tagAt = index-1;
	                const ch0 = /^[a-zA-Z]$/;
	                const chx = /^[a-zA-Z\d_]$/;
	                let tag = '';
	                let bang = false;
	                if (s.charAt(index)=='!') {
	                    bang = true;
	                    index++;
	                }
	                let jj = index;
	                let dotAt = -1;
	                for (; jj < s.length; jj++) {
	                    let ch = s.charAt(jj);
	                    if ((jj==index && ch.match(ch0))
	                            || (ch.match(chx)) || (bang==true && ch=='.' && dotAt == -1)) {
	                        tag += ch;
	                        if (ch=='.') dotAt = jj;
	                    } else {
	                        break;
	                    }
	                }
	                if (tag !== '') {

	                    index = jj;
	                    a = s.charAt(index++);
	                    let tagStr = null;
	                    let tagValue = null;
	                    let tagValueStr = null;

	                    if (a=='(') {
	                        for (var k = index; k < s.length; k++) {
	                            let ch = s.charAt(k);
	                            if (ch==')') {
	                                tagValueStr = s.substring(index,k);
	                                try {
	                                    tagValue = strToJs(tagValueStr,true);
	                                    tagStr = s.substring(tagAt,k+1);
	                                    index = k + 1;
	                                    a = s.charAt(index++);
	                                    break;
	                                } catch (e) {
	                                    // find next end bracket and try again
	                                }
	                            }
	                        }
	                        
	                        if (tagValue == null) {
	                            // if ')' was never found tagValueStr == null
	                            if (tagValueStr == null) {
	                                tagValueStr = s.substring(index);
	                            }
	                            tagValue = strToJs(tagValueStr,false);
	                        }
	                    } else {
	                        tagStr = s.substring(tagAt,index-1);
	                        tagValue = strToJs('true',false);
	                    }

	                    if (str != '') {
	                        parent.children.push(t(str));
	                        str = '';
	                    }

	                    if (bang) {
	                        const includeOpts = {
	                            type: 'include',
	                            name: tag, 
	                            args: tagValue
	                        };
	                        if (dotAt != -1) {
	                            const ss = tag.split('.');
	                            if (ss.length != 2) throw new Error(`error parsing tag with namespace "${tag}"`)
	                            includeOpts.collection = ss[0];
	                            includeOpts.name = ss[1];
	                        }
	                        parent.children.push(includeOpts);
	                    } else {
	                        parent.children.push({
	                            type:'tag',
	                            indent: 0,
	                            name: tag,
	                            colon: true,
	                            args: tagValue,
	                            children: [t(tagStr)] 
	                        });

	                    }

	                    if (index >= s.length) {
	                        break;
	                    }
	                }
	            }
	            if (index + 1 > s.length) {
	                str += escapeChar(a);
	                parent.children.push(t(str));
	                return index;//{index: index, str: strs};
	            }
	            if (a == b
	                    && (a == '!' || a == '*' || a == '~' || a == '/' || a == '_' || a == '-'
	                            || a == '^' || a == '`' || a == '$')) {
	                index++;
	                while (s.charAt(index)==a) {
	                    b = a;
	                    index++; // permissive with extra formatting tag chars
	                }
	                if (a == inChar) {
	                    parent.children.push(t(str));
	                    return index; //{index: index, str: strs};
	                } else {
	                    parent.children.push(t(str));
	                    str = '';
	                    const el = h(tagFor(a),{});
	                    parent.children.push(el);
	                    index = process(el,s,index,a);
	                }
	            } else {
	                str += escapeChar(a);
	            }
	        }

	        if (str != '' ) parent.children.push(t(str));//strs.push(str)
	        return index;//{index: index,str: strs};
	    }

	    return root.children
	}

	function tableOf(rows) {
	    let head = [];
	    let body = [];
	    let foot = [];
	    let colAlignment = {};

	    for (let i=0 ; i<rows.length ; i++) {
	        if (rows[i].divider) {
	            head = body;
	            body = [];
	            for (let j=i+1 ; j<rows.length ; j++) {
	                if (rows[j].divider) {
	                    for (let k=j+1 ; k<rows.length ; k++) {
	                        if (rows[k].divider) continue
	                        foot.push(rows[k]);
	                    }
	                    break
	                }
	                body.push(rows[j]);
	            }
	            break
	        }
	        body.push(rows[i]);
	    }

	    if (head.length>0) {
	        for (let i=0 ; i<head.length ; i++) {
	            for (let j=0 ; j<head[i].cells.length ; j++) {
	                if (head[i].cells[j].formatting.align) {
	                    colAlignment[j] = head[i].cells[j].formatting.align;
	                }
	            }
	        }
	    }

	    function cell(row,cellNumber,forceHeader) {
	        let el = h((forceHeader || row.cells[cellNumber].formatting.header ? 'th' : 'td'));

	        if (row.cells[cellNumber].formatting.colspan !== undefined) {
	            el.properties.colspan = row.cells[cellNumber].formatting.colspan;
	        }

	        if (row.cells[cellNumber].formatting.rowspan !== undefined) {
	            el.properties.rowspan = row.cells[cellNumber].formatting.rowspan;
	        }

	        if (row.cells[cellNumber].formatting.align !== undefined) {
	            el.properties.style = `text-align: ${row.cells[cellNumber].formatting.align};`;
	        } else if (colAlignment[cellNumber] !== undefined) {
	            el.properties.style = `text-align: ${colAlignment[cellNumber]};`;
	        }

	        return el
	    }

	    const table = h('table');

	    if (head.length>0) {
	        const thead = h('thead');
	        table.children.push(thead);
	        for (let i=0 ; i<head.length ; i++) {
	            const tr = h('tr');
	            thead.children.push(tr);
	            for (let j=0 ; j<head[i].cells.length ; j++) {
	                const th = cell(head[i],j,true);
	                tr.children.push(th);
	                th.children = head[i].cells[j].children;
	            }
	        }
	    }

	    const tbody = h('tbody');
	    table.children.push(tbody);
	    for (let i=0 ; i<body.length ; i++) {
	        const tr = h('tr');
	        tbody.children.push(tr);
	        for (let j=0 ; j<body[i].cells.length ; j++) {
	            const td = cell(body[i],j);
	            tr.children.push(td);
	            td.children = body[i].cells[j].children;
	        }
	    }

	    if (foot.length>0) {
	        const tfoot = h('tfoot');
	        table.children.push(tfoot);
	        for (let i=0 ; i<foot.length ; i++) {
	            const tr = h('tr');
	            tfoot.children.push(tr);
	            for (let j=0 ; j<foot[i].cells.length ; j++) {
	                const td = cell(foot[i],j);
	                tr.children.push(td);
	                td.children = foot[i].cells[j].children;
	            }
	        }
	    }

	    return table;
	}

	function sastToHast(sqrm) {

	    const doc = { type: "root", children: [] };
	    let footnotes = [];
	    let linkDefinitions = [];
	    let i = 0;

	    function next() {
	        if (i==sqrm.length) return null
	        return sqrm[i++]
	    }

	    function peek() {
	        if (i==sqrm.length) return null
	        return sqrm[i]
	    }

	    // function footnoteNum(id,text) {
	    //     for (let i=0 ; i<footnotes.length ; i++) {
	    //         if (footnotes[i].id == id) {
	    //             if (text != undefined) {
	    //                 footnotes[i].text = text;
	    //             }
	    //             return i+1
	    //         }
	    //     }
	    //     footnotes.push({ id: id, text: text });
	    //     return footnotes.length;
	    // }

	    function processIndentation(indent) {

	        function raw() {
	            const lines = [t('\n')];
	    
	            while (peek()!=null) {
	                if (peek().type == 'blank') {
	                    next();
	                    lines.push(t('\n'));
	                } else if (peek().indent > indent) {
	                    let n = next();
	                    lines.push(t(n.text.substring((indent+1)*2))); // TODO: hard coded indenting
	                    lines.push(t('\n'));
	                } else {
	                    break;
	                }
	            }
	    
	            return lines
	    
	        }

	        function pre(preIndent) {
	            const lines = [t('\n')];
	    
	            while (peek()!=null) {
	                if (peek().type == 'blank') {
	                    next();
	                    lines.push(t('\n'));
	                } else if (peek().indent > preIndent) {
	                    let n = next();

	                    if (n.type == 'div') {

	                        let props = {};
	                        Object.keys(n.properties).forEach(k => {
	                            props[k] = n.properties[k].value;
	                        });
	            
	                        let div = h(`${n.tag}`,props);
	                        div.children = div.children.concat(pre(n.indent));
	                        lines.push(div);
	                        lines.push(t('\n'));
	                    } else {
	                        // lines.push(t(n.text))
	                        // lines.push(t('\n'))
	                        const ss = n.text.split('\n');
	                        for (let j=0 ; j<ss.length ; j++) {
	                            lines.push(t(ss[j].substring((preIndent+1)*2))); // TODO: hard coded indenting
	                            lines.push(t('\n'));
	                        }
	                    }
	                } else {
	                    break;
	                }
	            }
	    
	            return lines
	    
	        }

	        function blockOf(language,lines) {
	            switch(language) {
	                case "info":
	                case "tip":
	                case "note":
	                case "warning":
	                    {
	                        const div = h('div',{class: 'alert-' + language},[]);
	                        let text = "";
	                        for (let i=0 ; i<lines.length ; i++) {
	                            // if (lines[i].type != 'blank') {
	                            //     if (div.children.length > 0) div.children.push(t('\n'))
	                            //     div.children.push(t(lines[i].text.substring((indent+1)*2)))
	                            // }
	                            if (lines[i].type == 'blank') {
	                                if (text!="") {
	                                    div.children.push(...lineToSxast(text));
	                                    text = "";
	                                }
	                            } else {
	                                const ss = lines[i].text.split('\n');
	                                for (let j=0 ; j<ss.length ; j++) {
	                                    if (text != "") text += '\n';
	                                    text += ss[j].substring((indent+1)*2); // TODO: hard coded indenting
	                                }
	                            }
	                        }
	                        if (text!="") {
	                            div.children.push(...lineToSxast(text));
	                        }

	                        return div            
	                    }
	                default:
	                    {
	                        const code = h('code',{class: 'language-' + (language==""?'text':language)});
	                        let text = '\n';
	                        for (let i=0 ; i<lines.length ; i++) {
	                            if (lines[i].type == 'blank') {
	                                text += '\n';
	                            } else {
	                                const ss = lines[i].text.split('\n');
	                                for (let j=0 ; j<ss.length ; j++) {
	                                    text += ss[j].substring((indent+1)*2) + '\n'; // TODO: hard coded indenting
	                                }
	                            }
	                        }
	                        code.children = [t(text)];
	                        return h('pre',{},[code])
	            
	                    }
	            }
	        }
	        
	        function div() {
	            let n = next();

	            let props = {};
	            if (n.properties) {
	                Object.keys(n.properties).forEach(k => {
	                    props[k] = n.properties[k].value;
	                });
	            }

	            if (n.tag == '!DOCTYPE') {
	                let doctype = { type: 'doctype', properties: props };
	                doctype.children = processIndentation(indent+1);
	                return doctype
	            } else if (n.tag == '!--') {
	                let comment = { type: 'comment' };
	                comment.children = raw();
	                return comment
	            } else if (n.tag == 'script' || n.tag == 'style') {
	                let el = h(n.tag);
	                el.children = raw();
	                return el
	            } else if (n.tag == 'pre') {
	                let el = h('pre');
	                el.children = pre(n.indent);
	                return el
	            } else {
	                // n.properties.forEach(p => {
	                //     props[p.name] = p.value
	                // })
	                let div = h(`${n.tag}`,props);
	                div.children = processIndentation(indent+1);
	                return div
	            }
	        }
	    
	        function heading() {
	            let n = next();
	            if (n==null || n.type != 'heading') {
	                throw new Error('expected heading but found ' + n.type)
	            }
	            return h(`h${Math.min(n.level,6)}`,{}, n.children)
	        }
	    
	        function xList(tagName,type) {
	            return function() {
	                const list = h(tagName,{}, [listItem()] );
	                let n = peek();
	                while (n!=null) {
	                    if (n.indent == indent && n.type == type) {
	                        list.children.push(listItem());
	                    } else if (n.type == 'blank') {
	                        blank();
	                    } else if (n.indent >= indent + 1 ) {
	                        list.children = list.children.concat(processIndentation(indent+1));
	                    } else {
	                        break
	                    }
	                    n = peek();
	                }
	                return list
	            }
	        }

	        let orderedList = xList('ol','ordered-list-item');
	        let unorderedList = xList('ul','unordered-list-item');

	        function listItem() {
	            let n = next();
	            if (n==null || (n.type != 'unordered-list-item' && n.type != 'ordered-list-item')) {
	                throw new Error('expected list-item but found ' + n.type)
	            }
	            const li = h('li',{}, n.children );
	            if (n.task) {
	                const form = h('form', {method: 'PUT'});
	                li.children.push(form);
	                const hidden = h('input',{type:'hidden',value:n.task.line});
	                form.children.push(hidden);
	                const checkbox = h('input',{type:'checkbox',onchange:'this.form.submit()'});
	                if (n.task.done) checkbox.properties.checked = 'checked';
	                form.children.push(checkbox);
	            }
	            // n = peek()
	            // while (n != null && n.indent == indent + 1 && n.type == 'text') {
	            //     n = next()
	            //     el.children = el.children.concat(t('\n')).concat(n.children)
	            //     n = peek()
	            // }
	            return li
	        }

	        function blank() {
	            let n = next();
	            if (n==null || n.type != 'blank') {
	                throw new Error('expected blank but found ' + n.type)
	            }
	            return null
	        }
	       
	        function paragraph() {
	            let n = next();
	            const p = h('div',{ class: 'p' }, n.children);
	            // n = peek()
	            // while (n != null && n.type == 'text' && n.indent == indent) {
	            //     n = next()
	            //     p.children = p.children.concat(t('\n')).concat(n.children)
	            //     n = peek()
	            // }
	            return p
	        }

	        function hr() {
	            next();
	            return h('hr')
	        }

	        function codeBlock() {
	            let n = next();
	            if (n==null || n.type != 'code-block') {
	                throw new Error('expected code-block but found ' + n.type)
	            }
	            const language = n.language;
	            let lines = [];
	            n = peek();
	            while (n!=null && (n.type == "blank" || n.indent >= indent + 1)) {
	                lines.push(next());
	                n = peek();
	            }
	            return blockOf(language,lines)
	        }
	    
	        function table() {
	            let n = next();
	            if (n==null || n.type != 'table-row') {
	                throw new Error('expected table-row but found ' + n.type)
	            }
	            let rows = [n];
	            n = peek();
	            while (n!=null && n.type == 'table-row' && n.indent == indent) {
	                rows.push(next());
	                n = peek();
	            }
	            return tableOf(rows)
	        }
	    
	        function yaml() {
	            let n = next();
	            return h('p',{}, n.children)
	        }

	        function processLine() {
	            let ln = peek();

	            if (ln.indent == undefined) {
	                return blank()
	            }
	    
	            if (ln.indent < indent) {
	                // reduced indentation, exit indented scope
	                return -1
	            }
	    
	            if (ln.indent > indent) {
	                let div = h('div');
	                const divIndent = indent + 1;
	                div.children = processIndentation(divIndent);
	                return div
	            }
	    
	            switch (ln.type) {
	                case 'code-block':
	                    return codeBlock()
	                case "div":
	                    return div()
	                case "footnote":
	                    footnotes.push(next());
	                    return null
	                case "heading":
	                    return heading()
	                case 'hr':
	                    return hr()
	                case "ordered-list-item":
	                    return orderedList()
	                case "unordered-list-item":
	                    return unorderedList()
	                case "paragraph":
	                    return paragraph()
	                case "table-row":
	                    return table()
	                case "yaml":
	                    return yaml()
	                case "link-definition":
	                    linkDefinitions.push(next());
	                    return null
	                default:
	                    throw new Error('un-handled type: ' + ln.type)                
	            }
	    
	        }

	        const lines = [];

	        while (peek()!=null) {
	            let child = processLine();
	            if (child == -1) break
	            if (child) lines.push(child);
	        }

	        return lines

	    }

	    doc.children = processIndentation(0);

	    // http://www.java2s.com/example/html-css/css-widget/adding-parentheses-in-html-ordered-list.html
	    if (footnotes.length>0) {
	        let footnotesLookup = {};
	        const ol = h('ol');
	        doc.children.push(h('section',{ class: 'footnotes'},[ol]));
	        for (let i=0 ; i<footnotes.length ; i++) {
	            footnotesLookup[footnotes[i].id] = i+1;

	            ol.children.push(h('li',{},[ h('a',{name:`footnote-${footnotes[i].id}`}
	            )].concat([t(' ')]).concat(footnotes[i].children)));
	        }

	        visit(doc, (node) => {
	            return node.type=='element' && node.tagName=='a' && node.properties['footnote-u'] !== undefined
	        }, (node) => {
	            const id = node.properties['footnote-u'];
	            let num = footnotesLookup[node.properties['footnote-u']];
	            if (num===undefined) {
	                // used but not defined
	                num = Object.keys(footnotesLookup).length + 1;
	                footnotesLookup[id] = num;
	                ol.children.push(h('li',{},[ h('a',{name:`footnote-${id}`}) ]));
	            }
	            node.children[0].value = `[${num}]`;
	        });
	    }

	    if (linkDefinitions.length>0) {

	        let lookup = {};

	        for (let i=0 ; i<linkDefinitions.length ; i++) {
	            lookup[linkDefinitions[i].id] = linkDefinitions[i];
	        }

	        visit(doc, (node) => {
	            return node.type=='element' && node.tagName=='a' && node.properties['link-ref'] !== undefined
	        }, (node) => {
	            const id = node.properties['link-ref'];
	            let ld = lookup[id];
	            if (ld) {
	                delete node.properties['link-ref'];
	                const href = ld.link.properties.href;
	                const txt = ld.link.children[0].value;
	                node.properties['href'] = ld.link.properties.href;
	                if (href != txt) {
	                    // if these are different the link definition contains link text
	                    node.children = ld.link.children;
	                }
	            }
	        });
	    }

	    return doc
	}

	let handler = {
	    has(target, property) {
	        switch (target.type) {
	            case 'object': {
	                for (let i=0 ; i<target.children.length ; i++) {
	                    let child = target.children[i];
	                    if (child.name == property) {
	                        return true
	                    }
	                }
	            }
	            case 'array': {
	                return property in target.children
	            }
	            case 'unknown': {
	                return false
	            }
	            // case 'value': {
	            //     return true
	            // }
	            default: {
	                throw new Error(target.type)
	            }
	        }
	        return false

	        // return property in target
	    },
	    get(target, property, receiver) {
	        switch (target.type) {
	            case 'object': {
	                for (let i=0 ; i<target.children.length ; i++) {
	                    let child = target.children[i];
	                    if (child.name == property) {
	                        if (child.type == 'value') {
	                            return child.value
	                        } else {
	                            return new Proxy(child,handler)
	                        }
	                    }
	                }
	                return null;
	            }
	            case 'array': {
	                const v = target.children[property];
	                if (v==null) return null
	                else if (v.type == 'value') return v.value
	                return new Proxy(v,handler)
	            }
	            case 'unknown': {
	                return null;
	            }
	            case 'value': {
	                return target.value[property]
	            }
	            default: {
	                throw new Error(target.type)
	            }
	        }
	    },
	    set(target, property, value, receiver) {
	        throw new Error('set not-implemented')
	    }
	};

	class JsonTree {

	    constructor() {
	        this.root = { minChildIndent: 0, type: 'unknown', name: 'root' };
	        this.json = new Proxy(this.root,handler);        
	    }

	    iterateLikeStack(cb) {
	        let el = this.root;
	        while (el != null) {
	            if (cb.call(null,el) === false) return
	            el = (el.children ? el.children[el.children.length-1] : null);
	            if (el!=null && el.type == 'value') {
	                el = null;
	            }
	        }
	    }   
	}

	class SqrmResponse {
	    constructor(db,jsonTree) {
	        this.db = db;
	        this.root = [];

	        this.yamlNotAllowedIndent = -1;

	        this.hastCallbacks = [];

	        this.jsonTree = jsonTree || new JsonTree();
	        this.json = this.jsonTree.json;

	        this.libs = {
	            h: h,
	            t: t,
	            matches: matches,
	            select: select,
	            selectAll: selectAll,
	            processHast: this.processHast.bind(this),
	            include: this.include.bind(this),
	//            j: this.j.bind(this),
	            maybeYaml: this.maybeYaml.bind(this),
	            addTask: this.addTask.bind(this),
	            inlineTag: this.inlineTag.bind(this),
	            appendToHtml: this.appendToHtml.bind(this),
	            template: this.template.bind(this),
	//            set: this.set,
	//            append: this.append//.bind(this),
	        };//, tree: new Tree(), util: util };


	    }

	    processHast(cb) {
	        this.hastCallbacks.push(cb);
	    }

	    include({collection = 'default',name,args}) {

	        const docs = this.db.find(collection,name);

	        if (docs == null) {
	            return { type: 'comment', value: `failed to include doc: ${collection}.${name}( ${JSON.stringify(args)} )` }
	        }

	        if (docs.length != 1) {
	            return { type: 'comment', value: `failed to include single doc: ${collection}.${name}( ${JSON.stringify(args)} )` }
	        }

	        const doc = docs[0];
	        let request = new SqrmRequest(args);
	        let response = new SqrmResponse(this.db,this.jsonTree);
	        doc.execute(request,response);
	        let hast = sastToHast(response.root);
	        return h('div',{class: `${collection}.${name}`},hast.children)
	    }

	    appendToHtml(obj) {

	        if (this.yamlNotAllowedIndent != -1 && obj.type != 'blank') {
	            if (obj.indent < this.yamlNotAllowedIndent) {
	                this.yamlNotAllowedIndent = -1;
	            }
	        }

	        if (this.yamlNotAllowedIndent == -1 && obj.type == 'div') {
	            switch (obj.tag) {
	                case 'pre':
	                case 'script':
	                case 'style':
	                case '!--':
	                    this.yamlNotAllowedIndent = obj.indent + 1;
	            }
	        }

	        let wasAppended = false;
	        if (this.appendTextToNode != null && obj.type == 'paragraph') {
	            if (this.appendTextToNode.minIndent !== undefined) {
	                if (this.appendTextToNode.minIndent <= obj.indent) {
	                    delete this.appendTextToNode.minIndent;
	                    this.appendTextToNode.indent = obj.indent;
	                    const ls = obj.text.split('\n');
	                    for (let i=0 ; i<ls.length ; i++) {
	                        if (this.appendTextToNode.jsonNode.value != '') {
	                            if (this.appendTextToNode.mode == '|') {
	                                this.appendTextToNode.jsonNode.value += '\n';
	                            } else {
	                                this.appendTextToNode.jsonNode.value += ' ';
	                            }
	                        }
	                        this.appendTextToNode.jsonNode.value += ls[i].trim(); // obj.text.trim()
	                    }
	                    wasAppended = true;
	                }
	            } else if (this.appendTextToNode.indent == obj.indent) {
	                const ls = obj.text.split('\n');
	                for (let i=0 ; i<ls.length ; i++) {
	                    if (this.appendTextToNode.jsonNode.value != '') {
	                        if (this.appendTextToNode.mode == '|') {
	                            this.appendTextToNode.jsonNode.value += '\n';
	                        } else {
	                            this.appendTextToNode.jsonNode.value += ' ';
	                        }
	                    }
	                    this.appendTextToNode.jsonNode.value += ls[i].trim(); // obj.text.trim()
	                }
	                wasAppended = true;
	            }
	        }

	        if (!wasAppended) {
	            this.appendTextToNode = null;
	            this.root.push(obj);
	        }
	    }

	    maybeYaml(obj) {

	        if (this.yamlNotAllowedIndent != -1 && obj.indent < this.yamlNotAllowedIndent) {
	            this.yamlNotAllowedIndent = -1;
	        }

	        const yaml = ( obj.type == 'yaml' ? obj : obj.yaml );

	        if (this.yamlNotAllowedIndent != -1) {
	            this.appendTextToNode = null;
	            if (obj.type == 'yaml') obj.type = 'paragraph';
	            this.root.push( obj );// { type: 'text', line: obj.line, text: obj.text, indent: obj.indent, children: obj.children }
	        } else {

	            let jsonNode = this.jsonTag(yaml);

	            if (jsonNode != null) {
	                if (yaml.value && yaml.value.length==1 && typeof yaml.value[0] == "string") {

	                    if (yaml.value[0]=='|' || yaml.value[0]=='>') {
	                        // remove the | or > from the value of this node
	                        jsonNode.value = '';
	                        this.appendTextToNode = { minIndent: yaml.indent+1, mode: yaml.value[0], jsonNode: jsonNode };
	                    } else {
	                        this.appendTextToNode = null;
	                    }
	                } else {
	                    this.appendTextToNode = null;
	                }

	                this.root.push( { type: 'blank', line: obj.line } );// h('a',{href:`/tags/${obj.name}`},obj.children)
	            } else {
	                this.appendTextToNode = null;
	                if (obj.type == 'yaml') obj.type = 'paragraph';
	                this.root.push( obj );// { type: 'text', line: obj.line, text: obj.text, indent: obj.indent, children: obj.children }
	            }
	        }
	    }

	    addTask({line,done,text}) {
	        let tasksNode = null;

	        if (this.jsonTree.root.type == 'unknown') {
	            this.jsonTree.root.type = 'object';
	            this.jsonTree.root.childrenIndent = 0;
	            delete this.jsonTree.root.minChildIndent;
	            tasksNode = { type: 'array', name: 'tasks', childrenIndent: 1, children: [] };
	            this.jsonTree.root.children = [tasksNode];
	        } else if (this.jsonTree.root.type == 'object') {
	            for (let i=0 ; i<this.jsonTree.root.children.length ; i++) {
	                const child = this.jsonTree.root.children[i];
	                if (child.name == 'tasks') {
	                    tasksNode = child;
	                    break
	                }
	            }

	            if (tasksNode == null) {
	                tasksNode = { type: 'array', name: 'tasks', childrenIndent: 1, children: [] };
	                this.jsonTree.root.children.push(tasksNode);
	            }
	        } else {
	            // silently not supported if the root is an array
	            return
	        }

	        const taskNode = { type: 'object', childrenIndent: 2, children: [] };
	        taskNode.children.push({ type: 'value', name: 'line', value: line });
	        taskNode.children.push({ type: 'value', name: 'text', value: text });
	        taskNode.children.push({ type: 'value', name: 'done', value: done });
	        tasksNode.children.push(taskNode);

	        // this.updateJson()
	    }

	    template(fn) {
	        return fn()
	    }

	    inlineTag({name,args,children}) {
	        this.jsonTag({
	            indent: 0,
	            isArrayElement: false,
	            name: name,
	            colon: true,
	            value: (args === undefined ? true : args )
	        });

	        return h('a',{ href: `/tags/${name}` }, children )
	    }

	    // j(name,value) {

	    //     if (typeof name == 'object') {
	    //         if (this.jsonTag(name)) {
	    //             // valid yaml, added to json
	    //             return h('a',{href:`/tags/${name.name}`},name.children)
	    //         } else {
	    //             return name.children
	    //         }
	    //     } else {
	    //         if (this.jsonTag({
	    //                 indent: 0,
	    //                 isArrayElement: false,
	    //                 name: name,
	    //                 colon: true,
	    //                 value: value})) {
	    //             // valid yaml, added to json
	    //             return h('a',{href:`/tags/${name.name}`},name.children)
	    //         } else {
	    //             return name.children
	    //         }
	    //     }
	    // }

	    jsonTag({indent,isArrayElement,name,colon,value}) {

	        if (value != undefined && value.length == 1) {
	            value = value[0];
	        }

	        let parent = null;
	        if (isArrayElement) {
	            // if this is an array element: look for unknown or array

	            this.jsonTree.iterateLikeStack((el) => {
	                if (el.type=='unknown' && el.minChildIndent<=indent) {
	                    parent = el;
	                    return false
	                } else if (el.type=='array' && el.childrenIndent==indent) {
	                    parent = el;
	                    return false
	                }
	            });

	        } else {
	            // if this is not an array element: look fo unknown or object

	            this.jsonTree.iterateLikeStack((el) => {
	                if (el.type=='unknown' && el.minChildIndent<=indent) {
	                    parent = el;
	                    return false
	                } else if (el.type=='object' && el.childrenIndent==indent) {
	                    parent = el;
	                    return false
	                }                
	            });
	        }

	        if (parent == null) {
	            return null
	        }

	        if (parent.type == 'unknown' && !isArrayElement) {
	            if (parent.minChildIndent > indent) throw new Error()

	            parent.type = 'object';
	            parent.childrenIndent = indent;
	            delete parent.minChildIndent;

	            if (colon && value === undefined) {
	                parent.children = [ { minChildIndent: indent, type: 'unknown', name: name } ];
	            } else {
	                parent.children = [ { type: 'value', name: name, value: value } ];
	            }

	            // this.updateJson()
	            return parent.children[0]
	        }

	        if (parent.type == 'unknown' && isArrayElement) {
	            if (parent.minChildIndent > indent) throw new Error()

	            parent.type = 'array';
	            parent.childrenIndent = indent;
	            delete parent.minChildIndent;

	            let jsonNode = null;
	            if (colon && value === undefined) {
	                jsonNode = { minChildIndent: indent+1, type:'unknown',name:name };
	                const arrayElement = { childrenIndent: indent+1, type: 'object', children: [jsonNode]};
	                parent.children = [arrayElement];
	            } else if (colon) {
	                jsonNode = { childrenIndent: indent+1, type:'value', name:name, value:value};
	                const arrayElement = { childrenIndent: indent+1, type: 'object', children: [jsonNode]};
	                parent.children = [arrayElement];
	            } else if (!colon) {
	                jsonNode = { type: 'value', value: value };
	                parent.children = [ jsonNode ];
	            }

	            // this.updateJson()
	            return jsonNode
	        }

	        if (parent.type == 'object' && !isArrayElement) {
	 
	            let child = null;
	            if (colon && value === undefined) {
	                child = { minChildIndent: indent, type: 'unknown', name: name };
	            } else {
	                child = { type: 'value', name: name, value: value };
	            }

	            for (let i=0 ; i<parent.children.length ; i++) {
	                if (parent.children[i].name == name) {
	                    parent.children[i] = child;
	                    return parent.children[i]
	                }
	            }

	            parent.children.push(child);
	            return parent.children[parent.children.length-1]
	        }

	        if (parent.type == 'array' && isArrayElement) {

	            let jsonNode = null;
	            if (colon && value === undefined) {
	                jsonNode = { minChildIndent: indent+1, type:'unknown',name:name };
	                const arrayElement = { childrenIndent: indent+1, type: 'object', children: [jsonNode]};
	                parent.children.push(arrayElement);
	            } else if (colon) {
	                jsonNode = { childrenIndent: indent+1, type:'value',name:name,value:value};
	                const arrayElement = { childrenIndent: indent+1, type: 'object', children: [jsonNode]};
	                parent.children.push(arrayElement);
	            } else if (!colon) {
	                jsonNode = { type: 'value', value: value };
	                parent.children.push(jsonNode);
	            }

	            // this.updateJson()
	            return jsonNode
	        }

	        return null
	    }

	    // append(ln) {
	    //     this.lines.push(ln)
	    // }
	}

	class SqrmDocument {
	    
	    constructor(collection,name,sxast,db) {
	        this.collection = collection;
	        this.name = name;
	        this.db = db;

	        const js = sxastToJs(collection,name,sxast);

	        this.fn = null;
	        try {
	            this.fn = new Function(js);

	            if (this.db.settings.log_code) {
	                console.log('= js =============');
	                console.log(js);
	            }
	    
	        } catch (e) {

	            // an error occured compiling the template
	            //
	            // the information from this js runtime isn't very
	            // useful for the user as it exposes the call stack
	            // of this code, rather than the users template code
	            //
	            // so we parse with acorn and get that error, but ...
	            // it can be a different error but in the same 
	            // location so its so useful
	            //
	            // do we throw an error or return the raw text?
	            //
	            // in the spirit of markdown where every document is
	            // a valid document we return the raw text

	            // which this isn't doing at the moment!

	            try {
	                const debugJs = sxastToDebugJs(sxast);
	                const node = parse(debugJs, {ecmaVersion: 2020});
	            } catch (e) {
	                const errorMessage = e.message.replace(/\([0-9]+:[[0-9]+\)/,'');
	                // -1 for 1 based line number in error
	                // -21 for number of extra lines in function
	                const errorLine = e.loc.line;// - 14// TODO: magic number
	                // -1 for 1 based column number in error
	                const errorColumn = e.loc.column;// - 1

	                const errJs = sxastToTextJs(collection,name,sxast,{errorMessage,errorLine,errorColumn});

	                try {
	                    this.fn = new Function(errJs);            

	                    if (this.db.settings.log_code) {
	                        console.log('= js =============');
	                        console.log(errJs);
	                    }

	                } catch (e) {
	                    // this should NOT occur, something really went wrong
	                    throw e
	                }
	            }
	        }
	    }

	    execute(request,response) {
	        if (this.fn == null) return

	        if (arguments.length == 0) {
	            request = new SqrmRequest();
	            response = new SqrmResponse(this.db);
	        }

	        try {
	            this.fn(request,response);
	        } catch (e) {
	            // this is handled in the doc scripts try/catch
	            // it is re-thrown so includes can handle it
	            // this can be ignored
	        }

	        return response
	    }

	    getIndexedJson() {
	        const doc = this.db.db[this.collection].findOne({ _id: this._id });
	        const res = Object.assign({},doc);
	        delete res._id;
	        delete res._text;
	        return res
	    }

	    getIndexedText() {
	        const doc = this.db.db[this.collection].findOne({ _id: this._id });
	        return doc._text
	    }
	}

	function sqrmToLines(str, indentation = 2) {

	    const l = str.length;
	    let lines = [];
	    let i = 0;
	    let j = 0;
	    let n = 1;

	    let atLineStart = true;
	    let indent = 0;

	    function addLine(split) {
	        lines.push({line: n, indent: Math.floor(indent/indentation), text: str.substring(i,j)});
	        ++n;
	        atLineStart = true;
	        indent = 0;
	        i = j + split;
	        j = i;
	    }

	    while (j<l) {

	        const s = str[j];
	        if (atLineStart) {
	            if (s==' ') {
	                ++indent;
	            } else {
	                atLineStart = false;
	            }
	        }
	        if (s=='\r') {
	            if (j+1<l && str[j+1]=='\n') {
	                addLine(2);
	            } else {
	                j++;
	            }
	        } else if (s=='\n') {
	            addLine(1);
	        } else {
	            ++j;
	        }
	    }
	    addLine(0);

	    return lines;
	}

	const RE_DocumentSeparator = /^---$/;

	const RE_BlankLine = /^\s*$/;
	const RE_Tag = /^\s*(([a-zA-Z_$][-a-zA-Z\d_$]*)\s*:(\s+(.*?))?)\s*$/;
	const RE_ListItemTag = /^\s*-\s+([a-zA-Z_$][-a-zA-Z\d_$]*)(\s*:(\s+(.*?))?)?\s*$/;
	const RE_Script = /^(\s*)<%(.*?)\s*$/;
	const RE_Footnote = /^\s*\[ *\^ *(\S+) *\] *: *(.+?) *$/;
	const RE_LinkDefinition = /^\s*\[ *([^\]]+) *\] *: *(.+?) *$/;
	const RE_CodeBlock = /^\s*``` *(([a-zA-Z]+)?)\s*$/;
	const RE_Div = /^\s*(<\s*((\!doctype)|([a-z]+([a-z0-9]+)?))((?:\s+[a-z]+(="[^"]*")?)*)\s*>?\s*)$/i;
	const RE_Heading = /^\s*((=+)\s*(\S.*?)\s*[-=]*)\s*$/;
	const RE_HR = /^\s*[-=_\*\s]+$/;
	const RE_ListItem = /^\s*(?:(?:([-*+])|(\d+[\.)]))\s+(\S.*?))\s*$/;
	const RE_ListItemTask = /^\s*\[ *([xX]?) *\]\s+(.*?)\s*$/;
	const RE_Table = /^\s*(\|(.+?)\|?)\s*$/;
	const RE_TableHeader = /^\s*[-| ]+$/;

	const RE_ScriptEnd = /%>\s*$/;

	function linesToSxast(lines) {
	    let docs = [[]];
	    let doc = docs[0];
	    let i = 0;

	    function next() {
	        if (i==lines.length) return null
	        return lines[i++]
	    }

	    function peek() {
	        if (i==lines.length) return null
	        return lines[i]
	    }

	    function script() {
	        while (peek()!=null) {
	            let ln = next();
	            let m = ln.text.match(RE_ScriptEnd);
	            if (m) {
	                doc.push({ type: 'script', line: ln.line, code: ln.text.replace(RE_ScriptEnd,''), text: ln.text});
	                break
	            } else {
	                doc.push({ type: 'script', line: ln.line, code: ln.text,text: ln.text });
	            }
	        }
	    }

	    while (peek()!=null) {
	        let ln = next();

	        const s = lineToSqrm(ln);

	        if (s.type == 'document-separator') {
	            doc = [];
	            docs.push(doc);
	        } else {

	            doc.push(s);

	            if (s.type == 'script') {
	                let m = ln.text.match(RE_ScriptEnd);
	                if (m) {
	                    s.code = s.code.replace(RE_ScriptEnd,'');
	                } else {
	                    script();
	                }
	            }
	        }
	    }

	    // TODO: put this logic inline rather than post
	    // at this point text lines and unordered/ordered-list-item lines 
	    // do not have have .children set

	    const docsX = [];
	    for (const doc of docs) {
	        const docX = [];
	        docsX.push(docX);
	        for (let i=0 ; i<doc.length ; i++) {
	            const line = doc[i];
	            if (line.type == 'text') {
	                let text = line.text;
	                let trimmed = line.text.trim();
	                for (let j=i+1 ; j<doc.length ; j++) {
	                    const lineX = doc[j];
	                    if (lineX.type == 'text' && lineX.indent == line.indent) {
	                        text += '\n' + lineX.text;
	                        trimmed += '\n' + lineX.text.trim();
	                        i++;
	                    } else {
	                        break
	                    }
	                }
	                line.type = 'paragraph';
	                line.children = textToHast(trimmed);
	                line.text = text;
	            } else if (line.type == 'unordered-list-item' || line.type == 'ordered-list-item') {
	                let text = line.text;
	                let trimmed = line.item.trim();

	                for (let j=i+1 ; j<doc.length ; j++) {
	                    const lineX = doc[j];
	                    if (lineX.type == 'text' && lineX.indent == line.indent + 1) {
	                        text += '\n' + lineX.text;
	                        trimmed += '\n' + lineX.text.trim();
	                        i++;
	                    } else {
	                        break
	                    }
	                }

	                line.item = trimmed;
	                line.children = textToHast(trimmed);
	                line.text = text;
	            }

	            docX.push(line);
	        }
	    }

	    return docsX
	}

	function textToCells(text) {

	    function splitText(text) {
	        let cells = text.split('|');

	        for (let c = cells.length-1 ; c>0 ; c--) {
	            if (cells[c-1].charAt(cells[c-1].length-1) == '\\') {
	                cells[c-1] = cells[c-1].slice(0,-1) + '|' + cells[c];
	                cells.splice(c,1);
	            }
	        }
	    
	        return cells;
	    }

	    function pragmasToAttributes(pragmas) {
	        let attr = {};
	        
	        for (let i=0 ; i<pragmas.length ; i++) {
	            switch (pragmas[i]) {
	                case '!' :
	                    attr.header = true;
	                    break;
	                case 'r':
	                    attr.align='right';
	                    break;
	                case 'l':
	                    attr.align='left';
	                    break;
	                case 'c':
	                    attr.align='center';
	                    break;
	                case 'v':
	                    if (i+1<pragmas.length) {
	                        let c = pragmas[i+1];
	                        if (c >= '3' && c <= '9') {
	                            attr.rowspan=c*1;
	                            i++;
	                        } else {
	                            attr.rowspan=2;
	                        }
	                    } else {
	                        attr.rowspan=2;
	                    }
	                    break;
	                case '>':
	                    if (i+1<pragmas.length) {
	                        let c = pragmas[i+1];
	                        if (c >= '3' && c <= '9') {
	                            attr.colspan=c*1;
	                            i++;
	                        } else {
	                            attr.colspan=2;
	                        }
	                    } else {
	                        attr.colspan=2;
	                    }

	                    break;
	            }
	        }
	        return attr
	    }

	    function tableCellFormatting(s) {
	        for (let i=0; i<s.length ; i++) {
	            if (s[i]==' ') {
	                if (i==0 || i==s.length-1) return ['',s.trim()];
	                return [s.substring(0,i),s.substring(i).trim()]
	            }
	        }
	        return ["",s.trim()];
	    }
	        
	    let cells = splitText(text);
	    for (let i=0 ; i<cells.length ; i++) {
	        let [f,t] = tableCellFormatting(cells[i]);
	        cells[i] = { children: textToHast(t), formatting: pragmasToAttributes(f) };
	    }
	    return cells;
	}

	function textToHast(text) {
	    return lineToSxast(text)
	}

	function lineToSqrm(ln) {

	    if (ln.text.length==0) {
	        return {type:'blank', line:ln.line, text: ln.text}
	    }

	    let m;

	    m = ln.text.match(RE_DocumentSeparator);
	    if (m) {
	        return {type:'document-separator', line: ln.line}
	    }

	    m = ln.text.match(RE_HR);
	    if (m) {
	        return {type:'hr',indent:ln.indent,line:ln.line, text: ln.text}
	    }

	    m = ln.text.match(RE_Heading);
	    if (m) {
	        return {type:'heading',text: ln.text, level:m[2].length,indent:ln.indent,children:textToHast(m[3]),line:ln.line}
	    }

	    m = ln.text.match(RE_ListItem);
	    if (m) {

	        if (m[1]!==undefined) {
	            let t = m[3].match(RE_ListItemTask);
	            if (t) {
	                let task = { line: ln.line, done: t[1]!='', text: t[2] };
	                // children = text and is converted to hast in post-process
	                return {type:'unordered-list-item',text: ln.text, indent:ln.indent,marker:m[1],item:t[2],line:ln.line, task: task}
	            } else {
	                // children = text and is converted to hast in post-process
	                let uli = {type:'unordered-list-item',text: ln.text, indent:ln.indent,marker:m[1],item:m[3],line:ln.line};

	                let yaml = ln.text.match(RE_ListItemTag);
	                if (yaml) {
	                    uli.yaml = { indent: ln.indent, isArrayElement: true };
	                    if (yaml[4]) {
	                        uli.yaml.name = yaml[1];
	                        uli.yaml.value = strToJs(yaml[4],false);
	                        uli.yaml.colon = true;
	                    } else if (yaml[2]) {
	                        uli.yaml.name = yaml[1];
	                        uli.yaml.colon = true;
	                    } else {
	                        uli.yaml.value = strToJs(yaml[1],false);
	                        uli.yaml.colon = false;
	                    }
	                }

	                return uli
	            }
	        } else if (m[2]!==undefined) {
	            let t = m[3].match(RE_ListItemTask);
	            if (t) {
	                let task = { line: ln.line, done: t[1]!='', text: t[2] };
	                // children = text and is converted to hast in post-process
	                return {type:'ordered-list-item',text: ln.text, indent:ln.indent,number:m[2],item:t[2],line:ln.line, task : task}
	            } else {
	                // children = text and is converted to hast in post-process
	                return {type:'ordered-list-item',text: ln.text, indent:ln.indent,number:m[2],item:m[3],line:ln.line}
	            }
	        }
	    }

	    m = ln.text.match(RE_Script);
	    if (m) {
	        return {type:'script',indent:ln.indent, code: m[1] + '  ' + m[2], line:ln.line, text: ln.text}
	    }

	    m = ln.text.match(RE_Div);
	    if (m) {
	        let properties = {};
	        if (m[6]) {
	            let props =  [... m[6].matchAll(/([^\s=]+)(=["]([^"]*)["])?/g) ];
	            for (let prop of props) {
	                if (prop[3]) {
	                    properties[prop[1]] = { value: prop[3] };
	                } else {
	                    properties[prop[1]] = { value: true };
	                }
	            }
	        }
	        return {type:'div',indent:ln.indent,tag:(m[2]?m[2]:'div'),properties:properties, text: ln.text, line:ln.line}
	    }

	    m = ln.text.match(RE_Table);
	    if (m) {
	        const divider = ln.text.match(RE_TableHeader) !== null;
	        return { type: 'table-row', indent: ln.indent, divider: divider, text: ln.text, cells: textToCells(m[2]), line: ln.line }
	    }

	    m = ln.text.match(RE_BlankLine); 
	    if (m) {
	        return {type:'blank', line:ln.line}
	    }

	    m = ln.text.match(RE_Tag);
	    if (m) {
	        let tag = {type:'yaml',indent:ln.indent, name:m[2], colon: true, isArrayElement: false, line:ln.line, children: textToHast(m[1]), text: ln.text};
	        if (m[4]) {
	            tag.value  = strToJs(m[4],false);
	        }
	        return tag
	    }

	    m = ln.text.match(RE_Footnote);
	    if (m) {
	        return { type: 'footnote', indent: ln.indent, id: m[1], children: textToHast(m[2]), text: ln.text }
	    }

	    m = ln.text.match(RE_LinkDefinition);
	    if (m) {
	        return { type: 'link-definition', indent: ln.indent, id: m[1].trim().toLowerCase(), link: strToLink(m[2]) }
	    }

	    m = ln.text.match(RE_CodeBlock);
	    if (m) {
	        return {type:'code-block',indent:ln.indent,language: m[1],line:ln.line}
	    }

	    // children = text and is converted to hast in post-process
	    return {type:'text',indent:ln.indent,line:ln.line, children:ln.text.trim(),text: ln.text}

	}

	function sxastParser(src,options) {

	    if (options.log_src) {
	        console.log('= src ================');
	        console.log(src);
	    }
	    
	    // TODO: hack to fix invalid javascript quoting
	    src = src.replace(/[]/g,'"');

	    const lines = sqrmToLines(src);
	    
	    if (options.log_lines) {
	        console.log('= lines =============');
	        console.log(JSON.stringify(lines,null,'\t'));
	    }
	    
	    const sxasts = linesToSxast(lines);
	    
	    if (options.log_sxast) {
	        console.log('= sxast =============');
	        console.log(JSON.stringify(sxasts,null,'\t'));
	    }
	    
	    return sxasts
	}

	/**
	 * List of HTML void tag names.
	 *
	 * @type {Array<string>}
	 */
	const htmlVoidElements = [
	  'area',
	  'base',
	  'basefont',
	  'bgsound',
	  'br',
	  'col',
	  'command',
	  'embed',
	  'frame',
	  'hr',
	  'image',
	  'img',
	  'input',
	  'isindex',
	  'keygen',
	  'link',
	  'menuitem',
	  'meta',
	  'nextid',
	  'param',
	  'source',
	  'track',
	  'wbr'
	];

	/**
	 * @typedef {import('../../types.js').Comment} Comment
	 */

	/** @type {import('unist-util-is').AssertPredicate<Comment>} */
	// @ts-ignore
	const comment$1 = convert('comment');

	/**
	 * @typedef {import('../../types.js').Parent} Parent
	 * @typedef {import('../../types.js').Child} Child
	 */

	const siblingAfter = siblings(1);
	const siblingBefore = siblings(-1);

	/**
	 * Factory to check siblings in a direction.
	 *
	 * @param {number} increment
	 */
	function siblings(increment) {
	  return sibling

	  /**
	   * Find applicable siblings in a direction.
	   *
	   * @param {Parent} parent
	   * @param {number} index
	   * @param {boolean} [includeWhitespace=false]
	   * @returns {Child}
	   */
	  function sibling(parent, index, includeWhitespace) {
	    const siblings = parent && parent.children;
	    let offset = index + increment;
	    let next = siblings && siblings[offset];

	    if (!includeWhitespace) {
	      while (next && whitespace$1(next)) {
	        offset += increment;
	        next = siblings[offset];
	      }
	    }

	    return next
	  }
	}

	/**
	 * @typedef {import('../../types.js').Node} Node
	 * @typedef {import('../../types.js').Text} Text
	 */

	/** @type {import('unist-util-is').AssertPredicate<Text>} */
	// @ts-ignore
	const isText = convert('text');

	/**
	 * Check if `node` starts with whitespace.
	 *
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function whitespaceStart(node) {
	  return isText(node) && whitespace$1(node.value.charAt(0))
	}

	/**
	 * @typedef {import('../types.js').OmitHandle} OmitHandle
	 */

	const own$2 = {}.hasOwnProperty;

	/**
	 * Factory to check if a given node can have a tag omitted.
	 *
	 * @param {Object.<string, OmitHandle>} handlers
	 * @returns {OmitHandle}
	 */
	function omission$1(handlers) {
	  return omit

	  /**
	   * Check if a given node can have a tag omitted.
	   *
	   * @type {OmitHandle}
	   */
	  function omit(node, index, parent) {
	    return (
	      own$2.call(handlers, node.tagName) &&
	      handlers[node.tagName](node, index, parent)
	    )
	  }
	}

	/**
	 * @typedef {import('../types.js').OmitHandle} OmitHandle
	 */

	const closing = omission$1({
	  html: html$1,
	  head: headOrColgroupOrCaption,
	  body: body$1,
	  p,
	  li,
	  dt,
	  dd,
	  rt: rubyElement,
	  rp: rubyElement,
	  optgroup,
	  option,
	  menuitem,
	  colgroup: headOrColgroupOrCaption,
	  caption: headOrColgroupOrCaption,
	  thead,
	  tbody: tbody$1,
	  tfoot,
	  tr,
	  td: cells,
	  th: cells
	});

	/**
	 * Macro for `</head>`, `</colgroup>`, and `</caption>`.
	 *
	 * @type {OmitHandle}
	 */
	function headOrColgroupOrCaption(_, index, parent) {
	  const next = siblingAfter(parent, index, true);
	  return !next || (!comment$1(next) && !whitespaceStart(next))
	}

	/**
	 * Whether to omit `</html>`.
	 *
	 * @type {OmitHandle}
	 */
	function html$1(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || !comment$1(next)
	}

	/**
	 * Whether to omit `</body>`.
	 *
	 * @type {OmitHandle}
	 */
	function body$1(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || !comment$1(next)
	}

	/**
	 * Whether to omit `</p>`.
	 *
	 * @type {OmitHandle}
	 */
	function p(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return next
	    ? isElement(next, [
	        'address',
	        'article',
	        'aside',
	        'blockquote',
	        'details',
	        'div',
	        'dl',
	        'fieldset',
	        'figcaption',
	        'figure',
	        'footer',
	        'form',
	        'h1',
	        'h2',
	        'h3',
	        'h4',
	        'h5',
	        'h6',
	        'header',
	        'hgroup',
	        'hr',
	        'main',
	        'menu',
	        'nav',
	        'ol',
	        'p',
	        'pre',
	        'section',
	        'table',
	        'ul'
	      ])
	    : !parent ||
	        // Confusing parent.
	        !isElement(parent, [
	          'a',
	          'audio',
	          'del',
	          'ins',
	          'map',
	          'noscript',
	          'video'
	        ])
	}

	/**
	 * Whether to omit `</li>`.
	 *
	 * @type {OmitHandle}
	 */
	function li(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, 'li')
	}

	/**
	 * Whether to omit `</dt>`.
	 *
	 * @type {OmitHandle}
	 */
	function dt(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return next && isElement(next, ['dt', 'dd'])
	}

	/**
	 * Whether to omit `</dd>`.
	 *
	 * @type {OmitHandle}
	 */
	function dd(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, ['dt', 'dd'])
	}

	/**
	 * Whether to omit `</rt>` or `</rp>`.
	 *
	 * @type {OmitHandle}
	 */
	function rubyElement(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, ['rp', 'rt'])
	}

	/**
	 * Whether to omit `</optgroup>`.
	 *
	 * @type {OmitHandle}
	 */
	function optgroup(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, 'optgroup')
	}

	/**
	 * Whether to omit `</option>`.
	 *
	 * @type {OmitHandle}
	 */
	function option(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, ['option', 'optgroup'])
	}

	/**
	 * Whether to omit `</menuitem>`.
	 *
	 * @type {OmitHandle}
	 */
	function menuitem(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, ['menuitem', 'hr', 'menu'])
	}

	/**
	 * Whether to omit `</thead>`.
	 *
	 * @type {OmitHandle}
	 */
	function thead(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return next && isElement(next, ['tbody', 'tfoot'])
	}

	/**
	 * Whether to omit `</tbody>`.
	 *
	 * @type {OmitHandle}
	 */
	function tbody$1(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, ['tbody', 'tfoot'])
	}

	/**
	 * Whether to omit `</tfoot>`.
	 *
	 * @type {OmitHandle}
	 */
	function tfoot(_, index, parent) {
	  return !siblingAfter(parent, index)
	}

	/**
	 * Whether to omit `</tr>`.
	 *
	 * @type {OmitHandle}
	 */
	function tr(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, 'tr')
	}

	/**
	 * Whether to omit `</td>` or `</th>`.
	 *
	 * @type {OmitHandle}
	 */
	function cells(_, index, parent) {
	  const next = siblingAfter(parent, index);
	  return !next || isElement(next, ['td', 'th'])
	}

	/**
	 * @typedef {import('../types.js').OmitHandle} OmitHandle
	 * @typedef {import('../types.js').Child} Child
	 */

	const opening = omission$1({
	  html,
	  head,
	  body,
	  colgroup,
	  tbody
	});

	/**
	 * Whether to omit `<html>`.
	 *
	 * @type {OmitHandle}
	 */
	function html(node) {
	  const head = siblingAfter(node, -1);
	  return !head || !comment$1(head)
	}

	/**
	 * Whether to omit `<head>`.
	 *
	 * @type {OmitHandle}
	 */
	function head(node) {
	  const children = node.children;
	  /** @type {Array.<string>} */
	  const seen = [];
	  let index = -1;
	  /** @type {Child} */
	  let child;

	  while (++index < children.length) {
	    child = children[index];
	    if (isElement(child, ['title', 'base'])) {
	      if (seen.includes(child.tagName)) return false
	      seen.push(child.tagName);
	    }
	  }

	  return children.length > 0
	}

	/**
	 * Whether to omit `<body>`.
	 *
	 * @type {OmitHandle}
	 */
	function body(node) {
	  const head = siblingAfter(node, -1, true);

	  return (
	    !head ||
	    (!comment$1(head) &&
	      !whitespaceStart(head) &&
	      !isElement(head, ['meta', 'link', 'script', 'style', 'template']))
	  )
	}

	/**
	 * Whether to omit `<colgroup>`.
	 * The spec describes some logic for the opening tag, but its easier to
	 * implement in the closing tag, to the same effect, so we handle it there
	 * instead.
	 *
	 * @type {OmitHandle}
	 */
	function colgroup(node, index, parent) {
	  const previous = siblingBefore(parent, index);
	  const head = siblingAfter(node, -1, true);

	  // Previous colgroup was already omitted.
	  if (
	    isElement(previous, 'colgroup') &&
	    closing(previous, parent.children.indexOf(previous), parent)
	  ) {
	    return false
	  }

	  return head && isElement(head, 'col')
	}

	/**
	 * Whether to omit `<tbody>`.
	 *
	 * @type {OmitHandle}
	 */
	function tbody(node, index, parent) {
	  const previous = siblingBefore(parent, index);
	  const head = siblingAfter(node, -1);

	  // Previous table section was already omitted.
	  if (
	    isElement(previous, ['thead', 'tbody']) &&
	    closing(previous, parent.children.indexOf(previous), parent)
	  ) {
	    return false
	  }

	  return head && isElement(head, 'tr')
	}

	/**
	 * @typedef {import('../types.js').Omission} Omission
	 */

	/** @type {Omission} */
	const omission = {opening, closing};

	/**
	 * @typedef CoreOptions
	 * @property {Array<string>} [subset=[]]
	 *   Whether to only escape the given subset of characters.
	 * @property {boolean} [escapeOnly=false]
	 *   Whether to only escape possibly dangerous characters.
	 *   Those characters are `"`, `&`, `'`, `<`, `>`, and `` ` ``.
	 *
	 * @typedef FormatOptions
	 * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format
	 *   Format strategy.
	 *
	 * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions
	 */

	/**
	 * Encode certain characters in `value`.
	 *
	 * @param {string} value
	 * @param {CoreWithFormatOptions} options
	 * @returns {string}
	 */
	function core(value, options) {
	  value = value.replace(
	    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
	    basic
	  );

	  if (options.subset || options.escapeOnly) {
	    return value
	  }

	  return (
	    value
	      // Surrogate pairs.
	      .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate)
	      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more
	      // non-ASCII ones).
	      .replace(
	        // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
	        /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
	        basic
	      )
	  )

	  /**
	   * @param {string} pair
	   * @param {number} index
	   * @param {string} all
	   */
	  function surrogate(pair, index, all) {
	    return options.format(
	      (pair.charCodeAt(0) - 0xd800) * 0x400 +
	        pair.charCodeAt(1) -
	        0xdc00 +
	        0x10000,
	      all.charCodeAt(index + 2),
	      options
	    )
	  }

	  /**
	   * @param {string} character
	   * @param {number} index
	   * @param {string} all
	   */
	  function basic(character, index, all) {
	    return options.format(
	      character.charCodeAt(0),
	      all.charCodeAt(index + 1),
	      options
	    )
	  }
	}

	/**
	 * @param {Array<string>} subset
	 * @returns {RegExp}
	 */
	function charactersToExpression(subset) {
	  /** @type {Array<string>} */
	  const groups = [];
	  let index = -1;

	  while (++index < subset.length) {
	    groups.push(subset[index].replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'));
	  }

	  return new RegExp('(?:' + groups.join('|') + ')', 'g')
	}

	/**
	 * Configurable ways to encode characters as hexadecimal references.
	 *
	 * @param {number} code
	 * @param {number} next
	 * @param {boolean|undefined} omit
	 * @returns {string}
	 */
	function toHexadecimal(code, next, omit) {
	  const value = '&#x' + code.toString(16).toUpperCase();
	  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next))
	    ? value
	    : value + ';'
	}

	/**
	 * Configurable ways to encode characters as decimal references.
	 *
	 * @param {number} code
	 * @param {number} next
	 * @param {boolean|undefined} omit
	 * @returns {string}
	 */
	function toDecimal(code, next, omit) {
	  const value = '&#' + String(code);
	  return omit && next && !/\d/.test(String.fromCharCode(next))
	    ? value
	    : value + ';'
	}

	/**
	 * List of legacy HTML named character references that dont need a trailing semicolon.
	 *
	 * @type {Array<string>}
	 */
	const characterEntitiesLegacy = [
	  'AElig',
	  'AMP',
	  'Aacute',
	  'Acirc',
	  'Agrave',
	  'Aring',
	  'Atilde',
	  'Auml',
	  'COPY',
	  'Ccedil',
	  'ETH',
	  'Eacute',
	  'Ecirc',
	  'Egrave',
	  'Euml',
	  'GT',
	  'Iacute',
	  'Icirc',
	  'Igrave',
	  'Iuml',
	  'LT',
	  'Ntilde',
	  'Oacute',
	  'Ocirc',
	  'Ograve',
	  'Oslash',
	  'Otilde',
	  'Ouml',
	  'QUOT',
	  'REG',
	  'THORN',
	  'Uacute',
	  'Ucirc',
	  'Ugrave',
	  'Uuml',
	  'Yacute',
	  'aacute',
	  'acirc',
	  'acute',
	  'aelig',
	  'agrave',
	  'amp',
	  'aring',
	  'atilde',
	  'auml',
	  'brvbar',
	  'ccedil',
	  'cedil',
	  'cent',
	  'copy',
	  'curren',
	  'deg',
	  'divide',
	  'eacute',
	  'ecirc',
	  'egrave',
	  'eth',
	  'euml',
	  'frac12',
	  'frac14',
	  'frac34',
	  'gt',
	  'iacute',
	  'icirc',
	  'iexcl',
	  'igrave',
	  'iquest',
	  'iuml',
	  'laquo',
	  'lt',
	  'macr',
	  'micro',
	  'middot',
	  'nbsp',
	  'not',
	  'ntilde',
	  'oacute',
	  'ocirc',
	  'ograve',
	  'ordf',
	  'ordm',
	  'oslash',
	  'otilde',
	  'ouml',
	  'para',
	  'plusmn',
	  'pound',
	  'quot',
	  'raquo',
	  'reg',
	  'sect',
	  'shy',
	  'sup1',
	  'sup2',
	  'sup3',
	  'szlig',
	  'thorn',
	  'times',
	  'uacute',
	  'ucirc',
	  'ugrave',
	  'uml',
	  'uuml',
	  'yacute',
	  'yen',
	  'yuml'
	];

	/**
	 * Map of named character references from HTML 4.
	 *
	 * @type {Record<string, string>}
	 */
	const characterEntitiesHtml4 = {
	  nbsp: '',
	  iexcl: '',
	  cent: '',
	  pound: '',
	  curren: '',
	  yen: '',
	  brvbar: '',
	  sect: '',
	  uml: '',
	  copy: '',
	  ordf: '',
	  laquo: '',
	  not: '',
	  shy: '',
	  reg: '',
	  macr: '',
	  deg: '',
	  plusmn: '',
	  sup2: '',
	  sup3: '',
	  acute: '',
	  micro: '',
	  para: '',
	  middot: '',
	  cedil: '',
	  sup1: '',
	  ordm: '',
	  raquo: '',
	  frac14: '',
	  frac12: '',
	  frac34: '',
	  iquest: '',
	  Agrave: '',
	  Aacute: '',
	  Acirc: '',
	  Atilde: '',
	  Auml: '',
	  Aring: '',
	  AElig: '',
	  Ccedil: '',
	  Egrave: '',
	  Eacute: '',
	  Ecirc: '',
	  Euml: '',
	  Igrave: '',
	  Iacute: '',
	  Icirc: '',
	  Iuml: '',
	  ETH: '',
	  Ntilde: '',
	  Ograve: '',
	  Oacute: '',
	  Ocirc: '',
	  Otilde: '',
	  Ouml: '',
	  times: '',
	  Oslash: '',
	  Ugrave: '',
	  Uacute: '',
	  Ucirc: '',
	  Uuml: '',
	  Yacute: '',
	  THORN: '',
	  szlig: '',
	  agrave: '',
	  aacute: '',
	  acirc: '',
	  atilde: '',
	  auml: '',
	  aring: '',
	  aelig: '',
	  ccedil: '',
	  egrave: '',
	  eacute: '',
	  ecirc: '',
	  euml: '',
	  igrave: '',
	  iacute: '',
	  icirc: '',
	  iuml: '',
	  eth: '',
	  ntilde: '',
	  ograve: '',
	  oacute: '',
	  ocirc: '',
	  otilde: '',
	  ouml: '',
	  divide: '',
	  oslash: '',
	  ugrave: '',
	  uacute: '',
	  ucirc: '',
	  uuml: '',
	  yacute: '',
	  thorn: '',
	  yuml: '',
	  fnof: '',
	  Alpha: '',
	  Beta: '',
	  Gamma: '',
	  Delta: '',
	  Epsilon: '',
	  Zeta: '',
	  Eta: '',
	  Theta: '',
	  Iota: '',
	  Kappa: '',
	  Lambda: '',
	  Mu: '',
	  Nu: '',
	  Xi: '',
	  Omicron: '',
	  Pi: '',
	  Rho: '',
	  Sigma: '',
	  Tau: '',
	  Upsilon: '',
	  Phi: '',
	  Chi: '',
	  Psi: '',
	  Omega: '',
	  alpha: '',
	  beta: '',
	  gamma: '',
	  delta: '',
	  epsilon: '',
	  zeta: '',
	  eta: '',
	  theta: '',
	  iota: '',
	  kappa: '',
	  lambda: '',
	  mu: '',
	  nu: '',
	  xi: '',
	  omicron: '',
	  pi: '',
	  rho: '',
	  sigmaf: '',
	  sigma: '',
	  tau: '',
	  upsilon: '',
	  phi: '',
	  chi: '',
	  psi: '',
	  omega: '',
	  thetasym: '',
	  upsih: '',
	  piv: '',
	  bull: '',
	  hellip: '',
	  prime: '',
	  Prime: '',
	  oline: '',
	  frasl: '',
	  weierp: '',
	  image: '',
	  real: '',
	  trade: '',
	  alefsym: '',
	  larr: '',
	  uarr: '',
	  rarr: '',
	  darr: '',
	  harr: '',
	  crarr: '',
	  lArr: '',
	  uArr: '',
	  rArr: '',
	  dArr: '',
	  hArr: '',
	  forall: '',
	  part: '',
	  exist: '',
	  empty: '',
	  nabla: '',
	  isin: '',
	  notin: '',
	  ni: '',
	  prod: '',
	  sum: '',
	  minus: '',
	  lowast: '',
	  radic: '',
	  prop: '',
	  infin: '',
	  ang: '',
	  and: '',
	  or: '',
	  cap: '',
	  cup: '',
	  int: '',
	  there4: '',
	  sim: '',
	  cong: '',
	  asymp: '',
	  ne: '',
	  equiv: '',
	  le: '',
	  ge: '',
	  sub: '',
	  sup: '',
	  nsub: '',
	  sube: '',
	  supe: '',
	  oplus: '',
	  otimes: '',
	  perp: '',
	  sdot: '',
	  lceil: '',
	  rceil: '',
	  lfloor: '',
	  rfloor: '',
	  lang: '',
	  rang: '',
	  loz: '',
	  spades: '',
	  clubs: '',
	  hearts: '',
	  diams: '',
	  quot: '"',
	  amp: '&',
	  lt: '<',
	  gt: '>',
	  OElig: '',
	  oelig: '',
	  Scaron: '',
	  scaron: '',
	  Yuml: '',
	  circ: '',
	  tilde: '',
	  ensp: '',
	  emsp: '',
	  thinsp: '',
	  zwnj: '',
	  zwj: '',
	  lrm: '',
	  rlm: '',
	  ndash: '',
	  mdash: '',
	  lsquo: '',
	  rsquo: '',
	  sbquo: '',
	  ldquo: '',
	  rdquo: '',
	  bdquo: '',
	  dagger: '',
	  Dagger: '',
	  permil: '',
	  lsaquo: '',
	  rsaquo: '',
	  euro: ''
	};

	/**
	 * List of legacy (that dont need a trailing `;`) named references which could,
	 * depending on what follows them, turn into a different meaning
	 *
	 * @type {Array<string>}
	 */
	const dangerous = [
	  'cent',
	  'copy',
	  'divide',
	  'gt',
	  'lt',
	  'not',
	  'para',
	  'times'
	];

	const own$1 = {}.hasOwnProperty;

	/**
	 * `characterEntitiesHtml4` but inverted.
	 *
	 * @type {Record<string, string>}
	 */
	const characters = {};

	/** @type {string} */
	let key;

	for (key in characterEntitiesHtml4) {
	  if (own$1.call(characterEntitiesHtml4, key)) {
	    characters[characterEntitiesHtml4[key]] = key;
	  }
	}

	/**
	 * Configurable ways to encode characters as named references.
	 *
	 * @param {number} code
	 * @param {number} next
	 * @param {boolean|undefined} omit
	 * @param {boolean|undefined} attribute
	 * @returns {string}
	 */
	function toNamed(code, next, omit, attribute) {
	  const character = String.fromCharCode(code);

	  if (own$1.call(characters, character)) {
	    const name = characters[character];
	    const value = '&' + name;

	    if (
	      omit &&
	      characterEntitiesLegacy.includes(name) &&
	      !dangerous.includes(name) &&
	      (!attribute ||
	        (next &&
	          next !== 61 /* `=` */ &&
	          /[^\da-z]/i.test(String.fromCharCode(next))))
	    ) {
	      return value
	    }

	    return value + ';'
	  }

	  return ''
	}

	/**
	 * @typedef FormatSmartOptions
	 * @property {boolean} [useNamedReferences=false]
	 *   Prefer named character references (`&amp;`) where possible.
	 * @property {boolean} [useShortestReferences=false]
	 *   Prefer the shortest possible reference, if that results in less bytes.
	 *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.
	 * @property {boolean} [omitOptionalSemicolons=false]
	 *   Whether to omit semicolons when possible.
	 *   **Note**: This creates what HTML calls parse errors but is otherwise still valid HTML  dont use this except when building a minifier.
	 *   Omitting semicolons is possible for certain named and numeric references in some cases.
	 * @property {boolean} [attribute=false]
	 *   Create character references which dont fail in attributes.
	 *   **Note**: `attribute` only applies when operating dangerously with
	 *   `omitOptionalSemicolons: true`.
	 */

	/**
	 * Configurable ways to encode a character yielding pretty or small results.
	 *
	 * @param {number} code
	 * @param {number} next
	 * @param {FormatSmartOptions} options
	 * @returns {string}
	 */
	function formatSmart(code, next, options) {
	  let numeric = toHexadecimal(code, next, options.omitOptionalSemicolons);
	  /** @type {string|undefined} */
	  let named;

	  if (options.useNamedReferences || options.useShortestReferences) {
	    named = toNamed(
	      code,
	      next,
	      options.omitOptionalSemicolons,
	      options.attribute
	    );
	  }

	  // Use the shortest numeric reference when requested.
	  // A simple algorithm would use decimal for all code points under 100, as
	  // those are shorter than hexadecimal:
	  //
	  // * `&#99;` vs `&#x63;` (decimal shorter)
	  // * `&#100;` vs `&#x64;` (equal)
	  //
	  // However, because we take `next` into consideration when `omit` is used,
	  // And it would be possible that decimals are shorter on bigger values as
	  // well if `next` is hexadecimal but not decimal, we instead compare both.
	  if (
	    (options.useShortestReferences || !named) &&
	    options.useShortestReferences
	  ) {
	    const decimal = toDecimal(code, next, options.omitOptionalSemicolons);

	    if (decimal.length < numeric.length) {
	      numeric = decimal;
	    }
	  }

	  return named &&
	    (!options.useShortestReferences || named.length < numeric.length)
	    ? named
	    : numeric
	}

	/**
	 * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options
	 * @typedef {import('./core.js').CoreOptions} LightOptions
	 */

	/**
	 * Encode special characters in `value`.
	 *
	 * @param {string} value
	 *   Value to encode.
	 * @param {Options} [options]
	 *   Configuration.
	 * @returns {string}
	 *   Encoded value.
	 */
	function stringifyEntities(value, options) {
	  return core(value, Object.assign({format: formatSmart}, options))
	}

	/**
	 * Count how often a character (or substring) is used in a string.
	 *
	 * @param {string} value
	 *   Value to search in.
	 * @param {string} character
	 *   Character (or substring) to look for.
	 * @return {number}
	 *   Number of times `character` occurred in `value`.
	 */
	function ccount(value, character) {
	  const source = String(value);

	  if (typeof character !== 'string') {
	    throw new TypeError('Expected character')
	  }

	  let count = 0;
	  let index = source.indexOf(character);

	  while (index !== -1) {
	    count++;
	    index = source.indexOf(character, index + character.length);
	  }

	  return count
	}

	// Maps of subsets.
	// Each value is a matrix of tuples.
	// The first value causes parse errors, the second is valid.
	// Of both values, the first value is unsafe, and the second is safe.
	const constants = {
	  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
	  name: [
	    ['\t\n\f\r &/=>'.split(''), '\t\n\f\r "&\'/=>`'.split('')],
	    ['\0\t\n\f\r "&\'/<=>'.split(''), '\0\t\n\f\r "&\'/<=>`'.split('')]
	  ],
	  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
	  unquoted: [
	    ['\t\n\f\r &>'.split(''), '\0\t\n\f\r "&\'<=>`'.split('')],
	    ['\0\t\n\f\r "&\'<=>`'.split(''), '\0\t\n\f\r "&\'<=>`'.split('')]
	  ],
	  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
	  single: [
	    ["&'".split(''), '"&\'`'.split('')],
	    ["\0&'".split(''), '\0"&\'`'.split('')]
	  ],
	  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
	  double: [
	    ['"&'.split(''), '"&\'`'.split('')],
	    ['\0"&'.split(''), '\0"&\'`'.split('')]
	  ]
	};

	/**
	 * @typedef {import('./types.js').Handle} Handle
	 * @typedef {import('./types.js').Comment} Comment
	 */

	/**
	 * @type {Handle}
	 * @param {Comment} node
	 */
	function comment(ctx, node) {
	  // See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>
	  return ctx.bogusComments
	    ? '<?' +
	        stringifyEntities(
	          node.value,
	          Object.assign({}, ctx.entities, {subset: ['>']})
	        ) +
	        '>'
	    : '<!--' + node.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + '-->'

	  /**
	   * @param {string} $0
	   */
	  function encode($0) {
	    return stringifyEntities(
	      $0,
	      Object.assign({}, ctx.entities, {subset: ['<', '>']})
	    )
	  }
	}

	/**
	 * @typedef {import('./types.js').Handle} Handle
	 */

	/**
	 * @type {Handle}
	 */
	function doctype(ctx) {
	  return (
	    '<!' +
	    (ctx.upperDoctype ? 'DOCTYPE' : 'doctype') +
	    (ctx.tightDoctype ? '' : ' ') +
	    'html>'
	  )
	}

	/**
	 * @typedef {import('./types.js').Handle} Handle
	 * @typedef {import('./types.js').Text} Text
	 */

	/**
	 * @type {Handle}
	 * @param {Text} node
	 */
	function text(ctx, node, _, parent) {
	  // Check if content of `node` should be escaped.
	  return parent &&
	    parent.type === 'element' &&
	    // @ts-expect-error: hush.
	    (parent.tagName === 'script' || parent.tagName === 'style')
	    ? node.value
	    : stringifyEntities(
	        node.value,
	        Object.assign({}, ctx.entities, {subset: ['<', '&']})
	      )
	}

	/**
	 * @typedef {import('./types.js').Handle} Handle
	 * @typedef {import('./types.js').Raw} Raw
	 */

	/**
	 * @type {Handle}
	 * @param {Raw} node
	 */
	function raw(ctx, node, index, parent) {
	  // @ts-ignore Hush.
	  return ctx.dangerous ? node.value : text(ctx, node, index, parent)
	}

	/**
	 * @typedef {import('./types.js').Handle} Handle
	 * @typedef {import('./types.js').Element} Element
	 * @typedef {import('./types.js').Context} Context
	 * @typedef {import('./types.js').Properties} Properties
	 * @typedef {import('./types.js').PropertyValue} PropertyValue
	 * @typedef {import('./types.js').Parent} Parent
	 */

	/**
	 * @type {Object.<string, Handle>}
	 */
	const handlers = {
	  comment,
	  doctype,
	  element,
	  // @ts-ignore `raw` is nonstandard
	  raw,
	  // @ts-ignore `root` is a parent.
	  root: all,
	  text
	};

	const own = {}.hasOwnProperty;

	/**
	 * @type {Handle}
	 */
	function one(ctx, node, index, parent) {
	  if (!node || !node.type) {
	    throw new Error('Expected node, not `' + node + '`')
	  }

	  if (!own.call(handlers, node.type)) {
	    throw new Error('Cannot compile unknown node `' + node.type + '`')
	  }

	  return handlers[node.type](ctx, node, index, parent)
	}

	/**
	 * Serialize all children of `parent`.
	 *
	 * @type {Handle}
	 * @param {Parent} parent
	 */
	function all(ctx, parent) {
	  /** @type {Array.<string>} */
	  const results = [];
	  const children = (parent && parent.children) || [];
	  let index = -1;

	  while (++index < children.length) {
	    results[index] = one(ctx, children[index], index, parent);
	  }

	  return results.join('')
	}

	/**
	 * @type {Handle}
	 * @param {Element} node
	 */
	// eslint-disable-next-line complexity
	function element(ctx, node, index, parent) {
	  const schema = ctx.schema;
	  const omit = schema.space === 'svg' ? undefined : ctx.omit;
	  let selfClosing =
	    schema.space === 'svg'
	      ? ctx.closeEmpty
	      : ctx.voids.includes(node.tagName.toLowerCase());
	  /** @type {Array.<string>} */
	  const parts = [];
	  /** @type {string} */
	  let last;

	  if (schema.space === 'html' && node.tagName === 'svg') {
	    ctx.schema = svg;
	  }

	  const attrs = serializeAttributes(ctx, node.properties);

	  const content = all(
	    ctx,
	    schema.space === 'html' && node.tagName === 'template' ? node.content : node
	  );

	  ctx.schema = schema;

	  // If the node is categorised as void, but it has children, remove the
	  // categorisation.
	  // This enables for example `menuitem`s, which are void in W3C HTML but not
	  // void in WHATWG HTML, to be stringified properly.
	  if (content) selfClosing = false;

	  if (attrs || !omit || !omit.opening(node, index, parent)) {
	    parts.push('<', node.tagName, attrs ? ' ' + attrs : '');

	    if (selfClosing && (schema.space === 'svg' || ctx.close)) {
	      last = attrs.charAt(attrs.length - 1);
	      if (
	        !ctx.tightClose ||
	        last === '/' ||
	        (last && last !== '"' && last !== "'")
	      ) {
	        parts.push(' ');
	      }

	      parts.push('/');
	    }

	    parts.push('>');
	  }

	  parts.push(content);

	  if (!selfClosing && (!omit || !omit.closing(node, index, parent))) {
	    parts.push('</' + node.tagName + '>');
	  }

	  return parts.join('')
	}

	/**
	 * @param {Context} ctx
	 * @param {Properties} props
	 * @returns {string}
	 */
	function serializeAttributes(ctx, props) {
	  /** @type {Array.<string>} */
	  const values = [];
	  let index = -1;
	  /** @type {string} */
	  let key;
	  /** @type {string} */
	  let value;
	  /** @type {string} */
	  let last;

	  for (key in props) {
	    if (props[key] !== undefined && props[key] !== null) {
	      value = serializeAttribute(ctx, key, props[key]);
	      if (value) values.push(value);
	    }
	  }

	  while (++index < values.length) {
	    last = ctx.tight ? values[index].charAt(values[index].length - 1) : null;

	    // In tight mode, dont add a space after quoted attributes.
	    if (index !== values.length - 1 && last !== '"' && last !== "'") {
	      values[index] += ' ';
	    }
	  }

	  return values.join('')
	}

	/**
	 * @param {Context} ctx
	 * @param {string} key
	 * @param {PropertyValue} value
	 * @returns {string}
	 */
	// eslint-disable-next-line complexity
	function serializeAttribute(ctx, key, value) {
	  const info = find(ctx.schema, key);
	  let quote = ctx.quote;
	  /** @type {string} */
	  let result;

	  if (info.overloadedBoolean && (value === info.attribute || value === '')) {
	    value = true;
	  } else if (
	    info.boolean ||
	    (info.overloadedBoolean && typeof value !== 'string')
	  ) {
	    value = Boolean(value);
	  }

	  if (
	    value === undefined ||
	    value === null ||
	    value === false ||
	    (typeof value === 'number' && Number.isNaN(value))
	  ) {
	    return ''
	  }

	  const name = stringifyEntities(
	    info.attribute,
	    Object.assign({}, ctx.entities, {
	      // Always encode without parse errors in non-HTML.
	      subset:
	        constants.name[ctx.schema.space === 'html' ? ctx.valid : 1][ctx.safe]
	    })
	  );

	  // No value.
	  // There is currently only one boolean property in SVG: `[download]` on
	  // `<a>`.
	  // This property does not seem to work in browsers (FF, Sa, Ch), so I cant
	  // test if dropping the value works.
	  // But I assume that it should:
	  //
	  // ```html
	  // <!doctype html>
	  // <svg viewBox="0 0 100 100">
	  //   <a href=https://example.com download>
	  //     <circle cx=50 cy=40 r=35 />
	  //   </a>
	  // </svg>
	  // ```
	  //
	  // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>
	  if (value === true) return name

	  value =
	    typeof value === 'object' && 'length' in value
	      ? // `spaces` doesnt accept a second argument, but its given here just to
	        // keep the code cleaner.
	        (info.commaSeparated ? stringify : stringify$1)(value, {
	          padLeft: !ctx.tightLists
	        })
	      : String(value);

	  if (ctx.collapseEmpty && !value) return name

	  // Check unquoted value.
	  if (ctx.unquoted) {
	    result = stringifyEntities(
	      value,
	      Object.assign({}, ctx.entities, {
	        subset: constants.unquoted[ctx.valid][ctx.safe],
	        attribute: true
	      })
	    );
	  }

	  // If we dont want unquoted, or if `value` contains character references when
	  // unquoted
	  if (result !== value) {
	    // If the alternative is less common than `quote`, switch.
	    if (ctx.smart && ccount(value, quote) > ccount(value, ctx.alternative)) {
	      quote = ctx.alternative;
	    }

	    result =
	      quote +
	      stringifyEntities(
	        value,
	        Object.assign({}, ctx.entities, {
	          // Always encode without parse errors in non-HTML.
	          subset: (quote === "'" ? constants.single : constants.double)[
	            ctx.schema.space === 'html' ? ctx.valid : 1
	          ][ctx.safe],
	          attribute: true
	        })
	      ) +
	      quote;
	  }

	  // Dont add a `=` for unquoted empties.
	  return name + (result ? '=' + result : result)
	}

	/**
	 * @typedef {import('./types.js').Node} Node
	 * @typedef {import('./types.js').Options} Options
	 * @typedef {import('./types.js').Context} Context
	 * @typedef {import('./types.js').Quote} Quote
	 */

	/**
	 * @param {Node|Array.<Node>} node
	 * @param {Options} [options]
	 * @returns {string}
	 */
	function toHtml(node, options = {}) {
	  const quote = options.quote || '"';
	  /** @type {Quote} */
	  const alternative = quote === '"' ? "'" : '"';

	  if (quote !== '"' && quote !== "'") {
	    throw new Error('Invalid quote `' + quote + '`, expected `\'` or `"`')
	  }

	  /** @type {Context} */
	  const context = {
	    valid: options.allowParseErrors ? 0 : 1,
	    safe: options.allowDangerousCharacters ? 0 : 1,
	    schema: options.space === 'svg' ? svg : html$2,
	    omit: options.omitOptionalTags ? omission : undefined,
	    quote,
	    alternative,
	    smart: options.quoteSmart,
	    unquoted: options.preferUnquoted,
	    tight: options.tightAttributes,
	    upperDoctype: options.upperDoctype,
	    tightDoctype: options.tightDoctype,
	    bogusComments: options.bogusComments,
	    tightLists: options.tightCommaSeparatedLists,
	    tightClose: options.tightSelfClosing,
	    collapseEmpty: options.collapseEmptyAttributes,
	    dangerous: options.allowDangerousHtml,
	    voids: options.voids || htmlVoidElements.concat(),
	    entities: options.entities || {},
	    close: options.closeSelfClosing,
	    closeEmpty: options.closeEmptyElements
	  };

	  return one(
	    context,
	    // @ts-ignore Assume `node` does not contain a root.
	    Array.isArray(node) ? {type: 'root', children: node} : node,
	    null,
	    null
	  )
	}

	function toJson(jast) {

	    if (jast==null) return null
	    
	    if (jast.type == 'value') return jast.value

	    if (jast.type == 'array') {
	        let a = [];

	        for (let i=0 ; i<jast.children.length ; i++) {
	            a.push(toJson(jast.children[i]));
	        }

	        return a
	    }
	    if (jast.type == 'object') {
	        let o = {};

	        for (let i=0 ; i<jast.children.length ; i++) {
	            o[jast.children[i].name] = toJson(jast.children[i]);
	        }

	        return o
	    }

	    if (jast.type == 'unknown') {
	        return null;
	    }

	    throw new Error('toJson Error, unhandled type: ',jast)
	}

	function responseToResult(response,options = {}) {
	    let sast = response.root;
	        
	    if (options.log_sast) {
	        console.log('= sast =================');
	        console.log(sast);
	    }

	    let hast = sastToHast(sast);
	    response.hastCallbacks.forEach((cb) => {
	        cb.call(null,hast);
	    });

	    if (options.log_hast) {
	        console.log('= hast =================');
	        console.log(hast);
	    }

	    let html = toHtml(hast);

	    if (options.log_html) {
	        console.log('= html =================');
	        console.log(html);
	    }

	    let text = '';
	    visit(hast, 'text', (node) => {
	        text += node.value +'\n';
	    });

	    if (options.log_text) {
	        console.log('= text =================');
	        console.log(text);
	    }

	    let jast = response.jsonTree;

	    if (options.log_jast) {
	        console.log('= jast =================');
	        console.log(jast);
	    }

	    let json = toJson(jast.root);    
	    if (json==null) json = {};

	    if (options.log_json) {
	        console.log('= json =================');
	        console.log(json);
	    }

	    return {html: html, json: json, text: text}
	}

	const defaults = {
	    collection: 'default',
	    name: 'doc',

	    log_src: false,
	    log_lines: false,
	    log_sxast: false,
	    log_code: false,

	    log_sast: false,
	    log_hast: false,
	    log_html: false,
	    log_jast: false,
	    log_json: false
	};

	class SqrmDB {

	    constructor(settings = {}) {
	        this.settings = Object.assign({}, defaults, settings);
	        this.settings.db = this;
	        this.collections = new Map();
	        this.db = new DB();
	        this.createCollection('default');
	    }
	  
	    createCollection(name) {
	        this.db.createCollection(name);
	        let info = { name: name, docs: new Map(), docsBy_id: new Map() };
	        this.collections.set(name,info);
	        return info
	    }

	    getCollectionNames() {
	        return this.db.getCollectionNames()
	    }

	    createDocument(collection,docName,src) {
	        const col = this.collections.get(collection);
	        const sxasts = sxastParser(src,this.settings);
	        
	        if (sxasts.length==1) {

	            let doc = new SqrmDocument(collection,docName,sxasts[0],this);
	            col.docs.set(docName,doc);

	            const createdDoc = { collection: collection, document: docName };

	            let request = new SqrmRequest();
	            let response = new SqrmResponse(this);

	            // generate output
	            doc.execute(request,response);
	            const res = responseToResult(response,this.settings);
	            const mongoDoc = Object.assign({},res.json);
	            mongoDoc._text = res.text;

	            // add to mongo
	            this.db[doc.collection].insertOne(mongoDoc);
	            doc._id = mongoDoc._id;
	            this.collections.get(doc.collection).docsBy_id.set(mongoDoc._id,doc);

	            createdDoc.html = res.html;
	            createdDoc.json = res.json;

	            return createdDoc

	        } else {
	            const createdDocs = { docs: [] };

	            for (let i=0 ; i<sxasts.length ; i++) {
	                let sxast = sxasts[i];
	    
	                const dn = `${docName}_${i+1}`;

	                let doc = new SqrmDocument(collection,dn,sxast,this);
	                col.docs.set(dn,doc);
	                const createdDoc = { collection: collection, document: dn };

	                let request = new SqrmRequest();
	                let response = new SqrmResponse(this);

	                // generate output
	                doc.execute(request,response);
	                const res = responseToResult(response,this.settings);
	                const mongoDoc = Object.assign({},res.json);
	                mongoDoc._text = res.text;

	                // add to mongo
	                this.db[doc.collection].insertOne(mongoDoc);
	                doc._id = mongoDoc._id;
	                this.collections.get(doc.collection).docsBy_id.set(mongoDoc._id,doc);

	                createdDoc.html = res.html;
	                createdDoc.json = res.json;

	                createdDocs.docs.push(createdDoc);
	            }

	            return createdDocs
	        }
	    }

	    call(collection,docName,args) {
	        const request = new SqrmRequest(args);
	        const response = new SqrmResponse(this);
	        const docs = this.find(collection,docName);
	        if (docs == null) {
	            console.log(`-- failed to call ${docName}(${args}) : not found --`);
	            return
	        }
	        if (docs.length != 1) {
	            console.log(`-- failed to call ${docName}(${args}) : not 1 document --`);
	            return
	        }
	        const doc = docs[0];
	        try {
	            doc.execute(request,response);
	        } catch (e) {
	            console.log(`-- failed to call ${docName}(${args}) : script error --`);
	            console.log(e);
	            console.log('---------------------------------------');
	        }

	        return responseToResult(response,this.settings)

	    }

	    find(collection,select,sort,skip,limit) {

	        function cursorToDocs(c) {
	            let res = [];

	            c.forEach(doc => {
	                res.push(col.docsBy_id.get(doc._id));
	            });

	            return res
	        }

	        if (typeof collection != "string") {
	            throw new Error('collection parameter should be string name of collection')
	        }

	        const col = this.collections.get(collection);

	        if (col == null) {
	            throw new Error(`collection "${collection}" doesn't exist`)
	        }

	        if (select == undefined) {
	            return cursorToDocs(this.db[collection].find())
	        } else if (typeof select == "string") {

	            const doc = col.docs.get(select);

	            // if single named doc can't be found return empty array
	            if (doc) return [doc]
	            else return []

	        } else if (typeof select == 'object' && select == Object(select)) {

	            let c;
	            // mongo throws an object rather than an error.
	            // catch it to create a proper error so that a
	            // useful message can be provided to the user.
	            try {
	                c = this.db[collection].find(select);
	            } catch (e) {
	                throw new Error(e['$err'])
	            }

	            if (sort !== undefined) {
	                c = c.sort(sort);

	                if (skip !== undefined) {
	                    c = c.skip(skip);

	                    if (limit !== undefined) {
	                        c = c.limit(limit);
	                    }
	                }
	            }

	            return cursorToDocs(c)
	        } else {
	            return []
	        }
	    } 
	}

	function sqrm(src, db = new SqrmDB()) {
	    return db.createDocument('default','document',src)
	}

	return sqrm;

})();
//# sourceMappingURL=sqrm-0.1.7.iife.js.map
